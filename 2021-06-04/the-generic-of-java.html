

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/panda.png">
  <link rel="icon" href="/img/panda.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#55967e">
  <meta name="description" content="欢迎乘坐八楼的二路公交车">
  <meta name="author" content="Rains.Lee">
  <meta name="keywords" content="Java">
  
  <title>java的泛型 - 一颗胡杨树</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"eripe.me","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":"UA-198559201-1","gtag":"G-19MVRDT9NM","tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"3MrDNVWQz1aBbREDmtPT7DuN-MdYXbMMI","app_key":"34YIO0Yk922Dzi79zUJidSkl","server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/rss2.xml" title="一颗胡杨树" type="application/rss+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Rains·Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/home.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="java的泛型">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-06-04 20:10" pubdate>
        2021年6月4日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      77
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">java的泛型</h1>
            
            <div class="markdown-body">
              <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>这篇文章是在研究java的Type体系顺带扯出的概念,泛型的使用要说简单也很简单,要说难也可以说难。本文将由浅入深,带你学习java中的”泛型”。</p>
</blockquote>
<h2 id="1-泛型的基本概念"><a href="#1-泛型的基本概念" class="headerlink" title="1. 泛型的基本概念"></a>1. 泛型的基本概念</h2><p>泛型的概念始于java1.5,所以在1.5之前所有使用java的地方都没有泛型的影子,那么为了保持向后兼容,java中的泛型被设计成了伪泛型,仅仅存在于编译时期,在实际生成的字节码文件中是没有泛型的,这一动作叫做泛型的<strong>擦除</strong>。</p>
<p>泛型的基本格式为:<code>class Perosn&lt;T&gt;</code>,其中定义在<code>&lt;&gt;</code>的变量称为<code>type variable</code>,这一概念是随着泛型而出生的,并且也跟java的Type子系统息息相关。在jse8文档中,声明<code>type variable</code>允许用在四个地方,但是并不限制<code>type variable</code>的使用个数。允许的四个地方分别是:</p>
<ul>
<li>泛型类</li>
<li>泛型接口</li>
<li>泛型方法</li>
<li>泛型构造函数</li>
</ul>
<p>其中泛型构造函数的使用可以归档在泛型方法一类中。</p>
<p>注意:</p>
<blockquote>
<p>使用泛型构造方法并不要求类是泛型类</p>
</blockquote>
<p>更新(2020-08-14 20:18:36):</p>
<p>还有一些概念,了解后可以更好的帮助我们了解泛型:</p>
<ul>
<li>泛型类型(generic type):是一个带着类型参数的类型,即类似于<code>class Person&lt;T&gt;</code></li>
<li>参数化类型(parameterized type):即使用具体的类型实参去实例化泛型类型的类型,例如使用类型<code>String</code>去实例化泛型类型<code>class Person&lt;T&gt;</code>,所得的参数类型为<code>class Person&lt;String&gt;</code></li>
</ul>
<h3 id="1-1-泛型使用的简单示例"><a href="#1-1-泛型使用的简单示例" class="headerlink" title="1.1 泛型使用的简单示例"></a>1.1 泛型使用的简单示例</h3><p><strong>泛型类与泛型接口:</strong></p>
<p>泛型类和泛型接口的声明比较简单,仅需要在类名或者接口名后面使用<code>&lt;&gt;</code>声明<code>type variable</code>即可。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//泛型类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T name;<br>    <span class="hljs-keyword">private</span> E age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T name,E id)</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.getClass().getSimpleName());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(T name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(E age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//泛型接口</span><br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">People</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>泛型方法:</strong></p>
<p>泛型方法又分为普通的泛型方法、静态泛型方法、泛型构造方法。泛型方法的声明麻烦一点,泛型方法需要在权限修饰后面定义所要使用的<code>type variable</code>。</p>
<p>下面是一组使用泛型方法和泛型类的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> generic;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> T name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(T name,<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>        <span class="hljs-keyword">this</span>.age=age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(T name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">V</span>&gt;</span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span>&lt;T&gt; V <span class="hljs-title">getInfo</span><span class="hljs-params">(People&lt;T&gt; p1, People&lt;T&gt; p2, V sum)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;p1:&quot;</span>+p1.getName()+<span class="hljs-string">&quot; &quot;</span>+p1.getAge());<br>        System.out.println(<span class="hljs-string">&quot;p2:&quot;</span>+p2.getName()+<span class="hljs-string">&quot; &quot;</span>+p2.getAge());<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        People&lt;String&gt; p1=<span class="hljs-keyword">new</span> People&lt;&gt;(<span class="hljs-string">&quot;Bob&quot;</span>,<span class="hljs-number">23</span>);<br>        People&lt;String&gt; p2=<span class="hljs-keyword">new</span> People&lt;&gt;(<span class="hljs-string">&quot;Lee&quot;</span>,<span class="hljs-number">20</span>);<br>        Test&lt;Integer&gt; t=<span class="hljs-keyword">new</span> Test&lt;&gt;();<br>        Object result= t.&lt;String&gt;getInfo(p1,p2,<span class="hljs-number">23</span>);<br>        <span class="hljs-comment">//Object result=t.getInfo(p1,p2,23);</span><br><br>        System.out.println(<span class="hljs-string">&quot;result is an instance of Integer:&quot;</span>+result <span class="hljs-keyword">instanceof</span> Integer);<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>运行结果如下:</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">p1:Bob <span class="hljs-number">23</span><br>p2:Lee <span class="hljs-number">20</span><br>result is an instance of Integer:<span class="hljs-keyword">true</span><br></code></pre></div></td></tr></table></figure>

<p>其中泛型方法签名为:<code>public&lt;T&gt; V getInfo(People&lt;T&gt; p1, People&lt;T&gt; p2, V sum)</code>,<code>T</code>是这个泛型方法<code>getInfo</code>指定的类型变量,而<code>V</code>则是泛型类指定的类型变量。在调用泛型方法时,可以在<code>.</code>和方法名之间明确指定泛型方法的具体类型,或者让编译器自己推断。</p>
<p>其实上面这个泛型方法有个明显的缺点,就是返回值的类型也是一个泛型,这就要求调用者必须判断返回值的具体类型,因为接口。那么可能有人会问了,那<code>ArrayList</code>的源码中也有很多返回泛型的例子,他们写的也差劲?例如:</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    rangeCheck(index);<br>    <span class="hljs-keyword">return</span> elementData(index);<br>&#125;<br><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-function">E <span class="hljs-title">elementData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (E) elementData[index];<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>这样写是因为库编写者已经确定容器中存储的元素的类型就是<code>E</code>,强制转换成<code>E</code>并不会出错,并且调用者也知道返回的类型到底是什么。而且因为方法的返回值是泛型<code>E</code>,编译器会在调用者部分的字节码中自动插入一段强制转换代码将元素类型转为为<code>E</code>。这是由于类型擦除导致的,这会在<strong>后文</strong>详细解释。</p>
<p>静态泛型方法与常规的泛型方法唯一区别就是<strong>静态泛型方法中不能使用泛型类的类型变量</strong>,例如在<code>people</code>中声明一个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;M&gt; calc(M year,M mouth)&#123;...&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>calc</code>中不能使用泛型类<code>People</code>中的类型变量<code>T</code>。</p>
<p><strong>泛型构造方法:</strong></p>
<p>最后泛型构造方法又可以分为两种:类本身就是泛型类,类不是泛型类。下面是一个简单的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//所在类不是泛型类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span></span>&#123;<br>    <span class="hljs-keyword">public</span> &lt;T &amp; Comparable&lt;T&gt;&gt; People(T age)&#123;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//所在类是泛型类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>其中<code>&lt;T &amp; Comparable&lt;T&gt;&gt;</code>的含义是要求<code>T</code>已经实现了Comparable接口。这部分细节可以查看jse8关于<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.4">type variable</a>的详细规范。</p>
<h2 id="2-泛型通配符"><a href="#2-泛型通配符" class="headerlink" title="2. 泛型通配符"></a>2. 泛型通配符</h2><p>在了解泛型通配符之前,我们需要知道一些基本术语:协变、逆变、不变,这一部分引自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31137677">仔细说说Java中的泛型</a>。</p>
<p>逆变与协变用来描述类型转换（type transformation）后的继承关系，其定义：如果A、B表示类型，f(X)表示类型转换，≤表示继承关系(比如,A≤B表示A继承于b),那么这里有三个关系</p>
<blockquote>
<ol>
<li>当A≤B时有f(B)≤f(A)成立，那么说f(X)是逆变（contravariant）的</li>
<li>当A≤B时有f(A)≤f(B)成立，那么说f(X)是协变(covariant)的</li>
<li>当上两者都不成立的时候，那么说f(X)是不变（invariant)的</li>
</ol>
</blockquote>
<p>在java中,<strong>数组是支持协变的</strong>,例如下面这句代码可以通过编译,但会产生运行时错误:</p>
<blockquote>
<p>Number[] test=new Integer[];</p>
</blockquote>
<p><code>Integer</code>是<code>Number</code>的子类,同时变成数组,<code>Integer[]</code>还是<code>Number[]</code>的子类。</p>
<hr>
<p><strong>Extension One:在java中数组为什么要设计成协变的?</strong></p>
<p>答案来源于:<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21394322">java中，数组为什么要设计为协变？</a>,我在这里补充一些我的理解。</p>
<p>在java1.5之前,java是不支持泛型的,因为没时间做。但是又需要泛型的特性,所以就把数组设计成协变的了。例如在比较数组时调用的是<code>Arrays.equals</code>方法,其底层调用的是<code>Object.equals</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object[] a, Object[] a2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a==a2)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> (a==<span class="hljs-keyword">null</span> || a2==<span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">int</span> length = a.length;<br>    <span class="hljs-keyword">if</span> (a2.length != length)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;length; i++) &#123;<br>        Object o1 = a[i];<br>        Object o2 = a2[i];<br>        <span class="hljs-keyword">if</span> (!(o1==<span class="hljs-keyword">null</span> ? o2==<span class="hljs-keyword">null</span> : o1.equals(o2)))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>如果</strong>数组是不支持协变的,那么比较<code>B</code>时得重写<code>equals</code>的代码,比较<code>A</code>时又得重写一份<code>equals</code>的代码,因为<code>A[]</code>不能赋值给<code>Object[]</code>,代码重写非常严重,违背了代码复用的宗旨。所以将数组设计成协变的,使得<code>A[]</code>能够赋值为<code>Object[]</code>,从而调用对象的<code>equals()</code>方法时,由于多态的原因,实际上调用的<code>A</code>的<code>equals</code>方法。实现了代码复用。</p>
<p>那么数组设计成协变会产生大问题吗?答案是不会,因为数组记得它到底保持的是什么类型,这会在<strong>编译时</strong>严格检查数据类型。而泛型协变有问题也只会在运行时出现，延后了问题出现的时间。违背了java是严格类型确定的编程语言。</p>
<p>但是<strong>并不支持</strong>泛型数组,因为数组能记得它存储的元素类型的前提是在创建时就严格确定了其存储的元素类型(之所以能记住这是靠虚拟机实现的,Array由虚拟机来实现)。</p>
<p><strong>Extension Two:java中为什么不支持泛型数组?</strong></p>
<p>参考自<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20928981/answer/117521433">java为什么不支持泛型数组？</a></p>
<p>java明确规定了数组的元素类型必须是可靠的.</p>
<blockquote>
<p>It is a compile-time error if the component type of the array being initialized is not reifiable</p>
</blockquote>
<p>其中<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.7">Reifiable Types</a>包括且只包括:</p>
<ul>
<li><p>It refers to a non-generic class or interface type declaration.</p>
</li>
<li><p>It is a parameterized type in which all type arguments are <strong>unbounded</strong> wildcards (§4.5.1).</p>
</li>
<li><p>It is a raw type (§4.8).</p>
</li>
<li><p>It is a primitive type (§4.2).</p>
</li>
<li><p>It is an array type (§10.1) whose element type is reifiable.</p>
</li>
<li><p>It is a nested type where, for each type T separated by a “.”, T itself is reifiable.</p>
</li>
</ul>
<p>下面是每个<code>Reifiable Type</code>的示例:</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">E</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&lt;<span class="hljs-title">X</span>&gt;</span>&#123;&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;&#125;<br><br><span class="hljs-comment">//It refers to a non-generic class or interface type declaration.</span><br><span class="hljs-comment">//是一个分泛型的类或接口的引用</span><br>A ref;<br>E ref;<br><span class="hljs-comment">//It is a parameterized type in which all type arguments are **unbounded** wildcards</span><br><span class="hljs-comment">//是一个参数化类型,但是所有的类型参数都是无界通配符</span><br>B&lt;?&gt; ref;<br><span class="hljs-comment">//raw type</span><br>List ref;<br><span class="hljs-comment">//primitive type</span><br><span class="hljs-keyword">int</span> ref;<br><span class="hljs-comment">//array type,并且元素类型都要求是可靠的</span><br><span class="hljs-keyword">int</span>[] ref;<br><span class="hljs-comment">//嵌套类型,要求类型参数参数都是可靠的</span><br>B&lt;?&gt;.C&lt;?&gt; ref;<br>B&lt;A&gt;.C&lt;A&gt; ref;<br><br></code></pre></div></td></tr></table></figure>

<p>所以想要数组支持泛型的唯一办法就是:</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//本意</span><br>ArrayList&lt;String&gt; ref=<span class="hljs-keyword">new</span> ArrayList&lt;String&gt;[];<span class="hljs-comment">//complie-error</span><br><span class="hljs-comment">//正确写法</span><br>ArrayList&lt;String&gt; ref=(ArrayList&lt;String&gt;[])<span class="hljs-keyword">new</span> ArrayList[];<span class="hljs-comment">//cast</span><br></code></pre></div></td></tr></table></figure>

<p>注:</p>
<blockquote>
<p>上述所有言论基于java1.8,似乎在java10中已经开始支持泛型数组,但并未考证</p>
</blockquote>
<hr>
<p>回到正题,java中的泛型是不变的。如果泛型是协变的,思考如下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ArrayList&lt;Number&gt; ref=<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><br>ref.add(<span class="hljs-number">2.3f</span>);<span class="hljs-comment">//cast</span><br></code></pre></div></td></tr></table></figure>
<p>在我们眼里,<code>ref</code>是一个存储<code>Number</code>的容器,那么就可以往里面存储<code>Double</code>、<code>Float</code>、<code>Integer</code>。取元素的时候到底转换成什么类型?程序不知道,程序员也不知道。并且很可能会产生运行时错误。既然这么,干脆就在编译期将这类错误禁止就完事了,但是仍然可以通过一些操作实现协变的逻辑。</p>
<p>对于泛型不支持逆变,是因为父类的引用赋值给子类就非常危险,所以当然不支持,而且也不可能实现。</p>
<h3 id="使用协变"><a href="#使用协变" class="headerlink" title="使用协变"></a>使用协变</h3><p>有些时候我们确实需要使用协变这一功能。比如我们有一组类<code>Dog``Cat``Pig</code>,需要对这些类实现一个通用的喂食功能,见如下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> generic;<br><br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>&#123;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">super</span>.getName()+<span class="hljs-string">&quot; eat shit.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cat</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">super</span>.getName()+<span class="hljs-string">&quot; eat air.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CovariantTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">feed</span><span class="hljs-params">(List&lt;Animal&gt; animalList)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(animalList==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(Animal elem:animalList)&#123;<br>            elem.eat();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;Dog&gt; dogs=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        dogs.add(<span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;peter&quot;</span>));<br>        dogs.add(<span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;tom&quot;</span>));<br><br>        ArrayList&lt;Cat&gt; cats=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        cats.add(<span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;lili&quot;</span>));<br>        cats.add(<span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;candy&quot;</span>));<br>        feed(dogs);<span class="hljs-comment">//complie-error</span><br>        feed(cats);<span class="hljs-comment">//complie-error</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>上面调用<code>feed</code>的代码是无法通过编译的,因为<code>feed</code>接受的是<code>List&lt;Animal&gt;</code>,而提供的是<code>ArrayList&lt;Dog&gt;</code>,这是因为泛型不支持协变。那么这个需求是确确实实存在的,怎么办?</p>
<p>这时候通配符<code>?</code>该上场了,泛型的作用是限制泛型的类型,提供类似协变的功能。</p>
<blockquote>
<p>通配符?表示我们不知道是什么类型,而不是任意类型!!!</p>
</blockquote>
<p>注意这里插一句,带有通配符的类型变量(type variable)叫做<code>wild type</code>(不知道是否官方,但是我看到别人这么叫了,而且这种叫法也不错,我就采用了)。但是通配符<code>?</code>是<strong>没有任何语义</strong>的,它不能代表任何一种类型,仅仅为了定义<code>wild type</code>的一个语法组成部分。所以定义类似<code>ArrayList&lt;?&gt;()</code>的对象就是错的,因为没有任何意义。</p>
<p>通配符是可以加边界来限制类型变量的类型的,通配符<code>?</code>边界分为以下三种:</p>
<ul>
<li>有上界的通配符:例如<code>? super Animal</code>,意思是这个泛型只能是<code>Animal</code>或者<code>Animal</code>的父类</li>
<li>有下界的通配符:例如<code>? extends Animal</code>,意思是这个泛型只能是<code>Animal</code>或者<code>Animal</code>的子类</li>
<li>无界的通配符:<code>?</code>,泛型是可以任意类型</li>
</ul>
<p>那么为了实现上面的需求,应将<code>feed</code>的签名改正为<code>public static void feed(List&lt;? extends Animal&gt; animalList)</code>,现在编译运行:</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">peter eat shit.<br>tom eat shit.<br>lili eat air.<br>candy eat air.<br></code></pre></div></td></tr></table></figure>
<p>成功实现了我们的需求。</p>
<h3 id="存下取上原则"><a href="#存下取上原则" class="headerlink" title="存下取上原则"></a>存下取上原则</h3><p>该原则取自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Xieyang-blog/p/9215934.html">Java中泛型区别以及泛型擦除详解</a>。</p>
<p><strong>A. 上界通配符:</strong><br>但是在使用了泛型通配符的地方,想要对容器增删元素就没有那么简单了。就拿上面的<code>List&lt;? extends Animal&gt; animals</code>做例子。传进来的参数有可能是<code>List&lt;Dog&gt;</code>,也有可能是<code>List&lt;Cat&gt;</code>,假设我们能够向<code>animals</code>中存储新元素,那么当我们取出我们存入的新元素时,它到底是什么类型的?编译器不知道。但是我们读取容器中的内容是没问题的,因为里面的元素至少是一个<code>Animals</code>,使用<code>Animals</code>的引用调用<code>Animals</code>的方法是没有任何问题的。这里就体现了<strong>存下取上</strong>的原则。</p>
<p>对于上界通配符<code>? extends Animal</code>,泛型的上界是<code>Animal</code>,没有下界,那就是<code>null</code>。所以所谓存下取上就是存储的时候按照泛型下界的类型存储,这里就是<code>null</code>,取出的时候按照泛型上界的类型取出,这里就是<code>Animal</code>。注意有一点原文没有说清楚:</p>
<blockquote>
<p>储存的元素类型<strong>至多</strong>是下界类型,取出时的元素类型<strong>至少</strong>是上界类型</p>
</blockquote>
<p>下面的图片很好的解释了这个原则:</p>
<p><img src="images/upper-bound.drawio.svg" srcset="/img/loading.gif" lazyload alt="upper-bound"></p>
<p>所以如果容器中,存在有<strong>上界通配符</strong>的泛型:对其写入的元素是很鸡肋的,相当于这个容器是<strong>只读</strong>的。</p>
<p><strong>B. 下界通配符:</strong></p>
<p>相应的,上界通配符实现的简单意义上的只写功能。例如<code>List&lt;? super Husky&gt; animals</code>,其中<code>husky</code>是<code>Dog</code>的子类,这里能存入的元素类型至多是<code>Husky</code>类型,没有上界,那么就是<code>Object</code>。</p>
<p>我们可以在<code>animals</code>中存储任意的<code>animals</code>子类对象(就像<code>List&lt;Dog&gt;</code>中存储的都是<code>Dog</code>类型的引用,但是可以在<code>List</code>中存储任意的<code>Dog</code>子类)。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Husky</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Dog</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Husky</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    List&lt;Dog&gt; list=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    insert(list);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> Dog&gt; set)</span></span>&#123;<br>    <span class="hljs-comment">//成功添加</span><br>    set.add(<span class="hljs-keyword">new</span> Husky(<span class="hljs-string">&quot;husky&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;success&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><img src="images/lower-bound.drawio.svg" srcset="/img/loading.gif" lazyload alt="lower-bound"></p>
<p>当然类似的,这里只能读取<code>Object</code>类型的对象,也很鸡肋。</p>
<p>所以如果容器中存在有下界通配符的泛型,那么该容器在非严格意义上是<strong>只写</strong>的。</p>
<p>这里的存下取上原则也叫做<code>PECS</code>原则,即<code>producer-extends,consumer super</code>。以容器的视角来说,当容器作为作为生产者,往外提供元素时,就使用<code>extends</code>;当容器作为消费者,需要存储元素时,就使用<code>super</code>。</p>
<p>在<code>Collections.copy</code>方法中,就是用PESC原则:</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//src为生产者,dest为消费者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>注意:<strong>如果</strong>同时有读写的要求呢?</strong></p>
<blockquote>
<p>就不需要使用泛型了。</p>
</blockquote>
<p><strong>C. 无界通配符:</strong></p>
<p>对于无界通配符<code>?</code>,它对应的下界为<code>null</code>,对应的上界为<code>Object</code>。</p>
<h3 id="3-泛型的擦除"><a href="#3-泛型的擦除" class="headerlink" title="3. 泛型的擦除"></a>3. 泛型的擦除</h3><p>在最开始曾说到java的泛型是<strong>伪泛型</strong>,仅仅保持在编译层面。在生成字节码文件时会对泛型擦除,将参数类型(parameterized types)转为原始类型(raw types)。所谓的参数类型就是类似于<code>class Person&lt;T&gt;</code>这种,而将它转换为原始类型就是<code>class Pseron</code>。在这种机制下，java中的多态就比较奇妙了。</p>
<h4 id="3-1-泛型下的多态"><a href="#3-1-泛型下的多态" class="headerlink" title="3.1 泛型下的多态"></a>3.1 泛型下的多态</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> generic;<br><span class="hljs-comment">//定义泛型类Person</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    T name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(T name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student s=<span class="hljs-keyword">new</span> Student();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Student类继承Person</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>Student</code>类继承了<code>Pseron</code>类,并且指定了父类的类型实参为<code>String</code>。那么父类的定义应该如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>然而java中的泛型都是假泛型,泛型在编译期被擦除后,因为类型变量<code>T</code>没有上界,所以编译会把T推断为<code>Object</code>类型。所以真正的代码如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    Object name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(Object name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>所以按道理,<code>Student</code>类中的<code>String</code>类型也应该变成<code>Object</code>类型,这样一来,不是全乱套了?所以java为了解决这个问题,发明了一种桥方法的机制。</p>
<p>可以看到,<code>Student</code>类中的<code>getName</code>和<code>setName</code>和<code>Person</code>类中的<code>getName</code>和<code>setName</code>参数类型根本就不一样,所以这根本就不是重载。但是代码又可以编译通过并且实现多态的特性。奇怪的事情发生了。我们看看<code>Studnet</code>编译后的字节码:</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// access flags 0x1</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span>Ljava/lang/String</span>;<br>   L0<br>    LINENUMBER <span class="hljs-number">22</span> L0<br>    ALOAD <span class="hljs-number">0</span><br>    GETFIELD generic/Student.stuName : Ljava/lang/String;<br>    ARETURN<br>   L1<br>    LOCALVARIABLE <span class="hljs-keyword">this</span> Lgeneric/Student; L0 L1 <span class="hljs-number">0</span><br>    MAXSTACK = <span class="hljs-number">1</span><br>    MAXLOCALS = <span class="hljs-number">1</span><br><br>  <span class="hljs-comment">// access flags 0x1</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">setName</span><span class="hljs-params">(Ljava/lang/String;)</span>V</span><br><span class="hljs-function">   L0</span><br><span class="hljs-function">    LINENUMBER 27 L0</span><br><span class="hljs-function">    ALOAD 0</span><br><span class="hljs-function">    ALOAD 1</span><br><span class="hljs-function">    PUTFIELD generic/Student.stuName : Ljava/lang/String</span>;<br>   L1<br>    LINENUMBER <span class="hljs-number">28</span> L1<br>    RETURN<br>   L2<br>    LOCALVARIABLE <span class="hljs-keyword">this</span> Lgeneric/Student; L0 L2 <span class="hljs-number">0</span><br>    LOCALVARIABLE name Ljava/lang/String; L0 L2 <span class="hljs-number">1</span><br>    MAXSTACK = <span class="hljs-number">2</span><br>    MAXLOCALS = <span class="hljs-number">2</span><br><br>  <span class="hljs-comment">// access flags 0x1041</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> synthetic bridge <span class="hljs-title">setName</span><span class="hljs-params">(Ljava/lang/Object;)</span>V</span><br><span class="hljs-function">   L0</span><br><span class="hljs-function">    LINENUMBER 18 L0</span><br><span class="hljs-function">    ALOAD 0</span><br><span class="hljs-function">    ALOAD 1</span><br><span class="hljs-function">    CHECKCAST java/lang/String</span><br><span class="hljs-function">    INVOKEVIRTUAL generic/Student.<span class="hljs-title">setName</span> <span class="hljs-params">(Ljava/lang/String;)</span>V</span><br><span class="hljs-function">    RETURN</span><br><span class="hljs-function">   L1</span><br><span class="hljs-function">    LOCALVARIABLE <span class="hljs-keyword">this</span> Lgeneric/Student</span>; L0 L1 <span class="hljs-number">0</span><br>    MAXSTACK = <span class="hljs-number">2</span><br>    MAXLOCALS = <span class="hljs-number">2</span><br><br>  <span class="hljs-comment">// access flags 0x1041</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> synthetic bridge <span class="hljs-title">getName</span><span class="hljs-params">()</span>Ljava/lang/Object</span>;<br>   L0<br>    LINENUMBER <span class="hljs-number">18</span> L0<br>    ALOAD <span class="hljs-number">0</span><br>    INVOKEVIRTUAL generic/Student.getName ()Ljava/lang/String;<br>    ARETURN<br>   L1<br>    LOCALVARIABLE <span class="hljs-keyword">this</span> Lgeneric/Student; L0 L1 <span class="hljs-number">0</span><br>    MAXSTACK = <span class="hljs-number">1</span><br>    MAXLOCALS = <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure>

<p>有两个<code>setName</code>,两个<code>getName</code>可以看到其中有一组<code>setName</code>和<code>getName</code>前面有修饰符<code>synthetic</code>和<code>bridge</code>。<code>synthetic</code>表示这是系统自动生成的,而<code>bridge</code>表示这是一个桥方法。</p>
<p>所以其实桥方法才真正是<code>override</code>了<code>Person</code>类中的两个方法。而桥方法又去调用了我们自定义的<code>setName</code>与<code>getName</code>完成了多态。</p>
<h4 id="3-2-泛型下的继承"><a href="#3-2-泛型下的继承" class="headerlink" title="3.2 泛型下的继承"></a>3.2 泛型下的继承</h4><p>普通的继承关系并没有类型的困扰。但是一旦给类上了泛型,那么就有点复杂了。大体分为四种情况:</p>
<ol>
<li>子类直接指定了父类的类型参数</li>
<li>子类继承了父类的类型参数</li>
<li>父类擦除了类型参数,子类没有擦除</li>
<li>子类与父类都擦出了类型参数</li>
</ol>
<p>下面我们一一解释以下,还是以上面的<code>Person</code>类作为例子:</p>
<p><strong>子类直接制定了父类的类型参数</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    E name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(E name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在这种情况,父类的类型参数已经被制定了,所以子类中从父类继承而来的东西也是被指定的类型,例如<code>String</code>。如果子类新加了类型参数<code>T</code>,那么这个<code>T</code>和父类没有任何关系。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;<br>    T age;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>子类继承了父类的类型参数</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>    T age;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(E name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>那么在子类中从父类继承而来的东西,类型还是<code>E</code>,类型参数<code>T</code>与父类没有任何关系。</p>
<p><strong>父类进行了泛型擦除而子类没有:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    T age;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(Object name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在这个例子中,由于<code>Person</code>类中的类型参数<code>E</code>没有上限,因为编译器只能把<code>E</code>推断为Object最为安全。如果类型参数<code>E</code>有上限,例如<code>E extends Number</code>,那么编译器就会将<code>E</code>推断为<code>Number</code>。上面代码中的<code>Object</code>就会全部换成<code>Number</code>了。</p>
<p><strong>子类与父类都进行了泛型擦除:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>     age;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(E name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>子类与父类都进行了擦除这么说并不准确,因为根本就没有定义子类的类型参数…规则和父类擦除而子类不擦除的规则一样。要看父类的类型参数有没有上限,因为编译器的推断类型是不一样的。</p>
<p><strong>那么为什么不能父类不擦除,而子类不擦除呢？</strong></p>
<p>因为继承泛型类时,子类必须对父类中的类型参数进行初始化,当然父类擦除或者由子类指定都可以。所以子类擦除而父类不擦除,父类中的类型参数由谁来初始化?</p>
<h4 id="3-3-泛型下的类型获取"><a href="#3-3-泛型下的类型获取" class="headerlink" title="3.3 泛型下的类型获取"></a>3.3 泛型下的类型获取</h4><p>上面曾说到，Java中的泛型是伪泛型，在编译时会被擦除为<code>Object</code>类型的，但是为什么又能够在运行时获取的泛型的真实类型呢？</p>
<p>首先我们需要知道一个逻辑：<strong>泛型擦除并不代表JVM不知道类型信息</strong>。对于泛型类，JVM可以从Class文件中的<code>Signature</code>属性来获取泛型类的<strong>声明</strong>类型，而不是实际类型。假设有代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">action</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    T a;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T a)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.a=a;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    action&lt;Integer&gt; test=<span class="hljs-keyword">new</span> action&lt;&gt;();<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在运行时我们可以获取引用<code>test</code>中的泛型类型，而不能获得<code>test.a</code>的泛型类。因为<code>test.a</code>在运行时会被泛化为<code>object</code>类型，无法通过class文件获取类型。但是对于<code>test</code>来说，因为在编译的时候编译器会将<code>test</code>泛型的声明类型作为<code>Signature</code>属性保存在<code>action</code>类的class文件中，所以我们可以通过<code>action.class</code>获取它的泛型声明类型。</p>
<p><strong>参考文献</strong></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.itzhai.com/articles/exploring-the-nature-of-java-generics.html">深入探索Java泛型的本质 | 泛型</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/346911525">Java中的泛型会被类型擦除，那为什么在运行期仍然可以使用反射获取到具体的泛型类型？</a></li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31137677">仔细说说Java中的泛型</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuqinglong/p/9456193.html">Java泛型类型擦除以及类型擦除带来的问题</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/313280">java泛型学习（2）</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000007925818">java 如何继承泛型</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ShierJun/article/details/51253870">泛型继承的几种写法</a></p>
</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%8F%8D%E5%B0%84/">反射</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">基本概念</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%B3%9B%E5%9E%8B/">泛型</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021-06-04/Frequently-asked-questions-about-generics.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">关于泛型的常见问题</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021-06-04/class-loading-mechanism.html">
                        <span class="hidden-mobile">类的加载机制</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@waline/client@0.16.2/dist/Waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"https://blog-comment-blond.vercel.app","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":true,"avatarCDN":"","avatarForce":false,"requiredFields":[],"emojiCDN":null,"emojiMaps":null,"anonymous":null},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        new Waline(options);
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  

  <div>
    <span id="timeDate">载入天数...</span>
    <span id="times">载入时分秒...</span>
    <script>
    var now = new Date();
    function createtime(){
        var grt= new Date("06/03/2021 00:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24;
        dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
        hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){
            hnum = "0" + hnum;
        }
        minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes);
        if(String(mnum).length ==1 ){
                  mnum = "0" + mnum;
        }
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds);
        if(String(snum).length ==1 ){
                  snum = "0" + snum;
        }
        document.getElementById("timeDate").innerHTML = "🚀 for&nbsp"+dnum+"&nbspdays";  //此次自定义显示内容
        document.getElementById("times").innerHTML = hnum + "&nbsphr&nbsp" + mnum + "&nbspmin&nbsp" + snum + "&nbspsec";
    }  //此次自定义显示内容
    setInterval("createtime()",250);
    </script>
  </div>
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  
    <!-- Google Analytics -->
    <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'UA-198559201-1', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  
    <!-- Google gtag.js -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-19MVRDT9NM"></script>
    <script defer>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-19MVRDT9NM');
    </script>
  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
