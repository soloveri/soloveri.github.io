

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/panda.png">
  <link rel="icon" href="/img/panda.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#55967e">
  <meta name="description" content="">
  <meta name="author" content="rain">
  <meta name="keywords" content="">
  
  <title>ThreadPoolExecutor线程池解析 - 一颗胡杨树</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"soloveri.github.io","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":"UA-198559201-1","gtag":"G-19MVRDT9NM","tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"3MrDNVWQz1aBbREDmtPT7DuN-MdYXbMMI","app_key":"34YIO0Yk922Dzi79zUJidSkl","server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/rss2.xml" title="一颗胡杨树" type="application/rss+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Rains·Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/home.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="ThreadPoolExecutor线程池解析">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-06-03 20:27" pubdate>
        2021年6月3日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      83
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">ThreadPoolExecutor线程池解析</h1>
            
            <div class="markdown-body">
              <h2 id="0-预备知识"><a href="#0-预备知识" class="headerlink" title="0. 预备知识"></a>0. 预备知识</h2><p>在了解<code>ThreadPoolExecutor</code>之前，我们首先需要了解一些基本概念，下图是<code>ThreadPoolExecutor</code>的部分核心字段。我先依次对其进行解释。</p>
<p><img src="images/ThreadPoolExecutor-fields.png" srcset="/img/loading.gif" lazyload alt="ThreadPoolExecutor"></p>
<h3 id="0-1-线程池状态"><a href="#0-1-线程池状态" class="headerlink" title="#0.1 线程池状态"></a>#0.1 线程池状态</h3><p>JUC为线程池规定了5种状态，如下图所示：<br><img src="images/Executor-state.drawio.svg" srcset="/img/loading.gif" lazyload alt="executor-state"></p>
<p>对于每种状态，含义如下：</p>
<ol>
<li>RUNNING: 线程池能够接受任务并处理阻塞队列中的任务</li>
<li>SHUTDOWN: 不再接受新的任务，但是会把阻塞队列中的任务全部执行完毕</li>
<li>STOP: 不再接受新的任务，不再处理阻塞队列中的任务，并且会中断正在执行的任务</li>
<li>TIDYING:  所有的任务都被终止，工作线程的数量为0，并且在转化为该状态时，线程池会执行<code>terminated()</code>方法</li>
<li>TERMINATED: <code>terminated()</code>方法执行完毕</li>
</ol>
<p>了解了线程池的五种状态后，那么它底层到底是如何实现的呢？其实也不复杂。<code>ThreadPoolExecutor</code>通过一个<code>AtomicInterger</code>维护了这五种状态。实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY   = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// runState is stored in the high-order bits</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING    = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br></code></pre></div></td></tr></table></figure>

<p>对于一个32为的<code>AtomicInteger</code>来说，它的信息分为两部分：</p>
<ul>
<li>第30~32位：线程池的状态</li>
<li>第1~29位，线程池中的线程数量</li>
</ul>
<p>从上面的定义中我们得知：<code>ctl</code>属性维护上述的两组信息，并且在初始化时会将线程数量设为0。获取状态时只需要通过<code>runStateOf(int)</code>方法获取<code>ctl</code>属性的高3位即可，对于线程数量的获取同理。</p>
<h3 id="0-2-线程池互斥锁"><a href="#0-2-线程池互斥锁" class="headerlink" title="#0.2 线程池互斥锁"></a>#0.2 线程池互斥锁</h3><p><code>ThreadPoolExecutor</code>内部维护了一个<code>ReentrantLock</code>用来实现对工作线程集合的互斥访问，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">new</span> ReentrantLock();<br></code></pre></div></td></tr></table></figure>

<p>因为在多线程环境，操作一个hashSet可能会出现线程不安全的问题。至于为什么不适用一个线程安全的set，是因为使用锁可以对<code>interruptIdleWorkers()</code>的操作进行序列化，从而避免了不必要的中断风暴，尤其是在关闭线程池期间。并且还能够简化一些数据的统计。</p>
<h3 id="0-3-线程包装类Worker"><a href="#0-3-线程包装类Worker" class="headerlink" title="#0.3 线程包装类Worker"></a>#0.3 线程包装类Worker</h3><p>在<code>ThreadPoolExecutors</code>中，定义了一个不可变对象<code>Worker</code>作为线程的wrapper，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span></span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * This class will never be serialized, but we provide a</span><br><span class="hljs-comment">    * serialVersionUID to suppress a javac warning.</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">6138294804551838833L</span>;<br><br>    <span class="hljs-comment">//具体执行任务的线程，为null表示出现错误</span><br>    <span class="hljs-keyword">final</span> Thread thread;<br>    <span class="hljs-comment">//worker执行的第一个任务，可能为null</span><br>    Runnable firstTask;<br><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> completedTasks;<br><br>    Worker(Runnable firstTask) &#123;<br>        <span class="hljs-comment">//防止在当前线程执行runWorker之前，就收到中断</span><br>        setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>        <span class="hljs-keyword">this</span>.firstTask = firstTask;<br>        <span class="hljs-keyword">this</span>.thread = getThreadFactory().newThread(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        runWorker(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Lock methods</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// The value 0 represents the unlocked state.</span><br>    <span class="hljs-comment">// The value 1 represents the locked state.</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>            setExclusiveOwnerThread(Thread.currentThread());<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br>        setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>        setState(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span>        </span>&#123; acquire(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span>  </span>&#123; <span class="hljs-keyword">return</span> tryAcquire(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span>      </span>&#123; release(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLocked</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> isHeldExclusively(); &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">interruptIfStarted</span><span class="hljs-params">()</span> </span>&#123;<br>        Thread t;<br>        <span class="hljs-keyword">if</span> (getState() &gt;= <span class="hljs-number">0</span> &amp;&amp; (t = thread) != <span class="hljs-keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.interrupt();<br>            &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>之所以要包装呢，是因为<code>Worker</code>可以比<code>Thread</code>提供更多的信息。例如当前<code>worker</code>累计执行了多少个任务。其实我们还可以注意到<code>Worker</code>继承了AQS。那么这里就会出现两个问题：</p>
<ol>
<li>为什么要继承AQS？一个<code>Worker</code>要锁干嘛？一个<code>Worker</code>不是自己负责一个任务吗？难道会有多个线程访问同一个<code>Worker</code>？</li>
<li>使用线程的锁不行吗？为什么要自己实现一个锁？</li>
</ol>
<p>那么对于第一个问题，其实这个问题在注释中已经说明了：</p>
<blockquote>
<p>Class Worker mainly <strong>maintains interrupt control state</strong> for threads running tasks, along with other minor bookkeeping. This class opportunistically extends AbstractQueuedSynchronizer to simplify acquiring and releasing a lock <strong>surrounding each task execution</strong>. This protects against interrupts that are intended to wake up a worker thread waiting for a task from instead interrupting a task being run. </p>
</blockquote>
<blockquote>
<p>We implement a simple <strong>non-reentrant mutual exclusion lock</strong> rather than use ReentrantLock because we do not want worker tasks to be able to reacquire the lock when they invoke pool control methods like setCorePoolSize. Additionally, to suppress interrupts until the thread actually starts running tasks, we initialize lock state to a negative value, and clear it upon start (in runWorker).</p>
</blockquote>
<p>大致意思是说：<br><code>Worker</code>类会管理线程在执行任务时的中断状态，以及一些其他的信息。<code>Worker</code>继承AQS是为了实现一个简单的不可重入的锁，用来在执行任务前上锁，在任务完毕后后释放锁。<strong>上锁的原因是因为如果有中断发生，那么只希望中断那些正在等待任务的<code>Worker</code>，而不是中断那些正在执行任务的<code>Worker</code>。</strong></p>
<p>自己实现一个简单的<strong>不可重入</strong>的锁是因为已有的锁都是可重入的，线程池需要一个不可重入锁的才能达到上面的目的。那么为什么不可重入的就能达到目的呢？考虑下面一个场景：假设主线程调用了<code>setCorePoolSize(int)</code>调整线程池的大小，那么<code>ThreadPoolExecutor</code>希望这个调整的动作不要影响那些正在执行任务的<code>Worker</code>，所以就通过能否获取<code>Worker</code>对应的锁来判断当前<code>Worker</code>是否处于空闲状态，那么这里的锁只能是独占锁。若是可重入锁，那么，无论是等待任务的，还是正在执行的，都会被中断。<code>setCorePoolSize(int)</code>如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//调用该函数需要中断那些空闲的线程</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCorePoolSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (workerCountOf(ctl.get()) &gt; corePoolSize)<br>        interruptIdleWorkers();<br>    ...<br>&#125;<br><br><span class="hljs-comment">//判断一个线程是否空闲就是看能否获取对应worker的不可重入独占锁</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> onlyOne)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (Worker w : workers) &#123;<br>            Thread t = w.thread;<br>            <span class="hljs-comment">//能够成功获取不可重入锁就表示当前Worker没有执行任务，自然可以执行中断</span><br>            <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    t.interrupt();<br>                &#125;<br>                ...<br>            &#125;<br>            ...<br>        &#125;<br>    &#125;<br>    ...<br></code></pre></div></td></tr></table></figure>

<h3 id="0-4-线程工厂-ThreadFactory"><a href="#0-4-线程工厂-ThreadFactory" class="headerlink" title="#0.4 线程工厂:ThreadFactory"></a>#0.4 线程工厂:ThreadFactory</h3><p>所谓的线程的工厂，JUC提供了一个线程工厂接口<code>ThreadFactory</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ThreadFactory</span> </span>&#123;<br>    <span class="hljs-function">Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>唯一需要重写的方法就是生产新线程的方法<code>newThread(Runnable)</code>。对<code>ThreadPoolExecutor</code>，它内部实现了两种工厂类：<code>DefaultThreadFactory</code>和<code>PrivilegedThreadFactory</code>。</p>
<p>区别就是前者生产的线程优先级默认为5，后者对于新生产的线程和调用线程工厂的线程具有相同优先级，并具有相同的线程上下文类加载器。下面只列出默认工厂的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ThreadFactory</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicInteger poolNumber = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadGroup group;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger threadNumber = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String namePrefix;<br><br>    DefaultThreadFactory() &#123;<br>        SecurityManager s = System.getSecurityManager();<br>        group = (s != <span class="hljs-keyword">null</span>) ? s.getThreadGroup() :<br>                                Thread.currentThread().getThreadGroup();<br>        namePrefix = <span class="hljs-string">&quot;pool-&quot;</span> +<br>                        poolNumber.getAndIncrement() +<br>                        <span class="hljs-string">&quot;-thread-&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(group, r,<br>                                namePrefix + threadNumber.getAndIncrement(),<br>                                <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (t.isDaemon())<br>            t.setDaemon(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-comment">//设置新线程的默认优先级为5</span><br>        <span class="hljs-keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)<br>            t.setPriority(Thread.NORM_PRIORITY);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="0-5-拒绝策略-defaultHandler"><a href="#0-5-拒绝策略-defaultHandler" class="headerlink" title="#0.5 拒绝策略:defaultHandler"></a>#0.5 拒绝策略:defaultHandler</h3><p>对于拒绝策略，我在讲解<a href="executor-interface.md">Executor框架</a>时曾说过，自带的拒绝策略有四种，而<code>ThreadPoolExecutor</code>默认采用的是AbortPolicy，直接拒绝提交的任务，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbortPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(<span class="hljs-string">&quot;Task &quot;</span> + r.toString() +<br>                                                <span class="hljs-string">&quot; rejected from &quot;</span> +<br>                                                e.toString());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="0-6-阻塞队列-workQueue"><a href="#0-6-阻塞队列-workQueue" class="headerlink" title="#0.6 阻塞队列:workQueue"></a>#0.6 阻塞队列:workQueue</h3><h2 id="1-任务添加流程"><a href="#1-任务添加流程" class="headerlink" title="1. 任务添加流程"></a>1. 任务添加流程</h2><p>阅读过源码的同学都知道，<code>ThreadPoolExecutor</code>并没有重写<code>ExecutorService</code>的<code>submit(Runnable)</code>的方法。当我们调用<code>submit</code>时实际调用的是<code>AbstractExecutorService</code>重写的<code>submit</code>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-keyword">null</span>);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在<code>submit</code>中又会调用<code>ThreadPoolExecutor</code>重写的<code>execute(Runnable)</code>方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <br>    <span class="hljs-keyword">int</span> c = ctl.get();<br>    <span class="hljs-comment">//如果当前线程池的线程数量小于核心线程数</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-comment">//尝试设置线程的第一个任务，因为通过execute调用addWorker，那么一定是</span><br>        <span class="hljs-comment">//因为有新任务进来了</span><br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br>    <span class="hljs-comment">//走到这说明线程数已经不小于核心线程数了</span><br>    <br>    <span class="hljs-comment">//如果线程池处于running状态，但是无法向阻塞队列中添加任务</span><br>    <span class="hljs-comment">//那么尝试添加新的worker</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-keyword">int</span> recheck = ctl.get();<br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))<br>        reject(command);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>主要的流程分为三步：</p>
<ol>
<li>如果当前活跃的线程的数量小于核心线程数，那么就尝试调用<code>addWaiter(Runnable,boolean)</code>增加一个线程，如果成功直接返回，否则执行2</li>
<li>走到这里说明线程数至少不小于核心线程数，那么尝试向阻塞队列中添加任务，如果添加成功，我们仍然需要通过双重检查是否应该增加线程（因为有可能在上次检查之后，线程池中的线程全部死亡），如果线程全部死亡，那么则尝试添加一个Worker。</li>
<li>如果无法向阻塞队列中添加任务，说明阻塞队列已满，如果此时无法增加worker，那么则会根据拒绝策略拒绝当前任务</li>
</ol>
<p>添加<code>worker</code>的方法<code>addWaiter(Runnable,boolean)</code>如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">返回true表示成功添加了工作线程并启动</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">但是返回false的情况有很多，但是都会进行回滚操作：</span><br><span class="hljs-comment">1. 表示线程池已经stop或者即将关闭</span><br><span class="hljs-comment">2. 线程创建失败，要么是因为线程工厂返回null，或者在启动线程的时候内存溢出，</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//第一个参数表示当前worker是否有第一个任务</span><br><span class="hljs-comment">//第二个参数core表示当前线程数量的上限是选核心线程数还是最大线程数</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;<br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-comment">//获取线程池状态</span><br>        <span class="hljs-keyword">int</span> rs = runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-comment">//如果当前线程池已经shutdown及之后的状态</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            <span class="hljs-comment">//线程不是shutdown状态，表示已经进入stop或tidying</span><br>            <span class="hljs-comment">//线程池是shutdown状态，并且firstTask不为空，但是shutdown状态不再接受任务，所以返回false</span><br>            <span class="hljs-comment">//线程池是shutdown状态，并且firstTask为空，并且阻塞队列为空，没有任务要执行，自然返回false</span><br><br>            ! (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span> &amp;&amp; ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br>            <span class="hljs-comment">//如果线程池的线程数量已经超过了最大容量，返回false</span><br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                <span class="hljs-comment">//如果以核心线程数作界限，那么就看当前线程数是否超过了核心线程数</span><br>                <span class="hljs-comment">//只有在队列满之后core才会为false</span><br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">//线程数没超标，那么添加线程</span><br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            <span class="hljs-comment">//cas失败说明有多个线程在同时添加任务</span><br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-comment">//如果线程池的状态发生改变，那么retry</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;<br>    Worker w = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//生成一个Worker</span><br>        w = <span class="hljs-keyword">new</span> Worker(firstTask);<br>        <span class="hljs-keyword">final</span> Thread t = w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck while holding lock.</span><br>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                <span class="hljs-comment">// shut down before lock acquired.</span><br>                <span class="hljs-keyword">int</span> rs = runStateOf(ctl.get());<br>                <span class="hljs-comment">//检查线程池是否已经关闭</span><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;<br>                    <span class="hljs-comment">//判断线程工厂创建线程是否成功</span><br>                    <span class="hljs-keyword">if</span> (t.isAlive())<br>                        <span class="hljs-comment">//预先检查新worker的状态</span><br>                        <span class="hljs-comment">//如果在我们没有启动线程的情况，线程就alive肯定要抛出异常</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();<br>                    <span class="hljs-comment">//将新生成的worker添加到线程池中，其实就是一个HashSet</span><br>                    workers.add(w);<br>                    <span class="hljs-keyword">int</span> s = workers.size();<br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                <span class="hljs-comment">//启动线程</span><br>                t.start();<br>                workerStarted = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>其中逻辑还是比较清晰的，在生成线程后如果能成功启动，那么则返回true，否则会调用<code>addWorkerFailed</code>进行回滚操作。</p>
<p>值得注意的是在访问<code>worker</code>集合<code>workers</code>的时候，需要保证互斥访问。具体原理在预备知识中已经介绍过。</p>
<h2 id="2-线程工作流程"><a href="#2-线程工作流程" class="headerlink" title="2. 线程工作流程"></a>2. 线程工作流程</h2><p>在启动<code>worker</code>之后，最后在<code>worker</code>的<code>run()</code>方法中会调用<code>runWorker(Worker)</code>实现不断的从阻塞队列中获取任务，并调用任务的<code>run()</code>执行。</p>
<p>值得注意的是：在当前<code>worker</code>获取到新任务时，会使用自身的不可重入独占锁进行一个加锁操作，这个操作标志着当前<code>worker</code>已经开始执行具体的任务了，暂时屏蔽线程池发出的中断。</p>
<p><code>runWorker(Worker)</code>代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runWorker</span><span class="hljs-params">(Worker w)</span> </span>&#123;<br>    Thread wt = Thread.currentThread();<br>    Runnable task = w.firstTask;<br>    w.firstTask = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//需要首先解锁一次，因为一个worker最初始的状态为-1，这么做是为了防止</span><br>    <span class="hljs-comment">//worker在执行runWorker之前就收到了中断，例如在主函数关闭了线程池，</span><br>    w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>    <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//如果获取不到新的任务，那么就会退出循环</span><br>        <span class="hljs-comment">//getTask在线程池至少处于shutdown时，会返回null</span><br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = getTask()) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//使用worker的锁，表示当前worker已经获得新任务，暂时屏蔽中断</span><br>            w.lock();<br><br>            <span class="hljs-comment">//如果线程池进入stopping状态，那么必须保证当前worker被中断</span><br>            <span class="hljs-comment">//否则，必须保证当前worker不能被中断</span><br>            <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>            <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>            <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>            <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                    <span class="hljs-comment">//这里做的是二次检查，有可能用户突然调用了shutdownNow</span><br>                    (Thread.interrupted() &amp;&amp;<br>                    runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())<br>                wt.interrupt();<br>            <span class="hljs-keyword">try</span> &#123;<br>                beforeExecute(wt, task);<br>                Throwable thrown = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//执行任务自己的run方法</span><br>                    task.run();<br>                <span class="hljs-comment">//捕捉任务可能抛出的异常，然后从线程池抛出</span><br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(x);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    afterExecute(task, thrown);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-keyword">null</span>;<br>                w.completedTasks++;<br>                w.unlock();<br>            &#125;<br>        &#125;<br>        completedAbruptly = <span class="hljs-keyword">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//如果一个线程无法再获取新的任务，那么就会将当前线程销毁</span><br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="2-1-获取新任务的流程"><a href="#2-1-获取新任务的流程" class="headerlink" title="2.1 获取新任务的流程"></a>2.1 获取新任务的流程</h3><p>每当<code>worker</code>完成一个任务后，会尝试调用<code>getTask()</code>从我们提供的阻塞队列中获取新的任务。当阻塞队列为空时，该函数可以无限时等待或者有限等待，这需要根据是否允许核心线程过期来抉择。</p>
<p>如果该函数返回null就表示当前worker已经结束使命了，可以终结了。返回null的情况很多：</p>
<ol>
<li>线程池已经处于STOPING状态</li>
<li>线程池已经处于SHUTDOWN状态并且阻塞队列为空</li>
<li>线程数已经超过最大值</li>
<li>当前worker等待新任务的时间过长，也就是说等待的时长超过了一个核心线程的存活时长</li>
</ol>
<p>否则返回一个新的任务具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title">getTask</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> timedOut = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-keyword">int</span> rs = runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-comment">//如果线程已经至少处于SHUTDOWN状态并且empty为空，因为后续都不可能有新任务提交，那么直接返回null</span><br>        <span class="hljs-comment">//表示当前worker的工作可以结束了</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            <span class="hljs-comment">//将线程数减1</span><br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br><br>        <span class="hljs-comment">// Are workers subject to culling?</span><br>        <span class="hljs-keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;<br><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Runnable r = timed ?<br>                <span class="hljs-comment">//收到中断时take会抛出InterruptException</span><br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="2-2-worker退出流程"><a href="#2-2-worker退出流程" class="headerlink" title="2.2 worker退出流程"></a>2.2 worker退出流程</h3><p>从上面<code>runWorker(Worker)</code>的处理流程可以看到，当一个<code>Worker</code>无法获得新任务时，那么就会调用<code>processWorkerExit(Worker,boolean)</code>将当前<code>Worker</code>移出线程集合，并根据当前池内的线程数量来决定是否要添加新的<code>Worker</code>，实现逻辑如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-keyword">boolean</span> completedAbruptly)</span> </span>&#123;<br>    <span class="hljs-comment">//如果工作线程的结束是因为用户的代码产生了异常</span><br>    <span class="hljs-keyword">if</span> (completedAbruptly) <span class="hljs-comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span><br>        decrementWorkerCount();<br><br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    <span class="hljs-comment">//对线程集合进行互斥访问</span><br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        completedTaskCount += w.completedTasks;<br>        <span class="hljs-comment">//将当前线程移出工作队列</span><br>        workers.remove(w);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br><br>    <span class="hljs-comment">//尝试关闭线程池</span><br>    tryTerminate();<br><br>    <span class="hljs-keyword">int</span> c = ctl.get();<br>    <span class="hljs-comment">//如果当前线程池处于RUNNING/SHUTDOWN状态</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 那么这里可能会产生一个问题：如果处于SHUTDOWN状态，我们应该将所有的Worker移出集合</span><br><span class="hljs-comment">    * 但是SHUTDOWN是可以通过下面的if条件，那么最后又会执行addWorker()，又往集合中添加一个新的worker</span><br><span class="hljs-comment">    * 那岂不是集合内的worker永远都无法彻底移出？</span><br><span class="hljs-comment">    * 其实这种担心是多虑的，因为addWorker()会首先检查当前线程池的状态，如果为SHUTDOWN，直接返回false</span><br><span class="hljs-comment">    * 并不会构造新的worker</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;<br>        <span class="hljs-comment">//如果工作线程是正常地结束</span><br>        <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;<br>            <span class="hljs-keyword">int</span> min = allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;<br>            <span class="hljs-comment">//如果核心线程有失效时间限制并且阻塞队列不为空</span><br>            <span class="hljs-comment">//那么线程池中至少要保留一个线程</span><br>            <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.isEmpty())<br>                min = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// replacement not needed</span><br>        &#125;<br>        <span class="hljs-comment">//如果线程数量小于min，那么需要补上一个新的worker</span><br>        addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在将无法获得任务的线程移出集合后，会根据当前是否允许核心线程过期获得线程池的最低线程数量：</p>
<ol>
<li>如果当前线程数量仍然不小于最低限度，直接返回即可，不需要重新补充<code>Worker</code></li>
<li>如果当前线程数小于最低限度，那么需要最后调用<code>addWorker()</code>重新补充一个<code>Worker</code></li>
</ol>
<h2 id="3-线程池终止流程"><a href="#3-线程池终止流程" class="headerlink" title="3. 线程池终止流程"></a>3. 线程池终止流程</h2><p><strong>对于线程池来说，关闭线程池（shutdown）和终止线程池（terminate）完全是两码事</strong>。所谓的关闭，是指线程池不再接受新的任务，而终止则是线程池中的所有工作线程都已经正确地关闭。</p>
<h3 id="3-1-shutdown-的执行逻辑"><a href="#3-1-shutdown-的执行逻辑" class="headerlink" title="3.1 shutdown()的执行逻辑"></a>3.1 shutdown()的执行逻辑</h3><p><code>ThreadPoolExectuor</code>提供了两种方法<code>shutdown</code>和<code>shutdownNow</code>用来关闭线程池。对于前者，它会保证已经提交到阻塞队列的任务被执行，并不是等到任务都执行完毕才会关闭线程池。在关闭的流程中，一直有一个问题困扰着我：为什么要通过调用<code>interrupt()</code>抛出中断当作线程池关闭的信号？带着这个问题，我首先梳理了<code>shutdown()</code>的逻辑。首先我们来看看<code>shutdown()</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//检查是否有权限关闭线程池</span><br>        checkShutdownAccess();<br>        <span class="hljs-comment">//将当前线程池升级到SHUTDOWN状态</span><br>        advanceRunState(SHUTDOWN);<br>        <span class="hljs-comment">//中断空闲的线程</span><br>        interruptIdleWorkers();<br>        <span class="hljs-comment">//为周期任务线程池准备的hook函数</span><br>        onShutdown();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    <span class="hljs-comment">//尝试真正地终止线程</span><br>    tryTerminate();<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>从源码中我们得知：当调用<code>shutdown()</code>方法后，首先会将线程池状态转化到SHUTDOWN。然后中断空闲的线程。那么这里就有两个问题：</p>
<ol>
<li>为什么要中断空闲线程？</li>
<li>为什么关闭线程池需要通过中断这个操作？</li>
</ol>
<p>对于第一个问题，先说说我的理解：所谓的关闭关闭线程池就是将每个工作线程正确关闭，又因为<code>shutdown()</code>不影响正在执行任务的线程，所以就先关闭空闲的线程。那么我们来看看<code>interruptIdleWorkers()</code>到底是如何运作的：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> onlyOne)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//遍历工作线程集合，找出空闲的线程并抛出中断</span><br>        <span class="hljs-keyword">for</span> (Worker w : workers) &#123;<br>            Thread t = w.thread;<br>            <span class="hljs-comment">//如果线程没有被中断并且能够获取worker的独占锁</span><br>            <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    t.interrupt();<br>                &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    w.unlock();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (onlyOne)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在分析<code>Worker</code>的工作流程时，曾说到，当一个<code>worker</code>正在执行任务时，会使用自身的独占不可重入锁上锁。那么在查询空闲<code>worker</code>时就利用了这个特点：<code>w.tryLock()</code>成功就说当前<code>worker</code>没有上锁，那也就是没有执行任务，自然可以关闭了。</p>
<p>那么这里的关闭的操作实际上调用当前<code>worker</code>的<code>interrupt()</code>函数发出一个中断，why？我们思考如下一个场景：</p>
<p>首先我们中断的都是空闲线程，那么空闲线程都在干嘛？是不是都在等待获取新的任务？那么如何等待？也就是通过调用阻塞队列的<code>take()</code>方法（无限等待场景下），当我们发生一个中断时，<code>take()</code>方法会抛出一个<code>InterruptException</code>，会在<code>getTask()</code>方法中被捕获。</p>
<p>捕获之后，也就说明被中断的<code>worker</code>已经被唤醒了。那么会重新执行循环，在循环初始部分，会判断当前线程池的状态，如果为SHUTDOWN或者类似的，会返回null。返回null表示什么？表示当前<code>worker</code>可以结束使命了，那么会跳出<code>runWorker()</code>中的循环，执行<code>processWorkerExit(Worker,boolean)</code>。在<code>processWorkerExit(Worker,boolean)</code>中，又会调用<code>tryTerminate()</code>尝试终止线程池。该函数的任务就是当线程池数量为0，将线程池状态转化为TIDYING状态，并执行hook函数<code>terminated()</code>。最后转化为TERMINATED状态。</p>
<p>值得注意的是，<code>tryTerminate()</code>中会调用<code>interruptIdleWorkers(ONLY_ONE)</code>传播线程池准备终止的信息。那么怎么传播呢？我们观察上述<code>interruptIdleWorkers()</code>函数的源码，因为我们传入的参数为true，那么会随机中断一个空闲线程<code>worker</code>。而空闲线程在被移出线程集合后，又会调用<code>processWorkerExit(Worker,boolean)</code>。周而复始，最后所有的空闲工作线程都会收到中断。<code>tryTerminate()</code>逻辑如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//这个方法只能在可能需要终止线程池的时候调用，例如剔除无用worker或者在shutdown状态移出队列任务</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryTerminate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-comment">//如果线程池处于RUNNING状态</span><br>        <span class="hljs-comment">//如果线程池正在处于终止状态</span><br>        <span class="hljs-comment">//或者线程池处于SHUTDOWN并且阻塞队列不为空</span><br>        <span class="hljs-comment">//那么就不需要再终止了，终止一次就够了</span><br>        <span class="hljs-keyword">if</span> (isRunning(c) ||<br>            runStateAtLeast(c, TIDYING) ||<br>            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//走到这说明线程池没有任务需要执行了，处于需要终止的状态</span><br><br>        <span class="hljs-comment">//如果线程数量不为0，那么就尝试中断最多一个空闲线程，并传播这个中断状态</span><br>        <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Eligible to terminate</span><br>            interruptIdleWorkers(ONLY_ONE);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//如果池中的线程数量为0，那么尝试将线程池状态转化为TIDYING</span><br>        <span class="hljs-comment">//如果转化成功，则会执行hook函数terminated()，并把线程池状态转化为TERMINATED</span><br>        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    terminated();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));<br>                    <span class="hljs-comment">//唤醒在awaitTermination条件上等待的线程</span><br>                    termination.signalAll();<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>        <span class="hljs-comment">// else retry on failed CAS</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>那么这里又有一个问题了，上面中断的都是空闲工作线程，如果我们执行<code>shutdown()</code>时，没有空闲线程怎么办？正在执行任务的线程如何被回收？岂不是会在<code>runWorker()</code>中，因为调用<code>getTask()</code>一直被阻塞直到获取新的任务，但是又永远都不会有新任务？我想了很久，最后发现答案竟然在<code>getTask()</code>的源码中。当我们的工作线程执行完当前任务后，会再次调用<code>getTask()</code>，而<code>getTask()</code>在一开始就会判断当前线程池的状态，如果状态为SHUTDOWN并且阻塞队列为空，那么直接返回，不会被阻塞。从而最后也会执行<code>processWorkerExit(Worker,boolean)</code>，传播中断状态。</p>
<h3 id="3-2-shutdownNow的区别"><a href="#3-2-shutdownNow的区别" class="headerlink" title="3.2 shutdownNow的区别"></a>3.2 shutdownNow的区别</h3><p>对于<code>shutdownNow()</code>方法，跟<code>shutdown()</code>流程差不多。唯一不同的是：<code>shutdownNow()</code>不管<code>worker</code>有没有执行任务，只要<code>worker</code>执行过<code>runWorker(Worker)</code>函数，就发出一个中断请求。我们需要注意的是：中断请求对于空闲线程来说是一定有限的；对于正在执行任务的线程，这需要用户任务的配合，也就说用户任务能够处理中断才能结束未完成的任务。后续的流程就跟<code>shutdown()</code>几乎一样。调用<code>tryTerminate()</code>尝试终止线程池。<code>shutdownNow()</code>方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Attempts to stop all actively executing tasks, halts the</span><br><span class="hljs-comment">* processing of waiting tasks, and returns a list of the tasks</span><br><span class="hljs-comment">* that were awaiting execution. These tasks are drained (removed)</span><br><span class="hljs-comment">* from the task queue upon return from this method.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* &lt;p&gt;This method does not wait for actively executing tasks to</span><br><span class="hljs-comment">* terminate.  Use &#123;<span class="hljs-doctag">@link</span> #awaitTermination awaitTermination&#125; to</span><br><span class="hljs-comment">* do that.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* &lt;p&gt;There are no guarantees beyond best-effort attempts to stop</span><br><span class="hljs-comment">* processing actively executing tasks.  This implementation</span><br><span class="hljs-comment">* cancels tasks via &#123;<span class="hljs-doctag">@link</span> Thread#interrupt&#125;, so any task that</span><br><span class="hljs-comment">* fails to respond to interrupts may never terminate.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span> </span>&#123;<br>List&lt;Runnable&gt; tasks;<br><span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>mainLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    checkShutdownAccess();<br>    advanceRunState(STOP);<br>    interruptWorkers();<br>    tasks = drainQueue();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    mainLock.unlock();<br>&#125;<br>tryTerminate();<br><span class="hljs-keyword">return</span> tasks;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="4-内置线程池"><a href="#4-内置线程池" class="headerlink" title="4. 内置线程池"></a>4. 内置线程池</h2><p>JUC中提供了四种基于<code>ThreadPoolExecutor</code>的内置线程池：</p>
<ol>
<li><p><strong>newFixedThreadPool</strong>：核心线程数和最大线程数相等的线程，阻塞队列无限长度。也就是说线程池的线程数量固定</p>
</li>
<li><p><strong>newCachedThreadPool</strong>：核心线程数为0的线程池，并且阻塞队列不存储任务。也就是说该线程池只会使用非核心线程来处理任务，如果超过60秒等不到新的任务，那么则会回收当前线程</p>
</li>
<li><p><strong>newSingleThreadExecutor</strong>：线程池的线程数量为1，阻塞队列无限长度。也就是线程数量固定为1的线程池。该线程池能够保证任务串行地完成</p>
</li>
<li><p><strong>newScheduledThreadPool</strong>：核心线程数固定地的周期任务线程池</p>
</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016586578">Java多线程进阶（三九）—— J.U.C之executors框架：executors框架概述</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://javamana.com/2021/02/20210228205934972L.html">Java并发之ThreadPoolExecutor源码解析（三）</a></p>
</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/java%E5%9F%BA%E7%A1%80/">java基础</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Executor/">Executor</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021-06-03/Executor-interface.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Exectuor框架解析</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021-06-03/Interrupt-mechanism.html">
                        <span class="hidden-mobile">中断机制</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@waline/client@0.16.2/dist/Waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"https://blog-comment-blond.vercel.app","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":true,"avatarCDN":"","avatarForce":false,"requiredFields":[],"emojiCDN":null,"emojiMaps":null,"anonymous":null},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        new Waline(options);
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  
    <!-- Google Analytics -->
    <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'UA-198559201-1', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  
    <!-- Google gtag.js -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-19MVRDT9NM"></script>
    <script defer>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-19MVRDT9NM');
    </script>
  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
