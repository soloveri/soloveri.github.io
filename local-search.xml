<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2021-06-03/maven-how-to-find-jar.html"/>
    <url>/2021-06-03/maven-how-to-find-jar.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021-06-03/readme.html"/>
    <url>/2021-06-03/readme.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本仓库主要作为我个人学习java、复习基础课的笔记，主要分为三大块：</p><ul><li>java部分</li><li>网络部分</li><li>os部分</li></ul><p>后续会慢慢补充，希望自己能一点一滴慢慢积累吧。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker使用方法(二)-文件系统架构</title>
    <link href="/2021-06-03/Docker-filesys-layout.html"/>
    <url>/2021-06-03/Docker-filesys-layout.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一定要将登录用户切换为root才能查看Docker的文件架构！！！</p><h2 id="0x0-基本文件布局"><a href="#0x0-基本文件布局" class="headerlink" title="0x0 基本文件布局"></a>0x0 基本文件布局</h2><p>Docker的文件主要都存储在<code>/var/lib/docker</code>目录下,文件目录如下所示:</p><p><img src="images/filesys.png" alt="filesys-layout"></p><p>其中<code>containers</code>存储的是容器,<code>images</code>存储的是镜像。在深入了解Docker的原理之前,我们需要了解两个基本名词:</p><ul><li>overlayFS</li><li>overlay2</li></ul><h2 id="0x1-overlayFS"><a href="#0x1-overlayFS" class="headerlink" title="0x1 overlayFS"></a>0x1 overlayFS</h2><p>其中overlayFS是一种类似于aufs的文件堆叠系统,但是比aufs更快。本质上来说,overlayFS是属于linux内核驱动的一部分。</p><p>overlayFS依赖于已有的底层文件系统,它并不实际参与硬盘的分区。而是将一些底层文件系统的文件合并,给不同的用户呈现不同的文件,实现了相同文件复用的功能,提高了空间使用率。下面一张图很好的解释了overlayFS的<a href="https://blog.csdn.net/luckyapple1028/article/details/77916194">基本工作原理</a>:</p><p><img src="images/overlayFS.jfif" alt="overlayFS"></p><p>overlayFS分为四个部分:</p><ul><li>lower dir:挂载时最多支持500个lower dir</li><li>upper dir</li><li>merge dir</li><li>work dir:用于存放文件系统挂载后产生的临时和简介文件,内容对用户不可见</li></ul><p>其中的lower dir和upper dir来自底层文件系统,可以由用户自行指定。其中merge dir就是overlayFS的挂载点。并且overlayFS有如下特点:</p><ul><li>如果lower和upper中有同名的目录或文件,会在merge中合并为同一个文件夹,并且upper会覆盖掉lower中的文件与目录。</li><li>如果有多个lower存在同名文件,那么使用层次较高的lower dir的同名文件</li><li>lower dir是<strong>只读</strong>的</li><li>upper dir是<strong>可读可写</strong>的</li><li>overlayFS具有copy-up的特性。也就是如果想对lower dir中的文件进行写入,只能将文件拷贝至upper dir,然后再对拷贝后的文件进行写入。</li></ul><h3 id="0x1-1-overlayFS的挂载"><a href="#0x1-1-overlayFS的挂载" class="headerlink" title="0x1-1 overlayFS的挂载"></a>0x1-1 overlayFS的挂载</h3><p>overlayFS的基本用法可以参考<a href="https://wiki.archlinux.org/index.php/Overlay_filesystem">官网</a>。下面是我参照<a href="https://blog.csdn.net/luckyapple1028/article/details/78075358">overlayFS的基本使用</a>做的一个复现。</p><p>首先需要创建lower、upper、work、merge这四类目录,文件树如下所示:</p><p><img src="images/worktree.png" alt="work tree"></p><p>首先对各个dir下的文件写入标记:</p><p><img src="images/write-content-1.png" alt="write-content-1"></p><p>然后对各个foo文件写入标记:</p><p><img src="images/write-content-2.png" alt="write-content-2"></p><p>最后执行挂载命令:</p><blockquote><p>sudo mount -t overlay overlay -o lowerdir=lower1:lower2,upperdir=upper,workdir=work merge</p></blockquote><p>注意<code>workdir</code>和<code>merge</code>之间是没有<code>,</code>的。<code>lowerdir</code>后面的目录是有顺序的,排在前面的lower dir在lower这个层次中的排名就较前,也就是如开头部分的图片所示:</p><p><img src="images/overlayFS.jfif" alt="overlayFS"></p><p>挂载后merge目录下的结构如下:</p><p><img src="images/merge-tree.png" alt="merge-tree"></p><p>最后在merge目录中的<code>aa</code>文件来自<code>lower1</code>,<code>bb</code>文件来自<code>upper</code>。<code>foo</code>文件来自<code>lower</code>与<code>upper</code>。如下图所示：<br><img src="images/result.png" alt="result"></p><p>可以看到确实将同名的底层文件都隐藏了起来。</p><h3 id="0x1-2-overlayFS的写入操作"><a href="#0x1-2-overlayFS的写入操作" class="headerlink" title="0x1-2 overlayFS的写入操作"></a>0x1-2 overlayFS的写入操作</h3><p>upper dir是一个可读可写层,而lower dir是只读层。所以如果我们想要写入的文件来自upper dir,那就是直接写入,在此就不举例说明了;如果来自lower dir,就会先将文件复制到upper再写入。这就是所谓的copy-up特性。</p><p>下图是在上述文件挂载完成后向来自<code>lower1/dir/</code>的<code>aa</code>写入文件:</p><p><img src="images/write-to-lower.png" alt="write-to-lower"></p><p>可以看到,我们在挂载点向lower层的文件写入内容后,upper层直接复制了了<code>lower1/dir/aa</code>,并直接追加写入的内容。而<code>lower1/dir/aa</code>本身的内容的却没有改变。</p><h3 id="0x1-3-overlayFS的删除操作"><a href="#0x1-3-overlayFS的删除操作" class="headerlink" title="0x1-3 overlayFS的删除操作"></a>0x1-3 overlayFS的删除操作</h3><p>overlayFS中的删除并不是真正的删除,它只是使用了一个障眼法-<strong>whiteout</strong>文件来覆盖同名文件,让用户以为已经把文件删除了。</p><blockquote><p>whiteout文件并非普通文件，而是主次设备号都为0的字符设备（可以通过”mknod <name> c 0 0”命令手动创建）</p></blockquote><blockquote><p>并且whiteout文件在merge层不可见。达到了隐藏文件的目的</p></blockquote><p>删除操作分为三个场景：</p><ul><li>要删除的文件/文件夹没有覆盖,仅来自upper层,那么直接删除就好</li><li>删除的文件/文件来自lower层,upper层中不存在,那么会在merge层和upper中生成同名的<strong>whiteout</strong>文件,用于屏蔽底层文件</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下图所示,其中upper在进行删除操作前为空目录：</p><p><img src="images/delete-from-merge.png" alt="delete-from-lower"></p><ul><li>要删除的文件来自lower层,upper中存在覆盖,那么会在merge层和upper层生成同名的<strong>whiteout</strong>文件,用于屏蔽底层文件。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原始文件结构如下:</p><p><img src="images/worktree.png" alt="file-struct"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除后的upper目录如下:</p><p><img src="images/delete-from-upper.png" alt="delete-from-upper"></p><p>这也就是docker中,虽然在container layer(upper)中删除了许多东西,但是image layer(lower)还是没有变小的原因。</p><p>这就是所谓的堆叠文件系统。详细介绍请移步:</p><ul><li><a href="https://blog.csdn.net/luckyapple1028/article/details/77916194">overlayFS的基本介绍</a></li><li><a href="https://blog.csdn.net/luckyapple1028/article/details/78075358">overlayFS的基本使用</a></li></ul><h2 id="0x2-overlay2"><a href="#0x2-overlay2" class="headerlink" title="0x2 overlay2"></a>0x2 overlay2</h2><p>docker为overlayFS提供了了两个存储驱动,一个是原始的overlay,另外一个就是现在新版的overlay2。所以docker自然也采用了堆叠的方式存储镜像。</p><p>这里以拉取最新的ubuntu images为例,可以看到,拉取的镜像为4层:</p><p><img src="images/pull-ubuntu.png" alt="pull-ubuntu"></p><p>在overlay2目录下出现了五个目录,其中四个为拉取的镜像,额外的目录为<code>l</code>。它存放的是对应镜像的软符号链接。为什么需要设置软符号链接?</p><blockquote><p>因为虽然在overlayFS中用户指定的lowerdir最多可以支持500层。但是由于mount的挂载选项最多支持1个内存page的输入（默认大小为4KB），所以如果指定的lowerdir数量较多且长度较长，会有溢出而导致挂载失败的风险（目前内核的-o挂载选项不支持超过1个内存页，即4KB大小）。</p></blockquote><p>所以设置软符号链接就是防止挂载失败,并且还能多挂载几个lower dir。每个软符号链接下的都会存在一个<code>diff</code>目录。接来看看看各个image layer中的内容:</p><p><img src="images/ubuntu-tree.png" alt="ubuntu-tree"></p><p>其中每个image layer中的<strong>diff文件夹存放了当前image layer的内容</strong>, link文件的内容是当前层对应的短符号链接,lower文件夹存放了当前层的所有下层<code>lower dir</code>的id。可以看到,id为<code>9045</code>的image layer没有<code>lower</code>,即<code>9045</code>就是最底层的image layer(这会在后面验证)。work目录用于挂载时的工作目录。</p><p>那么这些这些目录是怎么和镜像关联起来的呢？答案是通过元数据进行关联。元数据又分为image元数据和layer数据。</p><h3 id="0x2-1-image元数据"><a href="#0x2-1-image元数据" class="headerlink" title="0x2-1 image元数据"></a>0x2-1 image元数据</h3><p>image元数据存储在<code>/var/lib/docker/image/&lt;storage_driver&gt;/imagedb/content/sha256/</code>目录,文件名称是对应的iamge id,如下所示:</p><p><img src="images/imagedb.png" alt="imagedb"></p><p>该文件以json格式保存了该image的重要信息,其中<code>rootfs</code>值得关注,因为它指定了各个image layer的工作顺序。查看文件内容时可以将其格式化为json:(<code>使用vim :%!python -m json.tool格式化成json</code>),其中<code>rootfs</code>的内容如下:</p><p><img src="images/rootfs.png" alt="rootfs"></p><p>其中的diff_ids是有严格顺序的,从上到下,表示image layer的最底层到最高层id。顺序是反的是因为如果产生了新的image layer直接在最后面追加即可,非常方便。</p><p>那么image是又如何关联到layer的呢？docker是通过image元数据中的diff_id与一些历史信息计算出chainID关联到layer元数据,layer元数据再关联到对应的image layer。</p><h3 id="0x2-2-layer元数据"><a href="#0x2-2-layer元数据" class="headerlink" title="0x2-2 layer元数据"></a>0x2-2 layer元数据</h3><p><img src="images/layerdb.png" alt="layerdb"></p><p>在<code>/var/docker/&lt;storage_driver&gt;/image/layerdb/sha256</code>中,有四个目录,其中每个目录的数字就是每个diff_id对应的chainID。可以看到,只有最底层的<code>ce30</code>能在layerdb中找到对应的chainID,那是因为最底层的diff_id和chainID是相同的。所以除去最底层,剩下的chainID需要计算,这里不做演示。</p><p>每个chainID目录都有三个共同的文件<code>cache-id</code>、<code>diff</code>、<code>size</code>,而有的没有<code>parent</code>。下面一一解析下各个文件的内容。</p><h3 id="cache-id"><a href="#cache-id" class="headerlink" title="cache-id"></a>cache-id</h3><p>刚才说到layerdb保存的毕竟是元数据,那么这些元数据到底是怎么和具体数据链接起来呢?其中的<code>cache-id</code>是关键。</p><p>我们查看<code>ce30</code>的<code>cache-id</code>文件内容:</p><p><img src="images/cache-id.png" alt="cache-id"></p><p>docker随机生成的uuid，内容是保存image layer的目录索引。其中的id为<code>9045</code>就是刚才拉取的<code>ubuntu</code>镜像中的最底层image layer。说明没有<code>lower</code>目录的image layer就是在最底层。</p><p><img src="images/ubuntu-tree.png"></p><h4 id="size"><a href="#size" class="headerlink" title="size"></a>size</h4><p>size文件表示当前chainID对应的image layer的大小。</p><h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><p>保存了当前chainID对应的diff_id。</p><h4 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h4><p>这里的parent保存的是在<code>rootfs</code>中:位置较下的diff_id的上一个diff_id的chainID。</p><p>比如说chainID为<code>2515</code>的image layer。我们首先在diff中查看其对应的diff_id。</p><p><img src="images/2515-diff.png" alt="255-diff"></p><p>其对应的diff_id为<code>8eeb</code>。再来查看其<code>parent</code>文件:</p><p><img src="images/2515-parent.png" alt="255-parent"></p><p>而在<code>rootfs</code>中,<code>8eeb</code>的上一个diff_id对应的chainID就是<code>ce30</code>(因为第一个位置的diff_id与chainID相同)。</p><h3 id="0x2-3-overlay2的挂载"><a href="#0x2-3-overlay2的挂载" class="headerlink" title="0x2-3 overlay2的挂载"></a>0x2-3 overlay2的挂载</h3><p>挂载的信息存储在<code>/var/lib/docker/image/layerdb/mounts</code>目录下,每个目录名称就是对应的容器ID,如下图所示:</p><p><img src="images/mounts.png" alt="mount"></p><p><code>mounts</code>只有一个目录,对应于一个正在运行的容器。每个容器ID目录下存在三个文件。init-id对应当前挂载的容器的init层,mount-id就是对应的容器层(merge目录)。而parent文件还是存储位置在当前layer在<code>rootfs</code>上一个的diff_id的chainID。</p><p>三个文件的内容如下:</p><p><img src="images/threes.png" alt="threes"></p><p>可以看到,<code>parent</code>中的内容为<code>sha256:7515</code>,而该chainID对应的diff_id就是<code>0956</code>。</p><p>最后查看以下<code>/var/lib/docker/overlays/</code>目录:</p><p><img src="images/final.png" alt="final"></p><p>看到多了init层与container层。</p><p>关于init layer的<a href="https://stackoverflow.com/questions/33697774/init-layer-in-docker">作用</a>:</p><blockquote><p>Each containers has two layers, one (called the init layer), which is based on an image layer and a child of that which contains the actual container content. The init layer contains a few files that must always exist in Docker containers (e.g. /.dockerinit). Supported Filesystems</p></blockquote><p>简单来说就是帮我们对容器进行必要的初始化,避免我们自己初始化错误或者根本就忘掉。初始化的目录或文件如下:</p><blockquote><p>The containerID-init layer is the init layer of a container which is based on an image. It add some file into current container,include:<br>    “/dev/pts”:         “dir”,<br>    “/dev/shm”:         “dir”,<br>    “/proc”:            “dir”,<br>    “/sys”:             “dir”,<br>    “/.dockerenv”:      “file”,<br>    “/etc/resolv.conf”: “file”,<br>    “/etc/hosts”:       “file”,<br>    “/etc/hostname”:    “file”,<br>    “/dev/console”:     “file”,<br>    “/etc/mtab”:        “/proc/mounts”,</p></blockquote><p><strong>注意:init layer是一个只读层。</strong></p><p>最后以上述的四层ubuntu image为例,将iamgedb、layerdb、image layer、init layer、contain layer联合到一起。</p><p><img src="images/layout.drawio.svg" alt="layout"></p><p>可以看到和挂载命令基本一致:</p><p><img src="images/docker-mount.png" alt="mount"></p><p>其中挂载都是使用的符号链接,upper就是diff目录,work目录与diff目录同级。</p><h3 id="0x2-4-overlay2的删除操作"><a href="#0x2-4-overlay2的删除操作" class="headerlink" title="0x2-4 overlay2的删除操作"></a>0x2-4 overlay2的删除操作</h3><p>删除分为删除image与删除container。</p><ul><li>删除container:首先需要停止想要删除的容器:<code>docker stop [container ID]</code>,然后删除容器:<code>docker rm [container ID]</code></li><li>删除image:在删除image前,一定要删除container,完成上述步骤后,直接<code>docker rmi [image id]</code>即可。</li></ul><h2 id="0x3-小结"><a href="#0x3-小结" class="headerlink" title="0x3 小结"></a>0x3 小结</h2><ol><li><p>docker在每次创建容器时都会自动添加一个init layer对容器进行初始化,添加contain layer面向用户。并且每次默认启动的容器都是不相同的。</p></li><li><p>docker对于每种文件驱动,都会在<code>docker/image</code>下创建同名文件以保存元数据。docker通过imagedb、layerdb、关联到具体的image layer。</p></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://blog.51cto.com/haoyonghui/2457915">docker 存储驱之overlayFS</a></p></li><li><p><a href="https://blog.csdn.net/luckyapple1028/article/details/77916194">深入理解overlayfs（一）：初识</a></p></li><li><p><a href="https://blog.csdn.net/luckyapple1028/article/details/78075358">深入理解overlayfs（二）：使用与原理分析</a></p></li><li><p><a href="https://www.cnblogs.com/sammyliu/p/5877964.html">Docker镜像存储-overlayfs</a></p></li><li><p><a href="https://www.cnblogs.com/sammyliu/p/5877964.html">docker一站式学习</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dockerfile的基本规则</title>
    <link href="/2021-06-03/Docker-write-dockfile.html"/>
    <url>/2021-06-03/Docker-write-dockfile.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在了解了<a href="Docker-filesys-layout.md">docker的基本原理</a>后，是时候了解以下Dockerfile是怎么写的了。首先我们需要了解<code>RUN</code>与<code>CMD</code>命令的区别。</p><ul><li><code>RUN</code>命令：每执行一次，就会在原有镜像的基础上添加一个<code>upper dir</code>保存所作的改变，所以对于一类的命令我们尽量使用一条<code>RUN</code>，否则会创建过多的不必要的<code>upper dir</code></li><li><code>CMD</code>命令：容器是一个进程，<code>CMD</code>命令就像是容器启动时输入的命令参数，所以只能有一条<code>CMD</code></li></ul><h2 id="Dockerfile的栗子"><a href="#Dockerfile的栗子" class="headerlink" title="Dockerfile的栗子"></a>Dockerfile的栗子</h2><p>下面是我基于centos7.8制作的mysql5.7镜像。Dockerfile如下所示：</p><figure class="highlight dockerfile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> centos:<span class="hljs-number">7.8</span>.<span class="hljs-number">2003</span><br><br><span class="hljs-keyword">MAINTAINER</span> sssoloveri@gmail.com<br><span class="hljs-keyword">RUN</span><span class="bash"> (<span class="hljs-built_in">cd</span> /lib/systemd/system/sysinit.target.wants/; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> *; <span class="hljs-keyword">do</span> [ <span class="hljs-variable">$i</span> == \</span><br><span class="bash">systemd-tmpfiles-setup.service ] || rm -f <span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span>); \</span><br><span class="bash">rm -f /lib/systemd/system/multi-user.target.wants/*;\</span><br><span class="bash">rm -f /etc/systemd/system/*.wants/*;\</span><br><span class="bash">rm -f /lib/systemd/system/local-fs.target.wants/*; \</span><br><span class="bash">rm -f /lib/systemd/system/sockets.target.wants/*udev*; \</span><br><span class="bash">rm -f /lib/systemd/system/sockets.target.wants/*initctl*; \</span><br><span class="bash">rm -f /lib/systemd/system/basic.target.wants/*;\</span><br><span class="bash">rm -f /lib/systemd/system/anaconda.target.wants/*;</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;root:123456&quot;</span> | chpasswd \ </span><br>&amp;&amp; groupadd --gid <span class="hljs-number">1000</span> rain \<br>&amp;&amp; useradd --uid <span class="hljs-number">1000</span> --gid rain  --<span class="hljs-keyword">shell</span><span class="bash"> /bin/bash --create-home rain \</span><br><span class="bash">&amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;rain:123456&quot;</span> | chpasswd</span><br><span class="hljs-comment">#USER rain</span><br><span class="hljs-keyword">RUN</span><span class="bash"> rpm -ivh https://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm \</span><br><span class="bash">&amp;&amp; rpm --rebuilddb \ </span><br>&amp;&amp; yum install -y yum-utils net-tools sudo vim \<br>&amp;&amp; rpm -ivh https://dev.mysql.com/get/mysql57-community-release-el7-<span class="hljs-number">11</span>.noarch.rpm \<br>&amp;&amp; yum install -y mysql-community-server \<br>&amp;&amp; yum install -y openssh openssh-server openssh-clients \<br>&amp;&amp; mkdir -p /var/<span class="hljs-keyword">run</span><span class="bash">/sshd \</span><br><span class="bash"><span class="hljs-comment">#&amp;&amp; mkdir -p ~/.ssh \</span></span><br><span class="bash">&amp;&amp; yum install -y supervisor \</span><br><span class="bash">&amp;&amp; rm -rf /etc/supervisord.conf \</span><br><span class="bash">&amp;&amp; mkdir -p /etc/supervisord/conf.d \</span><br><span class="bash">&amp;&amp; mkdir -p /var/<span class="hljs-built_in">log</span>/supervisor/ \</span><br><span class="bash">&amp;&amp; mkdir -p /var/run/supervisor/ \</span><br><span class="bash">&amp;&amp; ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key \</span><br><span class="bash">&amp;&amp; ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key</span><br><span class="hljs-keyword">COPY</span><span class="bash"> authorized_keys /root/.ssh/authorized_keys</span><br><span class="hljs-keyword">COPY</span><span class="bash"> supervisord.conf /etc/supervisord.conf</span><br><span class="hljs-comment">#COPY mysql.conf /etc/supervisord/conf.d/</span><br><span class="hljs-comment">#COPY sshd.conf /etc/supervisord/conf.d/</span><br><span class="hljs-keyword">RUN</span><span class="bash"> yum clean all</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3306</span> <span class="hljs-number">22</span><br><br><span class="hljs-comment"># 挂载数据、配置和日志目录</span><br><span class="hljs-keyword">RUN</span><span class="bash"> rm -rf /etc/my.cnf /var/lib/mysql /var/<span class="hljs-built_in">log</span>/mysqld.log</span><br><span class="hljs-keyword">VOLUME</span><span class="bash"> [<span class="hljs-string">&quot;/var/lib/mysql&quot;</span>, <span class="hljs-string">&quot;/etc/my.cnf&quot;</span>,<span class="hljs-string">&quot;/var/log/mysqld.log&quot;</span>]</span><br><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;/usr/sbin/init&quot;</span>]</span><br></code></pre></div></td></tr></table></figure><p>上面的内容基本上可以分为以下四个步骤：</p><ol><li>选取基础镜像，声明作者</li><li>安装基础软件，这一步骤中不要写太多的<code>RUN</code>，因为这样会让镜像十分臃肿</li><li>拷贝一些必要的文件，设置数据挂载目录，开放网络端口</li><li>声明容器入口命令</li></ol><p>安装基础软件没什么好说的，按照自己的需求声明就好。 <strong>重点是数据卷映射的权限问题</strong>。以上面的Dockerfile为例，我们当前宿主机的用户id为1000。我们容器启动时的命令为：</p><figure class="highlight docker"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs docker">docker <span class="hljs-keyword">run</span><span class="bash"> -d -u 1000:1000 \                       </span><br>--name mysql --hostname mysql --privileged=true \<br>--<span class="hljs-keyword">volume</span><span class="bash"> /usr/<span class="hljs-built_in">local</span>/mysql/data/:/var/lib/mysql \</span><br><span class="bash">--publish 3306:3306  -v /usr/<span class="hljs-built_in">local</span>/mysql/config/my.cnf:/etc/my.cnf -v /usr/<span class="hljs-built_in">local</span>/mysql/<span class="hljs-built_in">log</span>/mysqld.log:/var/<span class="hljs-built_in">log</span>/mysqld.log mysql:latest /usr/sbin/init</span><br><br></code></pre></div></td></tr></table></figure><p>上面我进行了三项文件或目录的映射：</p><ol><li>(宿主机)/usr/local/mysql/data/—–&gt;(容器)/var/lib/mysql</li><li>(宿主机)/usr/local/mysql/config/my.cnf—–&gt;(容器)/etc/my.cnf</li><li>(宿主机)/usr/local/mysql/log/mysqld.log——&gt;(容器)/var/log/mysqld.log</li></ol><p>上述三个宿主机中的文件或目录的拥有者都是uid为1000的用户。那么就会产生四种情况：</p><ol><li>容器中没有uid为1000的用户，并且没有指定容器的启动用户</li><li>容器中没有uid为1000的用户，并且指定了一个容器中不存在的用户作为启动用户</li><li>容器有uid为1000的用户，并且指定了uid为1000的用户作为启动用户</li><li>容器有uid为1000的用户，但是指定了容器中的另一个uid=1111的用户作为启动用户</li></ol><p>面对上面的问题，我们需要树立一个总的前提：容器中被映射的目录或文件的所有权是与宿主机中映射的目录或文件相同的。所以在容器中，目录<code>var/lib.mysql</code>，文件<code>my.cnf</code>、<code>mysqld.log</code>的所有者都是uid=1000的用户。然后就是容器的启动用户是谁的问题。</p><ol><li>如果没有明确指定，那么容器的默认启动用户就是root</li><li>如果指定了一个容器中不存在的用户，那么容器会显示<code>I have no name!</code>，没有username，没有home</li><li>如果指定的是容器中存在的但不是uid=1000的用户，那么就会正常显示用户名，但不能操作文件，因为所有者不同</li><li>如果指定了容器中存在且和宿主机uid相同的用户，那么就能正常操作文件</li></ol><p>所以显而易见，docker是<strong>根据uid而不是username的映射</strong>来完成权限管理的。所以我们在创建镜像时，一般都会创建一个uid与宿主机数据卷所有者相同的用户方便在容器中操作文件。<strong>一定要确保容器执行者的权限和挂载数据卷的所有者相对应。</strong></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://www.cnblogs.com/woshimrf/p/understand-docker-uid.html">docker挂载volume的用户权限问题,理解docker容器的uid</a></li><li><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/workdir">docker的中文手册</a></li><li><a href="http://ghoulich.xninja.org/2018/03/27/how-to-build-and-use-mysql-docker-image/">MySQL的Docker镜像制作详解</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker使用方法(一)-基本安装</title>
    <link href="/2021-06-03/basic-Docker-install.html"/>
    <url>/2021-06-03/basic-Docker-install.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>实验主机:虚拟机ubuntu-18.04 LTS</p></li><li><p>docker版本:19.03</p></li><li><p>能google</p></li></ol><p>因为如果在安装vm的主机上直接安装docker for windows是基本不可能成功的,要么卸载vm,要么在把vm升级到15.5以上,再或者在vm将docker配置为虚拟机使用。所以我选择在虚拟机中安装docker。所以基本架构为:windows-&gt;vm-&gt;docker-&gt;containers,老套娃了。</p><h2 id="基本安装"><a href="#基本安装" class="headerlink" title="基本安装"></a>基本安装</h2><p>在ubuntu中安装我也是直接copy网上的指令就完事了。建议使用DaoCloud的<a href="http://get.daocloud.io/">一键安装脚本</a>就完事了。</p><h2 id="镜像配置"><a href="#镜像配置" class="headerlink" title="镜像配置"></a>镜像配置</h2><p>新版的配置采用json文件的方式,首次使用时需要在<code>/etc/Docker/</code>目录下新建<code>daemon.json</code>。然后填入以下内容:</p><blockquote><p>{<br>  “registry-mirrors”: [“your mirror url”]<br>}<br>中科大的镜像源为<code>https://docker.mirrors.ustc.edu.cn</code>。</p></blockquote><p>镜像源的选择一般有以下三种:</p><ul><li><a href="https://www.daocloud.io/mirror#accelerator-doc">DaoCloud</a></li><li><a href="https://developer.aliyun.com/article/29941">阿里云</a></li><li><a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker">中科大镜像源</a></li></ul><p>最后重启docker:</p><blockquote><p>service docker restart</p></blockquote><p>完事。</p><h2 id="Docker初体验"><a href="#Docker初体验" class="headerlink" title="Docker初体验"></a>Docker初体验</h2><p>使用<code>Docker pull hello-world</code>拉取镜像看看Docker是否能正常工作。</p><p>使用<code>Docker run hello-world</code>运行镜像。</p><p>ps:</p><p>如果你使用DaoCloud的脚本安装Docker,那么运行镜像的话会产生权限问题，如下所示:</p><blockquote><p>docker: Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Post http://%2Fvar%2Frun%2Fdocker.sock/v1.26/containers/create: dial unix /var/run/docker.sock: connect: permission denied.<br>See ‘docker run –help’.</p></blockquote><p>意思就是我们没有权限访问unix socket,从而导致无法与Docker Engine通信。</p><ul><li>临时办法:使用<code>sudo</code>运行</li><li>一劳永逸:<code>sudo usermod -a -G docker $USER</code>,记得重启或者重录当前用户,配置才能生效。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://www.jianshu.com/p/34d3b4568059">Docker的安装</a></p></li><li><p><a href="https://medium.com/@dhananjay4058/solving-docker-permission-denied-while-trying-to-connect-to-the-docker-daemon-socket-2e53cccffbaa">权限问题的解决方法</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计网热门问题</title>
    <link href="/2021-06-03/top-questions-for-network.html"/>
    <url>/2021-06-03/top-questions-for-network.html</url>
    
    <content type="html"><![CDATA[<p>本篇不为别的，只为记录面试过程中关于计网的热门问题。</p><p>[TOC]</p><hr><h2 id="1-点击一个链接后，发生了什么"><a href="#1-点击一个链接后，发生了什么" class="headerlink" title="1. 点击一个链接后，发生了什么"></a>1. 点击一个链接后，发生了什么</h2><p>首先，我们需要有一个总的概念：在点击一个链接后，网卡首先会将http请求使用http协议封装，接着将数据包经由tcp/udp协议封装，最后使用ip协议将数据包在各个网段之间传输直至到达目的地。http协议的封装这里不作详细介绍。tcp连接的建立和ip数据包的转发才是重点。</p><ol><li>tcp连接建立的基础是使用ip协议将数据包转发到目标主机</li><li>使用ip的前提是知道目标主机的ip地址</li><li>而ip地址的获取需要靠dns解析</li></ol><p>所以点击链接后发生的事，主要分为域名解析、ip数据包转发、tcp连接，我们依次分析这三小部分。</p><p><strong>I. 域名解析</strong></p><p>dns解析的流程比较简单，查询步骤如下：</p><ol><li><p>首先查询浏<strong>览器缓存</strong>，如若失败则执行2，否则执行6</p></li><li><p>查询本机<strong>host文件</strong>，如若失败则执行3，则执行6</p></li><li><p>查询<strong>本地dns服务器</strong>（一般是指由用户设置的dns服务器），如果失败，如果采用迭代模式，则执行4；如果采用递归模式，则执行5</p></li><li><p>本地dns服务器采用递归模式的查询流程如下所示：<br><img src="images/dns-recursion.png" alt="dns-recursive"></p></li><li><p>本地dns采用迭代模式的查询流程如下所示：<br><img src="images/dns-iteration.png" alt="dns-iteration"></p></li><li><p>返回域名对应的ip地址</p></li></ol><p>上图中所谓的根服务器的概念与域名的级别有关系，根服务器负责管理13个顶级域名服务器，如下图所示：<br><img src="images/root.png" alt="root-domain"></p><hr><p>延申问题：</p><p><strong>Q1. 域名解析是通过dns映射完成的，那么这个映射是如何建立？</strong></p><details><summary>展开</summary><p>映射一般需要我们手动建立，建立的类型一般就是两种：A类和CNAME类。</p><ul><li><p>A类可以简单理解为域名到ip地址的直接映射。</p></li><li><p>CNAME类（Canonical Name）就是域名到域名的映射。</p></li></ul><p>CNAME类解析的用处多多，我们可以像使用环境变量一样设置CNAME<a href="#refer-anchor-1"><sup>[1]</sup></a>。例如如果我们在域名<code>test.com</code>下有三个子域名<code>a.test.com</code>、<code>b.test.com</code>、<code>c.test.com</code>。现在我们想把这三个子域名解析到我们的ip<code>10.10.1.11</code>，当然我们可以为每个子域名设置一个A类解析，但是如果更改了ip地址，那么需要更改的地方是非常多的。<br>反之，我们将这三个子域名都是用CNAME解析到域名<code>test.com</code>，那么解析时就把问题转化为<code>test.com</code>的ip地址是多少。当ip地址改变时，只需要更改<code>test.com</code>的A记录</p><p> 主机名 | 记录类型 | 目标 |<br>| :—–| —-: | :—-: |<br>| test.com |A     | 10.10.1.11 |<br>| a.test.com | CNAME | test.com |<br>| b.test.com | CNAME | test.com |<br>| c.test.com | CNAME | test.com |</p><p>那么CNAME这么好用，它有什么缺陷呢？</p><ol><li>CNAME只能解析到另一个域名，不能解析ip</li><li>增加一次解析的负担，一般可以使用cdn加速</li></ol></details><p><strong>Q2. 多个域名绑定到同一ip怎么区分？</strong></p><details><summary>展开</summary><p>如上所述，我们可以将多个子域名绑定到同一ip，一般我们需要根据端口来区分针对不同域名发起的请求。但是为了用户体验，我们希望多个域名都访问80端口，这时一般使用nginx实现反向代理<a href="#refer-anchor-9"><sup>[13]</sup></a>来区分不同域名。nginx为什么能够区分？因为http请求头中都会包含请求的域名。</p><p>或者使用虚拟主机，直接将子域名映射到二级目录就行。</p></details><p><strong>Q3. 上面提到的子域名是什么？</strong></p><details><summary>展开</summary>正如前文所述，域名是有等级的。根据[维基百科](https://en.wikipedia.org/wiki/Domain_name)，一级域名是13个顶级域名。一级域名左侧为二级域名，二级域名左侧为三级域名，以此类推。<p>例如域名<code>lol.qq.com</code>，一级域名为<code>com</code>、二级域名为<code>qq</code>、三级域名为<code>lol</code>。域名所有者可以任意配置所有域名下的子域名<a href="#refer-anchor-2"><sup>[2]</sup></a>。</p><p>但是站在使用者的角度，我们一般称<code>qq.com</code>为一级域名，因为单单使用<code>com</code>什么都不是。</p></details><hr><p><strong>II. ip数据包的转发</strong></p><p>请求到目标域名的ip后，ip数据包首先需要传输到网关，然后再经过层层路由转发至目标主机<a href="#refer-anchor-3"><sup>[3-5]</sup></a>。而ip数据包的转发实际还要依靠链路层，而链路层的转发依靠的是mac地址。所以需要完成ip地址到mac地址之间的映射，这个工作交由arp协议来完成,由上可知<strong>arp工作在链路层</strong>。</p><p><strong>arp的请求是广播，而响应是单播</strong>，因为在一个局域网中，主机A只知道路由器B的ip地址，而不知道路由器B的mac地址是多少，必须发起广播，并且只有路由器B才会响应这个arp请求。那么为什么主机能够知道需要将数据包转发至路由器B呢？这里我们可以将这个路由器B看作<strong>默认网关</strong>，这一般都会自动获取，而网关之后的转发流程就是网关的事了。</p><p>完成ip到mac的映射后，数据包会从主机A转发到路由器B。路由器B解析ip数据包后，发现目的ip为<code>111.222.333.444</code>。那么接下来怎么转发才能到这个地址呢？这就需要以来路由器中的路由表。而路由表的生成有专门的协议来负责，后面将会介绍。查询路由表后，一般都会知道下一跳路由器的ip地址，这时再使用arp协议请求mac地址，重复上面的操作就会层层路由到ip为<code>111.222.333.444</code>的主机了。</p><hr><p>延申问题</p><p><strong>Q1：路由表是如何生成的？</strong></p><details><summary>展开</summary><p>首先我们需要知道根据不同的网络服务商，会组成不同的、各自的超大局域网，一般将超大局域网成为自治系统(autonomous system)。AS内部之间的路由协议称为<strong>内部网关协议</strong>( interior gateway protocol )，而AS之间的路由协议称为<strong>外部网关协议</strong>(Exterior gateway protocol)。</p><p>需要注意的是：参考<a href="https://en.wikipedia.org/wiki/Exterior_gateway_protocol">维基百科</a>，IGP是内部网关协议的总称，并不是一个具体的协议。而EGP既是外部网关协议的总称，而且确实有一种外部网关协议叫做EGP。</p><p>具体来说，IGP主要有两种类型：距离矢量类型和链路状态类型，所谓的距离矢量就是靠源地址与目标地址之间的路由跳数来决定路由路径。而距离矢量类型是指通过路径长度、可靠性、延迟、带宽、负载和通信开销来决定路由路径。距离适量类型的代表路由协议是<strong>路由信息协议RIP</strong>、<strong>内部网络路由协议IGRP</strong>。链路状态类型的代表路由协议有开放式最短路由协议<strong>OSPF</strong>、<strong>IS-IS</strong>。</p><p>EGP运行于AS之间，代表协议主要包括EGP、BGP（EGP的升级版）、EBGP等。</p></details><hr><p><strong>III. 建立tcp连接</strong></p><p>tcp连接的建立需要经过三次握手，如下图所示：</p><p><img src="images/tcp-three-handshake.png" alt="three-handshake"></p><ol><li>客户发送的第一个段是 SYN 段。这个段仅有 SYN 标志被置位，它用于序号同步。<strong>它占用一个序号，不能携带数据</strong>。当数据传输开始时，客户<strong>随机</strong>选择一个数字作为初始序号(ISN)。注意，这个段不包含确认号。它也没有定义窗口大小；窗口大小的定义只有当段包含确认号时才有意义。<br>&nbsp;</li><li>服务器发送第二个段，两个标志位SYN和ACK置位的段，即 SYN  +ACK 段。这个段有两个目的。首先，它是另一方向通信的 SYN 段。服务器使用这个段来<strong>随机</strong>初始化序号，这个序号用来给从服务器发向客户的字节编号。服务器也通过给 ACK 置位并展示下一个序号来确认已经接收到来自客户的SYN，这里的下一个序号是服务器预期从客户接收的序号。因为它包含确认，它也需要定义接收窗口，即 rwnd（供客户参考使用）。因为这个段起到 SYN段的作用，它需要被确认。因此，<strong>它占用一个序号。但SYN + ACK 段不携带数据</strong>。<br>&nbsp;</li><li>客户发送第三个段。这个段仅仅是一个 ACK 段。它使用 ACK 标志和确认序号字段来确认收到了第二个段。<strong>该段可携带或者不携带数据</strong>。注意，如果不携带数据，ACK段没有占用任何序号，但是一些实现允许这第三个段在连接阶段从客户端携带第一块数据，在这种情况下，段消耗的序号与数据字节数相同。</li></ol><p>标志位小结：</p><p>SYN：可以理解为谁需要同步序号，谁就要设置SYN标志位<br>ACK：谁收到了数据包，谁就要设置ACK标志位</p><hr><p>扩展问题：</p><p><strong>Q1: 为什么需要三次握手？</strong></p><details><summary>展开</summary>相信大家都知道，tcp连接的建立需要三次握手，但是想要明白为什么需要三次握手，我们首先就需要知道tcp的连接[<sup>[4]</sup>](#refer-anchor-4)和握手到底是什么意思。<p>根据<a href="https://tools.ietf.org/html/rfc793">RFC 793 - Transmission Control Protocol </a>的规定，tcp的连接定义如下：</p><blockquote><p>The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream. The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.</p></blockquote><p>大致是说，为了防止网络的不确定性可能会导致数据包的缺失和顺序颠倒等问题，需要为每一个数据流初始化和保持确定的状态信息，包括socket、数据包序号、窗口大小。这些状态信息叫做一个连接。</p><p>那么握手到底是啥意思？我认为所谓的握手是指：对于一个<strong>数据包</strong>来说，它经历了一组收发的过程，就叫一次握手。如下图所示：</p><p><img src="images/tcp-handshake.drawio.svg" alt="what-is-a-handshake"></p><p>明白了<strong>连接</strong>和<strong>握手</strong>的概念，我们再来讨论握手的次数。因为tcp是双工的，收方和发方都是可以发送信息的，所以就需要为收发两端同步上述的状态信息，而<strong>两次握手都不能完成同步信息(主要是序列号ISN)的任务</strong>。如何理解？</p><p><a href="https://tools.ietf.org/html/rfc793">RFC 793 - Transmission Control Protocol </a>指出使用三次连接原因主要是为了防止重复的连接初始化信息出现，导致连接错乱：</p><blockquote><p>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</p></blockquote><p>试想如下一个场景：<br>因为网络延迟较高，发送方A发出连接请求后，如果这个请求经过了很长时间才到达收方B。那么B无法判断这个请求是正常还是超时的。如果B采用两次握手，贸然建立连接，那么对A发出响应信息后，A是不会作出响应的，因为这个连接已经过时了。那么B建立连接的资源就一直无法释放。这是一个非常严重的问题。</p><p>那么为什么三次握手就能解决这个问题呢？其实我们可以把三次握手退化成四次握手，如下图所示：</p><p><img src="images/tcp-four-handshake.drawio.svg" alt="two-handshake"></p><p>经过四次握手后，主机A和主机B都确认对方能够收到数据，就会建立tcp连接。如果此时再出现A发送的连接请求超时到达，B不会建立连接，而是向A发送应答请求，并且试图同步序列号，如果同步失败，连接就不会建立，主机A和B都能很快的释放资源。但是其中数据包2、3是可以一起发送的。四次就退化成三次握手，如下所示：</p><p><img src="images/tcp-three-handshake.png" alt="three-handshake"></p><p>图中三次握手的重点就是<strong>同步序列号</strong>，序列号之所以如此重要，是因为它能够防止以下情况出现：</p><ol><li>数据包丢失、超时到达</li><li>数据包重发</li><li>数据包乱序</li></ol></details><p><strong>Q2: 为什么ISN是随机的？</strong></p><details><summary>展开</summary><p>简单来说，随机ISN防止了一些历史数据包和新数据包的冲突以及ISN欺骗攻击。</p><p><strong>数据包冲突问题</strong><br>如果ISN每次开始都是固定的、静止的起始值。想象如下一个场景：如果初始ISN固定为0，旧连接已经断开，因为网络问题旧数据包1-10仍残存于网络中。如果某时刻复用此旧链接，ISN又从0开始，那么新的数据包1-10和旧的数据包1-10有可能发生冲突。所以解决办法就是动态地随着时间增长生成ISN。但是这样同样存在下面的安全问题。</p><p><strong>ISN欺骗攻击</strong><br>如果ISN是根据当前时间计算，那么服务器生成的ISN有可能被破解，这就有可能发生ISN猜测攻击。下面是一个攻击场景<a href="#refer-anchor-5"><sup>[9]</sup></a>：现在我们有三台主机A、B、C</p><p>HOST A &lt;—-&gt; HOST B<br>^<br>|<br>|<br>HOST C</p><p>在这里，主机A和主机B是受信任的主机。主机A接受来自主机B的连接，因为它是受信任的源。此处的识别参数只是ip地址（示例是rlogin应用程序，网络中的主机受信任并允许执行命令。请参阅rlogin以查看其工作原理）</p><p>现在，HOST C想要欺骗主机B并与A建立连接。步骤如下：</p><ol><li>C（欺骗B）—-&gt;将SYN数据包发送给A，序列号为ISN_C。欺骗手段C发送以IP地址B作为源IP的数据包。</li><li>A用具有自己的序列号的SYN（ISN_A）+ ACK（ISN_C + 1）数据包响应SYN。但这不会达到C。这是因为B是受信任的源，并且A可以直接向B发送数据。A向B发送一个SYN + ACK数据包。但是B对此一无所知，并且可以选择重置连接。在这一阶段，我们必须通过使B充满垃圾数据包来使B保持忙碌，以便它不会响应A</li><li>现在，C知道ISN_C，但不知道ISN_A，因为它没有收到数据包。如果<strong>C可以预测ISN_A</strong>，则可以发送具有确认号ISN_A + 1的第三个ACK数据包。这样，我们与A建立了3种方式的握手。（通过具有可预测的序列号，我们可以建立连接。）</li></ol><p>现在我们可以将命令从C发送到A，它将执行该命令，因为我们正在欺骗可信任的源。这是一个严重的安全问题。同样，我们可以重置连接或将数据注入流中。</p><p>当然，上述攻击方式是有限制的：<br>1.如果C与A＆B在同一个网络中，并且可以嗅探数据包，则只需嗅探数据包就可以轻松看到ISN。随机序列号不会阻止这种情况。如果您与A和B位于不同的网络上，则可以防止受到攻击。</p><p>2.由于存在可信源（rlogin，rsh等）的概念且未进行任何加密，因此可能会发生这种攻击。如果具有任何类型的加密，则这种欺骗将不起作用。</p><p><strong>ISN计算公式</strong><br><a href="https://www.ietf.org/rfc/rfc1948.txt">RFC1948 Defending Against Sequence Number Attacks</a>提出的ISN计算方法如下：</p><blockquote><p>ISN = M + F(localhost, localport, remotehost, remoteport).</p></blockquote><p>其中M是一个4微妙计时器，F是一个秘密的hash算法。这防止了一部分ISN猜测攻击</p></details><p><strong>Q3：SYN泛洪攻击是什么？如何防范？</strong></p><details><summary>展开</summary><p>SYN泛洪攻击时大量tcp连接发送到服务器，但是只进行前两次握手，导致服务器的资源无法释放。</p><p>解决策略： 当服务器接受到 SYN 报文段时，不直接为该 TCP 分配资源，而只是打开一个半开的套接字。接着会使用 SYN 报文段的源Id，目的Id，端口号以及只有服务器自己知道的一个秘密函数生成一个 cookie，并把 cookie 作为序列号响应给客户端。</p><p>如果客户端是正常建立连接，将会返回一个确认字段为 cookie + 1 的报文段。接下来服务器会根据确认报文的源Id，目的Id，端口号以及秘密函数计算出一个结果，如果结果的值 + 1等于确认字段的值，则证明是刚刚请求连接的客户端，这时候才为该 TCP 分配资源</p><p>这样一来就不会为恶意攻击的 SYN 报文段分配资源空间，避免了攻击。</p></details><hr><h2 id="2-https的是什么？原理是什么？"><a href="#2-https的是什么？原理是什么？" class="headerlink" title="2. https的是什么？原理是什么？"></a>2. https的是什么？原理是什么？</h2><p>https全称为Hyper Text Transfer Protocol over Secure Socket Layer，也就是对http数据包使用tls/ssl协议加密。那么https的原理就是tls协议是如何工作的。</p><p>tls协议简单来说就是将http的明文数据包加密后再发送，那么如何同步客户端与服务端的加密套件、密钥呢？这些前提工作都会在tls握手的时候完成，这是我们需要重点理解的。</p><p>对于加密套件，我们都知道对称密钥算法的强度高，难破解。所以我们只需要为客户端和服务端同步一个对称加密算法。但是对称密钥在网络中的同步是十分困难的。所以对称密钥的同步是tls握手的重点，这一操作又称为密钥协商算法。常用的密钥协商算法分为基于RSA和基于DH两种类型。</p><p><strong>I. 基于RSA的密钥协商算法</strong></p><p>基于RSA的协商算法较为简单：客户端首先生成一个随机数，并使用服务端的公钥加密生成密文发送给服务端，服务端利用自己的私钥解密即可获得服务端生成的随机数。</p><p>但是<strong>RSA密钥交换的简单性是它最大的弱点</strong>。用于加密pre master key的服务器公钥，一般会保持多年不变。任何能够接触到对应私钥的人都可以解密第三个随机数，并构建相同的master key，从而危害到会话安全性。只要密钥泄露，就可以解密之前记录的所有流量了。</p><p><strong>基于DH的协商算法</strong></p><p>DH密钥协商基于一个数学难题，这个不详细介绍。我们只需要知道，对于求模公式<code>b = a^x mod p</code>：已知a计算b很容易，但是已知b计算a却很困难<a href="#refer-anchor-6"><sup>[10]</sup></a>，其中参数a、p均公开。</p><p>使用DH协商密钥的流程如下：</p><ol><li><p>服务器决定a、p两个参数，同时服务器首先生成一个随机数Xs，计算Ys=a^Xs mod p，将参数a、p和Ys发送给客户端，Xs保密</p></li><li><p>客户端生成随机数Xc，计算Yc=a^Xc mod p，发送给服务器，Xc保密</p></li><li><p>客户端利用公式Kc = Ys^Xc mod p计算公钥，服务器利用公式Ks = Yc^Xs mod p计算密钥，最终Kc和Ks一定相同，证明见<a href="#refer-anchor-6"><sup>[10]</sup></a>。</p></li></ol><p>现在比较流程的基于DH的协商算法有ECDH（elliptic curve Diffie-Hellman），ECDH仅仅将基于求模的数学难题替换为基于椭圆曲线的数学难题，后者同样会选择合适的参数a和p。</p><p>tls将密钥分为了三个部分：</p><ol><li>客户端生成的随机数</li><li>服务端生成的随机数</li><li>pre master key</li></ol><p>tls最终会基于这三个部分计算最终的master key。其中前两个随机数的协商较为简单，明文传输即可；对于pre master key的协商则会应用上述基于RSA或DH的协商算法。<br><strong>II. tls流程分析</strong></p><p>tls的握手流程如下所示：</p><p><img src="images/tls-workflow.drawio.svg" alt="tls-workflow"></p><p>接下来我们根据抓取访问淘宝的数据包来分析上图的各个阶段，我访问的ip地址为<code>140.205.94.189</code>，实际的握手数据包如下所示：</p><p><img src="images/taobao-tls.png" alt="taobao-tls"></p><p><strong>A. Client Hello</strong></p><p>该阶段就是客户端向服务器发起tls认证，向客户端发送了第一个随机数，,并声明客户端支持的算法套件。内容如下图所示：</p><p><img src="images/client-hello.png" alt="client-hello"></p><p><strong>B. Server hello</strong></p><p>该阶段确定了密钥算法，并向客户端发送了第二个随机数，如下图所示：</p><p><img src="images/server-hello.png" alt="server hello"></p><p><strong>C. Certificate</strong></p><p>该阶段将服务器的证书发送给客户端验证，如下图所示：</p><p><img src="images/certificate.png" alt="certificate"></p><p><strong>D. Server key Exchange</strong></p><p>该阶段服务器会选择好a、p两个参数（这里的协商算法基于ECDH），并计算出Ys发送给客户端，如下图所示：</p><p><img src="images/server-key-exchange.png" alt="server key"></p><p><strong>E. client key Excnahge</strong></p><p>该阶段客户端将自己的Yc发送给服务端，如下图所示：</p><p><img src="images/client-key-exchange.png" alt="client key"></p><p><strong>F. Change Chiper Spec</strong></p><p>客户端和服务端都会存在该阶段，这一阶段表示握手需要的信息发送完毕了，下面就可以使用生成的master key加密数据传输了。</p><p><strong>G. New Session Ticket</strong></p><p>该阶段的工作就是服务器传递给客户端一个Session用以维持https连接，不然每次都像上面这么连接是十分浪费资源的，此次传递的session如下图所示：</p><p><img src="images/session-ticket.png" alt="session ticket"></p><p>至此，同步了session后，客户端和服务端的握手流程结束，可以使用协商好的master key进行加密与解密了。</p><hr><p>扩展问题：</p><p><strong>Q1：tls为什么要使用两个随机数？</strong></p><details><summary>展开</summary><p>以下答案摘自<a href="https://coolcao.com/2018/08/06/https/">https运行原理解析笔记</a>：</p><blockquote><p>前两个随机数采用明文传输，存在被拦截的风险，最终对话密钥安全性只和第三个随机数有关，那么前两个随机数有没有必要？<br>“不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来*<em>保证协商出来的密钥的随机性</em>8。</p></blockquote><blockquote><p>对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。</p></blockquote><blockquote><p>pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。”</p></blockquote><p>所以简单来说，采用三个随机数是为了是最终的对话密钥更“随机”。</p></details><p><strong>Q2：tls使用的证书了解吗</strong></p><details><summary>展开</summary><p>证书按照认证等级可以划分为DV、OV、IV、EV，从左到右，安全性依次增强，当然价格也依次增高。</p><p>数字证书的作用就相当于我们的身份证。对于一个网站A来说，它没办法向客户端证明它是A，就好像我们证明自己身份时需要借助身份证一样。所以这时一般需要借助一个权威的机构来做信用背书，这个权威的机构向客户端证明网站A的真实性。我们是可以完全相信这些权威机构的，所以间接的，我们就相信网站A真的是它自己了。这里的权威机构就是CA（Certificate Authority）。</p><p>那么这里存在一个问题，CA证明我们的网站是真的，那么谁来证明这些CA是真的？答案很简单：因为CA是有等级的，会构成一条形如：网站A-&gt;普通CA-&gt;中等CA-&gt;顶级CA的信用链。顶级CA没有理由作假，因为没有必要砸自己的饭碗。所以顶级CA证明自己的方法就是在给自己颁发的证书上自签名，这一类自己给自己证明的证书叫<strong>自签证书</strong>，又称<strong>根证书</strong>。浏览器和操作系统一般都会将可信度的根证书内置，方便认证。</p><p>那么CA机构颁发数字证书的一般流程是怎么样的呢？</p><ol><li>首先向CA机构提供CSR(certificate signing request),CSR大致个人信息和公钥</li><li>CA验证我们提交的信息，主要是验证我们是否对域名有真正的控制权。如果验证通过，则会使用我们提交的CSR和公钥生成对应的CA证书，并使用自己的私钥对CA进行签名</li></ol><p>上述的认证过程肯定是要花钱的，那么是不是我们一定要花钱才能获得数字证书呢？当然不，因为上面曾提到顶级CA会发布自签证书，我们也可以利用开源软件，比如<a href="https://www.gokuweb.com/operation/d95eae05.html">openssl发布自定义自签证书</a>，再用自定义自签证书发布普通的CA证书。哎，那么那些花钱的人是不是傻？有免费的不用？</p><p>天下没有免费的午餐，自签证书虽然不花钱，但是它最大的缺点就是自签证书<strong>非常</strong>容易被伪造。并且浏览器一般无法认证由自定义自签证书签署的CA证书，会出现下面这种情况：</p><p><img src="images/self-signed.png" alt="self-signed"></p><p>这时因为自签根证书没有内置，信用链的顶部没有可信度。当然我们可以把自定义自签证书安装在浏览器中，就不会出现这种问题。当然，这可能会遭受中间人攻击。</p><p>自签名根证书可能被伪造，如果在主机中安装了伪造的根证书，这时中间人使用了伪造的自签名证书，就不会出现错误提示，劫持了正常流量，这样中间人和主机之间使用自签名的伪造证书建立了https链接，而中间人又和目标网站使用网站正规的CA证书建立了https链接，那么流量对于中间人来说，完全是明文的</p></details><p><strong>Q3：https一定安全吗？</strong></p><details><summary>展开</summary><p><strong>只要我们不信任不安全的CA的证书，https就是安全的。</strong></p><p>因为权威CA签署的证书不容易被篡改。如果篡改了证书内容，新的摘要无法使用CA机构的私钥加密。那么当客户端使用CA机构的公钥解密摘要时，明文和客户端自己计算的证书摘要对不上号，导致证书不被信任，拒绝连接。</p><p>当然仍然有办法攻破https，我发现了两个可能成功的办法：</p><p><strong>方法1：DNS欺骗+安装自定义根证书</strong></p><p>但是上面曾说道，我们可以发布自定义自签根证书，我们使用<a href="https://blog.cuiyongjian.com/safe/https-attack/">dns劫持+伪造证书</a>开展中间人攻击，https将不再安全。攻击方法如下图所示：</p><p><img src="images/https-hijack.drawio.svg" alt="https-hijack"></p><p>攻击前提是攻击者已经预先在主机中安装了自签名的根证书A，然后基本的攻击场景如下：</p><ol><li>首先主机对目标网站发起https连接，这时通过<strong>dns劫持</strong>将流量定向到攻击者的机器上</li><li>攻击者返回使用自定义根证书A签名的CA证书，这时由于根证书已经预先安装到主机上，浏览器不会发出警告。所以主机与攻击者之间建立了https连接，主机发送的数据对攻击者来说完全是可见的</li><li>攻击者再与真正的目标网站建立https连接，将主机发送给自己的数据完全转发到目标网站，同理网站的响应数据也将由攻击者转发到主机上</li></ol><p>经过上述的步骤，主机似乎与网站建立了安全的https连接，但是数据完全被中间人窃听了。</p><p><strong>方法2：sslStrip</strong></p><p>SSLStrip<a href="#refer-anchor-11"><sup>[15]</sup></a>方法也是中间人攻击一种。攻击前提时用户使用http发起第一次连接，因为用户一般只会写域名，而不会声明特定的协议。</p><p>该方法的核心操作是利用arp欺骗或dns欺骗将主机流量定向到攻击者机器上并建立http连接，而攻击者与目标网站建立真正的https连接。</p><p>那么如何防范上述攻击呢？这要从客户端和服务端两个方面防范：</p><ul><li>服务端：开启HSTS，拒绝http连接等等</li><li>客户端：不要相信不安全的证书、不要使用http连接</li></ul></details><p><strong>Q4：http如何升级为https？</strong></p><details><summary>展开</summary><p>将http升级为https的方法一般以下两种方法：</p><ol><li>302重定向</li><li>服务端开启HSTS(HTTP Strict Transport Security)<a href="#refer-anchor-8"><sup>[12]</sup></a></li></ol><p>重定向的方法很简单，简单让浏览器重定向访问即可，但是非常不安全。因为第一次连接使用http协议的，这有可能被劫持实施SSLStrip。而且即便当前连接是https，页内的连接仍有可能是http的，又给了黑客一次机会。所以这种方法很不安全。</p><p>上面的缺陷可以总结为两点：</p><ul><li>用户书签是http或者手动输入了http</li><li>https连接的页面内可能有http连接</li></ul><p>而HSTS能够在一定程度上解决上面的缺陷。因为开启HSTS后，浏览器内部会将http使用307重定向为https，并且HSTS还能够完全拒绝危险的证书。因为上面曾说过，浏览器虽然会对自签证书发出警告，但是用户可以选择忽略警告，继续访问，如下图所示：</p><p><img src="images/HSTS.png" alt="hsts"></p><p>HSTS则不会显示此选项，用户不能忽略警告。</p><p><strong>HSTS开启的方法</strong></p><p>只需要在http添加以下内容即可：</p><blockquote><p>Strict-Transport-Security: max-age=31536000; includeSubDomains</p></blockquote><p>其中<code>max-age</code>表示HSTS有效的时间。</p><p><strong>HSTS的缺陷</strong></p><p>HSTS虽然厉害，但仍然有缺点：用户首次访问某网站是不受HSTS保护的。这是因为首次访问时，浏览器还未收到HSTS，所以仍有可能通过明文HTTP来访问。解决这个问题的方法有两点<a href="#refer-anchor-10"><sup>[14]</sup></a>：</p><p>一是浏览器预置HSTS域名列表，Google Chrome、Firefox、Internet Explorer和Spartan实现了这一方案。google坚持维护了一个“HSTS preload list”的站点域名和子域名，并通过<a href="https://hstspreload.appspot.com/">https://hstspreload.appspot.com/</a>提交其域名。该域名列表被分发和硬编码到主流的web浏览器。客户端访问此列表中的域名将主动的使用HTTPS，并拒绝使用HTTP访问该站点。</p><p>二是将HSTS信息加入到域名系统记录中。但这需要保证DNS的安全性，也就是需要部署域名系统安全扩展。截至2014年这一方案没有大规模部署。</p></details><hr><h2 id="3-tcp的断开机制？"><a href="#3-tcp的断开机制？" class="headerlink" title="3. tcp的断开机制？"></a>3. tcp的断开机制？</h2><p>tcp的断开有两种情况：理想情况下的三次握手，或者<strong>半关闭</strong>的四次握手。</p><p>因为tcp是双工的，所以当tcp断开来接时，收发两端都需要确定对方收到了自己准备要断开连接的信息。所以与tcp建立连接的三次握手类似，在理想情况下，三次握手就能够保证收发两端收到足够的信息断开连接。过程如下图所示：</p><p><img src="images/tcp-remove-three-handshake.png" alt="tcp-remove-three"></p><p>而所谓的半关闭，是指在一方断开了连接的请款下，另一方仍能够发送剩余的信息。半关闭就需要四次握手才能传递足够的信息,这是因为理想情况下的第二次握手被拆分成了两次。如下图所示：</p><p><img src="images/tcp-remove-four-handshake.png" alt="tcp-remove-four"></p><hr><p>扩展问题</p><p><strong>Q1：TIME_WAIT状态了解吗？</strong></p><p>tcp连接与释放的过程中，会形成11种状态，如下图所示：</p><p><img src="images/11-status.png" alt="11-status"></p><p>而<code>TIME_WAIT</code>状态是<strong>断开</strong>连接时<strong>主动方独有</strong>的状态。当主动方进入该状态时，等待2MSL后，才会完全释放当前资源。</p><p>我们以半关闭四次握手的状态转化为例，了解什么时候会进入该状态：</p><p><img src="images/time-wait-status-in-four.png" alt="time-wait-status-in-four"></p><p>从上图中看出，当主动方发出FIN后，会经历FIN-WAIT-1 –&gt; FIN-WAIT-2 –&gt; TIME-WAIT  –&gt; CLOSED的状态转化。</p><p>而被动方第一次收到主动方的FIN后，会经历CLOSE-WAIT –&gt; LAST-ACK –&gt; CLOSED状态。</p><p><strong>Q2：TIME_WAIT为什么被设置为2MSL？</strong></p><p>有两点原因<a href="#refer-anchor-13"><sup>[17]</sup></a>：</p><ol><li>防止复用旧链接的ip、端口建立新链接时，旧链接的数据包还存活</li><li>保证tcp正确的被关闭，即被动关闭一方收到ACK</li></ol><p>首先MSL（maximum segment lifetime）是segment能够在网络中存活的最长时间。那么为什么2MSL就能保证旧链接的数据包不会存活呢？</p><p>在进入TIME-WAIT状态后，主动方会发送ACK，这个ACK最坏在刚好经过1MSL时，到达了被动收方。而被动收方在ACK到达前一直在重发FIN。如果在0.9999MSL时，被动收方发送了最后一个FIN，它最多在网络中存活1MSL。那么主动收方等待2MSL后，主动方发送的最后一个ACK、被动方发送的最后一个FIN都会在网络中消失。<br>那么旧链接的普通数据包肯定会在最后一个ACK和FIN之前发出，所以普通数据包也肯定会在网络中消失。</p><p>当主动方每次收到FIN,会重设2MSL的等待时间。</p><p>如果Server在长时间收不到ACK，重传FIN的次数达到某一设定值时，会向Client发送RESET报文段，表明“异常终止”，然后完全结束本次TCP连接（它不再操心客户是否收到RESET报文段），避免无限占用资源。（对应上图中的Stop Sending FIN)</p><hr><h2 id="4-tcp是如何保证可靠性的？"><a href="#4-tcp是如何保证可靠性的？" class="headerlink" title="4. tcp是如何保证可靠性的？"></a>4. tcp是如何保证可靠性的？</h2><p>保障可靠性主要有三个方面：流量控制、差错控制（校验和、确认机制、超时机制）、拥塞控制。</p><p>流量控制仅仅是考虑两台机器之间的传输能力，而拥塞控制则考虑了网络传输的能力。</p><h2 id="5-tcp的流量控制？"><a href="#5-tcp的流量控制？" class="headerlink" title="5. tcp的流量控制？"></a>5. tcp的流量控制？</h2><p>流量控制通过滑动窗口来实现，并且发送方的窗口通过接收方来控制。接收方会维护一个名为<code>rwind</code>的滑动窗口。还需更新</p><p>一般有一个要求：<br>新的ackNo+新rwnd&gt;=旧的ackNo+旧rwnd，也就是说滑动窗口的右沿一般不移动</p><hr><p><strong>Q1：糊涂窗口综合症是什么？如何避免？</strong></p><p>糊涂窗口综合症有两种：发方糊涂和收方糊涂。</p><p><strong>发方糊涂</strong>是指发送方每次发送的数据很少，极端情况下有效数据仅有一个字节，而tcp头部达到四十字节，极大降低效率。解决办法是nagle算法：</p><ol><li>nagle算法定义是任意时刻，最多只能有一个未被确认的小段。 所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。流程如下图所示：</li></ol><p><img src="images/nagle.png" alt="nagle"></p><p><strong>收方糊涂</strong>是指收方处理数据很慢，每次都只能处理一个字节，而发送方一次也只能发送一个字节。处理的方法一般有以下两种：</p><ol><li><p>延迟确认，这表示当一个报文段到达时并不立即发送确认。接收端在确认收到的报文段之前一直等待，直到缓存有足够的空间为止。</p></li><li><p>Clark解决方法，这表示只要有数据到达就发送确认，但宣布的窗口大小为零，直到或者缓存空间已能放入具有最大长度的报文段，或者缓存空间的一半已经空了。</p></li></ol><hr><h2 id="6-tcp的拥塞控制？"><a href="#6-tcp的拥塞控制？" class="headerlink" title="6. tcp的拥塞控制？"></a>6. tcp的拥塞控制？</h2><p>tcp提出了四种拥塞策略：慢启动，拥塞避免，快速重传，快恢复。而实际的拥塞算法可以按照判断拥塞的标准分为基于丢包的拥塞算法和基于网络延迟的拥塞算法<a href="#refer-anchor-14"><sup>[18]</sup></a>：</p><p><img src="images/base-packet-loss.png" alt="packet-loss"><br><img src="images/base-time.png" alt="time-loss"></p><p>而上述四种拥塞策略主要应用在传统的基于丢包的拥塞算法上：</p><ul><li>taho：采用慢启动和拥塞避免策略。并且用相同的拥塞策略对待超时和三次ACk</li><li>reno：采用慢启动、拥塞避免、快速恢复策略</li><li>new reno：采用慢启动、拥塞避免、快速恢复策略</li></ul><p>以下内容详细介绍了这四种策略的步骤，以及在三种算法中的应用。引自<a href="https://www.cnblogs.com/fll/archive/2008/06/10/1217013.html">TCP拥塞控制算法</a>：</p><p>最初由V. Jacobson在1988年的论文中提出的TCP的拥塞控制由“慢启动(Slow start)”和“拥塞避免(Congestion avoidance)”组成，后来TCP Reno版本中又针对性的加入了“快速重传(Fast retransmit)”、“快速恢复(Fast Recovery)”算法，再后来在TCP NewReno中又对“快速恢复”算法进行了改进，近些年又出现了选择性应答( selective acknowledgement,SACK)算法。</p><p>TCP的拥塞控制主要原理依赖于一个拥塞窗口(cwnd)来控制，在之前我们还讨论过TCP还有一个对端通告的接收窗口(rwnd)用于流量控制。TCP的拥塞控制算法就是要在这两者之间权衡，选取最好的cwnd值，从而使得网络吞吐量最大化且不产生拥塞，一般来说选择min(cwind,rwind)。</p><p>关于cwnd的单位，在TCP中是以<strong>字节</strong>来做单位的，我们假设TCP每次传输都是按照MSS大小来发送数据的，因此你可以认为cwnd按照数据包个数来做单位也可以理解，所以有时我们说cwnd增加1也就是相当于字节数增加1个MSS大小。</p><p><strong>I. 慢启动</strong></p><p>最初的TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此新建立的连接不能够一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量，以避免上述现象的发生。具体来说，当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加1个MSS大小。这样cwnd的值就随着网络往返时间(Round Trip Time,RTT)呈指数级增长，事实上，慢启动的速度一点也不慢，只是它的起点比较低一点而已。我们可以简单计算下：</p><ol><li><p>开始           —&gt;     cwnd = 1</p></li><li><p>经过1个RTT后   —&gt;     cwnd = 2*1 = 2</p></li><li><p>经过2个RTT后   —&gt;     cwnd = 2*2= 4</p></li><li><p>经过3个RTT后   —&gt;     cwnd = 4*2 = 8</p></li></ol><p>如果带宽为W，那么经过RTT*log2W时间就可以占满带宽。</p><p><strong>II. 拥塞避免</strong></p><p>从慢启动可以看到，cwnd可以很快的增长上来，从而最大程度利用网络带宽资源，但是cwnd不能一直这样无限增长下去，一定需要某个限制。TCP使用了一个叫慢启动门限(ssthresh)的变量，当cwnd超过该值后，慢启动过程结束，进入拥塞避免阶段。对于大多数TCP实现来说，ssthresh的值是65536(同样以字节计算)。<strong>拥塞避免的主要思想是加法增大，也就是cwnd的值不再指数级往上升，开始加法增加</strong>。此时当窗口中所有的报文段都被确认时，cwnd的大小加1，cwnd的值就随着RTT开始线性增加，这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。</p><p>上面讨论的两个机制都是没有检测到拥塞的情况下的行为，那么当发现拥塞了cwnd又该怎样去调整呢？</p><p>首先来看TCP是如何确定网络进入了拥塞状态的，<strong>TCP认为网络拥塞的主要依据是它重传了一个报文段</strong>。上面提到过，TCP对每一个报文段都有一个定时器，称为重传定时器(RTO)，当RTO超时且还没有得到数据确认，那么TCP就会对该报文段进行重传，当发生超时时，那么出现拥塞的可能性就很大，某个报文段可能在网络中某处丢失，并且后续的报文段也没有了消息，在这种情况下，TCP反应比较“强烈”：</p><ol><li><p>把ssthresh降低为cwnd值的一半</p></li><li><p>把cwnd重新设置为1</p></li><li><p>重新进入慢启动过程。</p></li></ol><p>从整体上来讲，TCP拥塞控制窗口变化的原则是AIMD原则，即加法增大、乘法减小。可以看出TCP的该原则可以较好地保证流之间的公平性，因为一旦出现丢包，那么立即减半退避，可以给其他新建的流留有足够的空间，从而保证整个的公平性。</p><p>其实TCP还有一种情况会进行重传：那就是收到3个相同的ACK。TCP在收到乱序到达包时就会立即发送ACK，TCP利用3个相同的ACK来判定数据包的丢失，此时进行<strong>快速重传</strong>，快速重传做的事情有：</p><ol><li><p>把ssthresh设置为cwnd的一半</p></li><li><p>把cwnd再设置为ssthresh的值(具体实现有些为ssthresh+3)</p></li><li><p>重新进入拥塞避免阶段。</p></li></ol><p><strong>III. 快速恢复</strong></p><p>后来的快速恢复算法是在上述的“快速重传”算法后添加的，当收到3个重复ACK时，TCP最后进入的不是拥塞避免阶段，而是快速恢复阶段。快速重传和快速恢复算法一般同时使用。快速恢复的思想是“数据包守恒”原则，即同一个时刻在网络中的数据包数量是恒定的，只有当“老”数据包离开了网络后，才能向网络中发送一个“新”的数据包，如果发送方收到一个重复的ACK，那么根据TCP的ACK机制就表明有一个数据包离开了网络，于是cwnd加1。如果能够严格按照该原则那么网络中很少会发生拥塞，事实上拥塞控制的目的也就在修正违反该原则的地方。</p><p>具体来说快速恢复的流程如下所示：</p><p><img src="images/reno.png" alt="reno-tcp"></p><ol><li><p>当收到3个重复ACK时，把ssthresh设置为cwnd的一半，把cwnd设置为ssthresh的值加3，然后重传丢失的报文段，加3的原因是因为收到3个重复的ACK，表明有3个“老”的数据包离开了网络。 </p></li><li><p>再收到重复的ACK时，拥塞窗口增加1。</p></li><li><p>当收到新的数据包的ACK时，把cwnd设置为第一步中的ssthresh的值。原因是因为该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。</p></li></ol><p>快速重传算法首次出现在4.3BSD的Tahoe版本，快速恢复首次出现在4.3BSD的Reno版本，也称之为Reno版的TCP拥塞控制算法。</p><p>可以看出Reno的快速重传算法是针对一个包的重传情况的，然而在实际中，一个重传超时可能导致许多的数据包的重传，因此当多个数据包从一个数据窗口中丢失时并且触发快速重传和快速恢复算法时，问题就产生了。因此NewReno出现了，它在Reno快速恢复的基础上稍加了修改，可以恢复一个窗口内多个包丢失的情况。具体来讲就是：Reno在收到一个新的数据的ACK时就退出了快速恢复状态了，而NewReno需要收到该窗口内所有数据包的确认后才会退出快速恢复状态，从而更一步提高吞吐量。</p><p>SACK就是改变TCP的确认机制，最初的TCP只确认当前已连续收到的数据，SACK则把乱序等信息会全部告诉对方，从而减少数据发送方重传的盲目性。比如说序号1，2，3，5，7的数据收到了，那么普通的ACK只会确认序列号4，而SACK会把当前的5，7已经收到的信息在SACK选项里面告知对端，从而提高性能，当使用SACK的时候，NewReno算法可以不使用，因为SACK本身携带的信息就可以使得发送方有足够的信息来知道需要重传哪些包，而不需要重传哪些包。</p><h2 id="7-加不加www有什么区别？"><a href="#7-加不加www有什么区别？" class="headerlink" title="7. 加不加www有什么区别？"></a>7. 加不加www有什么区别？</h2><p>其实是因为早期服务器资源有限，一个服务器往往要承担多项任务，所以在主域名前面加子域名<code>www</code>表示万维网服务<a href="#refer-anchor-12"><sup>[16]</sup></a>，例如<code>www.example.com</code>表示互联网，<code>mail.example.com</code>表示邮件服务。</p><p>而后来资源丰富，仍然加上www仅仅是为了纪念万维网的建立，</p><h2 id="8-http常用的状态码有哪些？"><a href="#8-http常用的状态码有哪些？" class="headerlink" title="8. http常用的状态码有哪些？"></a>8. http常用的状态码有哪些？</h2><ol><li>2xx状态码：操作成功。200 OK</li><li>3xx状态码：重定向。301 永久重定向；302暂时重定向</li><li>4xx状态码：客户端错误。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found；</li><li>5xx状态码：服务端错误。500服务器内部错误；501服务不可用</li></ol><h2 id="9-既然IP层已经分片了，TCP为什么还要分段？"><a href="#9-既然IP层已经分片了，TCP为什么还要分段？" class="headerlink" title="9. 既然IP层已经分片了，TCP为什么还要分段？"></a>9. 既然IP层已经分片了，TCP为什么还要分段？</h2><p>因为ip是没有重传机制的，如果tcp不分段，那么如果ip层丢失了某个报文片，就需要重传整个报文。</p><h2 id="10-GET和POST的区别？"><a href="#10-GET和POST的区别？" class="headerlink" title="10. GET和POST的区别？"></a>10. GET和POST的区别？</h2><ol><li><p>POST与相比GET，A通常在请求主体中具有相关信息。（一个GET不应该有主体，因此除了cookie之外，唯一可以传递信息的地方就是URL。）除了保持URL相对整洁之外，POST还可以让您发送更多的信息（由于URL的长度受到限制，因此在实际操作中用途），并让您几乎可以发送任何类型的数据（例如，文件上传表单不能使用GET-它们必须使用，还要POST加上特殊的内容类型/编码）。</p></li><li><p>除此之外，POST表示请求将更改某些内容，并且不应随意重做。这就是为什么您有时会在单击“后退”按钮时看到浏览器询问您是否要重新提交表单数据的原因。</p></li><li><p>GET另一方面，它应该是幂等的，这意味着您可以做一百万次，并且服务器每次都会做相同的事情（并且基本上显示出相同的结果）</p></li><li><p>最后，在使用AJAX发送GET请求时，一个重要的考虑因素是某些浏览器（尤其是IE）会缓存GET请求的结果。因此，例如，如果您使用相同的GET请求进行轮询，即使您正在查询的数据正在服务器端更新，您也将始终获得相同的结果。缓解此问题的一种方法是，通过附加时间戳使每个请求的URL唯一。</p></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><div id="refer-anchor-1"></div><p>[1] <a href="https://www.pythonthree.com/what-is-cname/">什么是CNAME记录？CNAME记录如何使用</a></p><div id="refer-anchor-1"></div><p>[2] <a href="https://www.zhihu.com/question/29998374">顶级域名 一级域名 二级域名 三级域名什么区别?</a></p><div id="refer-anchor-3"></div><p>[3] <a href="https://blog.csdn.net/lnboxue/article/details/52220928">一步一步学习IP路由流程</a></p><p>[4] <a href="https://cloud.tencent.com/developer/article/1173761">转发表(MAC表)、ARP表、路由表总结</a></p><p>[5] <a href="https://www.cnblogs.com/michael9/p/13345911.html">数据包的通信过程</a></p><p>[6] <a href="https://zhuanlan.zhihu.com/p/21392419">浅谈路由协议</a></p><div id="refer-anchor-4"></div><p>[7] <a href="https://draveness.me/whys-the-design-tcp-three-way-handshake/">为什么 TCP 建立连接需要三次握手</a></p><p>[8] <a href="https://developer.aliyun.com/article/742739">阿里面试官： HTTP、HTTPS、TCP/IP、Socket通信、三次握手四次挥手过程？（附全网最具深度的三次握手、四次挥手讲解）</a></p><div id="refer-anchor-5"></div><p>[9] <a href="https://www.quora.com/Why-in-a-TCP-sequence-is-a-number-taken-as-a-random-number-and-what-is-the-actual-number-at-the-start">Why in a TCP sequence, is a number taken as a random number and what is the actual number at the start?</a></p><div id="refer-anchor-6"></div><p>[10] <a href="http://wsfdl.com/algorithm/2016/02/04/%E7%90%86%E8%A7%A3Diffie-Hellman%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95.html">理解 Deffie-Hellman 密钥交换算法</a></p><div id="refer-anchor-7"></div><p>[11] <a href="https://razeencheng.com/post/ssl-handshake-detail">HTTPS篇之SSL握手过程详解</a></p><div id="refer-anchor-8"></div><p>[12] <a href="https://www.acunetix.com/blog/articles/what-is-hsts-why-use-it/">What Is HSTS and Why Should I Use It?</a></p><div id="refer-anchor-9"></div><p>[13] <a href="https://www.digitalocean.com/community/tutorials/understanding-nginx-http-proxying-load-balancing-buffering-and-caching">Understanding Nginx HTTP Proxying, Load Balancing, Buffering, and Caching</a></p><div id="refer-anchor-10"></div><p>[14] <a href="https://blog.csdn.net/weixin_44316575/article/details/103698819">nginx启用HSTS以支持从http到https不通过服务端而自动跳转</a></p><div id="refer-anchor-11"></div><p>[15] <a href="https://jjayyyyyyy.github.io/2017/04/27/HSTS.html">HSTS学习笔记</a></p><div id="refer-anchor-12"></div><p>[16] <a href="https://www.zhihu.com/question/20064691">为什么有些网址前面没有www？</a></p><div id="refer-anchor-13"></div><p>[17] <a href="https://www.zhihu.com/question/67013338">为什么TCP4次挥手时等待为2MSL？</a></p><div id="refer-anchor-14"></div><p>[18] <a href="https://my.oschina.net/u/3872630/blog/4434563">万字长文|全网最强 TCP/IP 拥塞控制总结…</a></p>]]></content>
    
    
    <categories>
      
      <category>network</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>反射初体验</title>
    <link href="/2021-06-03/%E5%8F%8D%E5%B0%84%E5%88%9D%E4%BD%93%E9%AA%8C.html"/>
    <url>/2021-06-03/%E5%8F%8D%E5%B0%84%E5%88%9D%E4%BD%93%E9%AA%8C.html</url>
    
    <content type="html"><![CDATA[<h3 id="0x0-反射是什么"><a href="#0x0-反射是什么" class="headerlink" title="0x0 反射是什么"></a>0x0 反射是什么</h3><p>反射是java中非常重要的一个概念。简而言之，反射就是在程序<strong>运行时</strong>可以<strong>动态</strong>的获取一个类的对象、执行某个类的方法等等。这里采用<a href="https://stackoverflow.com/questions/4453349/what-is-the-class-object-java-lang-class">overflow</a>上的一个回答。</p><blockquote><p>In order to fully understand the class object, let go back in and understand we get the class object in the first place. You see, every .java file you create, when you compile that .java file, the jvm will creates a .class file, this file contains all the information about the class, namely:</p></blockquote><blockquote><p>Fully qualified name of the class<br>Parent of class<br>Method information<br>Variable fields<br>Constructor<br>Modifier information<br>Constant pool<br>The list you see above is what you typically see in a typical class. Now, up to this point, your .java file and .class file exists on your hard-disk, when you actually need to use the class i.e. executing code in main() method, the jvm will use that .class file in your hard drive and load it into one of 5 memory areas in jvm, which is the method area, immediately after loading the .class file into the method area, the jvm will use that information and a Class object that represents that class that exists in the heap memory area.</p></blockquote><blockquote><p>Here is the top level view,<br>.java –compile–&gt; .class –&gt;when you execute your script–&gt; .class loads into method area –jvm creates class object from method area–&gt; a class object is born</p></blockquote><p>With a class object, you are obtain information such as class name, and method names, everything about the class.</p><p>反射机制是通过一个名为Class对象的概念来实现的。在编译每个.java文件后，都会生成一个对应的.class文件。这个.class文件包含了我们所编写的类的所有信息。比如类的全限定名、属性、方法、修饰符等等。然后当我们需要使用所编写的类时（这里记为target），.class文件会被加载至方法区，并且jvm会在堆区创建一个target类对应的Class对象。然后targt类的所有实例都由这个Class对象来产生。</p><p>注意，对于一个类，jvm只会生成一个对应的Class对象。</p><h3 id="0x1-反射有什么用"><a href="#0x1-反射有什么用" class="headerlink" title="0x1 反射有什么用"></a>0x1 反射有什么用</h3><p>反射最主要的作用的我认为就是提高了对未知应用的扩展能力。</p><p>试想一个场景：</p><p>项目的云服务我们最先使用的是阿里云，然后某天不爽想换成腾讯云，然后又换成什么亚马逊，七牛等等，需求不停的在变。如果我们在代码里写死了业务代码，那么每换一次，就要更新一次代码，烦不烦，你说烦不烦。</p><p>那么这是肯定有人想，写个配置文件，到时候我们在代码里判断到底用的是哪个云服务不就完事了？用什么反射，自找麻烦。</p><p>但是想过没有，我们if判断的条件只能是已知的，如果某天市场上杀出一个新的厂商，怎么办？还是得更新业务代码。得重新编译、重新运行。</p><p>所以为了处理这种未知的状况，就不得不使用使用反射了。我们把类名写在配置文件里，然后利用反射加载对应的类，这样以不变应万变。配置文件变化时只需要重新应用就行了，<strong>无需重新编译代码!!!</strong></p><p>当然，这些服务应该还有统一的接口，不然不可能实现一份代码适配多种情况。</p><h3 id="0x2-反射怎么用"><a href="#0x2-反射怎么用" class="headerlink" title="0x2 反射怎么用"></a>0x2 反射怎么用</h3><h4 id="1-获取反射对象"><a href="#1-获取反射对象" class="headerlink" title="1. 获取反射对象"></a>1. 获取反射对象</h4><p>想使用反射，我们必须得首先获得Class对象，获得Class对象的方法有三种：</p><ul><li>使用Class类的静态方法forName，参数为类的全限定名</li><li>直接使用某个类的class属性</li><li>调用某个对象的getClass()方法</li></ul><figure class="highlight java"><figcaption><span>"获取Class对象的三种方式"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//获取class对象的方法有三种</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getClassObject</span><span class="hljs-params">(Employee employee)</span></span>&#123;<br>        <span class="hljs-comment">//第一种通过全限定名获取</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Class c1=Class.forName(<span class="hljs-string">&quot;ReflectionBase.Employee&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">//第二种通过类的class属性获取</span><br>        Class&lt;ReflectionBase.Employee&gt; c2=Employee.class;<br><br>        <span class="hljs-comment">//第三种通过对象的getClass()方法获取</span><br>        Class&lt;? extends ReflectionBase.Employee&gt; c3=employee.getClass();<br>    &#125;<br></code></pre></div></td></tr></table></figure><h4 id="2-通过Class对象创造实例"><a href="#2-通过Class对象创造实例" class="headerlink" title="2. 通过Class对象创造实例"></a>2. 通过Class对象创造实例</h4><p>主要有两种方法：</p><ul><li>调用Class对象的newInstance()方法。</li><li>通过Class对象获取想要的Constructor，然后通过Constructor生成实例</li></ul><figure class="highlight java"><figcaption><span>"通过反射获取类的实例"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//通过newInstance方法</span><br><span class="hljs-keyword">try</span> &#123;<br>    Employee instance = c2.newInstance();<br>&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>    e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//通过获取Constructor来构造实例</span><br><span class="hljs-comment">//其中的参数填充要根据我们想要的构造函数</span><br><span class="hljs-keyword">try</span> &#123;<br>    Constructor&lt;Employee&gt; constructor = c2.getDeclaredConstructor(String.class, <span class="hljs-keyword">int</span>.class, String.class, <span class="hljs-keyword">int</span>.class, String.class, <span class="hljs-keyword">double</span>.class);<br>    <span class="hljs-comment">//取消访问检查</span><br>    constructor.setAccessible(<span class="hljs-keyword">true</span>);<br>    Employee e = constructor.newInstance(<span class="hljs-string">&quot;bob&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;eng&quot;</span>, <span class="hljs-number">200.2</span>);<br>    e.sayHello();<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，第一种方法只能通过默认无参构造方法构造对象，那么如果我们的类米有无参构造函数怎么办？这也许就是它被放弃的理由吧。</p><p>第二种可以获取任意一个构造函数，无论有参无参、私有公共，不过就是参数必须一一对应。</p><h4 id="3-获取修饰符"><a href="#3-获取修饰符" class="headerlink" title="3. 获取修饰符"></a>3. 获取修饰符</h4><p>修饰符的信息封装在<code>Modifier</code>类中，常见的用法通过<code>getModifiers()</code>返回一个用于描述Field、Method和Constructor的修饰符的整形数值，然后再由Modifier的静态方法<code>toString()</code>转为字符串。</p><p>以及一些常用的判断是否为<code>static</code>字段。</p><h4 id="4-获取类的属性"><a href="#4-获取类的属性" class="headerlink" title="4. 获取类的属性"></a>4. 获取类的属性</h4><p>类的属性都由Filed类管理。常用的方法有：</p><ul><li><code>getFields()</code>,获取该类所有的public属性，但不包括父类的属性。</li><li><code>getDeclaredFields()</code>,获取该类的所有属性，包括私有，但同样不包括父类的属性</li></ul><figure class="highlight java"><figcaption><span>"获取类的所有属性"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">parseFields</span><span class="hljs-params">(Class c)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    StringBuilder sb=<span class="hljs-keyword">new</span> StringBuilder();<br>    Field[] fields = c.getFields();<br><br>    <span class="hljs-keyword">for</span> (Field elem : fields) &#123;<br><br>        sb.append(SPLIT);<br>        <span class="hljs-keyword">int</span> modifiers = elem.getModifiers();<br>        <span class="hljs-keyword">if</span> (Modifier.toString(modifiers).length() &gt; <span class="hljs-number">0</span>) &#123;<br>            sb.append(Modifier.toString(modifiers)).append(SPLIT);<br><br>        &#125;<br>        Class&lt;?&gt; type = elem.getType();<br>        <span class="hljs-keyword">if</span> (type != <span class="hljs-keyword">null</span>) &#123;<br>            sb.append(type.getName()).append(SPLIT);<br>        &#125;<br>        sb.append(elem.getName());<br>        sb.append(<span class="hljs-string">&quot;;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br></code></pre></div></td></tr></table></figure><h4 id="5-获取类的构造方法"><a href="#5-获取类的构造方法" class="headerlink" title="5. 获取类的构造方法"></a>5. 获取类的构造方法</h4><p>同样，类的构造方法也会被封装在<code>Constructor</code>类中。<code>getDeclaredConstructors()</code>可以获取该类的所有构造方法。但是不包含<strong>父类的构造方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">parseConstructor</span><span class="hljs-params">(Class c)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    StringBuilder sb=<span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-comment">//获得该类的所有共有构造方法</span><br>    Constructor[] constructors = c.getConstructors();<br>    <span class="hljs-keyword">for</span>(Constructor elem:constructors)&#123;<br>        sb.append(SPLIT);<br>        <span class="hljs-keyword">int</span> modifiers = elem.getModifiers();<br>        <span class="hljs-keyword">if</span>(Modifier.toString(modifiers).length()&gt;<span class="hljs-number">0</span>)&#123;<br>            sb.append(Modifier.toString(modifiers)).append(SPLIT);<br>        &#125;<br>        sb.append(elem.getName()).append(<span class="hljs-string">&quot;(&quot;</span>);<br>        Class[] types = elem.getParameterTypes();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;types.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>)&#123;<br>                sb.append(<span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>            sb.append(types[i].getName());<br>        &#125;<br>        sb.append(<span class="hljs-string">&quot;);\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br></code></pre></div></td></tr></table></figure><h4 id="6-获取类的所有方法"><a href="#6-获取类的所有方法" class="headerlink" title="6. 获取类的所有方法"></a>6. 获取类的所有方法</h4><p>与上面类似，方法被封装在Method类中，同样，<code>getDeclaredMethod()</code>获取的方法<strong>不包括</strong>父类的方法。<code>getMethods()</code>获取公共的、父类或接口的所有方法。</p><figure class="highlight java"><figcaption><span>"获取类的所有方法"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">parseMethods</span><span class="hljs-params">(Class c)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    StringBuilder sb=<span class="hljs-keyword">new</span> StringBuilder();<br>    Method[] methods = c.getDeclaredMethods();<br>    <span class="hljs-keyword">for</span>(Method elem:methods)&#123;<br>        sb.append(SPLIT);<br>        <span class="hljs-keyword">int</span> modifiers = elem.getModifiers();<br>        <span class="hljs-keyword">if</span>(Modifier.toString(modifiers).length()&gt;<span class="hljs-number">0</span>)&#123;<br>            sb.append(Modifier.toString(modifiers)).append(SPLIT);<br>        &#125;<br>        Class&lt;?&gt; returnType = elem.getReturnType();<br>        sb.append(returnType.getName()).append(SPLIT);<br>        sb.append(elem.getName()).append(<span class="hljs-string">&quot;(&quot;</span>);<br>        Class&lt;?&gt;[] parameterTypes = elem.getParameterTypes();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;parameterTypes.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>)&#123;<br>                sb.append(<span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>            sb.append(parameterTypes[i].getName());<br>        &#125;<br>        sb.append(<span class="hljs-string">&quot;);\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>获取了方法，我们如何使用？非常简单，调用Method类的<code>invoke(Object invoke(Object obj, Object... args)</code> 执行方法，第一个参数执行该方法的对象，如果是static修饰的类方法，则传null即可方法。</p><p>通过获取Method对象时，仍然需要通过准确的参数类型才能找到我们想要的method对象。</p><h4 id="7-解析类的基本信息"><a href="#7-解析类的基本信息" class="headerlink" title="7. 解析类的基本信息"></a>7. 解析类的基本信息</h4><p>有了上面的工具我们就可以通过class文件来解析该类的基本信息了，我们构造两个类，Person和Employee类，后者继承前者：</p><figure class="highlight java"><figcaption><span>"Person类"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> String hobby;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String hobby)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.hobby = hobby;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getHobby</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> hobby;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHobby</span><span class="hljs-params">(String hobby)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.hobby = hobby;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><hr><figure class="highlight java"><figcaption><span>"Employee类"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> employeeId;<br>    <span class="hljs-keyword">protected</span> String title;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String hobby, <span class="hljs-keyword">int</span> employeeId, String title, <span class="hljs-keyword">double</span> salary)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name, age, hobby);<br>        <span class="hljs-keyword">this</span>.employeeId = employeeId;<br>        <span class="hljs-keyword">this</span>.title = title;<br>        <span class="hljs-keyword">this</span>.salary = salary;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;Hello, 我是 %s, 今年 %s 岁, 爱好是%s, 我目前的工作是%s, 月入%s元\n&quot;</span>,<br>                name, age, getHobby(), title, salary));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;My name is %s, 工作中勿扰.&quot;</span>, name));<br><br>    &#125;<br></code></pre></div></td></tr></table></figure><p>构造了上述类，我们就可以通过反射获取该类的字段、构造器、方法等等，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseClass</span><span class="hljs-params">(String className)</span></span>&#123;<br><br>    StringBuilder result=<span class="hljs-keyword">new</span> StringBuilder();<br>    Class c= <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        c = Class.forName(className);<br>        <span class="hljs-keyword">int</span> modifiers = c.getModifiers();<br>        <span class="hljs-comment">//打印类的修饰符</span><br>        result.append(Modifier.toString(modifiers));<br>        result.append(SPLIT);<br>        result.append(c.getName()).append(SPLIT);<br>        Class superclass = c.getSuperclass();<br>        <span class="hljs-keyword">if</span>(superclass!=<span class="hljs-keyword">null</span> &amp;&amp; superclass!=Object.class)&#123;<br>            result.append(<span class="hljs-string">&quot;extends&quot;</span>).append(SPLIT).append(superclass.getName());<br>        &#125;<br>        result.append(<span class="hljs-string">&quot;&#123;\n&quot;</span>);<br>        <span class="hljs-comment">//打印属性</span><br>        result.append(parseFields(c));<br>        <span class="hljs-comment">//打印构造函数</span><br>        result.append(parseConstructor(c));<br>        <span class="hljs-comment">//打印成员方法</span><br>        result.append(parseMethods(c));<br><br>        result.append(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>        System.out.println(result.toString());<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>        e.getMessage();<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ReflectionBase.Employee extends ReflectionBase.Person&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> employeeId;<br>    <span class="hljs-keyword">public</span> java.lang.String name;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="8-解析类的数据"><a href="#8-解析类的数据" class="headerlink" title="8. 解析类的数据"></a>8. 解析类的数据</h4><p>上面的解析是解析类的基本结构，那么如何获取一个对象的具体数据呢？与上面类似，我们将对象的类型分为三种，字符串、数组、普通对象。采用递归的方法解析所有字段。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">parseObject</span><span class="hljs-params">(Object obj)</span></span>&#123;<br><br>    <span class="hljs-keyword">if</span>(obj==<span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    StringBuilder sb=<span class="hljs-keyword">new</span> StringBuilder();<br><br>    Class&lt;?&gt; c = obj.getClass();<br>    <span class="hljs-comment">//判断是否为字符串类</span><br>    <span class="hljs-keyword">if</span>(c==String.class)&#123;<br>        <span class="hljs-keyword">return</span> (String)obj;<br>    &#125;<br>    <span class="hljs-comment">//判断对象是否为数组</span><br>    <span class="hljs-keyword">if</span>(c.isArray())&#123;<br>        sb.append(c.getComponentType()).append(<span class="hljs-string">&quot;[]&#123;\n&quot;</span>);<br>        System.out.println(Array.getLength(obj));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;Array.getLength(obj);i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>)&#123;<br>                sb.append(<span class="hljs-string">&quot;,\n&quot;</span>);<br>            &#125;<br>            sb.append(<span class="hljs-string">&quot;\t&quot;</span>);<br>            Object o = Array.get(obj, i);<br>            <span class="hljs-comment">//数组元素类型为8种普通类型，直接打印即可</span><br>            <span class="hljs-keyword">if</span>(c.getComponentType().isPrimitive())&#123;<br>                sb.append(o.toString());<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//数组元素类型为类，递归解析</span><br>                sb.append(parseObject(o));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.append(<span class="hljs-string">&quot;\n&#125;&quot;</span>).toString();<br>    &#125;<br>    <span class="hljs-comment">//既不是数组，也不是字符串，那就是普通对象</span><br>    <span class="hljs-keyword">while</span>(c!=<span class="hljs-keyword">null</span>)&#123;<br>        sb.append(c.getName());<br>        sb.append(<span class="hljs-string">&quot;[&quot;</span>);<br>        Field[] fields = c.getDeclaredFields();<br>        AccessibleObject.setAccessible(fields,<span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;fields.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!Modifier.isStatic(fields[i].getModifiers())) &#123;<br>                <span class="hljs-keyword">if</span> (!sb.toString().endsWith(<span class="hljs-string">&quot;[&quot;</span>)) &#123;<br>                    sb.append(<span class="hljs-string">&quot;,&quot;</span>);<br>                &#125;<br>                sb.append(fields[i].getName()).append(<span class="hljs-string">&quot;=&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//属性为8种普通类型，直接打印即可</span><br>                    <span class="hljs-keyword">if</span> (fields[i].getType().isPrimitive()) &#123;<br>                        sb.append(fields[i].get(obj));<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">//属性为类，继续递归解析</span><br>                        sb.append(parseObject(fields[i].get(obj)));<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        sb.append(<span class="hljs-string">&quot;]&quot;</span>);<br>        c=c.getSuperclass();<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>测试代码为：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        list.add(i*i);<br>    &#125;<br><br>    System.out.println(ReflectionUtil.parseObject(list).toString());<br><br></code></pre></div></td></tr></table></figure><hr><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">java.util.ArrayList[elementData=<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Object</span>[]</span>&#123;<br>    java.lang.Integer[value=<span class="hljs-number">1</span>]java.lang.Number[]java.lang.Object[],<br>    java.lang.Integer[value=<span class="hljs-number">4</span>]java.lang.Number[]java.lang.Object[],<br>    java.lang.Integer[value=<span class="hljs-number">9</span>]java.lang.Number[]java.lang.Object[],<br>    ,<br>    ,<br>    ,<br>    ,<br>    ,<br>    ,<br>&#125;,size=<span class="hljs-number">3</span>]java.util.AbstractList[modCount=<span class="hljs-number">3</span>]java.util.AbstractCollection[]java.lang.Object[]<br></code></pre></div></td></tr></table></figure><p>这里的空白行是为ArrayList的默认容量为10。</p><p>小结：我们通过Filed类的<code>getType()</code>的方法来获取属性的类型，通过Field类的<code>get(Object o)</code>获取该属性的值，参数为我们当前想要查看的对象。</p><h3 id="0x4-反射机制的优缺点"><a href="#0x4-反射机制的优缺点" class="headerlink" title="0x4 反射机制的优缺点"></a>0x4 反射机制的优缺点</h3><p>优点：</p><ul><li>就是灵活，提高了对未知代码的兼容性</li></ul><p>缺点：</p><ul><li>对性能有影响，反射的性能消耗比不使用的要高很多</li><li>而且打破了安全限制，使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</li><li>破坏了封装性</li></ul><p>所以能不用反射，就不用反射。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&mid=2247483785&idx=1&sn=f696c8c49cb7ecce9818247683482a1c&chksm=e9c2ed84deb564925172b2dd78d307d4dc345fa313d3e44f01e84fa22ac5561b37aec5cbd5b4&scene=0#rd">java反射机制详解</a></p></li><li><p><a href="https://laijianfeng.org/2018/12/Java-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/">动态代理详解</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>反射</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基本概念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java的内存布局</title>
    <link href="/2021-06-03/java-memory-layout.html"/>
    <url>/2021-06-03/java-memory-layout.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>众所周知,java虚拟机的内存布局和传统的内存布局都差不多,都分为栈、堆啥的。准确的来说，jvm的内存分为以下几个部分:</p><ul><li>程序计数器(就是eip)</li><li>堆</li><li>方法区</li><li>本地方法栈</li><li>虚拟机栈</li></ul><p>其中堆和方法区是所有线程锁共享的,而程序计数器、栈肯定都是线程私有的,因为这与程序的正常运行息息相关。</p><p>上述的五个区域都可能产生内存溢出,有的还可能产生内存泄漏(虽然内存由jvm管理,但是并不能保证内存不会泄露奥)。下面我将一一介绍上述四个区域(不包括程序计数器)产生内存溢出的一般情况,当然大部分内容还是来自&lt;&lt;深入理解JVM&gt;&gt;一书,我在这里仅仅做个概括加上自己一点的感想。</p><h2 id="0x1-虚拟机栈"><a href="#0x1-虚拟机栈" class="headerlink" title="0x1 虚拟机栈"></a>0x1 虚拟机栈</h2><p>虚拟机栈跟传统汇编里的栈感觉差不多,只不过这里用所谓的局部变量槽来保存(Slot)。当然栈就是用来存储局部变量和返回地址的，内容肯定和传统栈一样。当然本地方法栈和虚拟机栈在性质上就是一类东西,<strong>仅仅是用途不同而已</strong>。所以就不单独分开说本地方法栈了。</p><p>Tips:</p><blockquote><p>当进入一个方法时,这个方法需要多少个局部变量槽是确定的,局部变量所需的内存在编译时期分配完成,而具体内存是多少个byte是不确定的,因为局部变量槽的实现方式不在JVM规范中。由虚拟机厂商所决定。</p></blockquote><p>上面这个我也是才注意的,不像传统栈可以不停的push,使用的大小完全无法确定。</p><p>进入正题,虚拟机栈可能会发生两种内存错误:</p><ul><li>StackOverFlow</li><li>OutOfMemeory</li></ul><p>StackOverFlow要么是死递归造成的栈空间不够,要么是局部变量太多。感觉后者不太可能发生,因为需要的局部变量太多儿。所以出现StackOverFlow的第一直觉就是死递归。</p><p>第二种出现于允许栈可扩展的虚拟机中。虚拟机之王HotSpot是不支持虚拟机栈扩展的。但是仍然可能出现OOM,当线程申请栈空间失败时。反之申请成功就永远不会出现OOM。</p><h2 id="0x2-堆"><a href="#0x2-堆" class="headerlink" title="0x2 堆"></a>0x2 堆</h2><p>堆是所有线程共享的内存区域,堆中能出现的内存错误当然是OOM辣。在Java中,几乎所有的对象实例都在堆中分配(具体解释来自深入理解JVM:page45)。</p><p>堆的可以被实现为固定的或者可扩展的。hotSpot中堆属于可扩展的。堆的大小可以通过参数<code>-Xms</code>(初始堆的大小)和<code>-Xmx</code>(堆的最大值)来控制。</p><p>当在堆中无法完成对象的分配时,在堆上就会出现OOM。</p><h3 id="0x2-1-方法区"><a href="#0x2-1-方法区" class="headerlink" title="0x2-1 方法区"></a>0x2-1 方法区</h3><p>方法区跟堆一样也是属于所有线程共享的内存区域。其中主要存储由虚拟机加载的类型信息、常量、静态变量、JIT编译后的缓存数据等等。</p><p>在JDK8以前,HotSopt采用了永久代的方法实现了方法区,从而能够像管理堆一样管理方法区。<strong>但是这是一个陋习</strong>。永久代有上限,这就导致在加载过多类后会出现内存溢出。</p><p>所以在JDK7中,oracle已经将方法区中的常量池、静态变量移出了永久代。在JDK8中,在方法区中彻底废除了永久代,通过在本地内存中实现元空间(与J9类似)保存剩余的信息,大部分都是类型信息。</p><p>虚拟机规范对方法区的要求是非常宽松的,比如方法区可以<strong>不执行内存回收</strong>,当然在方法区执行内存回收也是比较麻烦的。</p><p>当在方法区中无法申请到满足要求的内存时,就会出现OOM错误。</p><h3 id="0x2-2-运行时常量池"><a href="#0x2-2-运行时常量池" class="headerlink" title="0x2-2 运行时常量池"></a>0x2-2 运行时常量池</h3><p>运行时常量池本来是属于方法区的东西(注意oralce在JDK7是把常量池移出了永久代,而不是移出了方法区)。在Class文件中有一项信息为常量表,存储的是编译时期的各种常量与符号引用。这部分内容将在类加载完成后存放至方法区的运行时常量池。</p><p>当然常量池的内容不一定得是编译时的常量，也可以在运行时将新常量加入到池中。所以说运行时常量池与Class文件的常量池相比,前者具有动态性。</p><p>运行时常量池既然是方法区的东西,自然也会受到方法区的限制,当无法申请到足够多的内存时,就会出现OOM。</p><h2 id="0x3-直接内存"><a href="#0x3-直接内存" class="headerlink" title="0x3 直接内存"></a>0x3 直接内存</h2><p>直接内存并不是虚拟机规范中定义的内存区域,但是逐渐变得很重要。</p><p>在JDK1.4中,java引入了NIO。注意IO操作可以是要频繁跟本地堆的内容进行交互的。所以在NIO中：</p><blockquote><p>引入了一种基于管道和缓冲区的IO方式,可以直接使用native函数库分配native堆,然后通过一个存储在java堆中的DirectByteBuffer对象作为native堆的引用来操作native堆</p></blockquote><p>上述这种操作就避免了在java堆中和native中频繁的复制数据。</p><p>native堆的分配大小一般都会忽略,导致各个内存区域的大小总和超过了本机主机内存,从而出现OOM。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://medium.com/platform-engineer/understanding-java-memory-model-1d0863f6d973">Understanding Java Memory Model</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双亲委派模型</title>
    <link href="/2021-06-03/parents-delegation-model.html"/>
    <url>/2021-06-03/parents-delegation-model.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先在了解双亲委派模型前，我们有必要了解它的英文名字：<code>parents delegation model</code>。其实在具体的模型中，并没有所谓的“双亲”，只有一个逻辑意义上的父类，详情见下文。</p><h2 id="1-类加载器"><a href="#1-类加载器" class="headerlink" title="1. 类加载器"></a>1. 类加载器</h2><p>在《深入理解java虚拟机》一书中写道：</p><blockquote><p>java团队有意将类加载阶段中的“通过一个类的全限定名来获取该类的二进制字节流”这个动作放到java虚拟机外部去实现<br>完成这个动作的代码就称为类加载器，以前不理解放到虚拟机外部是什么意思，现在我的理解是我们能够在编写程序时就能够编写目标类的加载过程，这也就是所谓的在虚拟机外部。这样如此，我们自定义的类加载器就能够处理我们自定义的字节码。</p></blockquote><p>值得一提的是：类加载器与类共同确定了该类在虚拟机中是否唯一。也就是说，在虚拟机要比较两个类是否相同，比较的前提是<strong>待比较的两个类是由同一个类加载器加载到虚拟机中的</strong>，才有比较的意义。</p><p>这里的比较包括：<code>instanceof</code>、Class对象的<code>equals()</code>、<code>isAssignableForm()</code>、<code>isInstance()</code>方法。</p><h2 id="2-双亲委派模型"><a href="#2-双亲委派模型" class="headerlink" title="2. 双亲委派模型"></a>2. 双亲委派模型</h2><p>在了解双亲委派模型前，我们需要知道，jvm中有三类自带的类加载器：</p><ul><li><code>bootstrap class loader</code>，启动类加载器</li><li><code>extension class loader</code>，扩展类加载器</li><li><code>Application class laoder</code>，应用程序类加载器</li></ul><p><strong>启动类加载器</strong><br>启动类加载器由cpp编写，在java代码中无法直接引用。该加载器负责加载java的核心库，包括<code>&lt;JAVA_HOME&gt;/lib/</code>下的库，例如rt.jar、tools.jar；或者由<code>-Xbootclasspath</code>指定的，并且存放在lib目录下的符合规则的库，这里的规则是库的名字由jvm指定，不符合名字要求的即使由参数指定，也不会被加载。</p><p>前面说到，该加载器由cpp编写时，所以在编写代码时如果我们需要使用到该加载器，我们可以用null指代启动类加载器，这一规则由java团队约定。</p><p><strong>扩展类加载器</strong><br>扩展类加载器由java编写，负责加载<code>&lt;JAVA_HOME&gt;/lib/ext/</code>目录下的库，或者由环境变量<code>java.extdirs</code>指定目录下的库。</p><p><strong>应用程序加载器</strong><br>应用程序类加载器通用由java编写，在代码中可以直接引用。该加载器是我们接触最多的加载器了，默认情况下，我们编写的class都由其加载至jvm中。它负责加载由<code>classpath</code>参数指定路径下的类库。</p><blockquote><p>应用程序类加载器由<code>sun.misc.Launcher$AppClassLoader</code>实现。并且应用程序类加载器是ClassLoader中的getSystemClassLoader()方法的返回值</p></blockquote><p>这三个加载器的关系如下所示：</p><p><img src="images/jvmclassloader.jpg" alt="jvm class loader"></p><p>可以看到，<code>BootStrap ClassLoader</code>作为顶层的父类，<code>Extension ClassLoader</code>作为<code>BootStrap ClassLoader</code>的子类，而<code>Application ClassLoader</code>又作为<code>Extension ClassLoader</code>的子类。我们可以看到，这里并没有所谓的双亲，只有单亲，而这么翻译可能是因为第一个翻译的人看到的是parents吧。</p><blockquote><p>这里的父类与子类并不是传统意义上的使用extends保持的继承关系，而是通过内部包含来实现逻辑意义上的继承关系</p></blockquote><p><strong>三类加载器的初始化过程</strong></p><p>下图显示了<code>ExtClassLoader</code>、<code>AppClassLoader</code>、<code>ClassLoader</code>三者真正的继承关系。<br><img src="images/Inheritance.png" alt="继承体系"></p><p><code>ExtClassLoader</code>和<code>AppClassLoader</code>处于平级的关系，那么如何实现所谓的双亲委派？这一切都要靠抽象类<code>ClassLoader</code>中的<code>parent</code>字段来实现，如下图所示：</p><p><img src="images/parents-field.png" alt="parent字段"></p><p>每生成一个新的<code>ClassLoader</code>,都会用父类加载器去初始化它。那么这三个加载器是如何初始化的呢？这一切都起源于<code>Launcher</code>类。 <strong>该类由<code>Bootstrap ClassLoader</code>来加载。</strong> 我们来看看它的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Launcher</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Launcher launcher = <span class="hljs-keyword">new</span> Launcher();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String bootClassPath = System.getProperty(<span class="hljs-string">&quot;sun.boot.class.path&quot;</span>);<br>    <span class="hljs-keyword">private</span> ClassLoader loader;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Launcher <span class="hljs-title">getLauncher</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> launcher;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Launcher</span><span class="hljs-params">()</span> </span>&#123;<br>        Launcher.ExtClassLoader var1;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//初始化ExtClassLoader</span><br>            var1 = Launcher.ExtClassLoader.getExtClassLoader();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException var10) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(<span class="hljs-string">&quot;Could not create extension class loader&quot;</span>, var10);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//初始化loader字段，将其设置为AppClassLoader</span><br>            <span class="hljs-keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException var9) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(<span class="hljs-string">&quot;Could not create application class loader&quot;</span>, var9);<br>        &#125;<br>        <span class="hljs-comment">//设置线程上下文加载器，也就是AppClassLoader</span><br>        Thread.currentThread().setContextClassLoader(<span class="hljs-keyword">this</span>.loader);<br>        ...<br>    &#125;<br>    ...<br></code></pre></div></td></tr></table></figure><p>在<code>Bootstrap ClassLoader</code>把<code>Launcher</code>加载进虚拟机后，<code>Launcher</code>会初始化静态字段<code>Launcher</code>，然后会调用构造方法。在构造方法中，我们目前只需关注三个部分：</p><ol><li><p>使用<code>Launcher.ExtClassLoader.getExtClassLoader()</code>生成扩展类加载器<code>ExtClassLoader</code></p></li><li><p>使用<code>Launcher.AppClassLoader.getAppClassLoader(var1)</code>生成应用类加载器<code>App ClassLoader</code>,其中<code>var1</code>就是第一步生成的扩展类加载器，其用来初始化<code>parent</code>字段</p></li><li><p>使用<code>Thread.currentThread().setContextClassLoader(this.loader)</code>初始化线程上下文加载器，其中<code>loader</code>字段就是第二步生成的应用类加载器</p></li></ol><p>此外我们还需要关注以下<code>App ClassLoader</code>的生成方法，因为其与<code>classpath</code>的设置息息相关。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClassLoader <span class="hljs-title">getAppClassLoader</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ClassLoader var0)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//读取系统属性classpath</span><br>    <span class="hljs-comment">//这里读取的是一个整个字符串，因为在windows上由“;”将多个路径拼接成一个string</span><br>    <span class="hljs-comment">//linux平台使用“:”拼接多个路径组成一个string</span><br>    <span class="hljs-keyword">final</span> String var1 = System.getProperty(<span class="hljs-string">&quot;java.class.path&quot;</span>);<br>    <span class="hljs-comment">//将多个路径抽象为File</span><br>    <span class="hljs-keyword">final</span> File[] var2 = var1 == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> File[<span class="hljs-number">0</span>] : Launcher.getClassPath(var1);<br>    <span class="hljs-keyword">return</span> (ClassLoader)AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Launcher.AppClassLoader&gt;() &#123;<br>        <span class="hljs-keyword">public</span> Launcher.<span class="hljs-function">AppClassLoader <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">//将多个路径转化为URL数组</span><br>            URL[] var1x = var1 == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> URL[<span class="hljs-number">0</span>] : Launcher.pathToURLs(var2);<br>            <span class="hljs-comment">//使用URl路径和Ext ClassLoader生成新的AppClassLoader</span><br>            <span class="hljs-comment">//具体的初始化逻辑见下</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Launcher.AppClassLoader(var1x, var0);<br>        &#125;<br>    &#125;);<br>&#125;<br><br>AppClassLoader(URL[] var1, ClassLoader var2) &#123;<br>    <span class="hljs-comment">//调用父类URLClassLoader的构造函数保存多个classpath路径</span><br>    <span class="hljs-keyword">super</span>(var1, var2, Launcher.factory);<br>    <span class="hljs-keyword">this</span>.ucp.initLookupCache(<span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-comment">//父类URLClassLoader的构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">URLClassLoader</span><span class="hljs-params">(URL[] urls, ClassLoader parent,</span></span><br><span class="hljs-params"><span class="hljs-function">                        URLStreamHandlerFactory factory)</span> </span>&#123;<br>    <span class="hljs-comment">//初始化parent字段</span><br>    <span class="hljs-keyword">super</span>(parent);<br>    ...<br>    <span class="hljs-comment">//实际使用ucp字符保存多个classpath路径</span><br>    ucp = <span class="hljs-keyword">new</span> URLClassPath(urls, factory, acc);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>经过上面的源码学习，我们已经非常清楚这三类加载器如何实现<strong>双亲</strong>的逻辑，并且还顺便搞懂了classpath的初始化过程。那么委派是什么呢？下面的加载流程很好地解释了什么是委派：</p><ol><li><p>在传统情况下，一个类的加载会由默认的类加载器加载，而一般情况下<code>Application ClassLoader</code>会作为默认的类加载器。类加载器首先会将请求委派给父类，而不是由自己来加载。</p></li><li><p><code>Application ClassLoader</code>会将加载请求委派给父类<code>Extension ClassLoader</code>,而<code>Extension ClassLoader</code>又会将请求委派给父类<code>BootStrap ClassLoader</code>。</p></li><li><p>如果<code>BootStrap ClassLoader</code>加载失败，那么具体的加载会由<code>Extension ClassLoader</code>完成。如果<code>Extension ClassLoader</code>加载失败，具体的加载会由<code>Extension ClassLoader</code>完成。如果再次不能完成，那么就会抛出异常。</p></li></ol><p>可以看到，加载请求会一级一级向上传递，直到传到根加载器。然后如果不能完成，请求又会一级一级从上到下传递到底部加载器。<strong>那么为什么要这么做呢？</strong></p><p>答案来自《深入理解java虚拟机》：</p><blockquote><p>这样做的一个显而易见的好处是，被加载的类随着它的加载器一起具备了一种优先级的层次关系。</p></blockquote><p>试想加载类<code>Object</code>,这个类肯定最终由<code>bootstrap ClassLoader</code>来加载。如果没有这种委派关系，我们随便写一个同名的类<code>Object</code>,虚拟机无法保证使用加载正确的<code>Object</code>类。那么最基础的核心类都无法保证正确加载，那就出大问题了。</p><p><strong>双亲委派模型的代码实现</strong></p><p>双亲委派的原理简单，代码实现也非常简单，下面的短短几十行代码就完成了操作：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>        <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// First, check if the class has already been loaded</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">long</span> t0 = System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//如果父类不为空，那么就使用父类的加载方法</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//否则使用根加载器加载</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                <span class="hljs-comment">// to find the class.</span><br>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br>                c = findClass(name);<br>                ...<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>系统类加载器的设置</strong></p><p>update：2021-01-18 00:31:03</p><p>复习到这时，我提出了一个问题：系统类加载器的设置和三类加载器之间的关系是怎么样的？是谁调用谁的？</p><p>目前我只能回答这个问题的一半：某个函数会首先调用<code>getSystemClassLoader()</code>，然后调用链如下：<code>getSystemClassLoader()</code>—&gt;<code>initSystemClassLoader</code>—&gt;<code>sun.misc.Launcher.getLauncher()</code></p><hr><p>我曾在上面提到，如果没有意外发生，那么在jvm中，<code>AppClassLoader</code>会被设置为默认的系统类加载器，这也是为什么会在某些场合称其为“系统类加载器”。那么这一设置是什么时候完成的呢？这一切都起源于<code>ClassLoader</code>中的方法<code>getSystemClassLoader</code>。其注释写道：</p><blockquote><p>If the system property “java.system.class.loader” is defined<br>when this method is first invoked then the value of that property is<br>taken to be the name of a class that will be returned as the system<br>class loader.  The class is loaded using the default system class loader<br>and must define a public constructor that takes a single parameter of<br>type ClassLoader which is used as the delegation parent.  An<br>instance is then created using this constructor with the default system<br>class loader as the parameter.  The resulting class loader is defined<br>to be the system class loader.</p></blockquote><p>如果设置为系统属性<code>java.system.class.loader</code>，那么在第一次调用<code>getSystemClassLoader</code>时，会将该系统属性指向的类设置为系统类加载器。值得注意的是，自定义的系统类加载器必须声明一个带有一个参数的公共构造方法，并且唯一参数用来当作委派父类。下面我们来看看这一方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClassLoader <span class="hljs-title">getSystemClassLoader</span><span class="hljs-params">()</span> </span>&#123;<br>    initSystemClassLoader();<br>    <span class="hljs-keyword">if</span> (scl == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    SecurityManager sm = System.getSecurityManager();<br>    <span class="hljs-keyword">if</span> (sm != <span class="hljs-keyword">null</span>) &#123;<br>        checkClassLoaderPermission(scl, Reflection.getCallerClass());<br>    &#125;<br>    <span class="hljs-keyword">return</span> scl;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们看到，该方法内部会调用<code>initSystemClassLoader()</code>，那么这个方法又做了什么事情呢？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initSystemClassLoader</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!sclSet) &#123;<span class="hljs-comment">//如果系统类加载器还没有被设置</span><br>        <span class="hljs-keyword">if</span> (scl != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;recursive invocation&quot;</span>);<br>        sun.misc.Launcher l = sun.misc.Launcher.getLauncher();<br>        <span class="hljs-keyword">if</span> (l != <span class="hljs-keyword">null</span>) &#123;<br>            Throwable oops = <span class="hljs-keyword">null</span>;<br>            scl = l.getClassLoader();<span class="hljs-comment">//获得ApplicationClassLoader</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                scl = AccessController.doPrivileged(<br>                    <span class="hljs-keyword">new</span> SystemClassLoaderAction(scl));<span class="hljs-comment">//设置系统类加载器</span><br>            &#125; <span class="hljs-keyword">catch</span> (PrivilegedActionException pae) &#123;<br>                oops = pae.getCause();<br>                <span class="hljs-keyword">if</span> (oops <span class="hljs-keyword">instanceof</span> InvocationTargetException) &#123;<br>                    oops = oops.getCause();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (oops != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (oops <span class="hljs-keyword">instanceof</span> Error) &#123;<br>                    <span class="hljs-keyword">throw</span> (Error) oops;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// wrap the exception</span><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(oops);<br>                &#125;<br>            &#125;<br>        &#125;<br>        sclSet = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中<code>sclSet</code>是<code>ClassLoader</code>的属性，如果是第一次调用，那么会通过<code>Launcher</code>调用<code>getSystemLoader</code>获取<code>Launcher</code>内部字段<code>loader</code>的值。不知道大家还记不记得，<code>loader</code>字段会被设置为<code>AppClassLoader</code>。此后<code>scl</code>会被设置为<code>AppCLassLoader</code>。</p><p>然后会使用<code>SystemClassLoaderAction</code>读取系统属性<code>java.system.class.loader</code>,完成系统类加载器的设置，我们来看看其源码。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemClassLoaderAction</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">PrivilegedExceptionAction</span>&lt;<span class="hljs-title">ClassLoader</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> ClassLoader parent;<br><br>    SystemClassLoaderAction(ClassLoader parent) &#123;<br>        <span class="hljs-keyword">this</span>.parent = parent;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ClassLoader <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String cls = System.getProperty(<span class="hljs-string">&quot;java.system.class.loader&quot;</span>);<br>        <span class="hljs-keyword">if</span> (cls == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> parent;<br>        &#125;<br>        Constructor&lt;?&gt; ctor = Class.forName(cls, <span class="hljs-keyword">true</span>, parent)<br>            .getDeclaredConstructor(<span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123; ClassLoader.class &#125;);<br>        ClassLoader sys = (ClassLoader) ctor.newInstance(<br>            <span class="hljs-keyword">new</span> Object[] &#123; parent &#125;);<br>        Thread.currentThread().setContextClassLoader(sys);<br>        <span class="hljs-keyword">return</span> sys;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们可以很清楚的看到，如果系统属性<code>java.system.class.loader</code>为空，那么就会返回<code>parent</code>。此前<code>parent</code>已通过构造函数被设置为<code>AppClassLoader</code>。</p><p>否则，加载系统属性指向的类并获取带有一个参数的构造方法。随后创建自定义类加载器的实例<code>sys</code>并返回。</p><p>至此，已经完成了系统类加载器的设置。所以说，默认情况下，所有的类都会使用<code>AppClassLoader</code>来加载。</p><h2 id="3-破坏双亲委派模型"><a href="#3-破坏双亲委派模型" class="headerlink" title="3. 破坏双亲委派模型"></a>3. 破坏双亲委派模型</h2><p>虽然双亲委派模型好，但它也不是万能的。到目前为止，已经出现了三次破坏行为。下面来品一哈。</p><h3 id="3-1-第一次破坏"><a href="#3-1-第一次破坏" class="headerlink" title="3.1 第一次破坏"></a>3.1 第一次破坏</h3><p>第一次破坏是由于JDK1.2之前还没有出现双亲委派模型，但是此时已经有了类加载器的概念。那么此时已经有了许多用户自定义的类加载器。那么为了兼容以前的代码，无法再以技术手段避免<code>loadClass()</code>被子类覆盖的可能性。这里所谓的无法避免是什么呢？我们再次来看看双亲委派的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>        <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// First, check if the class has already been loaded</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">long</span> t0 = System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//如果父类不为空，那么就使用父类的加载方法</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//否则使用根加载器加载</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                <span class="hljs-comment">// to find the class.</span><br>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br>                c = findClass(name);<br>                ...<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果此时用户代码还在覆盖<code>loadClass</code>,但是编写出的代码并没有采用双亲委派，那么就会使双亲委派失效。因为双亲委派就是靠<code>loadClass</code>来实现的。所以尽管不能避免之前的状态，但是以后要尽量避免让用户覆盖<code>loadClass</code>。</p><p>所以在JDK1.2之后，在<code>ClassLoader</code>中引入了一个<code>protected</code>方法<code>findClass()</code>。希望引导用户能够覆盖<code>findClass()</code>编写自定义类加载器。这样既不影响双亲委派，又可以按照用户自己的意愿加载类，就像上面源码中的那样，当父类加载失败，那么就会调用<code>findClass()</code>加载。</p><p>所以重写<code>loadClass</code>会破坏双亲模型，而重写<code>findClass</code>则不会，如果需要在多个类加载器中加载同一个<code>Class</code>，则需要使用前者。</p><h3 id="3-2-第二次破坏"><a href="#3-2-第二次破坏" class="headerlink" title="3.2 第二次破坏"></a>3.2 第二次破坏</h3><p>第二次破坏是因为双亲委派这个机制存在缺陷。首先我们需要明白下面这种机制：</p><blockquote><p>假设我们当前代码所处的类为D，如果此时要把一个从未解析的符号解析成类或接口C。如果C不是数组类型，那么<strong>jvm会使用加载D的类加载器来加载C</strong>。</p></blockquote><p>但是在双亲委派模型中，上层的类加载器是无法指派下层的类加载器来完成加载动作的。一个典型的例子就是JNDI(The Java Naming and Directory Interface)服务。简而言之，JDNI就是java规定一组服务的接口，但是具体的实现由第三方提供，例如数据库的驱动。</p><p>那么这个<strong>破坏</strong>在哪里呢？首先JDNI肯定是由启动类加载器加载至JVM。那么调用具体的实现类时，启动类加载器是不可能将实现类加载进来的，因为这不符合启动类加载器的规定。那么怎么办呢？</p><p>开发人员又设计了一种叫进程上下文类加载器(Thread Context ClassLoader)的东西来完成这个任务。启动类加载器会调用进程上下文类加载器来加载接口的实现类。</p><p>线程上下文类加载器在(默认情况下)由<code>Bootstrap classLoader</code>第一次加载<code>Launcher</code>类时就会被设置为<code>App ClassLoader</code>。当然，我们可以通过<code>setContextClassLoader(ClassLoader cl)</code>和<code>getContextClassLoader()</code>来设置和使用我们自定义的线程上下文类加载器。<strong>在多线程的情况下</strong>，子线程会继承父线程的线程上下文类加载器。</p><h3 id="3-3-第三次破坏"><a href="#3-3-第三次破坏" class="headerlink" title="3.3 第三次破坏"></a>3.3 第三次破坏</h3><p>这次破坏是为了实现java应用的热部署。简单来说就是OSGi机制破坏了双亲委派模型。以下引自《深入理解java虚拟机》：</p><blockquote><p>OSGi实现模块热部署的关键是它自定义的类加载机制的实现，每一个程序模块（OSGi称其为bundle）都有属于自己的类加载器。当需要替换Bundle时，就把Bundle连同类加载器一起替换以实现代码的热替换。</p><p>在OSGi环境下，类加载机制不再是委派双亲的树模型，而是一个<strong>网状</strong>结构。OSGi的类加载顺序中，只有前两个步骤符合双亲委派的原则，即：</p><ol><li>将以java.*开头的类，委派给父类加载器加载</li><li>否则,将委派列表名单内的类，委派给父类加载器加载</li></ol></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文详细介绍了双亲委派模型的类加载机制，解释了什么是“双亲”、什么是“委派”，三个系统自带的类加载器的初始化过程（仅限于JDK1.2-1.8）。以及历史上三次破坏双亲委派模型的事件，引出了SPI。后面我会以数据库加载驱动的案例讲解SPI到底是如何工作的。</p><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>我们在上面的源码中会经常看到<code> AccessController.doPrivileged()</code>这个方法，这又跟java的安全模型相关，谈起来不简单，后面我会专门开一篇来讲解它。</p><p><strong>参考文献</strong></p><p><a href="https://greenhathg.github.io/2019/06/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-Launcher%E7%B1%BB/">https://greenhathg.github.io/2019/06/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-Launcher%E7%B1%BB/</a></p><p><a href="https://juejin.im/post/6844903837472423944">https://juejin.im/post/6844903837472423944</a></p><p><a href="https://segmentfault.com/a/1190000021869536">https://segmentfault.com/a/1190000021869536</a></p>]]></content>
    
    
    <categories>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>类加载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021-06-03/tutorial.html"/>
    <url>/2021-06-03/tutorial.html</url>
    
    <content type="html"><![CDATA[<p>写完注释后,如果想要调试源码,那么需要重新编译源码</p><p>否则 调试的语句大概率不是我们想调试的</p><p><a href="https://stackoverflow.com/questions/18255474/debug-jdk-source-cant-watch-variable-what-it-is">debug jdk source can’t watch variable what it is</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java中的类型系统</title>
    <link href="/2021-06-03/type-system-of-java.html"/>
    <url>/2021-06-03/type-system-of-java.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>java的类型系统在1.5之后就变的很复杂了。但是又极其重要因为java中的反射基于此。所以想要深入理解反射还需要简单地学习一下java的类型系统。首先我们简要说明一下在逻辑上java的type分类。然后再在实现层次上简要了解一下java到底是如何实现的。</p><p>首先java是一个强类型语言,其任何一个变量、任何一个表达式都有类型。在Java中,总的分为<del>两类</del>三类(还有一个特殊的<code>null type</code>):</p><ul><li>primitive types:原始类型,分类<code>boolean type</code>和<code>numeric type</code>,后者又可以分为<code>integral types</code>和<code>floating-point types</code>。<ul><li>integral types:包括<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>char</code></li><li>floating-point type:包括<code>float</code>和<code>double</code></li></ul></li><li>reference types:包括<code>class types</code>、<code>interface types</code>、<code>array type</code>以及<code>type virables</code></li><li>special type:<code>null type</code></li></ul><blockquote><p>在java中,对象是类的实例或者是动态创建的数组,<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3">参考文献</a></p></blockquote><p>是的,数组也是一个对象。</p><hr><p><strong>Extension：</strong></p><p>这里额外说一下<code>null type</code>,关键字<code>null</code>不是一个类型而是一个特殊的值,可以简答的认为null指向一个特殊的内存区域。我们不能声明一个为<code>null type</code>的引用,也不能将<code>null type</code>声明为类型参数,例如<code>List&lt;null&gt;</code>(<a href="https://stackoverflow.com/questions/26632104/java-kinds-of-type-and-null-reference">参考</a>)。但是<code>null</code>却可以强转为任何类型的引用,转换结果为目标类型的空引用,<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.2">参考</a>。</p><blockquote><p>A value of the null type (the null reference is the only such value) may be assigned to any reference type, resulting in a null reference of that type.</p></blockquote><p>最后,<code>null type</code>不是一个引用类型。</p><hr><h3 id="Reference-Types"><a href="#Reference-Types" class="headerlink" title="Reference Types"></a>Reference Types</h3><p>下面的一段代码使用了四种引用类型(摘自<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3">jse8规范</a>):</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">int</span>[] metrics;<br>    T variables;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Move</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">int</span> deltax, <span class="hljs-keyword">int</span> deltay)</span></span>; &#125;<br></code></pre></div></td></tr></table></figure><p>其中,<code>Point</code>是一个<code>class type</code>(翻译成类类型好难受…),<code>int[]</code>是一个<code>array type</code>,<code>Move</code>是一个<code>interface type</code>,<code>T</code>是一个<code>type variable</code>。前三种都很好理解,最后一个<code>type variable</code>值得一提。</p><p>在jse8规范中,<code>type variable</code>被定义为一个唯一的符号在类、接口、方法、构造函数中作为一个type。所以这个<code>type variable</code>只能在上面四个地方使用。引入<code>type variable</code>的原因是因为在泛型类、泛型接口、泛型构造函数、泛型方法中定义了类型参数。</p><p>所以,很好理解,<code>type variable</code>就是泛型中<code>&lt;T&gt;</code>中的T。注意,<code>type</code></p><p><code>Type</code>接口是java中type信息的顶级接口。主要有五种type,分别是:</p><ul><li><code>raw types</code>:原始类型,使用对应类型的Class对象表示</li><li><code>primitive types</code>:基本类型,使用对应原始类型的Class对象表示</li><li><code>parameterized types</code>:参数类型,基于接口<code>ParameterizedTypes</code>,对应实现类为<code>ParameterizedTypesImpl</code></li><li><code>array types</code>:泛型数组类型,基于接口<code>GenericArrayType</code>,对应实现类为<code>GenericArrayTypeImpl</code></li><li><code>type variables</code>:类型变量,基于接口<code>TypeVariable</code>,对应实现类为<code>TypeVariableImpl</code></li><li><code>WildcardType</code>:通配符类型,基于接口<code>WildcardType</code>,对应实现类为<code>WildcardTypeImpl</code></li></ul><p>其中<code>ParameterizedTypes</code>、<code>GenericArrayType</code>、<code>TypeVariable</code>、<code>WildcardType</code>这四个接口是<code>Type</code>接口的子接口。继承图如下所示:</p><p><img src="images/Type.png" alt="Type继承图"></p><p>可以看到,<code>Class</code>类是<code>Type</code>接口的子类。下面来一一解释一下四种子接口的含义。</p><h2 id="1-ParameterizedType"><a href="#1-ParameterizedType" class="headerlink" title="1. ParameterizedType"></a>1. ParameterizedType</h2><p><code>ParameterizedType</code>翻译过来就是参数化类型,emm。应该就是将类型参数化,这是引入泛型(Generic)的必然结果。例如我们常用的<code>List&lt;Integer&gt;</code>,这一个完整的带<code>&lt;&gt;</code>的类型就叫做参数化类型。下面解释了raw type于parameterized type之间的关系。</p><ul><li>genric type:<code>List&lt;T&gt;</code></li><li>parameterized type:<code>List&lt;Integer&gt;</code></li><li>raw type:<code>List</code></li><li>type parameter:<code>Integer</code></li></ul><p><strong>有如下常用方法</strong>:</p><ul><li><code>Type getRawType()</code>: 返回承载该泛型信息的对象, 如上面那个Map&lt;String, String&gt;承载范型信息的对象是Map</li><li><code>Type[] getActualTypeArguments()</code>: 返回实际泛型类型列表, 如上面那个Map&lt;String, String&gt;实际范型列表中有两个元素, 都是String</li><li><code>Type getOwnerType()</code>: 返回当前成员的属主,例如<code>Map.Entry</code>属于<code>Map</code></li></ul><p>以具体的参数化类型, 如<code>Map&lt;String, String&gt;</code>为例:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestType</span> </span>&#123;<br>    Map&lt;String, String&gt; map;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Field f = TestType.class.getDeclaredField(<span class="hljs-string">&quot;map&quot;</span>);<br>        System.out.println(f.getGenericType());                               <span class="hljs-comment">// java.util.Map&lt;java.lang.String, java.lang.String&gt;</span><br>        System.out.println(f.getGenericType() <span class="hljs-keyword">instanceof</span> ParameterizedType);  <span class="hljs-comment">// true</span><br>        ParameterizedType pType = (ParameterizedType) f.getGenericType();<br>        System.out.println(pType.getRawType());                               <span class="hljs-comment">// interface java.util.Map</span><br>        <span class="hljs-keyword">for</span> (Type type : pType.getActualTypeArguments()) &#123;<br>            System.out.println(type);                                         <span class="hljs-comment">// 打印两遍: class java.lang.String</span><br>        &#125;<br>        System.out.println(pType.getOwnerType());                             <span class="hljs-comment">// null</span><br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="2-TypeVariable"><a href="#2-TypeVariable" class="headerlink" title="2. TypeVariable"></a>2. TypeVariable</h2><p>类型变量, 范型信息在编译时会被转换为一个特定的类型, 而TypeVariable就是用来反映在JVM编译该泛型前的信息.</p><p><strong>常用方法:</strong></p><ul><li><code>Type[] getBounds()</code>: 获取类型变量的上边界, 若未明确声明上边界则默认为Object</li><li><code>D getGenericDeclaration()</code>: 获取声明该类型变量实体,其中<code>D</code>是泛型类型的声明,也就是所在的类全限定名</li><li><code>String getName()</code>: 获取在源码中定义时的名字</li></ul><p>注意:<br>类型变量在定义的时候只能使用extends进行(多)边界限定, 不能用super;为什么边界是一个数组? 因为类型变量可以通过&amp;进行多个上边界限定，因此上边界有多个</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestType</span> &lt;<span class="hljs-title">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span> &amp; <span class="hljs-title">Serializable</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br>    K key;<br>    V value;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获取字段的类型</span><br>        Field fk = TestType.class.getDeclaredField(<span class="hljs-string">&quot;key&quot;</span>);<br>        Field fv = TestType.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>);<br>        Assert.that(fk.getGenericType() <span class="hljs-keyword">instanceof</span> TypeVariable, <span class="hljs-string">&quot;必须为TypeVariable类型&quot;</span>);<br>        Assert.that(fv.getGenericType() <span class="hljs-keyword">instanceof</span> TypeVariable, <span class="hljs-string">&quot;必须为TypeVariable类型&quot;</span>);<br>        TypeVariable keyType = (TypeVariable)fk.getGenericType();<br>        TypeVariable valueType = (TypeVariable)fv.getGenericType();<br>        <span class="hljs-comment">// getName 方法</span><br>        System.out.println(keyType.getName());                 <span class="hljs-comment">// K</span><br>        System.out.println(valueType.getName());               <span class="hljs-comment">// V</span><br>        <span class="hljs-comment">// getGenericDeclaration 方法</span><br>        System.out.println(keyType.getGenericDeclaration());   <span class="hljs-comment">// class com.test.TestType</span><br>        System.out.println(valueType.getGenericDeclaration()); <span class="hljs-comment">// class com.test.TestType</span><br>        <span class="hljs-comment">// getBounds 方法</span><br>        System.out.println(<span class="hljs-string">&quot;K 的上界:&quot;</span>);                        <span class="hljs-comment">// 有两个</span><br>        <span class="hljs-keyword">for</span> (Type type : keyType.getBounds()) &#123;                <span class="hljs-comment">// interface java.lang.Comparable</span><br>            System.out.println(type);                          <span class="hljs-comment">// interface java.io.Serializable</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;V 的上界:&quot;</span>);                        <span class="hljs-comment">// 没明确声明上界的, 默认上界是 Object</span><br>        <span class="hljs-keyword">for</span> (Type type : valueType.getBounds()) &#123;              <span class="hljs-comment">// class java.lang.Object</span><br>            System.out.println(type);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-GenericArrayType"><a href="#3-GenericArrayType" class="headerlink" title="3. GenericArrayType"></a>3. GenericArrayType</h2><p>我们仍然记得,不能创建泛型数组,那么这个<code>GenericArrayType</code>是啥意思?</p><p>虽然不能泛型数组,但是能够创建泛型数组引用啊,<code>T[] nums=null</code>是合法的,见下方代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestType</span> &lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Method method = Test.class.getDeclaredMethods()[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// public void com.test.Test.show(java.util.List[],java.lang.Object[],java.util.List,java.lang.String[],int[])</span><br>        System.out.println(method);<br>        Type[] types = method.getGenericParameterTypes();  <span class="hljs-comment">// 这是 Method 中的方法</span><br>        <span class="hljs-keyword">for</span> (Type type : types) &#123;<br>            System.out.println(type <span class="hljs-keyword">instanceof</span> GenericArrayType);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(List&lt;String&gt;[] pTypeArray, T[] vTypeArray, List&lt;String&gt; list, String[] strings, <span class="hljs-keyword">int</span>[] ints)</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>声明一个泛型数组引用还是没有问题的,运行结果如下:</p><ul><li>第一个参数List<String>[]的组成元素List<String>是ParameterizedType类型, 打印结果为true</li><li>第二个参数T[]的组成元素T是TypeVariable类型, 打印结果为true</li><li>第三个参数List<String>不是数组, 打印结果为false</li><li>第四个参数String[]的组成元素String是普通对象, 没有范型, 打印结果为false</li><li>第五个参数int[] pTypeArray的组成元素int是原生类型, 也没有范型, 打印结果为false</li></ul><p>所以数组元素是<code>ParameterizedType</code>或<code>TypeVariable</code>的数组类型才是<code>GenericArrayType</code>。</p><h2 id="4-WildcardType"><a href="#4-WildcardType" class="headerlink" title="4. WildcardType"></a>4. WildcardType</h2><p>该接口表示通配符泛型, 比如? extends Number 和 ? super Integer 它有如下方法:</p><ul><li>Type[] getUpperBounds(): 获取范型变量的上界</li><li>Type[] getLowerBounds(): 获取范型变量的下界<br>注意:</li></ul><p>现阶段通配符只接受一个上边界或下边界, 返回数组是为了以后的扩展, 实际上现在返回的数组的大小是1</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestType</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;? extends Number&gt; a;  <span class="hljs-comment">// // a没有下界, 取下界会抛出ArrayIndexOutOfBoundsException</span><br>    <span class="hljs-keyword">private</span> List&lt;? <span class="hljs-keyword">super</span> String&gt; b;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Field fieldA = TestType.class.getDeclaredField(<span class="hljs-string">&quot;a&quot;</span>);<br>        Field fieldB = TestType.class.getDeclaredField(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-comment">// 先拿到范型类型</span><br>        Assert.that(fieldA.getGenericType() <span class="hljs-keyword">instanceof</span> ParameterizedType, <span class="hljs-string">&quot;&quot;</span>);<br>        Assert.that(fieldB.getGenericType() <span class="hljs-keyword">instanceof</span> ParameterizedType, <span class="hljs-string">&quot;&quot;</span>);<br>        ParameterizedType pTypeA = (ParameterizedType) fieldA.getGenericType();<br>        ParameterizedType pTypeB = (ParameterizedType) fieldB.getGenericType();<br>        <span class="hljs-comment">// 再从范型里拿到通配符类型</span><br>        Assert.that(pTypeA.getActualTypeArguments()[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> WildcardType, <span class="hljs-string">&quot;&quot;</span>);<br>        Assert.that(pTypeB.getActualTypeArguments()[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> WildcardType, <span class="hljs-string">&quot;&quot;</span>);<br>        WildcardType wTypeA = (WildcardType) pTypeA.getActualTypeArguments()[<span class="hljs-number">0</span>];<br>        WildcardType wTypeB = (WildcardType) pTypeB.getActualTypeArguments()[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 方法测试</span><br>        System.out.println(wTypeA.getUpperBounds()[<span class="hljs-number">0</span>]);   <span class="hljs-comment">// class java.lang.Number</span><br>        System.out.println(wTypeB.getLowerBounds()[<span class="hljs-number">0</span>]);   <span class="hljs-comment">// class java.lang.String</span><br>        <span class="hljs-comment">// 看看通配符类型到底是什么, 打印结果为: ? extends java.lang.Number</span><br>        System.out.println(wTypeA);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>转载自<a href="http://loveshisong.cn/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2016-02-16-Type%E8%AF%A6%E8%A7%A3.html">Java中的Type详解</a>。</p>]]></content>
    
    
    <categories>
      
      <category>反射</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基本概念</tag>
      
      <tag>类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过MySQL驱动的加载学习SPI机制</title>
    <link href="/2021-06-03/SPI-service-mechanism.html"/>
    <url>/2021-06-03/SPI-service-mechanism.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言-什么是SPI"><a href="#前言-什么是SPI" class="headerlink" title="前言 什么是SPI"></a>前言 什么是SPI</h2><p>SPI机制（Service Provider Interface)简而言之，就是java规定了一组服务的接口，但是没有具体的实现类。那么具体的实现类肯定由不同的厂商实现，那么客户在使用时是仅依赖于接口的。<strong>SPI的具体实现是靠<code>ServiceLoader</code>完成的。</strong><br>在讲解双亲委派模型时，我们知道，SPI接口是通过<code>bootstrap ClassLoader</code>加载至jvm中的。而具体的驱动实现类是通过线程上下文类加载器加载至jvm中的。下面我们就通过加载数据库驱动的例子来了解SPI的实现原理。</p><h2 id="1-获得数据库连接实例的方式"><a href="#1-获得数据库连接实例的方式" class="headerlink" title="1. 获得数据库连接实例的方式"></a>1. 获得数据库连接实例的方式</h2><p>在JDBC4.0之前，还没有引入SPI，一般需要使用<code>Class.forName()</code>注册驱动，所以加载驱动的代码一般是如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Class.forName(<span class="hljs-string">&quot;xxxx&quot;</span>);<br>Connection c=DriverManager.getConnection(<span class="hljs-string">&quot;url&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>在JDBC4.0之后，我们只需要使用<code>DriverManager.getConnection(url)</code>就可以获得连接对象。这是因为在<code>getConnection()</code>内部会自己调用<code>Class.forName()</code>，这里包含了一层嵌套关系。而<code>DriverManager</code>又是由<code>Bootstrap ClassLoader</code>加载的，根据符号解析的规定，<code>DriverManager</code>内部的符号如果需要解析为类或接口，则会调用<code>DriverManager</code>的加载器。但是问题是<code>DriverManager</code>只会加载核心库。根据双亲委派模型，父类的请求无法派给子类，所以这时候就采用了线程上下文类加载器。<strong>而在JDBC4.0之前没有这层嵌套关系。</strong></p><p>下面我们来看看到底是如何获得驱动的。在初次使用<code>DriverManager</code>时，首先会执行静态代码块中<code>loadInitialDrivers()</code>函数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    loadInitialDrivers();<br>    println(<span class="hljs-string">&quot;JDBC DriverManager initialized&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>初始化函数如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadInitialDrivers</span><span class="hljs-params">()</span> </span>&#123;<br>    String drivers;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//查看是否设置了系统属性jdbc.drivers</span><br>        drivers = AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> System.getProperty(<span class="hljs-string">&quot;jdbc.drivers&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        drivers = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//使用ServiceLoader加载驱动</span><br>    AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);<br>            <br>            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">while</span>(driversIterator.hasNext()) &#123;<br>                    driversIterator.next();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;<br>            <span class="hljs-comment">// Do nothing</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;);<br><br>    println(<span class="hljs-string">&quot;DriverManager.initialize: jdbc.drivers = &quot;</span> + drivers);<br><br>    <span class="hljs-keyword">if</span> (drivers == <span class="hljs-keyword">null</span> || drivers.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//如果设置了系统属性jdbc.drivers,</span><br>    <span class="hljs-comment">//那么如果SPI已经成功加载了驱动，下面的代码还是会重复注册驱动</span><br>    String[] driversList = drivers.split(<span class="hljs-string">&quot;:&quot;</span>);<br>    println(<span class="hljs-string">&quot;number of Drivers:&quot;</span> + driversList.length);<br>    <span class="hljs-keyword">for</span> (String aDriver : driversList) &#123;<br>        ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，<code>DriverManager</code>的初始化分分为两个版本：</p><ul><li>设置系统属性<code>jdbc.drivers</code>属性</li><li>使用``ServiceLoader`加载，如果驱动以service provider的形式出现</li></ul><h2 id="2-SPI加载数据库驱动的原理"><a href="#2-SPI加载数据库驱动的原理" class="headerlink" title="2. SPI加载数据库驱动的原理"></a>2. SPI加载数据库驱动的原理</h2><h3 id="2-1-获取ServiceLoader对象"><a href="#2-1-获取ServiceLoader对象" class="headerlink" title="2.1 获取ServiceLoader对象"></a>2.1 获取ServiceLoader对象</h3><p>使用SPI初始化代码时首先使用<code>ServiceLoader</code>的静态方法<code>load</code>加载SPI<code>Driver</code>的class文件。源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-function">ServiceLoader&lt;S&gt; <span class="hljs-title">load</span><span class="hljs-params">(Class&lt;S&gt; service)</span> </span>&#123;<br>    ClassLoader cl = Thread.currentThread().getContextClassLoader();<br>    <span class="hljs-keyword">return</span> ServiceLoader.load(service, cl);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code> ServiceLoader.load(service, cl)</code>又会通过私有构造方法返回<code>ServiceLoader</code>对象，在私有构造方法内部调用了<code>reload()</code>方法，源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reload</span><span class="hljs-params">()</span> </span>&#123;<br>    providers.clear();<br>    lookupIterator = <span class="hljs-keyword">new</span> LazyIterator(service, loader);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先清空<code>providers</code>，这里的<code>providers</code>是一个<code>LinkedHashMap</code>，用来保存已经加载过服务实现类的实例。随后生成了<code>lazyIterator</code>对象，这个懒加载器是<code>ServiceLoader</code>的核心，它完成了查找实现类、加载实现类的动作。</p><p>那么这里的<strong>懒</strong>到底是指什么？我的理解是在程序启动之初，服务实现类并没有被加载至jvm中<strong>直到我们使用时</strong>。所以这里的懒就是在程序启动到我们使用之前的这一段时间内，不需要也没有加载服务实现类，懒就是懒在这个阶段。那非懒应该就是指在程序一启动就会加载所有的服务实现类。</p><h3 id="2-2-使用ServiceLoader对象迭代器遍历实现类容器"><a href="#2-2-使用ServiceLoader对象迭代器遍历实现类容器" class="headerlink" title="2.2 使用ServiceLoader对象迭代器遍历实现类容器"></a>2.2 使用ServiceLoader对象迭代器遍历实现类容器</h3><p>在成功获取ServiceLoader对象<code>loadedDrivers</code>后，会继续获取<code>loadedDrivers</code>的内部迭代器：</p><blockquote><p>Iterator<Driver> driversIterator = loadedDrivers.iterator();</p></blockquote><p>然后<code>DriverManager</code>会使用这个迭代器遍历ServiceLoader内部用来存储服务实现类对象的容器。具体的驱动注册就在遍历容器的时候完成。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-keyword">while</span>(driversIterator.hasNext()) &#123;<br>        driversIterator.next();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们来看看<code>ServiceLoader</code>内部迭代器的<code>hasNext()</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;S&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Iterator&lt;S&gt;() &#123;<br><br>        Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders<br>            = providers.entrySet().iterator();<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (knownProviders.hasNext())<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">return</span> lookupIterator.hasNext();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> S <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (knownProviders.hasNext())<br>                <span class="hljs-keyword">return</span> knownProviders.next().getValue();<br>            <span class="hljs-keyword">return</span> lookupIterator.next();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>hasNext()</code>首先调用内部容器<code>providers</code>自身的迭代器。失败后才会调用懒迭代器类<code>LazyIterator</code>的<code>hasNext()</code>，其具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyIterator</span></span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">S</span>&gt;</span><br><span class="hljs-class"></span>&#123;<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//无论执行if还是else，都会最终执行hasNextService</span><br>        <span class="hljs-keyword">if</span> (acc == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> hasNextService();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            PrivilegedAction&lt;Boolean&gt; action = <span class="hljs-keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;<br>                <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> hasNextService(); &#125;<br>            &#125;;<br>            <span class="hljs-keyword">return</span> AccessController.doPrivileged(action, acc);<br>        &#125;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在调用<code>LazyIteraotr</code>的<code>hasNext()</code>方法后，内部会调用<code>hashNextService()</code>:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNextService</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nextName != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (configs == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <br>            String fullName = PREFIX + service.getName();<br>            <span class="hljs-keyword">if</span> (loader == <span class="hljs-keyword">null</span>)<br>                configs = ClassLoader.getSystemResources(fullName);<br>            <span class="hljs-keyword">else</span><br>                configs = loader.getResources(fullName);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException x) &#123;<br>            fail(service, <span class="hljs-string">&quot;Error locating configuration files&quot;</span>, x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> ((pending == <span class="hljs-keyword">null</span>) || !pending.hasNext()) &#123;<br>        <span class="hljs-keyword">if</span> (!configs.hasMoreElements()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        pending = parse(service, configs.nextElement());<br>    &#125;<br>    nextName = pending.next();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们看到该方法内部有一个常量字符串<code>PREFIX</code>，其值为:</p><blockquote><p>private static final String PREFIX = “META-INF/services/“;</p></blockquote><p>这是因为java规定，所谓为SPI提供实现的厂商必须在jar包提供目录<code>META-INF/services/</code>，目录内的文件存放当前服务实现类的入口类名，文件名文当前服务接口的全限定名。以MySQL为例，其jar包内容如下：</p><p><img src="images/mysql-SPI.PNG" alt="mysql-SPI"></p><p>其中<code>java.sql.Driver</code>就是java数据库服务接口的全限定名，其内容如下：</p><p><img src="images/mysql-content.PNG" alt="mysql-content"></p><p><code>com.mysql.cj.jdbc.Driver</code>就是具体实现类的全限定名。<code>hasNextService</code>的目标就是把具体实现类的全限定名找到。找的方法就是找到文件：<code>META-INF/services/+service.name</code>。其中<code>service</code>的名字是java规定好的。例如加载数据库时的<code>service</code>就对应<code>Driver</code>类。</p><p>在找到具体实现类的名字后，下一步当然是要把它加载进来了。调用<code>ServiceLoader</code>迭代器的<code>next()</code>方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (acc == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> hasNextService();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        PrivilegedAction&lt;Boolean&gt; action = <span class="hljs-keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> hasNextService(); &#125;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> AccessController.doPrivileged(action, acc);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> S <span class="hljs-title">nextService</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!hasNextService())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>    String cn = nextName;<br>    nextName = <span class="hljs-keyword">null</span>;<br>    Class&lt;?&gt; c = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        c = Class.forName(cn, <span class="hljs-keyword">false</span>, loader);<br>    &#125;<br>    ...<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        S p = service.cast(c.newInstance());<br>        providers.put(cn, p);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>具体的加载由<code>Class.forName()</code>完成，注意，其中传入的loader是线程上下文类加载器。在将具体实现类加载进jvm后，会实例化一个实现类对象，即调用<code>c.newInstance()</code>。在实例化的过程完成了驱动的注册。我们来看看mysql实现类的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Driver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NonRegisteringDriver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">sql</span>.<span class="hljs-title">Driver</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Driver</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            DriverManager.registerDriver(<span class="hljs-keyword">new</span> Driver());<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException var1) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Can&#x27;t register driver!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>非常简单，一旦进行实例化，就会执行静态构造代码块，mysql实现的<code>Driver</code>会主动向<code>DriverManger</code>提出注册请求。至此，已经完成了数据库驱动的一次注册过程。</p><h3 id="2-3-获得数据库连接对象"><a href="#2-3-获得数据库连接对象" class="headerlink" title="2.3 获得数据库连接对象"></a>2.3 获得数据库连接对象</h3><p><code>DriverManager</code>会遍历所有已经注册过的驱动，如果能成功连接目标数据库，那么就返回当前连接对象，否则继续遍历剩下的Driver实例直至结束。下面是遍历驱动的核心代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;<br>    <span class="hljs-comment">// If the caller does not have permission to load the driver then</span><br>    <span class="hljs-comment">// skip it.</span><br>    <span class="hljs-keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            println(<span class="hljs-string">&quot;    trying &quot;</span> + aDriver.driver.getClass().getName());<br>            Connection con = aDriver.driver.connect(url, info);<br>            <span class="hljs-keyword">if</span> (con != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// Success!</span><br>                println(<span class="hljs-string">&quot;getConnection returning &quot;</span> + aDriver.driver.getClass().getName());<br>                <span class="hljs-keyword">return</span> (con);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException ex) &#123;<br>            <span class="hljs-keyword">if</span> (reason == <span class="hljs-keyword">null</span>) &#123;<br>                reason = ex;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        println(<span class="hljs-string">&quot;    skipping: &quot;</span> + aDriver.getClass().getName());<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，如果在一次尝试连接中抛出异常，那么就不会尝试后续的数据库驱动，这还是有点小bug的。</p><h3 id="2-4-存在的问题"><a href="#2-4-存在的问题" class="headerlink" title="2.4 存在的问题"></a>2.4 存在的问题</h3><p><strong>A. ServiceLoader的providers有什么用？</strong></p><p>可以看到，在<code>DriverMangaer</code>初次完成注册后，并没有使用过缓存<code>providers</code>。但是这仅仅是<code>DriverManager</code>的问题，并不能说明缓存没有用。如果我们此时再次遍历当前<code>loadedDrivers</code>，那么就不会再次使用<code>Class.forName()</code>加载，而是会通过内部缓存获得具体的实现类对象。</p><p><strong>B. 如果有多个驱动需要注册，那么在成功注册第一个驱动后，<code>knownProviders.hasNext()</code>返回的结果不应该是<code>true</code>吗？</strong></p><p>其实这跟HashMap迭代器的实现有关，在每次调用<code>entrySet().iterator()</code>后，返回的迭代器都是新<code>new</code>出来的，即初始化函数<code>loadInitialDrivers()</code>中的<code>driversIterator</code>永远都是<code>providers</code>为空时生成的迭代器。所以尽管成功了加载了一个驱动，<code>knownProviders.hasNext()</code>的结果依然是<code>false</code>，依旧会调用懒迭代器<code>lookupIterator</code>的<code>hasNext()</code>方法。</p><h2 id="3-传统的驱动加载方式"><a href="#3-传统的驱动加载方式" class="headerlink" title="3. 传统的驱动加载方式"></a>3. 传统的驱动加载方式</h2><p>传统的加载是通过<code>Class.forName()</code>完成的，而该方法会默认初始化目标类，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; forName(String className)<br>            <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    Class&lt;?&gt; caller = Reflection.getCallerClass();<br>    <span class="hljs-keyword">return</span> forName0(className, <span class="hljs-keyword">true</span>, ClassLoader.getClassLoader(caller), caller);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>一旦完成了实现类的初始化，数据库驱动会自己向<code>DriverManager</code>完成注册。SPI仅仅替代我们写了<code>Class.forName</code>这句话。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>SPI的核心<code>ServiceLoader</code>类，而该类的核心又是内部实现的<code>LazyIterator</code>。在实现SPI时，规定实现库的jar包中必须在<code>META-INF/services/</code>目录下存放以目标SPI命名的文件，其中的内容就是厂商具体实现类的全限定名。</p><p>但是SPI仍然是有缺点的：</p><ul><li>对于某一项服务，会加载所有的实现类，但是其中有一些我们并不需要</li><li>会存在并发问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>类加载</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SPI机制</tag>
      
      <tag>数据库驱动加载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于泛型的常见问题</title>
    <link href="/2021-06-03/Frequently-asked-questions-about-generics.html"/>
    <url>/2021-06-03/Frequently-asked-questions-about-generics.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里罗列一些关于泛型的常见问题,并给出解答。其中本篇大多数问题来自<a href="http://www.angelikalanger.com/GenericsFAQ/FAQSections/ParameterizedTypes.html">Java Generics FAQs - Generic And Parameterized Types</a>,我这里仅翻译一些我认为比较容易糊涂的问题。</p><p>当然,在解答这些问题时,我们需要牢记一个概念,通配符<code>?</code>表示的是不知道是什么类型,而不是任意类型。</p><ul><li>泛型类型:<code>class test&lt;T&gt;&#123;&#125;</code></li><li>具体参数类型:<code>class test&lt;String&gt; t1=null;</code></li><li>泛型参数类型:<code>test&lt;?&gt; t2=null;</code></li></ul><h2 id="1-使用通配符时经常出现的capture-XXX-of-到底什么意思"><a href="#1-使用通配符时经常出现的capture-XXX-of-到底什么意思" class="headerlink" title="1. 使用通配符时经常出现的capture#XXX of ? 到底什么意思?"></a>1. 使用通配符时经常出现的capture#XXX of ? 到底什么意思?</h2><p>在使用通配符时,我们很有可能会遇到类似<code>capture#337 of ?</code>这样莫名奇妙的错误。其中<code>capture</code>是捕获的意思,捕获的是通配符<code>?</code>,那么<code>#337</code>又代表着什么?这一切都要从捕获转化(Capture Conversion)开始说起。</p><p>让我们思考一个问题,如果我们定义定义一个泛型类C如下(类似于List容器)如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> &lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span>&gt;</span>&#123;<br>    ...<br>    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T)</span></span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">C&lt;?&gt; c</span>=<span class="hljs-keyword">new</span> C&lt;Integer&gt;()<br></code></pre></div></td></tr></table></figure><p>那么通过<code>c</code>调用对象方法时,方法的签名是什么样的?像下面这样?(编译时期泛型还是存在的)</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> &lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span>&gt;</span>&#123;<br>    ...<br>    ? get();<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(?)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这显然是毫无意义的,但是我们知道实例化类时一定会使用一个具体的类型X:&lt; Number( <strong>:&lt;</strong> 表示前者继承于后者),尽管我们不知道这个X到底是什么类型的。这并不重要。那么被具体类型X实例化的类C长下面这样:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&lt;<span class="hljs-title">X</span>&gt;</span>&#123;<span class="hljs-comment">//X:&lt;Number</span><br>    ...<br>    <span class="hljs-function">X <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(X)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用一个具有名字的类型比使用通配符<code>?</code>容易多了。所以编译器也是这么做的。只不过编译器并不会使用<code>X</code>,而是随机使用一个数字,例如<code>#337</code>表示上面这个通配符。所以才会有了这句<code>capture#337 of ?</code>。即编译将遇到这个统配符<code>?</code>分配了一个名字叫做<code>#337</code>。</p><p>当一个<code>value</code>的类型是通配符类型,编译器会使用类型变量替换这个<code>value</code>种存在的通配符<code>?</code>(类型变量中的数字按序增长),这种操作名为<code>capture conversion</code>,通过这个操作,编译器只需要处理带有具体类型的对象。</p><p>对于上面的例子,<code>get()</code>方法返回一个<code>X</code>类型的引用,其中<code>X:&lt;Number</code>,那么我们就可以执行下述操作:</p><blockquote><p>Number n= c.get();//c为类C的实例,get方法返回的是Number类型</p></blockquote><p>但是我们却不能向c中添加元素。</p><blockquote><p>c.add(number)//add方法接受的参数为类型为capture#1 of ?</p></blockquote><p>因为add方法接受的参数类型为x(编译器的名字可能为capture#1 of ?),而容器c中的引用至少都为Number类型,因为容器内的元素类型都有一个限制:<code>? extends Number</code>,所以编译器出于安全,将容器内的引用推断为<code>Number</code>类型肯定是不会错的。<br>那么一个存储<code>Number</code>类型的容器,能接受一个类型为<code>capture#1 of ?</code>的值吗?不知道,因为后者的类型编译器无法推断,所以为了保险起见,直接会产生编译错误。</p><p>只要有表达式产生了<code>wild type</code>的<strong>value</strong>(The compiler applies capture conversion on every expression that yields a value in wild type),<code>capture conversion</code>操作就存在。并且会为每个通配符<code>?</code>分配一个唯一ID。以下面代码为例:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;? extends Number&gt; foo(List&lt;? extends Number&gt; numberList)<br>&#123;<br>#<span class="hljs-number">1</span>  <span class="hljs-keyword">for</span>(Number number : numberList)<br>#<span class="hljs-number">2</span>      <span class="hljs-keyword">assert</span> numberList.contains(number);<br>#<span class="hljs-number">3</span>  numberList = numberList;<br>#<span class="hljs-number">4</span>  <span class="hljs-keyword">return</span> numberList;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面代码有四个地方都存在<code>wild type</code>的变量,我们一个一个来分析。</p><p>对于<code>#1</code>处的<code>numberList</code>,其类型为<code>List &lt;? extends Number&gt;</code>,那么会将这处的<code>numberList</code>转换为<code>List&lt;X1&gt;</code>类型,<code>List&lt;X1&gt;</code>是<code>Iterable&lt;X1&gt;</code>的子类,所以可以使用for循环遍历,number的类型是<code>X1</code>,又因为<code>X1:&lt;Number</code>,所以其可以向上转型为<code>Number</code></p><p>对于<code>#2</code>处的<code>numberList</code>,编译器会将其类型转换为<code>List&lt;X2&gt;</code>类型,其中的<code>contains</code>方法是<code>List&lt;X2&gt;</code>类型下的<code>contains</code>方法,所以该方法接受一个<code>X2</code>类型的参数</p><p>对于<code>#3</code>处的右<code>numberList</code>,编译器会将其类型转换为<code>List&lt;X3&gt;</code>,但是！！！对于左边的<code>numberList</code>,因为其是一个variable,而不是一个value,所以编译器不会对其类型进行转换,还是<code>List&lt;? extends Number&gt;</code>,将<code>List&lt;X3&gt;</code>类型赋值给<code>List&lt;? extends Number&gt;</code>类型是合法的,因为<code>X3:&lt;Number</code>。<br><strong>那么是否可以认为左侧的都是variable,而右侧的是value???</strong> 或者是否可以这样理解:右边的变量<code>numberList</code>把它的value赋值给了左侧的<code>numberList</code>,而这个value是<code>wild type</code>？或者说用的时候实际上使用的实际上是variable的value?</p><p>对于<code>#4</code>处的<code>numberList</code>,编译器同样会转换为<code>List&lt;X4&gt;</code>后返回。</p><p>上面的转换规则非常重要,我们再来看一个难一点的例子。现在有一个map,类型为<code>Map&lt;?,?&gt; map</code>,那么如果进行如下操作是合法的:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(Entry&lt;?,?&gt; entry : map.entrySet())<br></code></pre></div></td></tr></table></figure><p>因为<code>map</code>会被转型为<code>Map&lt;X1,X2&gt;</code>类型,那么返回的entrySet就是<code>Set&lt;Entry&lt;X1,X2&gt;&gt;</code>,因为<code>X1&lt;:?</code>,<code>X2&lt;:?</code>,所以将<code>Entry&lt;X1,X2&gt;</code>类型赋值给<code>Entry&lt;?,?&gt;</code>类型是合理的。但是下面的操作就非法了</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Set&lt;Entry&lt;?,?&gt;&gt; entrySet = map.entrySet(); <span class="hljs-comment">// compile error</span><br></code></pre></div></td></tr></table></figure><p>很简单,错误原因是因为泛型不是协变的,<code>Set&lt;Entry&lt;X1,X2&gt;&gt;</code>不是<code>Set&lt;Entry&lt;?,?&gt;&gt;</code>的子类。比较笨拙的办法是在定义一个<code>wild type</code>,如下所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Set&lt;? extends Entry&lt;?,?&gt;&gt; entrySet=map.entrySet();<br></code></pre></div></td></tr></table></figure><p>其实还有一个比较取巧的办法,通过名为<code>capture helper</code>的操作来解决这个问题。</p><h3 id="1-1-Capture-Helper"><a href="#1-1-Capture-Helper" class="headerlink" title="1.1 Capture Helper"></a>1.1 Capture Helper</h3><p>因为编译器对于<code>wild type</code>的取名都是任意的,并且对我们是不可见的,所以我们在源码中无法引用,以下面的代码为例:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(List&lt;? extends Number&gt; numberList)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// numberList.add( numberList.get(0) ); // compile error,因为左numberList接受的是X2类型,而又numberList接受的是X1类型</span><br><br>    <span class="hljs-comment">//假设下面的代码存在,我们将传进来的numberList转型为List&lt;X&gt;类型,那么该方法所有使用numberList的地方,其类型是List&lt;X&gt;</span><br>    <span class="hljs-comment">//而不是见一个numberList换一个类型</span><br>    List&lt;X&gt; list = numberList;  <span class="hljs-comment">// *imaginary* code</span><br><br>    X number = list.get(<span class="hljs-number">0</span>);     <span class="hljs-comment">// get() returns X</span><br>    list.add(number);           <span class="hljs-comment">// add() accepts X</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>既然人为定义<code>wild type</code>的类型,可行,那么我把类型<code>X</code>定义出来不久好了?如下面代码所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">&lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar2</span><span class="hljs-params">(List&lt;T&gt; list)</span></span><br><span class="hljs-function"></span>&#123;<br>    T number = list.get(<span class="hljs-number">0</span>);<br>    list.add(number);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后我们就可以调用<code>bar(numberList)</code>解决上面每个<code>numberList</code>类型不一样的问题。方法<code>bar2</code>就叫做<code>capture helper</code>。</p><p>那么<code>capture helper</code>的出现有什么意义呢?<br>答案是为了兼容老代码,因为1.5之前的代码没有泛型,如果使用泛型的代码想要接受没有泛型的容器,就得实现<code>capture helper</code>(当然不局限于容器,这里容器比较典型)</p><p><strong>参考文献:</strong></p><ol><li><p><a href="http://bayou.io/draft/Capturing_Wildcards.html#Capture_Everywhere">Capturing Wildcards</a></p></li><li><p><a href="http://bayou.io/draft/Wildcard_Case_Studies.html#Map&lt;?,?&gt;_Entry_Set">Wildcard Case Studies</a></p></li></ol><h2 id="2-lt-extends-E-gt-与-lt-T-extends-E-gt-有什么区别"><a href="#2-lt-extends-E-gt-与-lt-T-extends-E-gt-有什么区别" class="headerlink" title="2. &lt;? extends E&gt;与&lt;T extends E&gt;有什么区别?"></a>2. &lt;? extends E&gt;与&lt;T extends E&gt;有什么区别?</h2><p>这是容易搞混的一点,首先<code>T</code>叫做类型变量(type variable),<code>?</code>叫做通配符(wildcard)。</p><ol><li><p>类型变量不能使用<code>super</code>,即类型变量不能有上界,例如<code>T super E</code>,这样是非法的。至于为什么非法可以看下一个问题。但是通配符<code>?</code>却可以有上界或者下界。</p></li><li><p>类型变量可以有多个限制,例如<code>T extends A &amp; B</code>,但是通配符<strong>至多</strong>有一个界限。</p></li><li><p>通配符不能表示一个类型变量,所以通配符不能用来定义<code>generic type</code> ,类型变量可以用来定义<code>generic type</code></p></li></ol><p><strong>参考文献:</strong></p><ol><li><a href="https://stackoverflow.com/questions/18384897/what-is-difference-between-extends-object-and-e-extends-object">What is difference between &lt;? extends Object&gt; and <E extends Object>?</a></li></ol><h2 id="3-lt-T-super-E-gt-为什么是非法的"><a href="#3-lt-T-super-E-gt-为什么是非法的" class="headerlink" title="3. &lt;T super E&gt;为什么是非法的?"></a>3. &lt;T super E&gt;为什么是非法的?</h2><p>因为Object所有引用类型的父类。<T super E>并不会按照我们的想法工作。例如我们定义了一个容器<code>ArrayList&lt;Integer&gt; list</code>,思考下面的代码是否意义:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//add方法是list的对象方法</span><br><span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">super</span> Integer&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T)</span></span>&#123;<br>    list.add(T);<br>&#125;<br><br>ArrayList&lt;Integer&gt; list=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<span class="hljs-comment">//正常,没有任何问题</span><br>lsit.add(<span class="hljs-string">&quot;aaa&quot;</span>);<span class="hljs-comment">//我们的本意是这句不该通过编译,但是却通过了</span><br></code></pre></div></td></tr></table></figure><p><code>add</code>方法的本意是接受类型是<code>Integer</code>的参数,可以是<code>Object</code>、<code>Number</code>、<code>Integer</code>,不应该接受<code>String</code>类型。</p><p>但是<code>Object</code>也是<code>String</code>的父类。很有可能给<code>add</code>传入的参数静态类型是<code>Object</code>,动态类型是<code>String</code>。虽然放进去是没有问题,但是如果把这个<code>String</code>类型的元素取出来,会出现<code>castException</code>,因为<code>String</code>根本不可能转换为<code>Integer</code>。</p><p><strong>参考文献:</strong></p><ol><li><a href="https://stackoverflow.com/questions/2800369/bounding-generics-with-super-keyword">Bounding generics with ‘super’ keyword</a></li></ol><h2 id="4-为什么定义类型参数时不能使用通配符’-’"><a href="#4-为什么定义类型参数时不能使用通配符’-’" class="headerlink" title="4. 为什么定义类型参数时不能使用通配符’?’?"></a>4. 为什么定义类型参数时不能使用通配符’?’?</h2><p>因为通配符<code>?</code>只是用来定义<code>wild type</code>的一个语法成分,它没有任何语义,<strong>它不能表示任何类型</strong>。想象一下,如果下面的代码是合法的:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>&lt;?&gt;</span>&#123;<br>    ? get(<span class="hljs-keyword">int</span> index)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(? elem)</span></span>&#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在前面曾经说过,由于<code>capture conversion</code>的原因,编译器会把每一个类型是<code>wild type</code>的value中的通配符<code>?</code>赋一个名字,例如像下面这样:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">X1</span>&gt;</span>&#123;<br>    <span class="hljs-function">X2 <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> inedx)</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(X3 elem)</span></span>&#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么我们在实例化List的时候,像<code>List&lt;String&gt;</code>这样?那么<code>get</code>的返回值类型又是什么?这样就违背了我们使用<code>?</code>定义泛型类的初衷。我们的本意是<code>List</code>接受一个不知道是什么类型的类型参数(unkown type),并且想要<code>get</code>的返回值类型也是同一个<code>unknown type</code>。但是这很显然不可能。</p><p><strong>所以通配符<code>?</code>就不能用来定义一个类型变量(type variable),它只能用在类型声明的地方</strong>,例如声明方法的形参类型,声明一个变量。因为 <strong>?不是一个有效的变量名,不是一个有效的标识符</strong>:</p><blockquote><p>You can’t name a generic parameter as ?, because ? is not a valid identifier - a valid name of a variable.<br>You have to give a generic parameter a valid java name so you can refer to it in the implementation.</p></blockquote><p>下面是通配符常用的地方:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;?&gt; list;<span class="hljs-comment">//ok,声明变量类型</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(List&lt;? extends Number&gt; list)</span></span>;<span class="hljs-comment">//ok,声明参数类型</span><br></code></pre></div></td></tr></table></figure><p>那么所谓的定义一个泛型类型是什么?就像下面这样:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">    List MyList&lt;T&gt;&#123;<span class="hljs-comment">//定义了一个泛型类型MyList&lt;T&gt;,T是类型变量</span><br><br>    <span class="hljs-keyword">public</span> &lt;V&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(V num,T test)</span></span>&#123;&#125;<span class="hljs-comment">//定义了一个类型变量V</span><br>    <span class="hljs-keyword">public</span> &lt;?&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//compile error</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>并且统配符<code>?</code>只能用来填充类型变量。所谓的填充是什么意思,比如我们定义了一个方法接受<code>MyList&lt;T&gt;</code>泛型的方法,那么我们就可以用<code>?</code>填充这个T。那么填充在哪?</p><ul><li>声明方法的参数</li><li>声明变量</li></ul><p>如下所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//定义方法时声明参数,使用?填充T</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(MyList&lt;?&gt; myList)</span></span>&#123;&#125;<br><span class="hljs-comment">//或者加个界限</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(MyList&lt;? extends Number&gt; myList)</span></span>&#123;&#125;<br><span class="hljs-comment">//定义了一个MyList&lt;T&gt;的变量,使用?填充T</span><br>MyList&lt;?&gt; myList;<span class="hljs-comment">//</span><br></code></pre></div></td></tr></table></figure><p><strong>参考文献:</strong></p><ol><li><a href="https://stackoverflow.com/questions/24740590/java-generic-wildcard?rq=1">java Generic wildcard “?”</a></li><li><a href="https://blog.csdn.net/harvic880925/article/details/49883589">夯实JAVA基本之一——泛型详解(2)：高级进阶</a></li></ol><h2 id="5-有没有不能使用泛型的地方"><a href="#5-有没有不能使用泛型的地方" class="headerlink" title="5. 有没有不能使用泛型的地方?"></a>5. 有没有不能使用泛型的地方?</h2><p>几乎所有类型都可以拥有类型参数,但除了一下几种类型:</p><ul><li>枚举类型:因为枚举类型不能有类型参数,所以枚举类中的值都是静态类型的,但是又因为<strong>类型参数不能用于任何静态的上下文环境</strong>,所以在枚举类中使用泛型是没有任何意义的</li><li>匿名内部类:它可以继承一个参数化类型的类或者接口,但它本身不能是，因为<strong>匿名内部泛型类没有任何意义</strong>。因为匿名内部类没有名字,所以在声明时就没有地方提供类型参数</li><li>异常类:一个泛型类不能间接或者直接继承自<code>Throwable</code>接口,因为异常处理机制是一种运行时机制,但是在运行时泛型已经被擦出了。所以对于同一个泛型类型但是类型参数不同的两个参数化类型来说,虚拟机并不能区分它们,所以异常泛型类也是无意义的。</li></ul><h2 id="6-能不能强转成参数化类型"><a href="#6-能不能强转成参数化类型" class="headerlink" title="6.能不能强转成参数化类型?"></a>6.能不能强转成参数化类型?</h2><p>可以,但是这种操作是类型不安全的,且会产生”unchecked”的编译警告。</p><p>因为一个变量的类型分为静态类型与动态类型。一个类型转换操作也分为两个部分:</p><ul><li>编译时期的静态类型检查</li><li>运行十七的动态类型检查</li></ul><p>静态时期的类型检查去除了一些显而易见的错误,例如讲<code>String</code>转换成<code>Date</code>。而动态类型检查使用了动态类型进行检查。如果动态类型不是目标类型或者不是目标类型的子类(也就是所谓的向下转型),那么就会产生<code>ClassCastException</code>。</p><p>但是并不是所有类型转换都会动态类型检查。基本类型之间的转换仅会进行静态类型检查。并且向上转型也只会进行静态类型检查,向上转型不写也没关系,因为编译器会帮你做这件事。</p><p><strong>需要动态检查</strong>的类型转换潜在是类型不安全的,尤其是当目标类型为一个参数化类型。在运行时参数化类型的类型信息不在存在,虚拟机不能区分两个是同一个泛型,但是采用不同的类型参数实例化出的参数化类型,所以在这种情况下,本不该通过动态检查的类型转换却通过了,这不是我们希望看到的。例如下面的代码,将<code>Object</code>转换为<code>List&lt;String&gt;</code>,但是却没有抛出<code>ClassCastException</code>.</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br>  List&lt;Date&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Date&gt;();<br>  ...<br>  m2(list);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">(Object arg)</span> </span>&#123;<br>  ...<br>  List&lt;String&gt; list = (List&lt;String&gt;) arg;    <span class="hljs-comment">// unchecked warning</span><br>  ...<br>  m3(list);<br>  ...<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">(List&lt;String&gt; list)</span> </span>&#123;<br>  ...<br>  String s = list.get(<span class="hljs-number">0</span>);      <span class="hljs-comment">// ClassCastException</span><br>  ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意上面抛出异常的位置,不是在我们进行类型转换的位置,而是在我们提取元素的时候。这种没有在正确地方抛出的异常是我们非常不愿意看到的。所以为了引起我们对这种潜在的类型不安全的转换注意,编译器产生了”unchecked”警告在遇到可疑的转换时。</p><p>所以,<strong>编译器在每一处目标类型是参数化类型并且是向下转型的地方,都会产生一个unchecked警告</strong>。</p><h2 id="7-泛型中哪里会出现的”unchecked”警告"><a href="#7-泛型中哪里会出现的”unchecked”警告" class="headerlink" title="7.泛型中哪里会出现的”unchecked”警告?"></a>7.泛型中哪里会出现的”unchecked”警告?</h2><ol><li><p>首先就是上面一个问题所说的:向下转型为参数化类型的地方。</p></li><li><p>如果方法的参数类型没有因为类型擦除而改变,那么调用这个方法就是类型安全的</p></li><li><p>如果字段的类型因为类型擦除而改变,那么对该字段赋值就会产生”unchecked”,但是读取该字段的值却不会产生任何问题</p></li></ol><h2 id="8-unbound-wildcard-parameterized-type和raw-type有什么区别"><a href="#8-unbound-wildcard-parameterized-type和raw-type有什么区别" class="headerlink" title="8. unbound wildcard parameterized type和raw type有什么区别?"></a>8. unbound wildcard parameterized type和raw type有什么区别?</h2><p>其实这二者没有太大区别,二者都可以被视作是任何参数化类型的超级类,并且二者都是<code>reifiable types</code>。所以这两种类型可以作为数组的元素类型(注意是unbound wildcard而不是wildcard)。但是编译器对<code>unbound wildcard parameterized type</code>更严格。对于同样的操作,如果<code>raw type</code>产生了<code>unchecked</code>警告,那么<code>unbound wildcard parameterized type</code>则会产生编译错误。</p><h2 id="9-泛型真的不能使用instance-of吗"><a href="#9-泛型真的不能使用instance-of吗" class="headerlink" title="9. 泛型真的不能使用instance of吗?"></a>9. 泛型真的不能使用instance of吗?</h2><p>大部分都不行,只有无界通配符可以,因为只有<code>reifiable type</code>能够使用<code>instance of</code>,<code>reifiable types</code>包括且只包括:</p><ul><li><p>It refers to a non-generic class or interface type declaration.</p></li><li><p>It is a parameterized type in which all type arguments are <strong>unbounded</strong> wildcards (§4.5.1).</p></li><li><p>It is a raw type (§4.8).</p></li><li><p>It is a primitive type (§4.2).</p></li><li><p>It is an array type (§10.1) whose element type is reifiable.</p></li><li><p>It is a nested type where, for each type T separated by a “.”, T itself is reifiable.</p></li></ul><h2 id="10-能创建数组元素是具体参数化类型的数组吗"><a href="#10-能创建数组元素是具体参数化类型的数组吗" class="headerlink" title="10. 能创建数组元素是具体参数化类型的数组吗?"></a>10. 能创建数组元素是具体参数化类型的数组吗?</h2><p>所谓的具体参数化类型就是类型参数是一个具体的参数,例如<code>String</code>、<code>Integer</code>等等。对于这个问题的答案是不能,因为是类型不安全的。</p><p>因为插入操作会逃过数组的动态类型检查,见如下代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>  Pair&lt;Integer,Integer&gt;[] intPairArr = <span class="hljs-keyword">new</span> Pair&lt;Integer,Integer&gt;[<span class="hljs-number">10</span>] ; <span class="hljs-comment">// error</span><br>  addElements(intPairArr); <br>  Pair&lt;Integer,Integer&gt; pair = intPairArr[<span class="hljs-number">1</span>];<br>  Integer i = pair.getFirst();<br>  pair.setSecond(i);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addElements</span><span class="hljs-params">( Object[] objArr)</span> </span>&#123;<br>  objArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair&lt;Integer,Integer&gt;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>  objArr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Pair&lt;String,String&gt;(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);      <span class="hljs-comment">// should fail with ArrayStoreException,但是因为在运行时泛型已经不存在了</span><br>                                                  <span class="hljs-comment">//  逃过了数组插入时的类型动态检查</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="11-能创建数组元素类型是通配符参数化类型的数组吗"><a href="#11-能创建数组元素类型是通配符参数化类型的数组吗" class="headerlink" title="11. 能创建数组元素类型是通配符参数化类型的数组吗?"></a>11. 能创建数组元素类型是通配符参数化类型的数组吗?</h2><p>无界通配符可以,有界通配符不行。因为有界通配符的插入操作也可以逃过数组插入时的动态类型检查,而无界通配符不会。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//非法操作</span><br>Object[] numPairArr = <span class="hljs-keyword">new</span> Pair&lt;? extends Number,? extends Number&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">// illegal</span><br>numPairArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair&lt;Long,Long&gt;(<span class="hljs-number">0L</span>,<span class="hljs-number">0L</span>);     <span class="hljs-comment">// fine</span><br><span class="hljs-comment">//注意,下面这句逃过了数组的动态类型检查</span><br>numPairArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair&lt;String,String&gt;(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// should fail, but would succeed</span><br><br><span class="hljs-comment">//合法操作</span><br>Object[] pairArr = <span class="hljs-keyword">new</span> Pair&lt;?,?&gt;[<span class="hljs-number">10</span>] ;        <span class="hljs-comment">// fine</span><br>pairArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair &lt;Long,Long&gt;(<span class="hljs-number">0L</span>,<span class="hljs-number">0L</span>);     <span class="hljs-comment">// fine</span><br>pairArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair &lt;String,String&gt;(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// fine </span><br>pairArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> ArrayList &lt;String&gt;();        <span class="hljs-comment">// fails with ArrayStoreException</span><br></code></pre></div></td></tr></table></figure><h2 id="12-能创建数组元素是有界通配符参数化类型的数组引用吗"><a href="#12-能创建数组元素是有界通配符参数化类型的数组引用吗" class="headerlink" title="12. 能创建数组元素是有界通配符参数化类型的数组引用吗?"></a>12. 能创建数组元素是有界通配符参数化类型的数组引用吗?</h2><p>可以,但没必要。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//创建了数组元素类型是有界通配符类型的数组</span><br><br>Pair&lt;? extends Number,? extends Number&gt;[] arr = <span class="hljs-keyword">null</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">Double</span>,<span class="hljs-title">Double</span>&gt; </span>&#123; ... &#125;<br>Pair&lt;? extends Number,? extends Number&gt;[] arr = <span class="hljs-keyword">new</span> Point[<span class="hljs-number">2</span>];<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Point(-<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>);  <span class="hljs-comment">// fine</span><br><span class="hljs-comment">//虽然能通过静态类型检查,但是无法通过数组的动态类型检查</span><br>arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Pair&lt;Number,Number&gt;(-<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>); <span class="hljs-comment">// fine (causes ArrayStoreException)</span><br>arr[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Pair&lt;Integer,Integer&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// fine (causes ArrayStoreException)</span><br></code></pre></div></td></tr></table></figure><h2 id="13-通配符参数化类型不能干嘛"><a href="#13-通配符参数化类型不能干嘛" class="headerlink" title="13.通配符参数化类型不能干嘛?"></a>13.通配符参数化类型不能干嘛?</h2><p>不能做父类。见如下代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span> &lt;?&gt; </span>&#123; <span class="hljs-comment">// error</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">( ??? arg)</span> </span>&#123; ... &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>编译器无法知道<code>comapreTo</code>方法到底接受的是什么类型的参数,很奇怪。而且,如前面所说,因为有<code>capture conversion</code>操作,这样的定义是没有任何意义的。</p><h2 id="15-具体化参数类型不能做什么"><a href="#15-具体化参数类型不能做什么" class="headerlink" title="15. 具体化参数类型不能做什么?"></a>15. 具体化参数类型不能做什么?</h2><p>具体化参数类型(concrete parameterized type)就是使用具体类型实例化泛型类型的类型。那么它不能做:</p><ol><li>使用<code>instance of</code></li><li>不能创建数组</li><li>不能用于异常处理(泛型都不行)</li></ol><h2 id="14-泛型不能做什么"><a href="#14-泛型不能做什么" class="headerlink" title="14. 泛型不能做什么?"></a>14. 泛型不能做什么?</h2><ol><li>不能在静态字段中使用类型参数(type paramemter):<strong>因为type parameter不适用于静态上下文环境</strong>,所以泛型不能适用于静态泛型字段,例如<code>static T member</code>、<code>static List&lt;T&gt; list</code></li><li>不用如此使用：<code>obj instanceof T</code>，因为类型擦除的原因</li></ol><p><strong>参考文献:</strong></p><p>若非特殊标注,问题引自<a href="http://www.angelikalanger.com/GenericsFAQ/FAQSections/ParameterizedTypes.html#FAQ001">Java Generics FAQs - Generic And Parameterized Types</a></p>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java的泛型</title>
    <link href="/2021-06-03/the-generic-of-java.html"/>
    <url>/2021-06-03/the-generic-of-java.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>这篇文章是在研究java的Type体系顺带扯出的概念,泛型的使用要说简单也很简单,要说难也可以说难。本文将由浅入深,带你学习java中的”泛型”。</p></blockquote><h2 id="1-泛型的基本概念"><a href="#1-泛型的基本概念" class="headerlink" title="1. 泛型的基本概念"></a>1. 泛型的基本概念</h2><p>泛型的概念始于java1.5,所以在1.5之前所有使用java的地方都没有泛型的影子,那么为了保持向后兼容,java中的泛型被设计成了伪泛型,仅仅存在于编译时期,在实际生成的字节码文件中是没有泛型的,这一动作叫做泛型的<strong>擦除</strong>。</p><p>泛型的基本格式为:<code>class Perosn&lt;T&gt;</code>,其中定义在<code>&lt;&gt;</code>的变量称为<code>type variable</code>,这一概念是随着泛型而出生的,并且也跟java的Type子系统息息相关。在jse8文档中,声明<code>type variable</code>允许用在四个地方,但是并不限制<code>type variable</code>的使用个数。允许的四个地方分别是:</p><ul><li>泛型类</li><li>泛型接口</li><li>泛型方法</li><li>泛型构造函数</li></ul><p>其中泛型构造函数的使用可以归档在泛型方法一类中。</p><p>注意:</p><blockquote><p>使用泛型构造方法并不要求类是泛型类</p></blockquote><p>更新(2020-08-14 20:18:36):</p><p>还有一些概念,了解后可以更好的帮助我们了解泛型:</p><ul><li>泛型类型(generic type):是一个带着类型参数的类型,即类似于<code>class Person&lt;T&gt;</code></li><li>参数化类型(parameterized type):即使用具体的类型实参去实例化泛型类型的类型,例如使用类型<code>String</code>去实例化泛型类型<code>class Person&lt;T&gt;</code>,所得的参数类型为<code>class Person&lt;String&gt;</code></li></ul><h3 id="1-1-泛型使用的简单示例"><a href="#1-1-泛型使用的简单示例" class="headerlink" title="1.1 泛型使用的简单示例"></a>1.1 泛型使用的简单示例</h3><p><strong>泛型类与泛型接口:</strong></p><p>泛型类和泛型接口的声明比较简单,仅需要在类名或者接口名后面使用<code>&lt;&gt;</code>声明<code>type variable</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//泛型类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T name;<br>    <span class="hljs-keyword">private</span> E age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T name,E id)</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.getClass().getSimpleName());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(T name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(E age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//泛型接口</span><br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">People</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>泛型方法:</strong></p><p>泛型方法又分为普通的泛型方法、静态泛型方法、泛型构造方法。泛型方法的声明麻烦一点,泛型方法需要在权限修饰后面定义所要使用的<code>type variable</code>。</p><p>下面是一组使用泛型方法和泛型类的代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> generic;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> T name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(T name,<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>        <span class="hljs-keyword">this</span>.age=age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(T name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">V</span>&gt;</span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span>&lt;T&gt; V <span class="hljs-title">getInfo</span><span class="hljs-params">(People&lt;T&gt; p1, People&lt;T&gt; p2, V sum)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;p1:&quot;</span>+p1.getName()+<span class="hljs-string">&quot; &quot;</span>+p1.getAge());<br>        System.out.println(<span class="hljs-string">&quot;p2:&quot;</span>+p2.getName()+<span class="hljs-string">&quot; &quot;</span>+p2.getAge());<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        People&lt;String&gt; p1=<span class="hljs-keyword">new</span> People&lt;&gt;(<span class="hljs-string">&quot;Bob&quot;</span>,<span class="hljs-number">23</span>);<br>        People&lt;String&gt; p2=<span class="hljs-keyword">new</span> People&lt;&gt;(<span class="hljs-string">&quot;Lee&quot;</span>,<span class="hljs-number">20</span>);<br>        Test&lt;Integer&gt; t=<span class="hljs-keyword">new</span> Test&lt;&gt;();<br>        Object result= t.&lt;String&gt;getInfo(p1,p2,<span class="hljs-number">23</span>);<br>        <span class="hljs-comment">//Object result=t.getInfo(p1,p2,23);</span><br><br>        System.out.println(<span class="hljs-string">&quot;result is an instance of Integer:&quot;</span>+result <span class="hljs-keyword">instanceof</span> Integer);<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">p1:Bob <span class="hljs-number">23</span><br>p2:Lee <span class="hljs-number">20</span><br>result is an instance of Integer:<span class="hljs-keyword">true</span><br></code></pre></div></td></tr></table></figure><p>其中泛型方法签名为:<code>public&lt;T&gt; V getInfo(People&lt;T&gt; p1, People&lt;T&gt; p2, V sum)</code>,<code>T</code>是这个泛型方法<code>getInfo</code>指定的类型变量,而<code>V</code>则是泛型类指定的类型变量。在调用泛型方法时,可以在<code>.</code>和方法名之间明确指定泛型方法的具体类型,或者让编译器自己推断。</p><p>其实上面这个泛型方法有个明显的缺点,就是返回值的类型也是一个泛型,这就要求调用者必须判断返回值的具体类型,因为接口。那么可能有人会问了,那<code>ArrayList</code>的源码中也有很多返回泛型的例子,他们写的也差劲?例如:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    rangeCheck(index);<br>    <span class="hljs-keyword">return</span> elementData(index);<br>&#125;<br><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-function">E <span class="hljs-title">elementData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (E) elementData[index];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样写是因为库编写者已经确定容器中存储的元素的类型就是<code>E</code>,强制转换成<code>E</code>并不会出错,并且调用者也知道返回的类型到底是什么。而且因为方法的返回值是泛型<code>E</code>,编译器会在调用者部分的字节码中自动插入一段强制转换代码将元素类型转为为<code>E</code>。这是由于类型擦除导致的,这会在<strong>后文</strong>详细解释。</p><p>静态泛型方法与常规的泛型方法唯一区别就是<strong>静态泛型方法中不能使用泛型类的类型变量</strong>,例如在<code>people</code>中声明一个方法:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;M&gt; calc(M year,M mouth)&#123;...&#125;<br></code></pre></div></td></tr></table></figure><p><code>calc</code>中不能使用泛型类<code>People</code>中的类型变量<code>T</code>。</p><p><strong>泛型构造方法:</strong></p><p>最后泛型构造方法又可以分为两种:类本身就是泛型类,类不是泛型类。下面是一个简单的例子:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//所在类不是泛型类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span></span>&#123;<br>    <span class="hljs-keyword">public</span> &lt;T &amp; Comparable&lt;T&gt;&gt; People(T age)&#123;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//所在类是泛型类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中<code>&lt;T &amp; Comparable&lt;T&gt;&gt;</code>的含义是要求<code>T</code>已经实现了Comparable接口。这部分细节可以查看jse8关于<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.4">type variable</a>的详细规范。</p><h2 id="2-泛型通配符"><a href="#2-泛型通配符" class="headerlink" title="2. 泛型通配符"></a>2. 泛型通配符</h2><p>在了解泛型通配符之前,我们需要知道一些基本术语:协变、逆变、不变,这一部分引自<a href="https://zhuanlan.zhihu.com/p/31137677">仔细说说Java中的泛型</a>。</p><p>逆变与协变用来描述类型转换（type transformation）后的继承关系，其定义：如果A、B表示类型，f(X)表示类型转换，≤表示继承关系(比如,A≤B表示A继承于b),那么这里有三个关系</p><blockquote><ol><li>当A≤B时有f(B)≤f(A)成立，那么说f(X)是逆变（contravariant）的</li><li>当A≤B时有f(A)≤f(B)成立，那么说f(X)是协变(covariant)的</li><li>当上两者都不成立的时候，那么说f(X)是不变（invariant)的</li></ol></blockquote><p>在java中,<strong>数组是支持协变的</strong>,例如下面这句代码可以通过编译,但会产生运行时错误:</p><blockquote><p>Number[] test=new Integer[];</p></blockquote><p><code>Integer</code>是<code>Number</code>的子类,同时变成数组,<code>Integer[]</code>还是<code>Number[]</code>的子类。</p><hr><p><strong>Extension One:在java中数组为什么要设计成协变的?</strong></p><p>答案来源于:<a href="https://www.zhihu.com/question/21394322">java中，数组为什么要设计为协变？</a>,我在这里补充一些我的理解。</p><p>在java1.5之前,java是不支持泛型的,因为没时间做。但是又需要泛型的特性,所以就把数组设计成协变的了。例如在比较数组时调用的是<code>Arrays.equals</code>方法,其底层调用的是<code>Object.equals</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object[] a, Object[] a2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a==a2)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> (a==<span class="hljs-keyword">null</span> || a2==<span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">int</span> length = a.length;<br>    <span class="hljs-keyword">if</span> (a2.length != length)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;length; i++) &#123;<br>        Object o1 = a[i];<br>        Object o2 = a2[i];<br>        <span class="hljs-keyword">if</span> (!(o1==<span class="hljs-keyword">null</span> ? o2==<span class="hljs-keyword">null</span> : o1.equals(o2)))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>如果</strong>数组是不支持协变的,那么比较<code>B</code>时得重写<code>equals</code>的代码,比较<code>A</code>时又得重写一份<code>equals</code>的代码,因为<code>A[]</code>不能赋值给<code>Object[]</code>,代码重写非常严重,违背了代码复用的宗旨。所以将数组设计成协变的,使得<code>A[]</code>能够赋值为<code>Object[]</code>,从而调用对象的<code>equals()</code>方法时,由于多态的原因,实际上调用的<code>A</code>的<code>equals</code>方法。实现了代码复用。</p><p>那么数组设计成协变会产生大问题吗?答案是不会,因为数组记得它到底保持的是什么类型,这会在<strong>编译时</strong>严格检查数据类型。而泛型协变有问题也只会在运行时出现，延后了问题出现的时间。违背了java是严格类型确定的编程语言。</p><p>但是<strong>并不支持</strong>泛型数组,因为数组能记得它存储的元素类型的前提是在创建时就严格确定了其存储的元素类型(之所以能记住这是靠虚拟机实现的,Array由虚拟机来实现)。</p><p><strong>Extension Two:java中为什么不支持泛型数组?</strong></p><p>参考自<a href="https://www.zhihu.com/question/20928981/answer/117521433">java为什么不支持泛型数组？</a></p><p>java明确规定了数组的元素类型必须是可靠的.</p><blockquote><p>It is a compile-time error if the component type of the array being initialized is not reifiable</p></blockquote><p>其中<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.7">Reifiable Types</a>包括且只包括:</p><ul><li><p>It refers to a non-generic class or interface type declaration.</p></li><li><p>It is a parameterized type in which all type arguments are <strong>unbounded</strong> wildcards (§4.5.1).</p></li><li><p>It is a raw type (§4.8).</p></li><li><p>It is a primitive type (§4.2).</p></li><li><p>It is an array type (§10.1) whose element type is reifiable.</p></li><li><p>It is a nested type where, for each type T separated by a “.”, T itself is reifiable.</p></li></ul><p>下面是每个<code>Reifiable Type</code>的示例:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">E</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&lt;<span class="hljs-title">X</span>&gt;</span>&#123;&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;&#125;<br><br><span class="hljs-comment">//It refers to a non-generic class or interface type declaration.</span><br><span class="hljs-comment">//是一个分泛型的类或接口的引用</span><br>A ref;<br>E ref;<br><span class="hljs-comment">//It is a parameterized type in which all type arguments are **unbounded** wildcards</span><br><span class="hljs-comment">//是一个参数化类型,但是所有的类型参数都是无界通配符</span><br>B&lt;?&gt; ref;<br><span class="hljs-comment">//raw type</span><br>List ref;<br><span class="hljs-comment">//primitive type</span><br><span class="hljs-keyword">int</span> ref;<br><span class="hljs-comment">//array type,并且元素类型都要求是可靠的</span><br><span class="hljs-keyword">int</span>[] ref;<br><span class="hljs-comment">//嵌套类型,要求类型参数参数都是可靠的</span><br>B&lt;?&gt;.C&lt;?&gt; ref;<br>B&lt;A&gt;.C&lt;A&gt; ref;<br><br></code></pre></div></td></tr></table></figure><p>所以想要数组支持泛型的唯一办法就是:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//本意</span><br>ArrayList&lt;String&gt; ref=<span class="hljs-keyword">new</span> ArrayList&lt;String&gt;[];<span class="hljs-comment">//complie-error</span><br><span class="hljs-comment">//正确写法</span><br>ArrayList&lt;String&gt; ref=(ArrayList&lt;String&gt;[])<span class="hljs-keyword">new</span> ArrayList[];<span class="hljs-comment">//cast</span><br></code></pre></div></td></tr></table></figure><p>注:</p><blockquote><p>上述所有言论基于java1.8,似乎在java10中已经开始支持泛型数组,但并未考证</p></blockquote><hr><p>回到正题,java中的泛型是不变的。如果泛型是协变的,思考如下代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ArrayList&lt;Number&gt; ref=<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><br>ref.add(<span class="hljs-number">2.3f</span>);<span class="hljs-comment">//cast</span><br></code></pre></div></td></tr></table></figure><p>在我们眼里,<code>ref</code>是一个存储<code>Number</code>的容器,那么就可以往里面存储<code>Double</code>、<code>Float</code>、<code>Integer</code>。取元素的时候到底转换成什么类型?程序不知道,程序员也不知道。并且很可能会产生运行时错误。既然这么,干脆就在编译期将这类错误禁止就完事了,但是仍然可以通过一些操作实现协变的逻辑。</p><p>对于泛型不支持逆变,是因为父类的引用赋值给子类就非常危险,所以当然不支持,而且也不可能实现。</p><h3 id="使用协变"><a href="#使用协变" class="headerlink" title="使用协变"></a>使用协变</h3><p>有些时候我们确实需要使用协变这一功能。比如我们有一组类<code>Dog``Cat``Pig</code>,需要对这些类实现一个通用的喂食功能,见如下代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> generic;<br><br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>&#123;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">super</span>.getName()+<span class="hljs-string">&quot; eat shit.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cat</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">super</span>.getName()+<span class="hljs-string">&quot; eat air.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CovariantTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">feed</span><span class="hljs-params">(List&lt;Animal&gt; animalList)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(animalList==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(Animal elem:animalList)&#123;<br>            elem.eat();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;Dog&gt; dogs=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        dogs.add(<span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;peter&quot;</span>));<br>        dogs.add(<span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;tom&quot;</span>));<br><br>        ArrayList&lt;Cat&gt; cats=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        cats.add(<span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;lili&quot;</span>));<br>        cats.add(<span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;candy&quot;</span>));<br>        feed(dogs);<span class="hljs-comment">//complie-error</span><br>        feed(cats);<span class="hljs-comment">//complie-error</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面调用<code>feed</code>的代码是无法通过编译的,因为<code>feed</code>接受的是<code>List&lt;Animal&gt;</code>,而提供的是<code>ArrayList&lt;Dog&gt;</code>,这是因为泛型不支持协变。那么这个需求是确确实实存在的,怎么办?</p><p>这时候通配符<code>?</code>该上场了,泛型的作用是限制泛型的类型,提供类似协变的功能。</p><blockquote><p>通配符?表示我们不知道是什么类型,而不是任意类型!!!</p></blockquote><p>注意这里插一句,带有通配符的类型变量(type variable)叫做<code>wild type</code>(不知道是否官方,但是我看到别人这么叫了,而且这种叫法也不错,我就采用了)。但是通配符<code>?</code>是<strong>没有任何语义</strong>的,它不能代表任何一种类型,仅仅为了定义<code>wild type</code>的一个语法组成部分。所以定义类似<code>ArrayList&lt;?&gt;()</code>的对象就是错的,因为没有任何意义。</p><p>通配符是可以加边界来限制类型变量的类型的,通配符<code>?</code>边界分为以下三种:</p><ul><li>有上界的通配符:例如<code>? super Animal</code>,意思是这个泛型只能是<code>Animal</code>或者<code>Animal</code>的父类</li><li>有下界的通配符:例如<code>? extends Animal</code>,意思是这个泛型只能是<code>Animal</code>或者<code>Animal</code>的子类</li><li>无界的通配符:<code>?</code>,泛型是可以任意类型</li></ul><p>那么为了实现上面的需求,应将<code>feed</code>的签名改正为<code>public static void feed(List&lt;? extends Animal&gt; animalList)</code>,现在编译运行:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">peter eat shit.<br>tom eat shit.<br>lili eat air.<br>candy eat air.<br></code></pre></div></td></tr></table></figure><p>成功实现了我们的需求。</p><h3 id="存下取上原则"><a href="#存下取上原则" class="headerlink" title="存下取上原则"></a>存下取上原则</h3><p>该原则取自<a href="https://www.cnblogs.com/Xieyang-blog/p/9215934.html">Java中泛型区别以及泛型擦除详解</a>。</p><p><strong>A. 上界通配符:</strong><br>但是在使用了泛型通配符的地方,想要对容器增删元素就没有那么简单了。就拿上面的<code>List&lt;? extends Animal&gt; animals</code>做例子。传进来的参数有可能是<code>List&lt;Dog&gt;</code>,也有可能是<code>List&lt;Cat&gt;</code>,假设我们能够向<code>animals</code>中存储新元素,那么当我们取出我们存入的新元素时,它到底是什么类型的?编译器不知道。但是我们读取容器中的内容是没问题的,因为里面的元素至少是一个<code>Animals</code>,使用<code>Animals</code>的引用调用<code>Animals</code>的方法是没有任何问题的。这里就体现了<strong>存下取上</strong>的原则。</p><p>对于上界通配符<code>? extends Animal</code>,泛型的上界是<code>Animal</code>,没有下界,那就是<code>null</code>。所以所谓存下取上就是存储的时候按照泛型下界的类型存储,这里就是<code>null</code>,取出的时候按照泛型上界的类型取出,这里就是<code>Animal</code>。注意有一点原文没有说清楚:</p><blockquote><p>储存的元素类型<strong>至多</strong>是下界类型,取出时的元素类型<strong>至少</strong>是上界类型</p></blockquote><p>下面的图片很好的解释了这个原则:</p><p><img src="images/upper-bound.drawio.svg" alt="upper-bound"></p><p>所以如果容器中,存在有<strong>上界通配符</strong>的泛型:对其写入的元素是很鸡肋的,相当于这个容器是<strong>只读</strong>的。</p><p><strong>B. 下界通配符:</strong></p><p>相应的,上界通配符实现的简单意义上的只写功能。例如<code>List&lt;? super Husky&gt; animals</code>,其中<code>husky</code>是<code>Dog</code>的子类,这里能存入的元素类型至多是<code>Husky</code>类型,没有上界,那么就是<code>Object</code>。</p><p>我们可以在<code>animals</code>中存储任意的<code>animals</code>子类对象(就像<code>List&lt;Dog&gt;</code>中存储的都是<code>Dog</code>类型的引用,但是可以在<code>List</code>中存储任意的<code>Dog</code>子类)。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Husky</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Dog</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Husky</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    List&lt;Dog&gt; list=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    insert(list);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> Dog&gt; set)</span></span>&#123;<br>    <span class="hljs-comment">//成功添加</span><br>    set.add(<span class="hljs-keyword">new</span> Husky(<span class="hljs-string">&quot;husky&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;success&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="images/lower-bound.drawio.svg" alt="lower-bound"></p><p>当然类似的,这里只能读取<code>Object</code>类型的对象,也很鸡肋。</p><p>所以如果容器中存在有下界通配符的泛型,那么该容器在非严格意义上是<strong>只写</strong>的。</p><p>这里的存下取上原则也叫做<code>PECS</code>原则,即<code>producer-extends,consumer super</code>。以容器的视角来说,当容器作为作为生产者,往外提供元素时,就使用<code>extends</code>;当容器作为消费者,需要存储元素时,就使用<code>super</code>。</p><p>在<code>Collections.copy</code>方法中,就是用PESC原则:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//src为生产者,dest为消费者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>注意:<strong>如果</strong>同时有读写的要求呢?</strong></p><blockquote><p>就不需要使用泛型了。</p></blockquote><p><strong>C. 无界通配符:</strong></p><p>对于无界通配符<code>?</code>,它对应的下界为<code>null</code>,对应的上界为<code>Object</code>。</p><h3 id="3-泛型的擦除"><a href="#3-泛型的擦除" class="headerlink" title="3. 泛型的擦除"></a>3. 泛型的擦除</h3><p>在最开始曾说到java的泛型是<strong>伪泛型</strong>,仅仅保持在编译层面。在生成字节码文件时会对泛型擦除,将参数类型(parameterized types)转为原始类型(raw types)。所谓的参数类型就是类似于<code>class Person&lt;T&gt;</code>这种,而将它转换为原始类型就是<code>class Pseron</code>。在这种机制下，java中的多态就比较奇妙了。</p><h4 id="3-1-泛型下的多态"><a href="#3-1-泛型下的多态" class="headerlink" title="3.1 泛型下的多态"></a>3.1 泛型下的多态</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> generic;<br><span class="hljs-comment">//定义泛型类Person</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    T name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(T name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student s=<span class="hljs-keyword">new</span> Student();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Student类继承Person</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>Student</code>类继承了<code>Pseron</code>类,并且指定了父类的类型实参为<code>String</code>。那么父类的定义应该如下所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然而java中的泛型都是假泛型,泛型在编译期被擦除后,因为类型变量<code>T</code>没有上界,所以编译会把T推断为<code>Object</code>类型。所以真正的代码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    Object name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(Object name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>所以按道理,<code>Student</code>类中的<code>String</code>类型也应该变成<code>Object</code>类型,这样一来,不是全乱套了?所以java为了解决这个问题,发明了一种桥方法的机制。</p><p>可以看到,<code>Student</code>类中的<code>getName</code>和<code>setName</code>和<code>Person</code>类中的<code>getName</code>和<code>setName</code>参数类型根本就不一样,所以这根本就不是重载。但是代码又可以编译通过并且实现多态的特性。奇怪的事情发生了。我们看看<code>Studnet</code>编译后的字节码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// access flags 0x1</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span>Ljava/lang/String</span>;<br>   L0<br>    LINENUMBER <span class="hljs-number">22</span> L0<br>    ALOAD <span class="hljs-number">0</span><br>    GETFIELD generic/Student.stuName : Ljava/lang/String;<br>    ARETURN<br>   L1<br>    LOCALVARIABLE <span class="hljs-keyword">this</span> Lgeneric/Student; L0 L1 <span class="hljs-number">0</span><br>    MAXSTACK = <span class="hljs-number">1</span><br>    MAXLOCALS = <span class="hljs-number">1</span><br><br>  <span class="hljs-comment">// access flags 0x1</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">setName</span><span class="hljs-params">(Ljava/lang/String;)</span>V</span><br><span class="hljs-function">   L0</span><br><span class="hljs-function">    LINENUMBER 27 L0</span><br><span class="hljs-function">    ALOAD 0</span><br><span class="hljs-function">    ALOAD 1</span><br><span class="hljs-function">    PUTFIELD generic/Student.stuName : Ljava/lang/String</span>;<br>   L1<br>    LINENUMBER <span class="hljs-number">28</span> L1<br>    RETURN<br>   L2<br>    LOCALVARIABLE <span class="hljs-keyword">this</span> Lgeneric/Student; L0 L2 <span class="hljs-number">0</span><br>    LOCALVARIABLE name Ljava/lang/String; L0 L2 <span class="hljs-number">1</span><br>    MAXSTACK = <span class="hljs-number">2</span><br>    MAXLOCALS = <span class="hljs-number">2</span><br><br>  <span class="hljs-comment">// access flags 0x1041</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> synthetic bridge <span class="hljs-title">setName</span><span class="hljs-params">(Ljava/lang/Object;)</span>V</span><br><span class="hljs-function">   L0</span><br><span class="hljs-function">    LINENUMBER 18 L0</span><br><span class="hljs-function">    ALOAD 0</span><br><span class="hljs-function">    ALOAD 1</span><br><span class="hljs-function">    CHECKCAST java/lang/String</span><br><span class="hljs-function">    INVOKEVIRTUAL generic/Student.<span class="hljs-title">setName</span> <span class="hljs-params">(Ljava/lang/String;)</span>V</span><br><span class="hljs-function">    RETURN</span><br><span class="hljs-function">   L1</span><br><span class="hljs-function">    LOCALVARIABLE <span class="hljs-keyword">this</span> Lgeneric/Student</span>; L0 L1 <span class="hljs-number">0</span><br>    MAXSTACK = <span class="hljs-number">2</span><br>    MAXLOCALS = <span class="hljs-number">2</span><br><br>  <span class="hljs-comment">// access flags 0x1041</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> synthetic bridge <span class="hljs-title">getName</span><span class="hljs-params">()</span>Ljava/lang/Object</span>;<br>   L0<br>    LINENUMBER <span class="hljs-number">18</span> L0<br>    ALOAD <span class="hljs-number">0</span><br>    INVOKEVIRTUAL generic/Student.getName ()Ljava/lang/String;<br>    ARETURN<br>   L1<br>    LOCALVARIABLE <span class="hljs-keyword">this</span> Lgeneric/Student; L0 L1 <span class="hljs-number">0</span><br>    MAXSTACK = <span class="hljs-number">1</span><br>    MAXLOCALS = <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>有两个<code>setName</code>,两个<code>getName</code>可以看到其中有一组<code>setName</code>和<code>getName</code>前面有修饰符<code>synthetic</code>和<code>bridge</code>。<code>synthetic</code>表示这是系统自动生成的,而<code>bridge</code>表示这是一个桥方法。</p><p>所以其实桥方法才真正是<code>override</code>了<code>Person</code>类中的两个方法。而桥方法又去调用了我们自定义的<code>setName</code>与<code>getName</code>完成了多态。</p><h4 id="3-2-泛型下的继承"><a href="#3-2-泛型下的继承" class="headerlink" title="3.2 泛型下的继承"></a>3.2 泛型下的继承</h4><p>普通的继承关系并没有类型的困扰。但是一旦给类上了泛型,那么就有点复杂了。大体分为四种情况:</p><ol><li>子类直接指定了父类的类型参数</li><li>子类继承了父类的类型参数</li><li>父类擦除了类型参数,子类没有擦除</li><li>子类与父类都擦出了类型参数</li></ol><p>下面我们一一解释以下,还是以上面的<code>Person</code>类作为例子:</p><p><strong>子类直接制定了父类的类型参数</strong>:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    E name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(E name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这种情况,父类的类型参数已经被制定了,所以子类中从父类继承而来的东西也是被指定的类型,例如<code>String</code>。如果子类新加了类型参数<code>T</code>,那么这个<code>T</code>和父类没有任何关系。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;<br>    T age;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>子类继承了父类的类型参数</strong>:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>    T age;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(E name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么在子类中从父类继承而来的东西,类型还是<code>E</code>,类型参数<code>T</code>与父类没有任何关系。</p><p><strong>父类进行了泛型擦除而子类没有:</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    T age;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(Object name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这个例子中,由于<code>Person</code>类中的类型参数<code>E</code>没有上限,因为编译器只能把<code>E</code>推断为Object最为安全。如果类型参数<code>E</code>有上限,例如<code>E extends Number</code>,那么编译器就会将<code>E</code>推断为<code>Number</code>。上面代码中的<code>Object</code>就会全部换成<code>Number</code>了。</p><p><strong>子类与父类都进行了泛型擦除:</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>     age;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(E name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>子类与父类都进行了擦除这么说并不准确,因为根本就没有定义子类的类型参数…规则和父类擦除而子类不擦除的规则一样。要看父类的类型参数有没有上限,因为编译器的推断类型是不一样的。</p><p><strong>那么为什么不能父类不擦除,而子类不擦除呢？</strong></p><p>因为继承泛型类时,子类必须对父类中的类型参数进行初始化,当然父类擦除或者由子类指定都可以。所以子类擦除而父类不擦除,父类中的类型参数由谁来初始化?</p><h4 id="3-3-泛型下的类型获取"><a href="#3-3-泛型下的类型获取" class="headerlink" title="3.3 泛型下的类型获取"></a>3.3 泛型下的类型获取</h4><p>上面曾说到，Java中的泛型是伪泛型，在编译时会被擦除为<code>Object</code>类型的，但是为什么又能够在运行时获取的泛型的真实类型呢？</p><p>首先我们需要知道一个逻辑：<strong>泛型擦除并不代表JVM不知道类型信息</strong>。对于泛型类，JVM可以从Class文件中的<code>Signature</code>属性来获取泛型类的<strong>声明</strong>类型，而不是实际类型。假设有代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">action</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    T a;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T a)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.a=a;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    action&lt;Integer&gt; test=<span class="hljs-keyword">new</span> action&lt;&gt;();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在运行时我们可以获取引用<code>test</code>中的泛型类型，而不能获得<code>test.a</code>的泛型类。因为<code>test.a</code>在运行时会被泛化为<code>object</code>类型，无法通过class文件获取类型。但是对于<code>test</code>来说，因为在编译的时候编译器会将<code>test</code>泛型的声明类型作为<code>Signature</code>属性保存在<code>action</code>类的class文件中，所以我们可以通过<code>action.class</code>获取它的泛型声明类型。</p><p><strong>参考文献</strong></p><ol><li><a href="https://www.itzhai.com/articles/exploring-the-nature-of-java-generics.html">深入探索Java泛型的本质 | 泛型</a></li><li><a href="https://www.zhihu.com/question/346911525">Java中的泛型会被类型擦除，那为什么在运行期仍然可以使用反射获取到具体的泛型类型？</a></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://zhuanlan.zhihu.com/p/31137677">仔细说说Java中的泛型</a></p></li><li><p><a href="https://www.cnblogs.com/wuqinglong/p/9456193.html">Java泛型类型擦除以及类型擦除带来的问题</a></p></li><li><p><a href="https://developer.aliyun.com/article/313280">java泛型学习（2）</a></p></li><li><p><a href="https://segmentfault.com/q/1010000007925818">java 如何继承泛型</a></p></li><li><p><a href="https://blog.csdn.net/ShierJun/article/details/51253870">泛型继承的几种写法</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>反射</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基本概念</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类的加载机制</title>
    <link href="/2021-06-03/class-loading-mechanism.html"/>
    <url>/2021-06-03/class-loading-mechanism.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-类初始化的时机"><a href="#1-类初始化的时机" class="headerlink" title="1. 类初始化的时机"></a>1. 类初始化的时机</h1><p>update:2021-01-16 13:59:42</p><p>当复习类加载时机时，我给自己抛出了一个问题：这里的时机只说明了<strong>类</strong>的初始化，那么对于接口呢？接口什么时候会被初始化呢？</p><p>仔细回顾《深入理解Java虚拟机》，才发现，作者给出的是会触发<strong>类型</strong>初始化的六种时机，而不是<strong>类</strong>初始化。这里类型可能是指类或者接口。ok，那么我的问题迎刃而解了。接口初始化的时机同样遵循以下六种场景。</p><hr><p>在Java中，只有主动引用才会触发<del>类</del>类型加载动作。所谓的主动引用指<strong>只</strong>包括以下六种情况（除了下面这六种情况，其余的引用都称为被动引用）：</p><ol><li>遇到new、getstatic、setstatic或者invokestatic这4个字节码指令时，如果<strong>类型</strong>没有进行过初始化，那么需要先触发其初始化阶段。对应的java代码场景为：<ul><li>new一个关键字或者一个实例化对象时</li><li>读取或设置一个<strong>类型</strong>的静态字段时(final修饰、已在编译期把结果放入常量池的除外)</li><li>调用一个<strong>类行</strong>的静态方法时</li></ul></li><li>使用java.lang.reflect包的方法对<strong>类型</strong>进行反射调用的时候，如果类型没进行初始化，需要先触发其初始化。</li><li>当初始化一个<strong>类</strong>时，如果其父类还未进行初始化，会先触发其父类的初始化；当一个接口在初始化时。并不要求其父接口全部完成了初始化。只有真正使用到了父接口时（例如使用接口中定义的常量）才会对父接口进行初始化</li><li>当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的类)，虚拟机会先初始化这个类。</li><li>当使用JDK 1.7等动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li><li>当一个接口定义了JDK8新加入的默认方法时，如果这个接口的实现类发生了初始化，那么接口需要在其之前被初始化</li></ol><p><strong>注意：</strong><br>对于静态字段或者静态方法，只会对定义了这些内容的类执行类加载动作。我们通过下面的代码来理解这句话的真正含义：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">staticTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       subTest.m1();<br>    <span class="hljs-comment">// System.out.println(subTest.a);</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">subTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;load subclass subTest&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;load class Test&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;method m1&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>执行结果为：</p><blockquote><p>load class Test<br>method m1</p></blockquote><p>虽然通过子类名称调用父类的静态方法，但是jvm仍然只会加载真正定义了静态方法<code>m1</code>的类<code>Test</code>。这是一个特殊情况。</p><hr><p>update：2021-01-18 00:27:01</p><p>我又给自己提出了一个问题：当一个类被初始化时，它实现的接口是什么时候被加载的？这种情况不符合上面所述的六种场景啊。</p><p>经过我的思考，我发现我进入了一个误区。上面所述的六种场景只是声明类或接口被初始化的时机，而不是加载的时机。</p><p>初始化一定要求类或者接口被加载，但是反之则不一定，加载了类或接口，不一定需要初始化。所以我猜测，当是一个实现类在解析接口引用时，只是加载了接口，而没有初始化接口。不然类怎么实现验证步骤？</p><h1 id="2-类加载的七个步骤"><a href="#2-类加载的七个步骤" class="headerlink" title="2. 类加载的七个步骤"></a>2. 类加载的七个步骤</h1><p>将类的Class文件加载至jvm中一般会经历七个步骤：加载、验证、准备、解析、初始化、使用、卸载。但是注意：<strong>这七个步骤并不是完全串行的</strong>。有可能在一个步骤的执行中开启另外一个步骤，而不是等待当前步骤执行完毕。</p><p>并且其中的验证、准备、解析合在一起叫做“连接”。这不就是cpp编译过程的符号链接的步骤嘛，搞的这么花里胡哨的。</p><p>并且其中的初始化是指类的初始化，而不是对象的初始化。类的初始化是指：</p><ul><li>静态字段的初始化</li><li>静态代码的执行</li></ul><p>并且类的初始化只会在类加载的时候执行一次。下面我们就来看看这七个步骤。</p><h2 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1 加载"></a>2.1 加载</h2><p>这个加载是指整个类加载过程中的第一个步骤，而且是整个类加载过程中我们可以实实在在用代码控制的部分。该步骤分为三小步：</p><ol><li>通过类的全限定名获取类的二进制字节流</li><li>将二进制字节流表示的静态存储结构转化<strong>方法区</strong>为运行时存储结构</li><li>生成Class对象，作为方法区各种类型数据的访问接口</li></ol><p>其中通过类的权限名获取类的二进制字节流就是我们能够控制的部分，虚拟机规范只规定了我们要获取字节流，而没有规定从哪里获取字节流。可以从Class文件中获取、静态的jar包中获取、网络中获取，或者动态的在内存中生成，也就是所谓的动态代理技术，这完全都可以自定义实现。<strong>并且获取字节流这个动作就是通过我们自定义的类加载器来实现。</strong></p><p>但是有一个特殊情况，就是数组类的加载不是我们可以控制的，但是数组中的元素类却又是我们可以控制的。因为<strong>数组类的并不是由类加载器加载，而是由jvm在内存中直接构造的。</strong></p><hr><p>这里的数组类可以看作数组的wrapper，即数组的包装类，由jvm动态生成，数组类提供了一些数组的属性，并且数组的访问也通过该类实现。</p><blockquote><p>java访问数组的安全性比c++高很大程度是因为该类包装了数组的访问操作。</p></blockquote><hr><h3 id="2-1-1-数组类的加载机制"><a href="#2-1-1-数组类的加载机制" class="headerlink" title="2.1.1 数组类的加载机制"></a>2.1.1 数组类的加载机制</h3><ul><li>如果数组的组件类型(即数组去掉一个维度，例如int[4][3],实际的组件类型为int[3],因为二维数组可以看作元素类型是一维数组的一维数组)。那么就递归的采用类加载过程去加载这个组件类型。是类就用类的加载过程，是数组类就用数组类的加载过程。并且该数组会被标识在加载该组件类型的类加载器的类名称空间上，因为这样才能唯一的确定一个类</li><li>如果数组的组件类型不是引用类型，那么该数组会被标识在启动类加载器的类名称空间上</li><li>数组类的可访问性和它组件类型的可访问性一致，如果组件类型不是引用类型，那么数组类的可访问性默认为public</li></ul><h3 id="2-1-2-生成Class对象"><a href="#2-1-2-生成Class对象" class="headerlink" title="2.1.2 生成Class对象"></a>2.1.2 生成Class对象</h3><p>在获得类文件的二进制的字节流后，会被转化为方法区的动态存储结构，这个结构是怎么样的并没有强制规定。但是在转化完成后，会在<strong>堆区</strong>实例化一个代表当前类的Class对象。作为方法区存储结构中的数据的访问接口。</p><p><strong>加载阶段和连接阶段是交叉进行的。</strong></p><h2 id="2-2-验证"><a href="#2-2-验证" class="headerlink" title="2.2 验证"></a>2.2 验证</h2><p>验证显而易见就是验证获取的二进制字节流是否安全，符合虚拟机规范。<strong>因为Class不一定是通过编译生成的</strong>，也确实可以直接在二进制层面拼接。<strong>那么在生成Class对象前不是应该先完成验证步骤？</strong></p><p>验证主要验证四个部分：</p><ol><li>文件格式的验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ol><h3 id="2-2-1-文件格式验证"><a href="#2-2-1-文件格式验证" class="headerlink" title="2.2.1 文件格式验证"></a>2.2.1 文件格式验证</h3><p>文件格式的验证就是验证我们在加载阶段获取到的二进制字节流是否符合<strong>Class文件格式</strong>的规范，只有完成这一步验证，字节流才会转化为方法区的存储结构，并且后续的三个验证步骤是基于方法区的存储结构，而不会直接操作二进制流了。</p><h3 id="2-2-2-元数据验证"><a href="#2-2-2-元数据验证" class="headerlink" title="2.2.2 元数据验证"></a>2.2.2 元数据验证</h3><p>元数据验证是验证方法区存储的字节码是否《java语言规范》的语法要求。所谓的语义包括是否继承了final修饰的类、是否修改了final修饰的字段等等。即验证是否符合java的语法。</p><h3 id="2-2-3-字节码验证"><a href="#2-2-3-字节码验证" class="headerlink" title="2.2.3 字节码验证"></a>2.2.3 字节码验证</h3><p><strong>字节码验证主要是验证代码的语义正确性。</strong>例如将父类对象赋值给子类引用（语法验证会通过，但可能会产生运行时问题）。如果代码没有通过字节码验证，说明代码肯定有错误，但反之则不一定，即使通过了验证，也不能说代码完全正确，有可能产生间接的语义错误。</p><p>但是计算代码是否有语义错误显而易见是一项庞大的工程，放到代码运行之前验证不太好。所以在JDK6之后，java团队将验证语义的操作大部分都转移到了编译期间。编译器会在编译时为代码属性添加<code>StackMapTable</code>属性，这一属性描述了代码是否有语义错误。在字节码验证阶段jvm只需要验证该属性是否符合规范。当然，这并不能做到十全十美。</p><h3 id="2-2-4-符号引用验证"><a href="#2-2-4-符号引用验证" class="headerlink" title="2.2.4 符号引用验证"></a>2.2.4 符号引用验证</h3><p>符号引用验证的目的是为了保证<strong>解析阶段</strong>正常进行。会进行权限检查</p><h3 id="2-2-5-小结"><a href="#2-2-5-小结" class="headerlink" title="2.2.5 小结"></a>2.2.5 小结</h3><p>验证阶段可有可无，并不是强制的，只要能够保证代码是正确的，那么也可以关闭大部分类的验证措施来加速类的加载。</p><h2 id="2-3-准备"><a href="#2-3-准备" class="headerlink" title="2.3 准备"></a>2.3 准备</h2><p>准备阶段是为类的静态变量(而不是实例变量，实例变量会在对象实例化时分配空间)分配内存空间，以及赋予静态变量默认的初值，这里的初值指的是int的默认为0、boolean的默认为false之类的默认值。例如:</p><blockquote><p>public static int value=123;</p></blockquote><p>在准备阶段，value的值为默认值，即为0。在初始化阶段才会被赋值为123。</p><p><strong>无论代码中有没有对静态变量的赋值的操作，都会对变量进行初始化操作，至于赋值的步骤，会在初始化阶段完成!!!</strong></p><p>注意：准备阶段只为静态变量做准备。</p><h2 id="2-4-解析"><a href="#2-4-解析" class="headerlink" title="2.4 解析"></a>2.4 解析</h2><p>解析肯定就是符号的链接过程咯。准备来说就是将常量池中的符号引用替换为直接引用。例如Class文件中的<code>CONSTANT_Class_info</code>、<code>CONSTANT_Fieldref_info</code>、<code>CONSTANT_Method_info</code>等符号引用，存储形式都是常量。</p><blockquote><p>解析过程是把符号链接到正确的内存地址，符号引用变为直接引用，而不是确定符号，后者是编译期做的事，<del>解析这件事已经属于运行期了</del>。准确来说，解析并不是运行期，因为解析阶段还没有真正的开始执行字节码，我的理解时<strong>执行字节码才叫做真正的运行期</strong>。</p></blockquote><p>在解析阶段解析符号的过程被称为<strong>静态解析</strong>，当然能够被静态解析的符号类型有限：</p><ul><li>类或接口</li><li>字段</li><li>一部分方法</li><li>接口方法</li></ul><p>关于方法的解析比较复杂，后文单独开一章进行讲解。</p><h3 id="2-4-1-类或接口的解析"><a href="#2-4-1-类或接口的解析" class="headerlink" title="2.4.1 类或接口的解析"></a>2.4.1 类或接口的解析</h3><p>类或接口的解析有一个核心规则：</p><p>如果当前代码所处的类为D，如果想要把D中一个从未解析过的符号引用N解析为类或接口C，那么则有：</p><ol><li><p>如果c不是一个数组类型，那么会使用<strong>D的类加载器</strong>加载c，其中会将c的全限定名传递给D的类加载器。如果其中又需要加载其他类，那么重复整个解析程序</p></li><li><p>如果c是一个数组类型，并且数组元素是对象类型，那么会重复第一步，<strong>并且由虚拟机生成该数组</strong></p></li><li><p>如果上面两步没有出现问题，那么会检查符号引用的权限，确认D对C具有访问，否则会抛出异常</p></li></ol><h3 id="2-4-2-字段的解析"><a href="#2-4-2-字段的解析" class="headerlink" title="2.4.2 字段的解析"></a>2.4.2 字段的解析</h3><p>首先我们需要找到字段所属的类或接口C，然后：</p><ol><li><p>如果在c中找到了简单名称和描述符都与目标相符的字段，那么会返回字段的直接引用</p></li><li><p>在c实现的接口中，从下往上查找目标</p></li><li><p>在c继承的父类中，从下往上查找目标</p></li><li><p>如果成功获得了直接引用，还会检查是否对目标字段具有访问权限</p></li></ol><p>如果在c的父类或接口中实现了相同字段，虽然按照规则可以成功找到目标字段，但是编译器为了安全，还是会选择拒绝编译。</p><blockquote><p>字段会在解析阶段完全解析好，因为符号引用在编译时期就确定了</p></blockquote><h3 id="2-4-3-接口方法的解析"><a href="#2-4-3-接口方法的解析" class="headerlink" title="2.4.3 接口方法的解析"></a>2.4.3 接口方法的解析</h3><p>首先在接口方法表中解析出当前方法所属的类或接口c，然后：</p><ol><li><p>如果c是一个类，那么抛出IncompatibleClassChangeError</p></li><li><p>否则在接口c中查看目标方法，如果成功，则返回直接引用</p></li><li><p>否则在c继承的接口中查找目标方法，这一步骤有一点值得注意：会一直向上递归查找，直到对java.lang.Object查找完毕，因为接口方法的查找范围<strong>包括Object类中的方法。</strong></p></li><li><p>对查找的直接引用进行权限检查在JDK9之后，因为JDK9之后引入了模块化系统。</p></li></ol><p>如果在继承的多个父接口中查找到了多个目标方法，虽然虚拟机规范规定随意返回一个即可。</p><h2 id="2-5-初始化"><a href="#2-5-初始化" class="headerlink" title="2.5 初始化"></a>2.5 初始化</h2><p>这里的初始化是指对类进行初始化，并且这一阶段可以通过程序控制。</p><p>初始化阶段就是执行类构造器<code>&lt;cinit&gt;()</code>方法的过程。这一方法通过编译器自动生成，生成规则如下：</p><ol><li><p>收集类中所有类变量的赋值动作和静态代码块的语句按<strong>顺序</strong>而合成，如果没有静态变量<strong>赋值</strong>语句和静态代码块，那么并不会生成<code>&lt;cinit&gt;()</code></p></li><li><p>静态代码块只能访问定义在块之前的静态变量，对于块之后定义的静态变量，静态代码块只能赋值，不能访问</p></li><li><p>虚拟机会保证父类的类构造器<code>&lt;cinit&gt;()</code>一定会在子类的<code>&lt;cinit&gt;()</code>执行之前执行，这与实例构造器<code>&lt;init&gt;()</code>一样，会保证父类的实例构造器先于子类执行，并且JVM保证在多线程环境下<code>&lt;cinit&gt;()</code>只会被执行一次</p></li></ol><p>这里怎么保证呢？就是虽然<code>super</code>是在是在子类构造器中调用的，但是<code>super</code>实际是在调用父类的<code>&lt;init&gt;</code>，而子类的<code>&lt;init&gt;</code>根本还没有开始执行，这样保证了父类的<code>&lt;init&gt;</code>一定会在子类的<code>&lt;init&gt;</code>之前完成，例如在下面的代码中：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FieldHashNoPolymorphic</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> money = <span class="hljs-number">1</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Father</span><span class="hljs-params">()</span> </span>&#123;<br>            ...<br>            showMeTheMoney();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMeTheMoney</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am Father, I have $&quot;</span> + money);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> money = <span class="hljs-number">3</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Son</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">//虽然super在Son的构造方法中，但是实际上Son的&lt;init&gt;还没有开始执行</span><br>            <span class="hljs-keyword">super</span>();<br>            ...<br>            showMeTheMoney();<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMeTheMoney</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am Son, I have $&quot;</span> + <span class="hljs-keyword">this</span>.money);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Father guy = <span class="hljs-keyword">new</span> Son();<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在执行<code>super</code>的时候，<code>Son</code>类的<code>&lt;init&gt;</code>方法还没有开始调用，所以<code>Son</code>类的<code>money</code>字段仍然为0。那么<code>&lt;init&gt;</code>由哪些部分组成呢？与<code>&lt;cinit&gt;</code>类似，也是由三部分组成：</p><ol><li>成员变量显式赋值代码</li><li>非静态代码块中的代码</li><li>构造器中的代码</li></ol><p>其中1、2部分按照出现的顺序排列，3永远排在最后执行。</p><h3 id="2-5-1-接口的初始化"><a href="#2-5-1-接口的初始化" class="headerlink" title="2.5.1 接口的初始化"></a>2.5.1 接口的初始化</h3><p>对于接口来说，并没有强制要求父接口的<code>&lt;cinit&gt;()</code>一定要在子接口<code>&lt;cinit&gt;()</code>之前执行。只有当父接口中定义的变量被使用时，才会执行父接口的<code>&lt;cinit&gt;()</code>方法。并且接口的实现类初始化时也不会执行接口的<code>&lt;cinit&gt;()</code>方法。</p><h1 id="3-类方法的解析"><a href="#3-类方法的解析" class="headerlink" title="3. 类方法的解析"></a>3. 类方法的解析</h1><p>方法的总体来说可以分为两个部分：</p><ul><li>能够在解析阶段完成解析的方法</li><li>只能在运行时完成解析的方法</li></ul><p>那么如何区分它们呢？这与具体的方法调用的字节码指令有关，在java中，有五条字节码与方法调用有关：</p><ul><li>invokestatic:调用静态方法</li><li>invokespecial：用于调用特殊的实例方法，包括实例初始化方法（<init>()方法）、私有方法、父类方法（<strong>最近的一个父类</strong>）</li><li>invokevirtual：用于调用对象的实例方法</li><li>invokeinferface：用于调用接口方法</li><li>invokedynamic：用于运行时动态解析出调用点限定符所引用的方法</li></ul><p>我们可以根据这五条调用方法的指令来判定当前方法能否在类加载过程中的解析阶段完成符号链接。值得注意的是<strong>前四条的方法调用逻辑</strong>是完全固化在虚拟机内的，而最后一条指令的调用指派完全由程序员指定。</p><h2 id="3-1-类加载阶段的方法符号解析"><a href="#3-1-类加载阶段的方法符号解析" class="headerlink" title="3.1 类加载阶段的方法符号解析"></a>3.1 类加载阶段的方法符号解析</h2><p>只要是通过<code>invokestatic</code>、<code>incokespecial</code>调用的或者被<code>final</code>修饰的方法，就能在类加载阶段中的解析步骤时将符号引用转换为目标方法的直接引用。总计分为五种方法：</p><ul><li>静态方法</li><li>对象的构造方法</li><li>私有方法</li><li>父类方法</li><li>被<code>final</code>修饰的方法</li></ul><p>上述五类方法被称为“非虚方法”，调用的方法的符号引用在编译器就已经完全确定，这类方法的调用称为<strong>解析</strong>。其他的所有方法都为“虚方法”，java中默认方法都是虚方法。</p><h2 id="3-2-运行时的方法符号解析"><a href="#3-2-运行时的方法符号解析" class="headerlink" title="3.2 运行时的方法符号解析"></a>3.2 运行时的方法符号解析</h2><p>除了在3.1小节指出的非虚方法外，其余的方法会在第一次调用时进行链接。这类方法的符号解析有一个特殊的名字，称为<strong>分派</strong>。顾名思义，分派肯定是从多个候选者选择一个。我认为这是与解析最大的不同，因为解析调用的候选方法只有一个。</p><p>分派又可分为静态分派和动态分派。</p><h3 id="3-2-1-静态分派"><a href="#3-2-1-静态分派" class="headerlink" title="3.2.1 静态分派"></a>3.2.1 静态分派</h3><p>所谓的静态分派和上述非虚方法的解析并没有太大差别，都是在编译期确定目标方法的符号引用。值得注意的是：在重载环境下，编译器依赖方法参数的静态类型选择合适的版本。这也侧面说明了重载时只有参数不同才算重载。</p><p>这类依赖静态类型来决定目标方法版本的操作称为静态解析，因为候选者有多个！<strong>静态解析的结果由编译器决定而不是虚拟机。</strong></p><h3 id="3-2-2-动态分派"><a href="#3-2-2-动态分派" class="headerlink" title="3.2.2 动态分派"></a>3.2.2 动态分派</h3><p>静态分派是靠编译器实现的，动态分派是靠<code>invokevirtual</code>执行实现的，<code>invokevirtual</code>的执行步骤如下：</p><ol><li>找到操作数栈顶第一个元素指向的对象的实际类型C</li><li>在类C中查找是否存在描述符和简单名称都符合预期目标的方法，如果存在，那么结束查找</li><li>否则在类C的各个父类中进行查找，直到无法找到抛出异常</li></ol><p>这类依赖变量动态类型来决定调用的方法版本称为动态分派。值得注意的是：字段永远不存在多态，只会存在覆盖的概念。查询字段只会在最近的范围内查找。下面的代码很好地解释了动态分派与同名字段覆盖：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FieldHashNoPolymorphic</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> money = <span class="hljs-number">1</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Father</span><span class="hljs-params">()</span> </span>&#123;<br>            money = <span class="hljs-number">2</span>;<br>            System.out.println(<span class="hljs-keyword">this</span>.money+<span class="hljs-string">&quot;---&quot;</span>+<span class="hljs-keyword">this</span>);<br>            showMeTheMoney();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMeTheMoney</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am Father, I have $&quot;</span> + money);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> money = <span class="hljs-number">3</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Son</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//这个this实际上是不能被传递的，这里只是示意</span><br>            System.out.println(<span class="hljs-keyword">this</span>);<br>            money = <span class="hljs-number">4</span>;<br>            showMeTheMoney();<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMeTheMoney</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am Son, I have $&quot;</span> + money);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Father guy = <span class="hljs-keyword">new</span> Son();<br>        <span class="hljs-comment">// 通过静态类型访问到了父类中的money，输出2</span><br>        System.out.println(<span class="hljs-string">&quot;This guy has $&quot;</span> + guy.money);<br>        <span class="hljs-comment">// 将静态类型强转成Son，访问的就是子类中的money，输出4</span><br>        System.out.println(<span class="hljs-string">&quot;This guy has $&quot;</span> + ((Son) guy).money);<br>    &#125;<br>&#125;<br># 输出如下<br><span class="hljs-number">2</span>---jvm.FieldHashNoPolymorphic$Son@6ed3ef1<br>I am Son, I have $<span class="hljs-number">0</span><br>jvm.FieldHashNoPolymorphic$Son@6ed3ef1<br>I am Son, I have $<span class="hljs-number">4</span><br>This guy has $<span class="hljs-number">2</span><br>This guy has $<span class="hljs-number">4</span><br><br></code></pre></div></td></tr></table></figure><p>在第一次执行中，为什么会调用<code>Son</code>类的<code>showTheMoney()</code>?因为在调用方法时，会将方法接收者（也就是caller）的引用传递进去，调用父类构造函数的代码是<code>super(this)</code>，这里的<code>this</code>代表<code>Son</code>类的对象。所以在执行下面代码时：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Father</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.money = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">this</span>.showMeTheMoney();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>虽然这里的<code>this</code>指向的是子类<code>Son</code>对象，但是我们想想，<code>Son</code>对象肯定会包含了父类<code>Father</code>的数据啊，所以这两个<code>this</code>显示地是同一个地址没毛病。</p><p>但是<code>sout(this.money)==2</code>就说明这里使用的<code>money</code>属性是父类的，因为代码执行处离父类<code>Father</code>最近。而显示的<code>I am Son, I have $0</code>就说明此时使用的是子类<code>Son</code>的<code>money</code>属性，因为此时代码执行处处离<code>Son</code>最近。值为0是因为此时子类<code>Son</code>的<code>money</code>属性还没有初始化，因为父类的构造函数还未执行完毕。</p><p>虽然在Son类型的对象中，内存中会存在两个<code>money</code>,但是Son对象只会使用离他最近的一个，也就是自身类中的<code>money</code>属性，子类的属性会隐藏父类的同名属性。</p><h3 id="3-2-3-单分派与多分派"><a href="#3-2-3-单分派与多分派" class="headerlink" title="3.2.3 单分派与多分派"></a>3.2.3 单分派与多分派</h3><p>决定单分派与多分派的标准是使用的宗量数量。宗量分为两大类：方法的接受者（caller）与方法的参数。采用《深入理解java虚拟机》中的例子作为解释：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dispatch</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QQ</span></span>&#123;&#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_360</span></span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hardChoice</span><span class="hljs-params">(QQ arg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;father choose qq&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hardChoice</span><span class="hljs-params">(_360 arg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;father choose 360&quot;</span>);<br>    &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hardChoice</span><span class="hljs-params">(QQ arg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;son choose qq&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hardChoice</span><span class="hljs-params">(_360 arg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;son chooes 360&quot;</span>);<br>    &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Father father = <span class="hljs-keyword">new</span> Father();<br>    Father son = <span class="hljs-keyword">new</span> Son();<br><br>    father.hardChoice(<span class="hljs-keyword">new</span> _360());<span class="hljs-comment">//father choose 360</span><br>    son.hardChoice(<span class="hljs-keyword">new</span> QQ());<span class="hljs-comment">//son choose qq</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于<code>fahter.hardChoice(new _360())</code>,在编译时期编译器确定调用符号时，可以看出候选者非常多（候选者有哪些，需要列出来）。那么在调用<code>father.hardChoice</code>时发现方法的接收者的静态类型这是<code>Father</code>,这就决定了在<code>Father</code>类中选择。那么接着查看调用方法的参数，发现实参的静态类型为<code>360</code>,那么通过方法调用者和函数实参这两个标准在编译器确定了符号调用，这就代表使用了两个宗量。同理编译<code>son.hardChoice(new QQ())</code>时也会使用两个宗量确定符号引用。</p><p>上述确定的两个符号引用会使用<code>invokevirtual</code>调用。那么在运行时,因为已经在编译器确定了方法签名，但是候选者仍然有两个：</p><ul><li>Father::hardChoice(_360 arg)</li><li>Son::hardChoice(_360 arg)</li></ul><p>因为上述的两个函数调用实际会使用<code>invokeVirtual</code>执行，所以在运行时虚拟机会从上述的两个候选者中选择一个。以<code>father.hardChoice(new _360())</code>为例，方法接收者<code>father</code>的实际类型为<code>Son</code>，所以虚拟机会选择<code>Son</code>类中的方法。可以看出在抉择过程中只用了“方法调用者”这一个参考因素。</p><p>所以到目前为止，<strong>java是一个静态多分派、动态单分派的语言</strong>。那么时候才会进入分派的阶段，也就是使用<code>virtualinvoke</code>指定？</p><p>我认为答案是调用非虚方法时，会进入分派阶段。</p><hr><p><strong>Extension: invokevirtual的执行过程</strong></p><ol><li><code>invokevirtual</code>首先会找到操作数栈的栈顶第一个元素所指向的对象的实际类型，记为C；</li><li>在C自身中进行查找符号和描述相符的方法，如果找到，则需要检查权限</li><li>如果在C自身中未找到，那么会按照继承关系<strong>自下而上</strong>在C的父类中进行查找，如果找到则需要进行权限检查</li><li>如果都为找到，则会抛出<code>AbstractMethodError</code>异常</li></ol><hr><h3 id="3-2-4-分派的具体实现"><a href="#3-2-4-分派的具体实现" class="headerlink" title="3.2.4 分派的具体实现"></a>3.2.4 分派的具体实现</h3><p>在每次调用时才去执行分派效率必定低下，所以jvm选择以虚表(virtual method table)的形式实现分派的过程。虚表和cpp中的虚表概念差不多。这个虚表建立在方法区。对于子类来说，如果没有重写父类的方法，那么子类的虚方法表中，没有被重写的方法的指针和父类同一方法的指针指向同一个函数。</p><blockquote><p>虚表会在类加载阶段完成初始化，在完成连接阶段中的初始化过程后，会完成该类的虚表初始化</p></blockquote><h1 id="4-小测试"><a href="#4-小测试" class="headerlink" title="4. 小测试"></a>4. 小测试</h1><p>根据类加载的规则，下面的代码输出到底是多少？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleTon</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingleTon singleTon = <span class="hljs-keyword">new</span> SingleTon();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count1;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count2 = <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingleTon</span><span class="hljs-params">()</span> </span>&#123;<br>        count1++;<br>        count2++;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleTon <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> singleTon;<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SingleTon singleTon = SingleTon.getInstance();<br>        System.out.println(<span class="hljs-string">&quot;count1=&quot;</span> + singleTon.count1);<br>        System.out.println(<span class="hljs-string">&quot;count2=&quot;</span> + singleTon.count2);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>一个经常出现的错误答案是：</p><blockquote><p>count1=1;<br>count2=1;</p></blockquote><p>但是正确的执行结果为：</p><blockquote><p>count1=1;<br>count2=0;</p></blockquote><p>为什么呢？因为类加载过程中准备阶段是在初始化阶段之前的，虽然在上面的代码中有<code>count2=0</code>，但是准备阶段不关心这个。准备阶段完成后：</p><blockquote><p>count1=0;<br>count2=0;</p></blockquote><p>最后在初始化过程中，编译器生成的<code>&lt;cinit&gt;</code>方法是按照代码书写顺序生成的，例如这个例子中生成的是：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">cinit()&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingleTon singleTon = <span class="hljs-keyword">new</span> SingleTon();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count1;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count2 = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>虽然在执行<code>SingleTon</code>的构造方法时，会执行<code>count2=1</code>的操作，但是注意，<code>&lt;cinit&gt;</code>方法还没有执行完成呢。在<code>&lt;cinit&gt;</code>中最后还是会执行<code>count2=0</code>的操作。</p><p>所以最终的答案是：</p><blockquote><p>count1=1;<br>count2=0;</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>类加载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap源码分析(三)-删除源码</title>
    <link href="/2021-06-03/HashMap-analysis-part-three.html"/>
    <url>/2021-06-03/HashMap-analysis-part-three.html</url>
    
    <content type="html"><![CDATA[<p>HashMap的删除操作一般通过<code>remove</code>完成。在remove方法中,同样存在fast-fail机制,不了解的可以去看看<a href="../Collection/List/ArrayList-source-code-analysis.md">ArrayList中的fast-fail</a>。通过fast-fail机制检查后,会调用真正的删除方法<code>removeNode</code>,如下面代码所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">removeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key, Object value,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">boolean</span> matchValue, <span class="hljs-keyword">boolean</span> movable)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, index;<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>            <span class="hljs-comment">//通过hash找出一个Node p</span><br>            (p = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>        Node&lt;K,V&gt; node = <span class="hljs-keyword">null</span>, e; K k; V v;<br>        <span class="hljs-comment">//注意,Hash相等不一定是同一个key,因为可能发生hash冲突</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>                <span class="hljs-comment">//如果是同一个对象或者使用equals返回true</span><br>                <span class="hljs-comment">//那么p就是我们要删除的点</span><br>            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            node = p;<br>        <span class="hljs-comment">//在链表中或RB树中查找目标节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = p.next) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key ||<br>                            (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<br>                        node = e;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    p = e;<br>                &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||<br>                                (value != <span class="hljs-keyword">null</span> &amp;&amp; value.equals(v)))) &#123;<br>            <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-comment">//从RB树中删除目标节点</span><br>                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="hljs-keyword">this</span>, tab, movable);<br>            <span class="hljs-comment">//如果目标节点在数组中</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == p)<br>                <span class="hljs-comment">//直接把链表的头部去除</span><br>                tab[index] = node.next;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">//如果此时HashMap仍然是以双向链表存储,那么直接链接后一个节点即可</span><br>                p.next = node.next;<br>            ++modCount;<br>            --size;<br>            afterNodeRemoval(node);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中<code>matchValue</code>表示删除元素时需要value匹配才能删除,<code>movable</code>为<code>false</code>表示当移除元素时不会移动其他节点。在<code>HashMap</code>中<code>matchValue</code>默认为false。在具体阅读源码之前,我们需要了解,<code>HashMap</code>中的链表或者RB树都是hash冲突的元素。<br>所以这个方法的逻辑比较简单:</p><ol><li>首先通过<code>key</code>的hash找出目标桶。</li><li>然后从对应的链表或者RB树找到对应的节点。注意这里对应的节点要求<code>key</code>与<code>value</code>都完全匹配,因为hash冲突。</li><li>如果当前存储形式为RB树,那么调用当前节点的<code>removeTreeNode</code>方法删除自身</li></ol><p>这里需要着重分析的是<code>TreeNode</code>的<code>removeTreeNode</code>方法,该方法非常复杂,需要耐心观看。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeTreeNode</span><span class="hljs-params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-keyword">boolean</span> movable)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> index = (n - <span class="hljs-number">1</span>) &amp; hash;<br>    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;<br>    TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;<br>    <span class="hljs-comment">//删除节点有两种视角,分别是链表视角和红黑树视角</span><br>    <span class="hljs-comment">//能这样操作是因为TreeNode既可以作为红黑树的节点，也可以作为链表节点</span><br>    <span class="hljs-comment">//这里先将hashmap作为链表处理，如果删除完毕节点个数不多于6个,那么直接就将RB树转为链表即可</span><br>    <span class="hljs-comment">//如果想要删除的节点就是根节点</span><br>    <span class="hljs-keyword">if</span> (pred == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-comment">//那么直接使用后继节点补上</span><br>        tab[index] = first = succ;<br>    <span class="hljs-keyword">else</span><br>        pred.next = succ;<br>    <span class="hljs-keyword">if</span> (succ != <span class="hljs-keyword">null</span>)<br>        succ.prev = pred;<br>    <span class="hljs-keyword">if</span> (first == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (root.parent != <span class="hljs-keyword">null</span>)<br>        root = root.root();<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span><br>        || (movable<br>            &amp;&amp; (root.right == <span class="hljs-keyword">null</span><br>                || (rl = root.left) == <span class="hljs-keyword">null</span><br>                || rl.left == <span class="hljs-keyword">null</span>))) &#123;<br>        tab[index] = first.untreeify(map);  <span class="hljs-comment">// too small</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">/******以RB树的视角删除节点************</span><br><span class="hljs-comment">    下面的代码目标是找到替换p的节点replacement然后将p进行真正的删除</span><br><span class="hljs-comment">    */</span><br>        TreeNode&lt;K,V&gt; p = <span class="hljs-keyword">this</span>, pl = left, pr = right, replacement;<br>    <span class="hljs-comment">//如果当前节点的左右子树都不为空</span><br>    <span class="hljs-keyword">if</span> (pl != <span class="hljs-keyword">null</span> &amp;&amp; pr != <span class="hljs-keyword">null</span>) &#123;<br>        TreeNode&lt;K,V&gt; s = pr, sl;<br>        <span class="hljs-comment">//那么就找到右子树的最左节点</span><br>        <span class="hljs-keyword">while</span> ((sl = s.left) != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// find successor</span><br>            s = sl;<br>        <span class="hljs-comment">//交换待删除节点p和p的右子树最左节点的颜色</span><br>        <span class="hljs-keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="hljs-comment">// swap colors</span><br>        <span class="hljs-comment">//此时的s是没有左子树的</span><br>        TreeNode&lt;K,V&gt; sr = s.right;<br>        TreeNode&lt;K,V&gt; pp = p.parent;<br>        <span class="hljs-comment">/***********接下来的操作就是交换s节点和p节点************</span><br><span class="hljs-comment">            * s是p右子树的最左节点</span><br><span class="hljs-comment">            * 总要要设置的就是s和p的left、right、parent三类指针</span><br><span class="hljs-comment">            * pp的left或right指针</span><br><span class="hljs-comment">            * sr的parent指针、pl和pr的parent指针***/</span><br>        <span class="hljs-comment">//如果s是p的右节点,那么就将p设置为s的右节点</span><br>        <span class="hljs-keyword">if</span> (s == pr) &#123; <span class="hljs-comment">// p was s&#x27;s direct parent</span><br>            p.parent = s;<br>            s.right = p;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            TreeNode&lt;K,V&gt; sp = s.parent;<br>            <span class="hljs-comment">//设置p的parent指针,如果s的父节点不为空,将s的父节点设置为p的父节点</span><br>            <span class="hljs-keyword">if</span> ((p.parent = sp) != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (s == sp.left)<br>                    sp.left = p;<br>                <span class="hljs-keyword">else</span><br>                    sp.right = p;<br>            &#125;<br>            <span class="hljs-comment">//设置s的right指针,如果p的右子树不空,那么把p的右子树接到s的右边</span><br>            <span class="hljs-keyword">if</span> ((s.right = pr) != <span class="hljs-keyword">null</span>)<br>                <span class="hljs-comment">//设置pr的parent指针</span><br>                pr.parent = s;<br>        &#125;<br>        <span class="hljs-comment">//设置p的left指针,因为s就是没有左子树的,所以交换后p的left指向null</span><br>        p.left = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//设置p的right指针,将s的右子树接到p的右边</span><br>        <span class="hljs-keyword">if</span> ((p.right = sr) != <span class="hljs-keyword">null</span>)<br>            sr.parent = p;<br>        <span class="hljs-comment">//设置s的left指针,将p的左子树接到s的左边</span><br>        <span class="hljs-keyword">if</span> ((s.left = pl) != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-comment">//设置pl的parent指针</span><br>            pl.parent = s;<br>        <span class="hljs-comment">//设置s的parent指针,设置s的父节点为p的父节点</span><br>        <span class="hljs-keyword">if</span> ((s.parent = pp) == <span class="hljs-keyword">null</span>)<br>            root = s;<br>        <span class="hljs-comment">//设置pp的left指针或者right指针</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == pp.left)<br>            pp.left = s;<br>        <span class="hljs-keyword">else</span><br>            pp.right = s;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">            * sr还是原来s的右子节点,这里并没有产生变化</span><br><span class="hljs-comment">            */</span><br>        <span class="hljs-keyword">if</span> (sr != <span class="hljs-keyword">null</span>)<br>            replacement = sr;<br>        <span class="hljs-keyword">else</span><br>            replacement = p;<br>    &#125;<br>    <span class="hljs-comment">//只有左子树,那么直接使用左子树的根节点替换</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pl != <span class="hljs-keyword">null</span>)<br>        replacement = pl;<br>    <span class="hljs-comment">//只有右子树,那么直接使用右子树的根节点替换</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pr != <span class="hljs-keyword">null</span>)<br>        replacement = pr;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">//当左右子树都为空时,当前节点就是被替换的节点</span><br>        replacement = p;<br>    <span class="hljs-comment">//如果replacement和p不是同一个节点,那么将二者交换</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 这里仅仅是简单的将pp变成replacement的父节点</span><br><span class="hljs-comment">        * 将p的所有指针都置空,方便垃圾回收</span><br><span class="hljs-comment">        */</span><br>    <span class="hljs-keyword">if</span> (replacement != p) &#123;<br>        TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;<br>        <span class="hljs-keyword">if</span> (pp == <span class="hljs-keyword">null</span>)<br>            root = replacement;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == pp.left)<br>            pp.left = replacement;<br>        <span class="hljs-keyword">else</span><br>            pp.right = replacement;<br>        p.left = p.right = p.parent = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-comment">/**如果p是红色,那么可以直接删除红节点</span><br><span class="hljs-comment">        * 否则从replacement开始调整颜色,此时p可以说是已经完全脱离RB树了</span><br><span class="hljs-comment">        */</span><br>        TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);<br>    <span class="hljs-comment">//只有p的左右子树都为空才会走下面的if分支</span><br>    <span class="hljs-keyword">if</span> (replacement == p) &#123;  <span class="hljs-comment">// detach</span><br>        TreeNode&lt;K,V&gt; pp = p.parent;<br>        p.parent = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (pp != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (p == pp.left)<br>                pp.left = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == pp.right)<br>                pp.right = <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (movable)<br>        moveRootToFront(tab, r);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>该方法的<code>this</code>指针就指向当前待删除的节点。在代码中我也写了,该方法删除节点有两种视角,因为<code>TreeNode</code>既可以作为RB树的节点,也可以作为双链表的节点。该方法的思路如下:</p><ol><li>首先以双链表的视角,删除当前节点,如果删除后RB树的节点不多于6个,那么就会执行<code>untreeify</code>方法,将RB树退化为单链表</li><li>当前剩余节点多于6,那么以RB树的视角删除当前节点,这里的核心思想是找到一个节点<code>s</code>替换当前待删除节点<code>p</code>。</li><li>如果节点<code>p</code>是红的,那么直接删除就好,因为删除红节点不会影响平衡性</li><li>如果节点<code>p</code>是黑的,删除节点<code>p</code>后,我们需要从从<code>replacement</code>节点开始调整RB树的颜色,这里的<code>replacement</code>是<code>p</code>的左或者右孩子,或者是<code>s</code>交换前的右孩子,或者是p本身</li></ol><p>经过上述四步,已经完成删除节点操作了,当然其中调整RB树平衡性的方法<code>balanceDeletion</code>是重中之重,但是记下来非常困难,看懂理解就好了。该方法的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 如果能进入到这个函数,那么删除的必是黑节点</span><br><span class="hljs-comment">    * 并且从x开始调整RB树的颜色</span><br><span class="hljs-comment">    * 返回的是RB树的根节点</span><br><span class="hljs-comment">    */</span><br><span class="hljs-keyword">static</span> &lt;K,V&gt; <span class="hljs-function">TreeNode&lt;K,V&gt;  <span class="hljs-title">balanceDeletion</span><span class="hljs-params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123;<br>        <span class="hljs-comment">//如果x是根节点,那么不用调整</span><br>        <span class="hljs-comment">//直接返回root</span><br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span> || x == root)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-comment">//如果x的父节点为空,那么x就是新的父节点</span><br>        <span class="hljs-comment">//直接返回x</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((xp = x.parent) == <span class="hljs-keyword">null</span>) &#123;<br>            x.red = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>        <span class="hljs-comment">//如果x是红节点,因为删除了一个黑节点,需要补上一个黑节点,否则破坏了RB树的完美黑平衡</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.red) &#123;<br>            x.red = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">            * 到这里为止,x必是黑色,因为从x到叶子节点的路径中</span><br><span class="hljs-comment">            * 少了一个黑节点,所有必须想办法把这个黑节点从别的地方补回来</span><br><span class="hljs-comment">            * 我们需要关注的节点就是x</span><br><span class="hljs-comment">            * 下面的代码就是在不断地变换x的指针</span><br><span class="hljs-comment">            * 下面的case1的四种情况图示可以参考:http://jackhuang.online/2019/08/09/red-black-tree%E7%AE%80%E4%BB%8B/</span><br><span class="hljs-comment">            *  case2为镜像分布</span><br><span class="hljs-comment">            */</span><br><br>        <span class="hljs-comment">//case1</span><br>        <span class="hljs-comment">//如果x是其父节点的左孩子</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((xpl = xp.left) == x) &#123;<br>            <span class="hljs-comment">//如果x有右兄弟并且右兄弟是红的,那么就把这个红色移到左边来</span><br>            <span class="hljs-comment">//因为x是xp的左孩子</span><br>            <span class="hljs-comment">//case1-1:</span><br>            <span class="hljs-keyword">if</span> ((xpr = xp.right) != <span class="hljs-keyword">null</span> &amp;&amp; xpr.red) &#123;<br>                xpr.red = <span class="hljs-keyword">false</span>;<br>                xp.red = <span class="hljs-keyword">true</span>;<br>                root = rotateLeft(root, xp);<br>                xpr = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.right;<br>            &#125;<br>            <span class="hljs-comment">//向左旋转后,x没有兄弟,重新设置x为xp</span><br>            <span class="hljs-keyword">if</span> (xpr == <span class="hljs-keyword">null</span>)<br>                x = xp;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">/**到此为止,x必有右兄弟,至于黑红目前还不知道</span><br><span class="hljs-comment">                */</span><br>                TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;<br>                <span class="hljs-comment">//如果右兄弟孩子双全并且都是黑孩子</span><br>                <span class="hljs-comment">//或者有一个孩子并且孩子是黑的</span><br>                <span class="hljs-comment">//case1-2:</span><br>                <span class="hljs-keyword">if</span> ((sr == <span class="hljs-keyword">null</span> || !sr.red) &amp;&amp;<br>                    (sl == <span class="hljs-keyword">null</span> || !sl.red)) &#123;<br>                    xpr.red = <span class="hljs-keyword">true</span>;<br>                    x = xp;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//走到这x的右兄弟必有孩子,因为如果没有孩子不会进入这个else分支</span><br>                    <span class="hljs-comment">//如果有一个孩子,那么该孩子必是红的</span><br>                    <span class="hljs-comment">//如果有两个孩子,必然是一个黑色,一个红色,或者两个都是红色</span><br>                    <span class="hljs-comment">/**</span><br><span class="hljs-comment">                        * 在这我们关注的都是xpr的右孩子</span><br><span class="hljs-comment">                        */</span><br><br><br>                    <span class="hljs-comment">//case1-3:如果xpr没有右孩子或者右孩子是黑的</span><br>                    <span class="hljs-keyword">if</span> (sr == <span class="hljs-keyword">null</span> || !sr.red) &#123;<br>                        <span class="hljs-keyword">if</span> (sl != <span class="hljs-keyword">null</span>)<br>                            sl.red = <span class="hljs-keyword">false</span>;<br>                        xpr.red = <span class="hljs-keyword">true</span>;<br>                        root = rotateRight(root, xpr);<br>                        xpr = (xp = x.parent) == <span class="hljs-keyword">null</span> ?<br>                            <span class="hljs-keyword">null</span> : xp.right;<br>                    &#125;<br>                    <span class="hljs-comment">//走到这,xpr的必有右孩子且右孩子是红的</span><br><br><br>                    <span class="hljs-comment">//case1-4</span><br>                    <span class="hljs-keyword">if</span> (xpr != <span class="hljs-keyword">null</span>) &#123;<br>                        xpr.red = (xp == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">false</span> : xp.red;<br>                        <span class="hljs-keyword">if</span> ((sr = xpr.right) != <span class="hljs-keyword">null</span>)<br>                            sr.red = <span class="hljs-keyword">false</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;<br>                        xp.red = <span class="hljs-keyword">false</span>;<br>                        root = rotateLeft(root, xp);<br>                    &#125;<br>                    x = root;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//case2</span><br>        <span class="hljs-comment">//如果x是其父节点的右孩子,这根上面是镜像的</span><br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// symmetric</span><br>            <span class="hljs-keyword">if</span> (xpl != <span class="hljs-keyword">null</span> &amp;&amp; xpl.red) &#123;<br>                xpl.red = <span class="hljs-keyword">false</span>;<br>                xp.red = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-comment">//与上面相似,这里将红色往右边移,因为x是xp的右节点</span><br>                root = rotateRight(root, xp);<br>                xpl = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.left;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (xpl == <span class="hljs-keyword">null</span>)<br>                x = xp;<br>            <span class="hljs-keyword">else</span> &#123;<br>                TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;<br>                <span class="hljs-keyword">if</span> ((sl == <span class="hljs-keyword">null</span> || !sl.red) &amp;&amp;<br>                    (sr == <span class="hljs-keyword">null</span> || !sr.red)) &#123;<br>                    xpl.red = <span class="hljs-keyword">true</span>;<br>                    x = xp;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (sl == <span class="hljs-keyword">null</span> || !sl.red) &#123;<br>                        <span class="hljs-keyword">if</span> (sr != <span class="hljs-keyword">null</span>)<br>                            sr.red = <span class="hljs-keyword">false</span>;<br>                        xpl.red = <span class="hljs-keyword">true</span>;<br>                        root = rotateLeft(root, xpl);<br>                        xpl = (xp = x.parent) == <span class="hljs-keyword">null</span> ?<br>                            <span class="hljs-keyword">null</span> : xp.left;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (xpl != <span class="hljs-keyword">null</span>) &#123;<br>                        xpl.red = (xp == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">false</span> : xp.red;<br>                        <span class="hljs-keyword">if</span> ((sl = xpl.left) != <span class="hljs-keyword">null</span>)<br>                            sl.red = <span class="hljs-keyword">false</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;<br>                        xp.red = <span class="hljs-keyword">false</span>;<br>                        root = rotateRight(root, xp);<br>                    &#125;<br>                    x = root;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>在该方法中,<code>x</code>就是我们一直需要关注的节点,主要思想就是从x开始不断地由下向上调整整颗RB树的颜色,其主要逻辑如下:</p><ol><li>如果<code>x</code>没有父节点或者其本身就是root节点,表示并不需要调整什么</li><li>如果<code>x</code>是红节点,那么把<code>x</code>变黑即可,因为原来从根节点到叶节点包含<code>x</code>的这条路径,少了一个黑节点,这里补上的话就没有什么问题了</li><li>如果<code>x</code>是黑节点,那么比较惨,调整操作就比较复杂了,这里分成了两个大case,每个case里面有四种小case,具体见代码注释,并且这四种小case的图解可以<a href="http://jackhuang.online/2019/08/09/red-black-tree%E7%AE%80%E4%BB%8B/">参考</a>,就像图片的作者所说,我也认为这里不要去怀疑这些移动策略的正确性,仅作了解,看懂了即可。</li></ol>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Queue接口分析</title>
    <link href="/2021-06-03/Queue-interface-analysis.html"/>
    <url>/2021-06-03/Queue-interface-analysis.html</url>
    
    <content type="html"><![CDATA[<h2 id="0x1-基本概念"><a href="#0x1-基本概念" class="headerlink" title="0x1 基本概念"></a>0x1 基本概念</h2><p><code>Queue</code>接口继承自超级接口<code>Collection</code>,其不仅实现了<code>Coolection</code>中的基本方法,而且额外增加了适用于队列的增、删、差方法。并且对应这三种操作,Queue提供了两套方法,一套在操作失败时抛出异常,另一套在操作失败时返回<code>null</code>,不过在文档中说到:</p><blockquote><p>The latter form of the insert operation is designed specifically for use with capacity-restricted Queue implementations</p></blockquote><p>说是后者是专门为容量有限的队列而设计的,why?这点不是很懂。</p><p>更新:2020-07-23 19:12:32</p><p>现在懂了,如果对于<strong>容量有限</strong>的队列,比如<code>ArrayBlockingQueue</code>,它是继承自抽象类<code>AbstractQueue</code>,如果调用其<code>offer</code>方法(在<code>AbstractQueue</code>中实现),添加元素失败后只会返回true,否则返回false。而调用<code>add</code>的话,如果插入失败,就会抛出状态异常。所以说,offer类方法可用于检查队列是否已满,比add类方法优秀点。但是对于<code>LinkedList</code>、<code>ArrayQueue</code>等带自动扩容属性的队列来说,二者效果差不多,不过offer类可以返回操作是否成功的信息。还是推荐使用offer类。</p><p>两组方法如下图所示:</p><p><img src="images/methods.png" alt="methods"></p><h2 id="0x2-抽象类AbstractQueue"><a href="#0x2-抽象类AbstractQueue" class="headerlink" title="0x2 抽象类AbstractQueue"></a>0x2 抽象类AbstractQueue</h2><p>当然,跟<code>Collection</code>接口差不多,<code>Queue</code>也有一个抽象类用于实现一般的方法:</p><figure class="highlight java"><figcaption><span>"AbstractQueue"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractCollection</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    ...<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>可以看到,因为<code>Queue</code>本身就继承自<code>Clooection</code>,所以<code>AbstractQueue</code>的实现继承自<code>AbstractClloection</code>没有任何异议吧。当然为了实现了Queue的特有方法,也实现了接口<code>Queue</code>。下面简单分析一下<code>offer()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (offer(e))<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Queue full&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>add在内部调用了offer,所以用谁不用我多说了吧。不过一开始我看到写法还是一愣,这<code>offer()</code>方法的实现在哪啊?</p><p>后来一想,抽象类不一定要实现嘛,把这个方法留到子类去实现也行奥。</p><h2 id="0x3-Deque接口"><a href="#0x3-Deque接口" class="headerlink" title="0x3 Deque接口"></a>0x3 Deque接口</h2><p>Deque就是<code>double ended queue</code>,也就是所谓的双端队列,什么是双端队列我就不说了,来看看其规定的抽象方法:</p><figure class="highlight java"><figcaption><span>"Deque"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <br>    <span class="hljs-comment">//双端队列方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(E e)</span></span>;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offerFirst</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offerLast</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">removeLast</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">pollFirst</span><span class="hljs-params">()</span></span>;<br> <br>    <span class="hljs-function">E <span class="hljs-title">pollLast</span><span class="hljs-params">()</span></span>;<br> <br>    <span class="hljs-function">E <span class="hljs-title">getFirst</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">getLast</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">peekFirst</span><span class="hljs-params">()</span></span>;<br> <br>    <span class="hljs-function">E <span class="hljs-title">peekLast</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">removeFirstOccurrence</span><span class="hljs-params">(Object o)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">removeLastOccurrence</span><span class="hljs-params">(Object o)</span></span>;<br><br>    <span class="hljs-comment">// 单向队列方法</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">element</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>;<br><br><br>    <span class="hljs-comment">//栈方法</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//重写Collection的部分方法</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Iterator&lt;E&gt; <span class="hljs-title">descendingIterator</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap源码分析(一)-HashMap中的那些常量</title>
    <link href="/2021-06-03/HashMap-analysis-part-one.html"/>
    <url>/2021-06-03/HashMap-analysis-part-one.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HashMap实现了接口<code>Map</code>、<code>Cloneable</code>、<code>Serializable</code>,后两个都是标记接口,注意HasnMap的<code>clone</code>方法也仅仅是浅复制(shadow copy)。而<code>Map</code>是跟<code>Collection</code>并列的顶级接口。HashMap并且继承抽象类<code>AbstractMap</code>。</p><p>本文将首先简单说说接口<code>Map</code>,因为<code>AbstarctMap</code>作为实现接口<code>Map</code>的骨架,仅实现了一些基本方法,没什么好说的。</p><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br>    ...<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>Map提供了三种方法来遍历自身:</p><ul><li>通过<code>keySet()</code>方法返回Map中所有键组成的Set</li><li>通过<code>values()</code>返回Map中values组成的Collection</li><li>通过<code>entrySet()</code>返回由<code>Map.Entry</code>组成的Set</li></ul><p>前两种都比较常规。值得一提的是第三种方式中的<code>Map.Entry</code>。在<code>Map</code>接口定义了一个内部接口<code>Entry</code>。Entry维护了一组键值对,类似于c++HashMap中的pair结构。这个Entry结构只能通过Map的迭代器获得。并且这些Entry集合<strong>只</strong>在遍历的过程中有效,如果在遍历过程中修改了集合,那么对Entry的操作是未定义的,除非使用Entry定义的<code>setValue()</code>方法。</p><h2 id="1-HashMap中的常量"><a href="#1-HashMap中的常量" class="headerlink" title="1. HashMap中的常量"></a>1. HashMap中的常量</h2><p>HashMap中定义了一些比较重要的常量,如下所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//默认初始容量,必须是2的倍数</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br><br><span class="hljs-comment">//HashMap最大的容量,也就是2^30,因为必须是2的倍数</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br><span class="hljs-comment">//扩容因子,如果当前存储的Entry个数达到容量的75%,那么就进行扩容</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The bin count threshold for using a tree rather than list for a</span><br><span class="hljs-comment"> * bin.  Bins are converted to trees when adding an element to a</span><br><span class="hljs-comment"> * bin with at least this many nodes. The value must be greater</span><br><span class="hljs-comment"> * than 2 and should be at least 8 to mesh with assumptions in</span><br><span class="hljs-comment"> * tree removal about conversion back to plain bins upon</span><br><span class="hljs-comment"> * shrinkage.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//当一条链表上的数据容量达到8时就采用红黑树存储</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The bin count threshold for untreeifying a (split) bin during a</span><br><span class="hljs-comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span><br><span class="hljs-comment"> * most 6 to mesh with shrinkage detection under removal.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//当一条链表上的数据少于等于6个时,就从红黑树转为链表存储一个桶中的数据</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The smallest table capacity for which bins may be treeified.</span><br><span class="hljs-comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span><br><span class="hljs-comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span><br><span class="hljs-comment"> * between resizing and treeification thresholds.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//如果一旦采用红黑树存储,那么HashMap的容量至少为64</span><br><span class="hljs-comment">//当然用红黑树存储一个桶中的数据时,那么就至少是4*TREEIFY_THRESHOLD的容量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;<br></code></pre></div></td></tr></table></figure><p>下面将罗列一些常见的关于HashMap常量的问题。</p><h3 id="1-1-为什么Map的容量都是2的整数幂"><a href="#1-1-为什么Map的容量都是2的整数幂" class="headerlink" title="1.1 为什么Map的容量都是2的整数幂?"></a>1.1 为什么Map的容量都是2的整数幂?</h3><p>有两个理由:</p><ul><li>寻找bucket索引更快</li><li>让扩容方法resize()效率更高，在理想情况下，能够等概率地将一个长链表分为两半，一半在原位置，一半移动到新扩容的地方</li></ul><p>对于第一点,因为在JDK8中,HashMap计算bucket的索引方法如下:</p><blockquote><p>i = (n - 1) &amp; hash == hash % n == (n-1) &amp; (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</p></blockquote><p>tab就是用来存储bucket的数组。n是数组的容量。如果n是2的整数幂,那么<code>(n-1)&amp; hash== hash% n</code>,其中hash是一个32位整数。没错,就是这么神奇。这样计算索引只需移位操作,比取模更快。所以都是2的整数幂。</p><p>对于第二点:每次HashMap扩容都是变为原来的两倍,扩容是一个代价高昂的操作。在扩容时不仅需要复制元素,而且需要更新对应的索引。如果HashMap的容量都是2的整数幂。那么它的索引要么在原来位置,要么偏移了2的整数次幂(<strong>偏移了原始容量的距离</strong>)。</p><p>对于这一点,我们随便设一个hash做验证,令hashcode=0x00008435。未扩容前的容量为2^4=16。那么当前计算出的索引:</p><blockquote><p>0000 0000 0000 0000 1000 0100 0001 0101 -&gt; hash<br>0000 0000 0000 0000 0000 0000 0000 1111 -&gt; n-1</p></blockquote><p>计算出的索引为:0101b &amp; 1111b=101b=5。现在将容量扩张为原来的2倍:</p><blockquote><p>0000 0000 0000 0000 0000 0000 0001 1111 -&gt; n-1</p></blockquote><p>计算出的索引为:11111b &amp; 10101b=10101b=21。索引移动了2的整数幂。再将容量扩充为原来的2倍:</p><blockquote><p>0000 0000 0000 0000 0000 0000 0011 1111 -&gt; n-1</p></blockquote><p>计算出的索引为:111111b &amp; 010101b=10101b=21。索引没有变化。</p><p>从上面的结果可以看出,索引动与不动随机的取决于hashcode某1bit是0还是1。后者是0还是1的概率为0.5。</p><p>将容量扩充为原来的两倍的同时,也公平的将每个桶的容量也扩充为原来的两倍,因为桶中的元素移动于不移动完全是等概率的,取决于hashcode某bit是1还是0。</p><blockquote><p>值得注意的是,JDK1.8中,HashMap扩容不会讲链表倒置,而JDK1.7会</p></blockquote><h3 id="1-2-为什么hash要这么计算"><a href="#1-2-为什么hash要这么计算" class="headerlink" title="1.2 为什么hash要这么计算?"></a>1.2 为什么hash要这么计算?</h3><p>在JDK1.8中,Map计算hashcode采用了新的方法:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-comment">//null的hash为0</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>    <span class="hljs-comment">//这里调用的key的hashCode方法,实际上调用的key的具体实现类,而不是Object的hashCode</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>是将key的hash高16位于低16位进行异或。最后的hash高16位还是原来的高16位,低16位是异或后的结果。为什么要这么做呢?</p><p>简单来说是为了增加hash的随机性。比如两个整数:365(11110101b),165(01110101b)。如果只采用Integer自己实现的hash算法,那么计算出来的hash就是365于165。</p><p>现在进行索引的计算(map容量为16):<code>(n-1) &amp; 16</code>。计算出的结果都为<code>101b</code>,发生了hash碰撞。但是这两个数差别还是蛮大的。所以将对象的原始hash的高16位与低16位异或,这么做也是为了在低16中保留高16位的特性,加大低16位的随机性。</p><p>所以说最终目的就是为了<strong>防止hash碰撞</strong>。JDK1.7的hash算法并不怎么随机,曾经产生了dos攻击。<a href="https://coolshell.cn/articles/6424.html">HASH COLLISION DOS 问题</a></p><p><strong>最后,null的hash为0!</strong></p><h3 id="1-3-为什么HashMap的默认容量为16"><a href="#1-3-为什么HashMap的默认容量为16" class="headerlink" title="1.3 为什么HashMap的默认容量为16?"></a>1.3 为什么HashMap的默认容量为16?</h3><p>既然HashMap的容量必须是2的整数幂,那么为什么不是2,4,或者16,32。emm,这个问题我在网上看到的回答是:</p><blockquote><p>如果是2、4、8之类的,容量太小,容易导致频繁扩容。上文说过,扩容代价很高的。而不设置成32、64等更大的值是因为太大了,用到的概率不大。避免浪费空间。</p></blockquote><p>这个答案还行吧,好像有那么一点道理。</p><h3 id="1-4-为什么桶中节点数到8才采用RB树"><a href="#1-4-为什么桶中节点数到8才采用RB树" class="headerlink" title="1.4 为什么桶中节点数到8才采用RB树?"></a>1.4 为什么桶中节点数到8才采用RB树?</h3><p>答案存在于源码中的开发笔记。这里仅摘抄最重要的部分。</p><blockquote><p>Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use(see TREEIFY_THRESHOLD). And when they become too small (due to removal or resizing) they are converted back to plain bins.  In usages with well-distributed user hashCodes, tree bins are rarely used.  Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution (<a href="http://en.wikipedia.org/wiki/Poisson_distribution">http://en.wikipedia.org/wiki/Poisson_distribution</a>) with a parameter of about 0.5 on average for the default resizing threshold of 0.75, although with a large variance because of resizing granularity.</p></blockquote><p>大致意思是说,采用红黑树的存储所消耗的空间是采用链表存储的两倍。所以仅在链表中数据足够多的情况下会转为红黑树存储,当节点数减少到一定数量,就会再次退化为链表存储。<strong>如果使用足够好的hash算法</strong>,那么计算出的hashcode应该是足够分散的。</p><p>在理想hash下,每个桶中的节点数符合参数为0.5的泊松分布。分布公式为<code>(exp(-0.5) * pow(0.5, k) / * factorial(k))</code>。通过公式的计算,每个桶中各个节点数出现的情况如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">0</span>:    <span class="hljs-number">0.60653066</span><br><span class="hljs-number">1</span>:    <span class="hljs-number">0.30326533</span><br><span class="hljs-number">2</span>:    <span class="hljs-number">0.07581633</span><br><span class="hljs-number">3</span>:    <span class="hljs-number">0.01263606</span><br><span class="hljs-number">4</span>:    <span class="hljs-number">0.00157952</span><br><span class="hljs-number">5</span>:    <span class="hljs-number">0.00015795</span><br><span class="hljs-number">6</span>:    <span class="hljs-number">0.00001316</span><br><span class="hljs-number">7</span>:    <span class="hljs-number">0.00000094</span><br><span class="hljs-number">8</span>:    <span class="hljs-number">0.00000006</span><br></code></pre></div></td></tr></table></figure><p>可以看到,一个桶中出现出现8个节点的概率为千万分之六。几乎是不可能出现的情况。当然,回归现实,不可能每次都出现理想hash。所以采用8个节点作为分界点。一个桶中达到8个节点,就转为红黑树存储。</p><p>这里又可以引申出一个问题,<strong>为什么泊松分布的参数要设置为0.5?</strong></p><blockquote><p>emmm,从注释中看,应该也是一个经验值吧。</p></blockquote><h3 id="1-5-为什么桶中节点数减少为6才采用链表"><a href="#1-5-为什么桶中节点数减少为6才采用链表" class="headerlink" title="1.5 为什么桶中节点数减少为6才采用链表?"></a>1.5 为什么桶中节点数减少为6才采用链表?</h3><p>在节点数减少到6时才桶中元素采用RB树转为链表,为什么不是5或者7?</p><p>不设置为5、4、3的原因显而易见,节点太少,用红黑树存储从空间角度上来说不划算,因为是链表存储的2倍。</p><p>那么为什么不设置为7呢?</p><p>因为如果设置为7,那么加一个entry,变为8就要升级红黑树,减一个entry就变为7降级为链表。如果对HashMap频繁的进行增删操作,那么桶的存储方式就得频繁的在红黑树和链表之间转换,这个开销是不可忽视的。所以设为6,有一个缓冲的空间。</p><h3 id="1-6-为什么factor设为0-75"><a href="#1-6-为什么factor设为0-75" class="headerlink" title="1.6 为什么factor设为0.75?"></a>1.6 为什么factor设为0.75?</h3><p>在官方注释中,下面的节选部分解释了为什么<code>load factor</code>是0.75。</p><blockquote><p>As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs.  Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the <tt>HashMap</tt> class, including <tt>get</tt> and <tt>put</tt>).  The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of<br>rehash operations.  If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.</p></blockquote><p>简而言之,0.75是一个经验值,在时间和空间两个方面达到了平衡。<strong>这也就解释为什么不是0.5或是1?</strong></p><p>如果factor是<strong>0.5</strong>,那么就会导致map频繁扩容,代价比较高。而且空间利用率也比较低。但是链表中的内容或者RB树的节点就比较少,提升了查询效率。<strong>是以空间换时间的方式。</strong></p><p>如果factor设置为<strong>1</strong>,虽然空间利用率达到了100%,在使用完才会扩容,一定程度增加了put的时间。并且可能会发生大量的hash碰撞,此时的查询效率是非常低的。<strong>是以时间换空间的方式。</strong></p><p><strong>那么为什么不是0.6或者0.8?</strong></p><p>首先如果<code>load factor</code>为0.75,那么每次<code>load factor * capacity</code>都会得到一个整数。</p><p>其次,在StackOverflow上有一个<a href="https://stackoverflow.com/questions/10901752/what-is-the-significance-of-load-factor-in-hashmap">回答</a>,采用了二项分布的方式计算出了<code>load factor</code>与<code>capacity</code>的最佳比例:</p><p>他首先规定,在完美情况下,在每次插入时所选取的桶应该是一个空桶。泊松分布的极限就是二项分布。在n次插入实验中,每次插入都选取空桶的概率总和应该为0.5。计算公式为:</p><blockquote><p>1/2=P=C(n, 0) * (1/s)^0 * (1 - 1/s)^(n - 0),其中s是桶的数量,n是试验次数</p></blockquote><p>我一直不明白<code>1/s</code>代表的是什么?每次都选取的是非空桶?那么解释不了<code>1/s</code>啊。而且StackOverflow新人还不能评论,可恶啊。</p><p>进行简单变化,在s趋于正无穷时,<code>n/s=load factor</code>趋近于<code>ln(2)</code>。所以他得出load facotr在<code>ln(2)~0.75</code>之间HashMap都能有很出色的表现。</p><p>我对上述回答产生了如下疑问:</p><ol><li>也不一定要求每次插入都必须要求空桶吧?</li><li><code>1/s</code>的数学意义到底代表着什么?</li></ol><h2 id="2-HashMap的属性"><a href="#2-HashMap的属性" class="headerlink" title="2. HashMap的属性"></a>2. HashMap的属性</h2><p>HashMap中的magic number在上面已经分析过,下面是HashMap的一些属性:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The table, initialized on first use, and resized as</span><br><span class="hljs-comment">* necessary. When allocated, length is always a power of two.</span><br><span class="hljs-comment">* (We also tolerate length zero in some operations to allow</span><br><span class="hljs-comment">* bootstrapping mechanics that are currently not needed.)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//用来存储bucket的底层数组,无论是初始化HashMap还是扩容,容量一直都是2的整数幂</span><br><span class="hljs-comment">//当然上面也指出了在某些时候允许长度为0,从而允许一些当前不需要的引导机制????这是啥意思</span><br><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Holds cached entrySet(). Note that AbstractMap fields are used</span><br><span class="hljs-comment">* for keySet() and values().</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The number of key-value mappings contained in this map.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//这是HashMap中实际的Entry数量,不是容量哦</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The number of times this HashMap has been structurally modified</span><br><span class="hljs-comment">* Structural modifications are those that change the number of mappings in</span><br><span class="hljs-comment">* the HashMap or otherwise modify its internal structure (e.g.,</span><br><span class="hljs-comment">* rehash).  This field is used to make iterators on Collection-views of</span><br><span class="hljs-comment">* the HashMap fail-fast.  (See ConcurrentModificationException).</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//modCount曾在分析ArrayList的源码解释过,用于支持fast-fail机制,从而也说明HashMap是线程不安全的</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The next size value at which to resize (capacity * load factor).</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// (The javadoc description is true upon serialization.</span><br><span class="hljs-comment">// Additionally, if the table array has not been allocated, this</span><br><span class="hljs-comment">// field holds the initial array capacity, or zero signifying</span><br><span class="hljs-comment">// DEFAULT_INITIAL_CAPACITY.)</span><br><br><span class="hljs-comment">//注释中的大致意思就是下一次扩容时的容量,如果HashMap还未初始化,那么就存储初始化的容量,或者0(表示默认初始化容量)</span><br><span class="hljs-keyword">int</span> threshold;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The load factor for the hash table.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//HashMap的装载因子,一旦确定,不可更改</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;<br></code></pre></div></td></tr></table></figure><p>更新:2020-08-02 18:57:49</p><p><code>HashMap</code>中的<code>threshold</code>=<code>loadFactor*capacity</code>,并<strong>不是</strong>下一次扩容的容量,当然如果HashMap还未初始化,并且用户指定了初始化容量,那么存储的就是根据用户指定容量计算出的元素数量阈值,否则0就是表示默认值12。       </p><p><code>table</code>数组的元素是Node,这又是什么呢?来一起康康:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>        <span class="hljs-comment">//key的Hash值,是一个32bit的int,不可更改</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;<br>        <span class="hljs-comment">//key,不可更改</span><br>        <span class="hljs-keyword">final</span> K key;<br>        V value;<br>        <span class="hljs-comment">//next指针,因为刚开始就是使用链表存储的Entry的</span><br>        Node&lt;K,V&gt; next;<br>        <span class="hljs-comment">//构造函数</span><br>        <span class="hljs-comment">//注意:没有默认构造函数</span><br>        Node(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-keyword">this</span>.hash = hash;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.value = value;<br>            <span class="hljs-keyword">this</span>.next = next;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span>        </span>&#123; <span class="hljs-keyword">return</span> key; &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span>      </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">&quot;=&quot;</span> + value; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">setValue</span><span class="hljs-params">(V newValue)</span> </span>&#123;<br>            V oldValue = value;<br>            value = newValue;<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Map.Entry) &#123;<br>                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;<br>                <span class="hljs-keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;<br>                    Objects.equals(value, e.getValue()))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>从上面可以看出,Node是在HashMap使用链表存储模式时一组key-value的wrapper类。而<code>Map.Entry</code>是在<code>Map</code>接口中定义的一个内部接口,规定了一些<code>Entry</code>必须实现的方法。基本上就可以说这个<code>Entry</code>就相当于c++中的<code>pair</code>结构。保存一对key-value。<code>Entry</code>的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-function">K <span class="hljs-title">getKey</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">V <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">V <span class="hljs-title">setValue</span><span class="hljs-params">(V value)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K extends Comparable&lt;? <span class="hljs-keyword">super</span> K&gt;, V&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByKey() &#123;<br>        <span class="hljs-keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)<br>            (c1, c2) -&gt; c1.getKey().compareTo(c2.getKey());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V extends Comparable&lt;? <span class="hljs-keyword">super</span> V&gt;&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByValue() &#123;<br>        <span class="hljs-keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)<br>            (c1, c2) -&gt; c1.getValue().compareTo(c2.getValue());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey(Comparator&lt;? <span class="hljs-keyword">super</span> K&gt; cmp) &#123;<br>        Objects.requireNonNull(cmp);<br>        <span class="hljs-keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)<br>            (c1, c2) -&gt; cmp.compare(c1.getKey(), c2.getKey());<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue(Comparator&lt;? <span class="hljs-keyword">super</span> V&gt; cmp) &#123;<br>        Objects.requireNonNull(cmp);<br>        <span class="hljs-keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)<br>            (c1, c2) -&gt; cmp.compare(c1.getValue(), c2.getValue());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在<code>Entry</code>中定义了四个获取比较器的静态方法,对于不熟悉java8新语法的同学来说,静态方法内部的实现可能让人摸不着头脑。</p><p>首先,<code>(c1, c2) -&gt; c1.getKey().compareTo(c2.getKey());</code>其实是lambda表达式,它的一般格式如下:</p><blockquote><p>(type1 arg1,type2 arg2…)-&gt;{ body…}</p></blockquote><p>lambda有<a href="http://blog.oneapm.com/apm-tech/226.html">以下特点</a>:</p><ul><li>一个 Lambda 表达式可以有零个或多个参数</li><li>参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同</li><li>所有参数需包含在圆括号内，参数之间用逗号相隔。例如：(a, b) 或 (String a, int b, float c)<br>空圆括号代表参数集为空。例如：() -&gt; 42</li><li>当只有一个参数，且其类型可推导时，<strong>圆括号</strong>（）可省略。例如：a -&gt; return a*a</li><li>Lambda 表达式的主体可包含零条或多条语句</li><li>如果 Lambda 表达式的主体只有<strong>一条</strong>语句，<strong>花括号</strong>{}可省略。匿名函数的返回类型与该主体表达式一致</li><li>如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</li></ul><p>关于lambda表达式更高级知识可以了解一下函数式语言中的闭包,java中的lambda就是最接近闭包的概念。</p><p>接下来再看看为什么一个lambda表达式能够强转为接口。<code>Comparator</code>是一个函数式接口(<code>@FunctionalInterface</code>)。函数式接口的标准就是其内部只能定义一个抽象方法。在java8中,每个lambda表达式都能隐式的赋值给函数时接口。当然lambda表达式的返回值和参数得和接口中定义的抽象方法一样才行。</p><p>然而我们去实际看<code>Comparator</code>接口源码时,却发现<code>Comparator</code>有两个抽象方法:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(T o1, T o2)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span>;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>竟然和函数式接口的定义不一样?然而答案在<code>FunctionInterface</code>的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html">官方文档</a>中。</p><blockquote><p>If an interface declares an abstract method overriding one of the public methods of java.lang.Object, that also does not count toward the interface’s abstract method count since any implementation of the interface will have an implementation from java.lang.Object or elsewhere.</p></blockquote><p>意思就是说如果函数式接口的抽象方法如果重写自<code>object</code>,那么是不计入函数式接口定义的方法个数中的,因为<code>Object</code>中的方法肯定都会在自身中实现或者override于其他地方。</p><p>最后强转的类型是竟然是<code>(Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</code>,两个类型还能进行与操作?</p><p>其实这也是java8中的新语法,StackOverflow上关于此问题的<a href="https://stackoverflow.com/questions/28509596/java-lambda-expressions-casting-and-comparators">回答</a>如下:</p><blockquote><p>The lambda is initialized with its target type as Comparator and Serializable. Note the return type of method is just Comparator, but because Serializable is also inscribed to it while initialization, it can always be serialized even though this message is lost in method signature.</p></blockquote><p>简而言之就是lambda表达式的初始化的目标类型是<code>Comparator</code>和<code>Serializable</code>。但是最后的<strong>返回类型</strong>却只是<code>Comparator</code>,但是<code>Serializable</code>类型已经在表达式初始化时注册(inscribe)过了。所以尽管在函数签名中丢失了该信息,但是返回值是一定总是可以初始化的。</p><p>ok,经过上述的简单科普,相信返回比较器的代码实现已经不是问题了。上述所有的点都是java8的新语法,包括在接口中定义<code>default</code>方法和<code>static</code>方法。</p><h2 id="3-HashMap的构造方法"><a href="#3-HashMap的构造方法" class="headerlink" title="3. HashMap的构造方法"></a>3. HashMap的构造方法</h2><p><code>HashMap</code>总共有4个构造方法,除了<code>HashMap(Map&lt;? extends K, ? extends V&gt; m)</code>以外,其他3个构造函数都是仅仅设置装载因子<code>load factor</code>,在这三个构造函数中,除了默认构造函数,<del>另外两个都会设置初始容量</del>。</p><p><del>这里传入的初始容量仅仅是为了设置threshold,而不是设置初始容量</del>,这里再次收回所说的话,虽然表面上看仅仅是将传入容量修正为最近的2的整数幂,并赋值给threshold。</p><p><strong>但是在第一次put元素时</strong>,会将刚才设置好的threshold赋值给table的新容量,也就实现的指定HashMap的容量的操作。但是这三个构造都不会进行table内存的分配,<strong>只会在第一次put时调用resize()进行分配</strong>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +<br>                                           initialCapacity);<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                           loadFactor);<br>    <span class="hljs-keyword">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br><br><span class="hljs-comment">//默认构造函数不会设置threshold</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span><br>&#125;<br><br><span class="hljs-comment">//会在putEntries中设置threshold    </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>    putMapEntries(m, <span class="hljs-keyword">false</span>);<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>在第四个使用<code>Map</code>对象构造HashMap的构造函数中,其调用了<code>putMapEntries(Map,boolean)</code>方法,这个函数值得一提,因为其第二个参数的意义会在后面用到:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Implements Map.putAll and Map constructor.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> m the map</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> evict false when initially constructing this map, else</span><br><span class="hljs-comment">     * true (relayed to method afterNodeInsertion).</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putMapEntries</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m, <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> s = m.size();<br>        <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (table == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// pre-size</span><br>                <span class="hljs-comment">//下面的操作是在计算完全存储m中的元素需要的capacity,注意不是threshold</span><br>                <br>                <span class="hljs-comment">//下面的加1.0F是为在计算出的loadFactor为小数时向上取整</span><br>                <span class="hljs-keyword">float</span> ft = ((<span class="hljs-keyword">float</span>)s / loadFactor) + <span class="hljs-number">1.0F</span>;<br>                <span class="hljs-keyword">int</span> t = ((ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY) ?<br>                         (<span class="hljs-keyword">int</span>)ft : MAXIMUM_CAPACITY);<br>                <span class="hljs-comment">//查看所需的capacity是否比当前HashMap的扩容阈值还大,比阈值还大的情况下,不可能存储下m的所有元素,即使当前HashMap为空</span><br>                <span class="hljs-comment">//那么就需要更新当前HashMap的阈值</span><br>                <span class="hljs-keyword">if</span> (t &gt; threshold)<br>                    threshold = tableSizeFor(t);<br>            &#125;<br>            <span class="hljs-comment">//当调用HashMap的putAll方法时,会再次调用该方法执行到下面的else if </span><br>            <span class="hljs-comment">//这里的resize相当于一次预判,如果m的元素个数比当前hashmap的元素个数阈值threshold还高的话</span><br>            <span class="hljs-comment">//那么即使当前HashMap为空,也无法存储m的所有元素,所以必须扩容</span><br>            <span class="hljs-comment">//当然即使s&lt;=threshold,当前HashMap还是有可能存储不下,这会在putVal内部进行扩容</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &gt; threshold)<br>                resize();<br>            <span class="hljs-keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;<br>                K key = e.getKey();<br>                V value = e.getValue();<br>                putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, evict);<br>            &#125;<br>        &#125;<br>    &#125; <br></code></pre></div></td></tr></table></figure><p>在<code>else if</code>中的扩容操作体现了HashMap的扩容懒汉模式,仅仅在已经确定没有足够空间存储的情况中才会进行扩容操作,因为扩容操作的代价太高了。</p><p><strong>evict参数:</strong></p><p>如果当前<code>HashMap</code>的table还未进行分配,那么就会将参数<code>evict</code>设置为false,表示当前正处于构造模式。这个单词本身的意思具有驱逐的意思,主要应用于<code>LinkedHashMap</code>构造<code>LRU</code>时使用。与<code>HashMap</code>中的意义不同。</p><p>最后代码中经常使用<code>tableSizeFor(int)</code>方法就是把用户输入的容量调整到最近的2的整数幂。其代码与<code>ArrayQueue</code>的调整方式基本一致。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACIT      Y : n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>唯一与<code>ArrayQueue</code>不同的时,当把容量调整到离cap最近的2的整数幂-1时:</p><ul><li>如果已经溢出,那么会将容量设为1</li><li>如果此时的容量小于<code>2^31</code>但是大于<code>2^30</code>,那么就将容量修正为<code>2^30</code></li><li>否则最新容量就是最近的2的整数幂。</li></ul><p><a href="https://stackoverflow.com/questions/857420/what-are-the-reasons-why-map-getobject-key-is-not-fully-generic">为什么HashMap的get方法没有写成泛型？</a></p><h2 id="0x3-JDK1-8与JDK1-7的HashMap异同"><a href="#0x3-JDK1-8与JDK1-7的HashMap异同" class="headerlink" title="0x3 JDK1.8与JDK1.7的HashMap异同"></a>0x3 JDK1.8与JDK1.7的HashMap异同</h2><ol><li><p>实现方式不同,在JDK1.7中,HashMap采用数组+链表的方式实现,1.8则采用数组+链表+红黑树实现。</p></li><li><p>扩容与插入顺序不同,1.7在链表中扩容是需要时再扩,也就是在插入时发现实在没办法插入再进行扩容,然后重新完成插入操作。我认为这很正常,没地方放再扩容不是正常逻辑?<br>JDK1.8中是先把节点放入map中,最后再决定是否要调用<code>resize</code>,我认为这是因为1.8中链表和RB树会进行相互转换。如果先进行扩容,那么本来需要进行树化的链表由于扩容被迫拆为两条小链表,可能会浪费空间。例如链表为7个,插入后为8个需要进行树化,但是先扩容导致该链表的长度减为4,又不需要树化了。</p></li><li><p>链表的插入顺序不同,1.7中是采用头插法,1.8中采用尾插法。</p></li></ol><h2 id="0x4-JDK1-7的HashMap中存在的问题"><a href="#0x4-JDK1-7的HashMap中存在的问题" class="headerlink" title="0x4 JDK1.7的HashMap中存在的问题"></a>0x4 JDK1.7的HashMap中存在的问题</h2><ol><li>死循环问题,因为1.7中采用头插法,在多线程环境下进行扩容操作时(resize过后在调用transfor时可能会出现问题)可能会形成循环链表,导致在进行get操作时陷入死循环。这种情况出现在原hashmap中有:3-&gt;5-&gt;7,扩容后的hashmap分割为：5-&gt;3和7，这时可能会产生死循环</li></ol><p>对于1.7hashmap的transform方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Entry[] newTable)</span> </span>&#123;<br>    Entry[] src = table;<br>    <span class="hljs-keyword">int</span> newCapacity = newTable.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; src.length; j++) &#123;<br>        Entry&lt;K,V&gt; e = src[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            src[j] = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">do</span> &#123;<br>                Entry&lt;K,V&gt; next = e.next;<br>                <span class="hljs-keyword">int</span> i = indexFor(e.hash, newCapacity);<br>                <span class="hljs-comment">//如果线程1在这就被挂起，那么当前这个do...while循环本身就不会结束</span><br>                e.next = newTable[i];<br><br>                <span class="hljs-comment">//死循环产生点</span><br>                <span class="hljs-comment">//线程1正准备执行下面一句时被挂起，才会出现get时死循环</span><br>                newTable[i] = e;<br>                <br>                e = next;<br>            &#125; <span class="hljs-keyword">while</span> (e != <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="2"><li>数据丢失问题,同样是因为头插法,原始链表的末尾数据可能会产生丢失问题。</li></ol><p>这种情况出现在原hashmap中有:3-&gt;5-&gt;7,扩容后的hashmap分割为：7-&gt;3和5，这时可能会丢失数据3。详情见：<a href="https://www.cnblogs.com/bendandedaima/p/13259284.html">HashMap为什么线程不安全（死循环+数据丢失过程分析）</a></p><h2 id="0x5-JDK1-8的HashMap中存在的问题"><a href="#0x5-JDK1-8的HashMap中存在的问题" class="headerlink" title="0x5 JDK1.8的HashMap中存在的问题"></a>0x5 JDK1.8的HashMap中存在的问题</h2><p>仍然会出现死循环以及数据丢失的问题。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">....<br><span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>    tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>...<br></code></pre></div></td></tr></table></figure><p>上述是<code>putVal</code>中的部分代码,在多线程环境下,如果线程1已经通过if检查但是被迫放弃cpu,而线程2因为hash相同已经完成了插入操作,线程1重新获取cpu,此时再进行插入就会覆盖线程2插入的线程。</p><p>数据丢失问题是多线程环境下必然产生的问题。而1.8下的死循环原因却不相同,在对链表进行树化(<code>treeify</code>)或者调整树平衡(<code>balanceInsertion</code>)时仍然会产生死循环问题。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://runzhuoli.me/2018/09/20/why-hashmap-size-power-of-2.html">为什么容量都是2的整数幂</a></p></li><li><p><a href="https://albenw.github.io/posts/df45eaf1/">关于HashMap的一些理解</a></p></li><li><p><a href="https://blog.csdn.net/reliveIT/article/details/82960063?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param">HashMap defaultLoadFactor = 0.75和泊松分布没有关系</a></p></li><li><p><a href="https://juejin.im/post/5d5d25e9f265da03f66dc517">HashMap面试必问的6个点，你知道几个</a></p></li><li><p><a href="https://www.cnblogs.com/liang1101/p/12728936.html">1.7与1.8HashMap的异同</a></p></li><li><p><a href="https://stackoverflow.com/questions/10901752/what-is-the-significance-of-load-factor-in-hashmap">1.8散列因子为0.75的可能原因</a></p></li><li><p><a href="https://www.cnblogs.com/xrq730/p/5037299.html">1.7中HashMap存在的问题</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap源码分析(二)-插入源码</title>
    <link href="/2021-06-03/HashMap-analysis-part-two.html"/>
    <url>/2021-06-03/HashMap-analysis-part-two.html</url>
    
    <content type="html"><![CDATA[<p>HashMap中最常用的就是<code>put(key,value)</code>函数与<code>remove</code>函数,而且这些函数还会包含RB树与list的相互转换,比较复杂。值得认真推敲。</p><h2 id="1-put方法"><a href="#1-put方法" class="headerlink" title="1. put方法"></a>1. put方法</h2><p>下面JDk1.8中,HashMap的<code>put</code>源码。其又在内部调用了<code>putVal</code>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>...<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)</code>有四个参数,其中前两个参数都好理解。第三个参数<code>onlyIfAbsent</code>为一个标志位:</p><ul><li>如果为false,表示对于相同key的value会进行覆盖</li><li>为true则不会进行覆盖</li></ul><p><strong>在<code>HashMap</code>默认对相同key的value进行覆盖。</strong> 最后一个参数<code>evict</code>已在介绍<code>putEntries</code>方法时介绍过。在<code>HashMap</code>表示是否处于创建模式,<strong>默认为false</strong>。</p><p>在深入分析<code>putVal</code>方法之前,需要先了解一下<code>resize()</code>方法,下面是其源码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Initializes or doubles table size.  If null, allocates in</span><br><span class="hljs-comment">    * accord with initial capacity target held in field threshold.</span><br><span class="hljs-comment">    * Otherwise, because we are using power-of-two expansion, the</span><br><span class="hljs-comment">    * elements from each bin must either stay at same index, or move</span><br><span class="hljs-comment">    * with a power of two offset in the new table.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> the table</span><br><span class="hljs-comment">    */</span><br><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-keyword">int</span> oldThr = threshold;<br>    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//如果HashMap不为空,已经是存储过元素了才会不为空</span><br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//如果当前容量已经超过最大容量了,已经没办法扩大了,那么就只会更新存储个数的阈值,只能利用剩下的25%空间</span><br>        <span class="hljs-comment">//无需进行复制</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">//这就是常规的对容量进行扩充一倍的操作</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                    <span class="hljs-comment">//如果原始容量太小,那么threshold就会在后面进行自动计算</span><br>                    <span class="hljs-comment">//比如原始容量为4,原始threshold为3,但是newThr通过原始threshold左移一位也能正确</span><br>                    <span class="hljs-comment">//得出答案啊,为啥还要多此一举?</span><br>                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-comment">//仅仅是调用了能够设置初始容量的构造函数,但是还未put值</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;<br>    <span class="hljs-comment">//如果当前HashMap的table还未分配,也就是调用默认的无参构造函数</span><br>    <span class="hljs-comment">//此时threshold=0,就是分配默认大小的table</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//新的容量就是默认的初始化容量为16</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        <span class="hljs-comment">//设置新的threshold,新的threshold就是12</span><br>        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-comment">//执行下面if语句只会有两种情况发生,一种就是调用能够设置初始容量的构造函数但还未put元素</span><br>    <span class="hljs-comment">//另外一种就是当前HashMap已经有元素,但是当前容量小于默认容量,也就是小于16</span><br>    <span class="hljs-comment">//因为如果调用默认构造函数,那么threshold在上面已经分配</span><br>    <span class="hljs-comment">//如果HashMap中已经有元素,也会直接设置好</span><br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//通过用户的指定的容量进行threshold的计算</span><br>        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?<br>                    (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];<br>    table = newTab;<br>    <span class="hljs-comment">//已经设置好新的容量与新的threshold,如果原始HashMap不为空,那么就进行元素的复制</span><br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//逐个拷贝</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)<br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    <span class="hljs-comment">//如果是使用红黑树存储的,那么就把一棵树分裂成两颗树?这留着后面再分析</span><br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                    <span class="hljs-comment">//HashMap会把一个完整的链表分成高低两个链表,每个链表的具体个数取决元素hash的某一bit是否为1,概率各为50%,高表示当前使用的bit位为1,低表示bit位为0</span><br>                    <span class="hljs-comment">//所以理想情况下分成两个长度相等的链表</span><br><br>                    <span class="hljs-comment">//低链表的头尾</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<br>                    <span class="hljs-comment">//高链表的头尾</span><br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        <span class="hljs-comment">//尾插法</span><br>                        next = e.next;<br>                        <span class="hljs-comment">//低链表,如果当前使用的bit为0,那么就使用尾插法加入到链表中</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">//这里为什么需要判断非null呢?因为有可能运气不好,元素全部聚集到low链表或high链表中</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;<br>                        loTail.next = <span class="hljs-keyword">null</span>;<br>                        <span class="hljs-comment">//如果是low链表,那么索引就会保持原位置不动</span><br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-keyword">null</span>;<br>                        <span class="hljs-comment">//如果是high表,那么索引就会偏移原来的容量的长度</span><br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-putVal方法"><a href="#2-putVal方法" class="headerlink" title="2. putVal方法"></a>2. putVal方法</h2><p>老规矩,先把代码粘上来:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Implements Map.put and related methods.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> hash hash for key</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> key the key</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> value the value to put</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> evict if false, the table is in creation mode.</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> previous value, or null if none</span><br><span class="hljs-comment">    */</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;<br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>        <span class="hljs-comment">//前文说过,(n-1)&amp;hash等价于hash%n,不同hash的key不可能取到同一个下标</span><br>        <span class="hljs-comment">//如果还没有创建过节点,那么创建新节点放到对应桶中即可</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">//目标bucket已经有元素了,那么会有两种情况:</span><br>    <span class="hljs-comment">//要么是替换key对应的value,要么就是加入一个新节点    </span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">//这里总是首先判断目标bucket中第一个元素是否和key是用一个元素,p就是第一个元素</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k)))) <span class="hljs-comment">//@Fisrt Question</span><br>            <span class="hljs-comment">//把bucket中的第一个元素赋值给e</span><br>            e = p;<br>        <span class="hljs-comment">//如果目标bucket已经使用RB tree存储了,那么就调用TreeNode的putTreeVal方法存入新节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">//走到这里,说明bucket还是使用链表存储</span><br>        <span class="hljs-comment">//那么需要判断是加入新节点还是替换value</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">//链表已经遍历完了,还是没有找到相同的对象,说明用户的目的是插入新节点</span><br>                    <br>                    <span class="hljs-comment">//注意,Hash冲突的在这里也会执行插入,导致一条链表过长</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">//因为是从p.next开始遍历的,所以在插入第七个元素时,进行树化</span><br>                    <span class="hljs-comment">//从0开始计算，0表示第一个节点，所以如果原来本身就有8个节点，那么则会调用treeifyBin</span><br>                    <span class="hljs-comment">//但是只有table的长度达到64时，才会进行树化</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//与上面的@First Question一样,判断我们当前处理的链表节点与key是否为同一个对象</span><br>                <span class="hljs-comment">//如果是,说明用户的目的是替换value,而不是插入</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果用户目的是替换元素,那么额e就是找出来的对象,否则如果是插入新节点e就会为null</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            V oldValue = e.value;<br>            <span class="hljs-comment">//onlyIfAbsent为false允许替换元素,如果不允许替换元素,那么就看看原始value是否为null</span><br>            <span class="hljs-comment">//如果为null,那么即使onlyAbsence为true也能替换</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<span class="hljs-comment">//@second question</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//为了实现fast-fail机制</span><br>    ++modCount;<br>    <span class="hljs-comment">//如果插入后元素个数超出了存储阈值,那么就会调用resize扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>不难理解的代码都写在注释中了,这里写写比较难以理解的地方。</p><p>@First Question:为什么要这么写?</p><p>首先,<code>if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</code>这一句是在判断插入的key与bucket中的第一个key是否为同一个对象,在HashMap中判断两个对象是否为同一个需要hash相同并且对象相同。所以用<code>&amp;&amp;</code>把hash是否相同与对象是否相同的两个条件连接起来没什么问题。并且判断hash比后面的判断要快,所以把判断hash写在前面。但是判断两个对象是否相同为什么要使用<code>(key != null &amp;&amp; key.equals(k)))</code>?</p><p>因为对于引用类型,<code>==</code>比较的是对象地址。所以如果两个对象地址都相同,那么肯定是同一个对象。后面的条件是为了满足有些重写了<code>equals</code>与<code>hashCode</code>方法的类需要把逻辑上相同的两个对象认为是同一个对象。</p><p>@Second Question:<code>afterNodeAccess</code>有什么用?</p><p>追踪其实现代码,发现其其实是空函数:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// Callbacks to allow LinkedHashMap post-actions</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeInsertion</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeRemoval</span><span class="hljs-params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;<br></code></pre></div></td></tr></table></figure><p>注释里写的是给<code>LinkedHashMap</code>用作回调函数,不知道为什么HashMap里也使用这个,我们可以override这些函数,在完成插入、替换或者移除节点这些动作后执行一些通用的操作。</p><blockquote><p>Attention!!!<br>能存储在一个链表或者一颗红黑树中的,都是hash冲突的key-value,我到今天才发现!!!惭愧！！！</p></blockquote><h3 id="2-1-treeifyBin"><a href="#2-1-treeifyBin" class="headerlink" title="2.1 treeifyBin"></a>2.1 treeifyBin</h3><p><code>putVal</code>中还有一个非常重要的方法,就是<code>treeifyBin</code>,该方法将链表转化为一颗RB tree,实现代码如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Replaces all linked nodes in bin at index for given hash unless</span><br><span class="hljs-comment">    * table is too small, in which case resizes instead.</span><br><span class="hljs-comment">    */</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> hash)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, index; Node&lt;K,V&gt; e;<br>    <span class="hljs-comment">//如果tab的长度小于64,那么就会扩容,而不是树化</span><br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>        resize();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//hd是头节点,tl指向尾节点</span><br>        TreeNode&lt;K,V&gt; hd = <span class="hljs-keyword">null</span>, tl = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">//Node节点转换为TreeNode双链表</span><br>            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-keyword">null</span>);<br>            <span class="hljs-comment">//设置头节点</span><br>            <span class="hljs-keyword">if</span> (tl == <span class="hljs-keyword">null</span>)<br>                hd = p;<br>            <span class="hljs-comment">//尾插法</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                p.prev = tl;<br>                tl.next = p;<br>            &#125;<br>            tl = p;<br>        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">//因为TreeNode是Node的子列,所以将tab[index]替换成RB树的头节点</span><br>        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-keyword">null</span>)<br>            hd.treeify(tab);<br>    &#125;<br><br>    <span class="hljs-comment">// For treeifyBin</span><br>    <span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">replacementTreeNode</span><span class="hljs-params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看出,<code>treeifyBin</code>仅仅是将目标bucket的由<code>Node</code>组成的双向链表转化为由<code>TreeNode</code>组成的双向链表,具体的树化还得看双向链表的头节点<code>hd</code>的方法<code>treeify</code>。</p><h3 id="2-2-TreeNode"><a href="#2-2-TreeNode" class="headerlink" title="2.2 TreeNode"></a>2.2 TreeNode</h3><p>在深入了解<code>treeify</code>之前,我们还需要简单了解一下<code>TreeNode</code>的结构。<code>TreeNode</code>继承于<code>LinkedHashMap.Entry</code>,而<code>LinkedHashMap.Entry</code>又继承于<code>HashMap.Node</code>,最后<code>HashMap.Node</code>继承于<code>Map.Entry</code>。这一串继承下来,<code>TreeNode</code>的变量总共有11个。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    TreeNode&lt;K,V&gt; parent;  <span class="hljs-comment">// red-black tree links</span><br>    TreeNode&lt;K,V&gt; left;<br>    TreeNode&lt;K,V&gt; right;<br>    TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>    <span class="hljs-keyword">boolean</span> red;<br>    TreeNode(<span class="hljs-keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-keyword">super</span>(hash, key, val, next);<br>    &#125;<br>    ...<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>.<span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    Entry&lt;K,V&gt; before, after;<br>    Entry(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-keyword">super</span>(hash, key, value, next);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    V value;<br>    Node&lt;K,V&gt; next;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面是<code>TreeNode</code>的<code>treeify</code>方法,该方法就是将一个双向链表转化为红黑树,树化肯定要从根节点开始树化嘛。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Forms tree of the nodes linked from this node.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeify</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;<br>    TreeNode&lt;K,V&gt; root = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="hljs-keyword">this</span>, next; x != <span class="hljs-keyword">null</span>; x = next) &#123;<br>        <span class="hljs-comment">//x.next的运行时类型为TreeNode,但是静态类型为Node,所以需要强制转换</span><br>        next = (TreeNode&lt;K,V&gt;)x.next;<br>        x.left = x.right = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//还没有设置RB树的根节点,设置一哈</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            x.parent = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-comment">//根节点必为黑</span><br>            x.red = <span class="hljs-keyword">false</span>;<br>            root = x;<br>        &#125;<br>        <span class="hljs-comment">//开始放置新的树节点</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//x就是当前要放入的节点</span><br>            K k = x.key;<br>            <span class="hljs-keyword">int</span> h = x.hash;<br>            Class&lt;?&gt; kc = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;<br>                <span class="hljs-keyword">int</span> dir, ph;<br>                K pk = p.key;<br>                <span class="hljs-comment">//@First-Q</span><br>                <span class="hljs-comment">//为什么要比较hash的大小</span><br>                <span class="hljs-keyword">if</span> ((ph = p.hash) &gt; h)<br>                    dir = -<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ph &lt; h)<br>                    dir = <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//hash相等</span><br>                <span class="hljs-comment">//如果没有实现Comparable接口,那没法比了,只能调用tieBreakOrder强行比较</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((kc == <span class="hljs-keyword">null</span> &amp;&amp;(kc = comparableClassFor(k)) == <span class="hljs-keyword">null</span>) ||<br>                            <span class="hljs-comment">//实现了Comparable接口,但是二者compare的结果还是相等的</span><br>                            (dir = compareComparables(kc, k, pk)) == <span class="hljs-number">0</span>)<br>                    <span class="hljs-comment">//强行比较</span><br>                    dir = tieBreakOrder(k, pk);<br><br>                TreeNode&lt;K,V&gt; xp = p;<br>                <span class="hljs-comment">//dir&lt;=0就插入到左子树中,否则插入到右子树中,并且如果目标方向的子节点为空,才会进行插入</span><br>                <span class="hljs-comment">//否则继续向下遍历</span><br>                <span class="hljs-keyword">if</span> ((p = (dir &lt;= <span class="hljs-number">0</span>) ? p.left : p.right) == <span class="hljs-keyword">null</span>) &#123;<br>                    x.parent = xp;<br>                    <span class="hljs-keyword">if</span> (dir &lt;= <span class="hljs-number">0</span>)<br>                        xp.left = x;<br>                    <span class="hljs-keyword">else</span><br>                        xp.right = x;<br>                    <span class="hljs-comment">//平衡颜色</span><br>                    root = balanceInsertion(root, x);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//对树进行平衡调整,从根节点开始调整</span><br>    moveRootToFront(tab, root);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么其中<code>comaprableClassFor</code>是干嘛的呢?康康它的源码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Returns x&#x27;s Class if it is of the form &quot;class C implements</span><br><span class="hljs-comment">    * Comparable&lt;C&gt;&quot;, else null.</span><br><span class="hljs-comment">    */</span><br><span class="hljs-keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;<br>    <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> Comparable) &#123;<span class="hljs-comment">//如果对象x实现了Comparable接口</span><br>        Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;<br>        <span class="hljs-keyword">if</span> ((c = x.getClass()) == String.class) <span class="hljs-comment">// bypass checks</span><br>            <span class="hljs-keyword">return</span> c;<br>        <span class="hljs-comment">//ts是一个Type类型的数组</span><br>        <span class="hljs-comment">//getGenericInterfaces返回的是c直接实现的接口</span><br>        <span class="hljs-keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ts.length; ++i) &#123;<br>                <span class="hljs-comment">//如果t是一个参数化类型并且原始类型是Comparable,并且t的泛型类型中参数个数只有1个,并且参数是x.getClass()</span><br>                <span class="hljs-comment">//那么就返回x的Class对象,否则返回null</span><br>                <span class="hljs-keyword">if</span> (((t = ts[i]) <span class="hljs-keyword">instanceof</span> ParameterizedType) &amp;&amp;<br>                    ((p = (ParameterizedType)t).getRawType() ==<br>                        Comparable.class) &amp;&amp;<br>                    (as = p.getActualTypeArguments()) != <span class="hljs-keyword">null</span> &amp;&amp;<br>                    as.length == <span class="hljs-number">1</span> &amp;&amp; as[<span class="hljs-number">0</span>] == c) <span class="hljs-comment">// type arg is c</span><br>                    <span class="hljs-keyword">return</span> c;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>该方法其中就是判断类<code>c</code>是否实现了接口<code>Comparable&lt;c&gt;</code>,如果实现了,就返回<code>c</code>的<code>Class</code>对象,否则返回null。那么<code>compareComparables</code>是干嘛的?顺便康康其源码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Returns k.compareTo(x) if x matches kc (k&#x27;s screened comparable</span><br><span class="hljs-comment">    * class), else 0.</span><br><span class="hljs-comment">    */</span><br><span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span> <span class="hljs-comment">// for cast to Comparable</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareComparables</span><span class="hljs-params">(Class&lt;?&gt; kc, Object k, Object x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (x == <span class="hljs-keyword">null</span> || x.getClass() != kc ? <span class="hljs-number">0</span> :<br>            ((Comparable)k).compareTo(x));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先会比较待插入键<code>y</code>的<code>Class</code>文件<code>kc</code>与树中的节点<code>x</code>的<code>Class</code>文件是否相同,这一句就要求了如果<code>y</code>和<code>x</code>必须是同一类型,否则即使<code>y</code>实现了<code>Comaprable</code>接口也不能比较,因为我们不知道<code>x</code>是否实现了<code>Comparable</code>接口。</p><p>如果是同一类型,那么就是<code>comparaTo</code>方法比较这两个键的大小。注意这里还是有可能相等的,还是无法决定这两个键谁大谁小。那么当然还有最后一招,就是方法<code>tieBreakOrder</code>,这个方法必须抉择处待插入的节点和数中的某个节点到底谁大。那么它怎么比的?还是看源码咯。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Tie-breaking utility for ordering insertions when equal</span><br><span class="hljs-comment">* hashCodes and non-comparable. We don&#x27;t require a total</span><br><span class="hljs-comment">* order, just a consistent insertion rule to maintain</span><br><span class="hljs-comment">* equivalence across rebalancings. Tie-breaking further than</span><br><span class="hljs-comment">* necessary simplifies testing a bit.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tieBreakOrder</span><span class="hljs-params">(Object a, Object b)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> d;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-keyword">null</span> || b == <span class="hljs-keyword">null</span> ||<br>        (d = a.getClass().getName().<br>            compareTo(b.getClass().getName())) == <span class="hljs-number">0</span>)<br>        d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?<br>                -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先判断<code>a</code>或者<code>b</code>的名字谁长,名字短的排在前面。如果名字长度相等,那么计算<code>a</code>和<code>b</code>的hashCode,hash相等的话,<code>a</code>排在前面。那么<code>identityHashCode</code>是怎么计算的?</p><p>该方法就是返回对象<code>a</code>或<code>b</code>的默认hashcode,无论<code>a</code>或者<code>b</code>是否override了<code>hashCode</code>方法。<code>null</code>的<code>hashCode</code>为0。</p><p>经过上述最多三次的抉择,终于能决定待插入节点<code>x</code>和树中的节点谁大谁小了。那么抉择出来了,就可以在树中插入节点<code>x</code>了吗?当然不行,上面的代码仅仅是比较大小而已,真正插入时需要在RB树中找到一个合适的叶节点。下面的代码就是寻找合适的叶节点:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//下文中的x是待插入节点</span><br><span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;<br>    <span class="hljs-keyword">int</span> dir, ph;<br>    K pk = p.key;<br>    <span class="hljs-comment">//@First-Q</span><br>    <span class="hljs-comment">//为什么要比较hash的大小</span><br>    <span class="hljs-keyword">if</span> ((ph = p.hash) &gt; h)<br>        dir = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ph &lt; h)<br>        dir = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//hash相等</span><br>    <span class="hljs-comment">//如果没有实现Comparable接口,那没法比了,只能调用tieBreakOrder强行比较</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((kc == <span class="hljs-keyword">null</span> &amp;&amp;(kc = comparableClassFor(k)) == <span class="hljs-keyword">null</span>) ||<br>                <span class="hljs-comment">//实现了Comparable接口,但是二者compare的结果还是相等的</span><br>                (dir = compareComparables(kc, k, pk)) == <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">//强行比较</span><br>        dir = tieBreakOrder(k, pk);<br><br>    TreeNode&lt;K,V&gt; xp = p;<br>    <span class="hljs-comment">//dir&lt;=0就插入到左子树中,否则插入到右子树中,并且如果目标方向的子节点为空,这才是真正的插入点</span><br>    <span class="hljs-comment">//否则继续向下遍历寻找合适的位置 </span><br>    <span class="hljs-keyword">if</span> ((p = (dir &lt;= <span class="hljs-number">0</span>) ? p.left : p.right) == <span class="hljs-keyword">null</span>) &#123;<br>        x.parent = xp;<br>        <span class="hljs-keyword">if</span> (dir &lt;= <span class="hljs-number">0</span>)<br>            xp.left = x;<br>        <span class="hljs-keyword">else</span><br>            xp.right = x;<br>        <span class="hljs-comment">//平衡颜色</span><br>        root = balanceInsertion(root, x);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在找到插入位置并完成插入后,需要调用<code>balanceInsertion</code>平衡节点之间的颜色。这个函数是红黑树的调整的核心操作。我把注释都写在了代码中:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;K,V&gt; <span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">balanceInsertion</span><span class="hljs-params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;<br><br>    <span class="hljs-comment">//注意在JDK8中,红黑树是左右倾都存在的</span><br>    <span class="hljs-comment">//要从插入的节点x开始逐级向上调整</span><br>    <span class="hljs-comment">//插入的节点一定是红色,而且可能插在x的左侧或者右侧</span><br>    x.red = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;<br>        <span class="hljs-comment">//如果x没有父节点,那么根本不用调整</span><br>        <span class="hljs-comment">//将x的颜色设为黑色返回即可,因为x此时就是根节点</span><br>        <span class="hljs-keyword">if</span> ((xp = x.parent) == <span class="hljs-keyword">null</span>) &#123;<br>            x.red = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>        <span class="hljs-comment">//如果x的父节点xp是黑的,这时可以直接返回,因为在xp左侧插入一个红节点不影响RB的完美平衡</span><br>        <span class="hljs-comment">//或者xp是红色的,但是xp没有父节点,那么可以直接返回?</span><br>        <span class="hljs-comment">//查了一下,xp是红色但是没有父节点的情况不会出现,这样是为了给xpp赋值</span><br>        <span class="hljs-comment">//综上,如果xp是黑色,就直接返回root,因为不影响平衡性</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-comment">//只要上面的else if没返回,那么xp必是红节点,而且xpp必然存在</span><br>        <span class="hljs-comment">//因为xp为红但是xp为根节点的情况不存在</span><br>        <span class="hljs-comment">//不然这里的if判断可能会产生null</span><br>        <span class="hljs-keyword">if</span> (xp == (xppl = xpp.left)) &#123;<br>            <span class="hljs-comment">//走到这,xp就必定是左红节点，如果xpp有右子节点并且xppr为红</span><br>            <span class="hljs-comment">//此时我们就需要把xppl和xppr的红色向上传递?为什么,因为插入的x节点必是红节点,不允许连续子节点和父节点都是红节点</span><br>            <span class="hljs-comment">//这里进行向上传递红色的操作</span><br>            <span class="hljs-keyword">if</span> ((xppr = xpp.right) != <span class="hljs-keyword">null</span> &amp;&amp; xppr.red) &#123;<br>                xppr.red = <span class="hljs-keyword">false</span>;<br>                xp.red = <span class="hljs-keyword">false</span>;<br>                xpp.red = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-comment">//将xpp赋值给x是因为xpp的所有子节点已经调整好了</span><br>                <span class="hljs-comment">//这就相当于递归回溯调整颜色的过程,调整完颜色后直接从新的x节点开始继续开始下一轮循环</span><br>                x = xpp;<br>            &#125;<br><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//如果xpp有右子节点但是为黑</span><br>                <span class="hljs-comment">//或者xpp根本就没有右子节点</span><br>                <span class="hljs-comment">//总之这时已经出现了x和xp两个连续的左红节点,要么都是左红节点,或者x是右红,xp是左红</span><br><br>                <span class="hljs-keyword">if</span> (x == xp.right) &#123;<br>                    <span class="hljs-comment">//如果x是右红,那么就要先以xp为轴点进行左旋,形成x和xp都是左红的局面</span><br>                    <span class="hljs-comment">//注意,这里不是把xp赋值给x后把x传进去,而是传进去xp,顺便把xp赋值给x</span><br>                    root = rotateLeft(root, x = xp);<br>                    <span class="hljs-comment">//这里左旋x就会成为新的xp</span><br>                    <span class="hljs-comment">//这里xp=x.parent也可能是进行赋值操作?</span><br>                    <span class="hljs-comment">//xpp也是赋值操作?</span><br>                    xpp = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.parent;<br>                &#125;<br>                <span class="hljs-comment">//走到这,x和xp就一定都是左红,这里要以xpp为轴点进行右旋</span><br>                <span class="hljs-comment">//这里为毛需要判空?xp不是一定存在?</span><br>                <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">//注意,这里xp一定是红色,那么xpp必然是黑色</span><br>                    <span class="hljs-comment">//旋转后,xp会成为新的xpp,这里是将xpp的颜色赋值给xp</span><br>                    xp.red = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">if</span> (xpp != <span class="hljs-keyword">null</span>) &#123;<br>                        <span class="hljs-comment">//将xp的颜色赋值给xpp,因为xp原来是红色</span><br>                        xpp.red = <span class="hljs-keyword">true</span>;<br>                        <span class="hljs-comment">//右旋,可能会产生新的root节点</span><br>                        root = rotateRight(root, xpp);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//跟上面的插入情况差不多</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//走到这,xp必是右红节点</span><br>            <span class="hljs-comment">//将红色向上传递</span><br>            <span class="hljs-keyword">if</span> (xppl != <span class="hljs-keyword">null</span> &amp;&amp; xppl.red) &#123;<br>                xppl.red = <span class="hljs-keyword">false</span>;<br>                xp.red = <span class="hljs-keyword">false</span>;<br>                xpp.red = <span class="hljs-keyword">true</span>;<br>                x = xpp;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//如果x是左红节点</span><br>                <span class="hljs-keyword">if</span> (x == xp.left) &#123;<br>                    <span class="hljs-comment">//那么就需要以xp为轴点,向右旋,也就是把xp和x安排到一条直线上,也就是像下面这样</span><br>                    <span class="hljs-comment">//    xpp(xpp不一定有)           xpp</span><br>                    <span class="hljs-comment">//      \                         \</span><br>                    <span class="hljs-comment">//       xp  ----&gt;                 xp</span><br>                    <span class="hljs-comment">//       /                          \</span><br>                    <span class="hljs-comment">//      x                            x</span><br>                    root = rotateRight(root, x = xp);<br>                    xpp = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.parent;<br>                &#125;<br>                <span class="hljs-comment">//xp是必然存在的,xpp也是必然存在的,步知道为什么会有这两个判断</span><br>                <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;<br>                    xp.red = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">if</span> (xpp != <span class="hljs-keyword">null</span>) &#123;<br>                        xpp.red = <span class="hljs-keyword">true</span>;<br><br>                        <span class="hljs-comment">//   xpp                xp</span><br>                        <span class="hljs-comment">//    \               /  \</span><br>                        <span class="hljs-comment">//     xp -------&gt;   xpp  x</span><br>                        <span class="hljs-comment">//     \</span><br>                        <span class="hljs-comment">//      x</span><br>                        root = rotateLeft(root, xpp);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树入门</title>
    <link href="/2021-06-03/red-black-tree.html"/>
    <url>/2021-06-03/red-black-tree.html</url>
    
    <content type="html"><![CDATA[<p>本篇将带你一步一步了解红黑树，当然大部分内容来源于算法(第4版)一书，我仅仅对一点内容总结了自己的心得。</p><p>在谈谈红黑树之前，我们先来回顾一下二叉排序树(balanced sort tree),因为红黑树是从BST的概念演化而来的。BST的定义很简单，对于一个节点来说，左树的所有节点的值都小于当前节点的值，右树所有节点的值都大于当前节点的值。但是在最坏情况下BST的高度会达到O(N),效率太差。</p><p>我们在这里引入一个抽象的2-3树，所谓的2就是指节点只有两个指针指向子树，相应的3指的是节点中有三个指针指向子树，当然3节点中就会包含2个key。</p><p>2-3保证了一点性质：<strong>所有的空节点到达根节点的路径都是一样长的</strong>,这条性质保证了查找的复杂度在O(logN)的水平。</p><h2 id="1-2-3树的插入"><a href="#1-2-3树的插入" class="headerlink" title="1. 2-3树的插入"></a>1. 2-3树的插入</h2><p>2-3树的插入还是比较复杂的，分为插入位置在2节点还是3节点。</p><h3 id="1-1-2节点位置插入"><a href="#1-1-2节点位置插入" class="headerlink" title="1.1 2节点位置插入"></a>1.1 2节点位置插入</h3><p>2节点位置的插入比较简单，首先我们需要查找目标应该在的位置，如果查找结束于一个2节点，那么直接将目标插入结束的节点即可，下图演示了在2-3树中插入key为N的节点(按照字典序)。</p><p><img src="../images/red-black-tree/red-black-tree.drawio.svg" alt="2节点中插入新节点"></p><h3 id="1-2-3节点位置插入"><a href="#1-2-3节点位置插入" class="headerlink" title="1.2 3节点位置插入"></a>1.2 3节点位置插入</h3><p>3节点位置的插入比较复杂，分为一下三种情况：</p><ul><li>没有父节点的3节点</li><li>父节点为2节点的3节点</li><li>父节点为3节点的3节点</li></ul><p><strong>没有父节点的3节点:</strong></p><p>如果没有父节点，那么在3节点中再加入一个新值的话3节点就会升级为4节点，这在2-3树中是不允许的，采取的办法是为4节点构造一个父节点，将4节点降级为3节点，那么构造的父节点的值是多少？应该是4节点中3个值的中间数，如下图所示：</p><p><img src="../images/red-black-tree/insert-node-to-three.drawio.svg" alt="3节点位置插入-1"></p><p><strong>父节点为2节点的3节点:</strong></p><p>思路是一样的，只不过这里不再需要人为构造父节点了，只需要把4节点中三个数中的中间位置数向上传递就行了，并且将当前节点分割为两个2节点，这样父节点就会由2节点升级为3节点。如下图所示：</p><p><img src="../images/red-black-tree/insert-node-to-three-II.drawio.svg" alt="3节点位置插入-2"></p><p><strong>父节点为3节点的3节点</strong></p><p>操作与上面完全相同，有一点要记住：<strong>如果3节点是通过4节点降级得到的，那么就必须把这个3节点分割为两个2节点</strong>。因为如果不分割，退化后的3节点是不符合规则的。</p><p>经过上面讲解，可以发现有如下规律：</p><ul><li>在插入节点，不管当前位置是2节点还是3节点，我们先把值加入到这个节点中，然后再慢慢调整</li><li>如果3节点是通过4节点降级得到的，那么必须要把这个3节点分割为两个2节点</li></ul><h2 id="2-左倾红黑树"><a href="#2-左倾红黑树" class="headerlink" title="2. 左倾红黑树"></a>2. 左倾红黑树</h2><p>虽然2-3树的理解非常方便，但是代码实现起来比较困难，所以就产生了红黑树等价代替2-3树。但是红黑树都是2节点，怎么保存3节点呢？很简单，就是通过所谓的红或者黑来代替3节点。</p><p>我们通过红链接或者黑链接来表示2-3树。<strong>红链接将两个2节点连接起来构成3节点，黑链接就是普通的链接</strong>。那么这个链接是如何表示？这个颜色到底保存在哪？有如下规定：</p><p>如果a是b的子节点，且二者之间的链接是红色的，那么这个红色的信息保存在a中(也就是子节点)，也就是一个节点的颜色等于指向该节点的链接的颜色。</p><p>那么红黑树的官方定义是什么？</p><p><del>红黑树就是满足以下定义的二叉查找树</del>满足下面定义的仅仅是左倾红黑树:</p><ul><li>根节点总是黑色的</li><li>红链接均为左连接</li><li>没有任何一个节点同时和两条红链接相连</li><li>该树是完美黑色平衡的，就是所有空节点到达根节点所经历的黑链接数量是相同的，也不难理解，因为红链接的两个节点实际在一层，因为表示的是3节点</li></ul><hr><p><strong>Extensions:</strong></p><p>红黑树有很多种,左倾、右倾、或者左右倾等等,我一直以为左倾红黑树就是全部的红黑树,实际上只是因为它简单,算法第4版才会选择它进行讲解。实际上只要满足以下定义的都是红黑树:</p><ul><li>每一个节点不是红就是黑</li><li>根节点必是黑色</li><li>所有叶子节点(最底层的空节点)都是黑色</li><li>红节点的两个直接子节点必须都是黑色（换言之也就是不能同时有两个红节点相连）</li><li>从任意一个节点到到它的最底层子空节点所经过的黑节点个数都是一样的,也就是RB树是完美黑平衡的,注意,这个空节点只能是所选定的节点的子节点,而不能是它兄弟节点的空子节点。也就是任意空节点到达根节点经过的黑节点个数是相同的</li></ul><hr><p>我们如果将红黑树的红链接画平，那么就是一颗2-3树。如下图所示:</p><p><img src="../images/red-black-tree/rb-tree-and-2-3-tree.drawio.svg" alt="红黑树与2-3树的转换"></p><p>那么为了保证左倾红黑树的3条性质，我们还需要熟悉以下几项操作。</p><p><strong>保证红链接均为左链接:</strong></p><p>为了保证以上性质，我们可以采用旋转的操作：</p><p><img src="../images/red-black-tree/rb-tree-left-rotate.drawio.svg" alt="左旋操作"></p><figure class="highlight java"><figcaption><span>"左旋操作"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//返回旋转后的根节点</span><br><span class="hljs-function">Node <span class="hljs-title">rotateLeft</span><span class="hljs-params">(Node h)</span></span>&#123;<br>    Node x=h.right;<br>    h.right=x.left;<br>    x.left=h;<br>    <span class="hljs-comment">//把原来h节点的颜色赋给新的头节点</span><br>    x.color=h.color;<br>    h.color=red;<br>    x.size=h.size;<br>    h.size=<span class="hljs-number">1</span>+size(h.left)+size(h.right);<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>右旋代码是非常类似的。</p><figure class="highlight java"><figcaption><span>"右旋操作"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">Node <span class="hljs-title">rotateRight</span><span class="hljs-params">(Node h)</span></span>&#123;<br>    Node x=h.left;<br>    h.left=x.right;<br>    x.color=h.color;<br>    h.color=red;<br>    x.size=h.size;<br>    h.size=size(h.left)+size(h.right)+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>保证不会出现两条连续的红链接</strong></p><p>这个性质的实现也是通过旋转来实现的,额外的操作是可能需要进行颜色转换，因为可能出现4节点降级为两个2节点。我们需要遵守以下三条准则：</p><ul><li>如果当前节点的左子链接是黑色而右子链接为红色，那么进行对当前节点左旋</li><li>如果当前节点的左子链接是红色的，并且左子链接的左子链接也是红色的，那么将当前节点进行右旋</li><li>如果左右链接都是红色的，那么进行颜色颜色转换，将红链接向上传递。</li></ul><p>前两条规则如下图所示:</p><div align=center><img src="../images/red-black-tree/part-I.png"/></div><p>最后一条规则如下所示:</p><div align=center><img src="../images/red-black-tree/part-II.png"/></div><p>对于第一条规则我认为没有必须要求左子链接为黑色，因为不可能产生三条连续的红链接，因为都是在树底插入，在插入之前就不可能产生两条连续的红色链接，所以插入后最多产生两条连续的红链接。</p><h3 id="2-1-红黑树的插入操作"><a href="#2-1-红黑树的插入操作" class="headerlink" title="2.1 红黑树的插入操作"></a>2.1 红黑树的插入操作</h3><p>红黑树插入新节点时插入的是<strong>红节点</strong>,至于保持平衡那需要在插入之后修正。下面是红黑树的插入节点的代码,与普通的BST差别不是很大,最后需要在回溯修正节点的颜色时遵循上面规则：</p><figure class="highlight java"><figcaption><span>"红黑树插入代码"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">put</span><span class="hljs-params">(Node x,Key key,Value val)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Node(key,val,RED,<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">int</span> cmp=key.compareTo(x.key);<br>        <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>)&#123;<br>            x.left=put(x.left,key,val);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp&gt;<span class="hljs-number">0</span>)&#123;<br>            x.right=put(x.right,key,val);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            x.val=val;<br>        &#125;<br>        <span class="hljs-comment">//修正红黑树的颜色</span><br>        <span class="hljs-comment">//感觉第二个条件也不一定需要吧，只是减少了旋转的次数,如果加了左子树为黑的条件，则不会进行下一行的旋转，因为可以直接进行颜色转换</span><br>        <span class="hljs-comment">//如果删去左子树为黑的条件，那么会多余执行一次下一行的转换，再进行颜色转换，本来可以直接转的，上面做了多余一步的操作</span><br>        <br>        <span class="hljs-comment">//对于左倾红黑树，必须先左转，将红节点调整到右边</span><br>        <span class="hljs-comment">//然后再右转，最后再进行颜色传递</span><br>        <span class="hljs-keyword">if</span>(isRed(x.right)&amp;&amp; !isRed(x.left))&#123;<br>            x=rotateLeft(x);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(isRed(x.left) &amp;&amp; isRed(x.left.left))&#123;<br>            x=rotateRight(x);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(isRed(x.left) &amp;&amp; isRed(x.right))&#123;<br>            flipColor(x);<br>        &#125;<br>        x.size=size(x.left)+size(x.right)+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="2-2-红黑树的删除操作"><a href="#2-2-红黑树的删除操作" class="headerlink" title="2.2 红黑树的删除操作"></a>2.2 红黑树的删除操作</h3><p>红黑树的删除比插入还复杂些,因为红黑树是完美黑节点平衡的,所以在删除时我们就不能删除黑节点,只能删除红节点。但是如果我们想要删除的值就是黑的,怎么办？办法就是把它变红。简单来说就是不断变换颜色。直到我们的目标删除节点为红色时。</p><p>待删除的节点分两种：一种是在底部，没有子节点，像这样的节点，把它转换成红色的删除就好。另外一种就是有后继节点，为了保持树的有序性，我们采取跟BST的一样的操作，把待删除节点的后继节点找到，然后将待删除节点替换为后继节点。</p><p>总的来说：</p><ul><li>我们只能删除红节点</li><li>并且待删除节点不能是个2-节点，因为直接将2-节点删除会破坏平衡性</li></ul><p>所以在我们向下寻找待删除节点的时候，我们就必须保证当前处理的节点不是2-节点。</p><p><strong>删除最小值:</strong></p><p>这里以删除最小值为例,与BST的删除操作类似，采用递归删除。我们在每一轮递归调用时，都需要将当前节点的左子节点调整为非2-节点。如果处理节点为2-节点,这就需要:</p><ul><li>从当前的父节点(当前节点)借一个</li></ul><p><img src="../images/red-black-tree/borrow-from-parent.png" alt="borrow-from-father"></p><ul><li>或者当前节点的左子节点的兄弟节点借一个</li></ul><p><img src="../images/red-black-tree/borrow-from-bro-min.png" alt="borrow-from-bro"></p><p>步骤如下：我们首先从父节点借一个，这里所谓的借一个是将父节点的颜色变黑，两个子节点的颜色变红，也就是改造为4节点，然后我们再看左子节点的兄弟是否为非2-节点。如果是，那么就从兄弟借，把从父节点借的再还回去。然后我们进入下一轮递归调用，这样继续处理左子节点。保证了路径上的每个节点都不是2-节点,<strong>把红链接一层一层传递下去</strong>。最后删除最底层的红节点,然后再层层回溯修复节点颜色。</p><figure class="highlight java"><figcaption><span>"删除最小值"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//删除操作的大小修正都在balance中了</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteMin</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//为啥要进行这步操作，仅仅是为了假装根节点为3-节点吗？？？</span><br>        <span class="hljs-comment">//做这步操作可能是因为flipColor的写法</span><br>        <span class="hljs-comment">//因为flipColor的操作是把当前节点和两个子节点的颜色取反，如果不把根节点的颜色设红，后面的子节点没法借</span><br>        <span class="hljs-keyword">if</span>(!isRed(root.left)&amp;&amp;!isRed(root.right))&#123;<br>            root.color=RED;<br>        &#125;<br><br>        root=deleteMin(root);<br>        <span class="hljs-comment">//恢复根节点的颜色</span><br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-keyword">null</span>)&#123;<br>            root.color=BLACK;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//能够进入这个函数的当前节点一定不是2节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">deleteMin</span><span class="hljs-params">(Node h)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(h.left==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//判断当前节点的左子节点是否为3节点</span><br>        <span class="hljs-keyword">if</span>(!isRed(h.left) &amp;&amp; !isRed(h.left.left))&#123;<br>            <span class="hljs-comment">//左子节点为黑，且它的子节点为黑，表示左子节点是一个2-节点，需要借</span><br>            <span class="hljs-comment">//moveRedLeft就是调整红链接一直往左边走</span><br>            h=moveRedLeft(h);<br>        &#125;<br>        h.left=deleteMin(h.left);<br>        <span class="hljs-comment">//因为前面借节点的时候，有可能只是从父节点借了一个，</span><br>        <span class="hljs-comment">// 这样就会导致存在right-leaning的红链接，需要修正</span><br>        <span class="hljs-keyword">return</span> balance(h);<br>    &#125;<br></code></pre></div></td></tr></table></figure><p><strong>删除最大值:</strong></p><p>删除最大值类似，唯一一点不同的是，我们需要把当前节点的左子节点的红链接先翻转到右边,道理很简单。删除最小值不用这么做是因为红黑树的红链接本身就在左侧。删除最大值就是要把红链接一层一层的向底层传递直到不能传递。并且如果不把红链接翻转到右侧，右树底下的节点如果为2-节点时，他没有办法向上借了。</p><figure class="highlight java"><figcaption><span>"删除最大值"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteMax</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!isRed(root.left)&amp;&amp; !isRed(root.right))&#123;<br>            root.color=RED;<br>        &#125;<br>        root=deleteMax(root);<br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-keyword">null</span>)&#123;<br>            root.color=BLACK;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">deleteMax</span><span class="hljs-params">(Node h)</span></span>&#123;<br>        <span class="hljs-comment">//如果左链接是红色，那么就需要翻转到右边，不然右子节点下面的节点没法向它们的父节点借了</span><br>        <span class="hljs-keyword">if</span>(isRed(h.left))&#123;<br>            h=rotateRight(h);<br>        &#125;<br>        <br>        <span class="hljs-comment">//具体的删除操作，直接置空</span><br>        <span class="hljs-keyword">if</span>(h.right==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!isRed(h.right) &amp;&amp; !isRed(h.right.left))&#123;<br>            h=moveRedRight(h);<br>        &#125;<br>        h.right=deleteMax(h.right);<br>        <span class="hljs-keyword">return</span> balance(h);<br>    &#125;<br><br></code></pre></div></td></tr></table></figure><p><strong>删除任意值:</strong></p><p>删除任意值就是删除最小值与最大值的组合操作。如果想要删除的值比当前节点的值小，那么就向左继续寻找，与删除最小值类似，如果不小于当前节点的值，那么就往右走，类似于删除最大值。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Key key)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!isRed(root.left) &amp;&amp; !isRed(root.right))&#123;<br>            root.color=RED;<br>        &#125;<br>        root=delete(root,key);<br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-keyword">null</span>) &#123;<br>            root.color = BLACK;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">delete</span><span class="hljs-params">(Node h,Key key)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> cmp=key.compareTo(h.key);<br>        <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(!isRed(h.left) &amp;&amp; !isRed(h.left.left))&#123;<br>                h=moveRedLeft(h);<br>            &#125;<br>            h.left=delete(h.left,key);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//把红链接转到右边,因为原来的红链接都是左斜的，如果最大键在3-节点中，删除会导致树的不平衡,就是把红链接往右边传递</span><br>            <span class="hljs-keyword">if</span>(isRed(h.left))&#123;<br>                h=rotateRight(h);<br>            &#125;<br>            <span class="hljs-comment">//目标节点在底部</span><br>            <span class="hljs-comment">//这里只看右子节点是因为如果右子节点不为空，就说明我们找当前节点的后继节点来替换，</span><br>            <span class="hljs-comment">//如果为空，又因为当前节点必不是2-节点，所以可以放心删除</span><br>            <span class="hljs-keyword">if</span>(h.key.compareTo(key)==<span class="hljs-number">0</span> &amp;&amp; h.right==<span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>            <span class="hljs-comment">//走到这里有两种情况，要么我们需要找后继节点替换，要么目标节点在当前节点的右边</span><br>            <span class="hljs-comment">//总之都需要向右边的子节点走，所以必须提前右子节点为非2-节点</span><br>            <span class="hljs-comment">//保证要删除的值所在节点必须不能是2-节点,</span><br>            <span class="hljs-keyword">if</span>(!isRed(h.right) &amp;&amp; !isRed(h.right.left))&#123;<br>                h=moveRedRight(h);<br>            &#125;<br>            <span class="hljs-comment">//如果删除的节点不是在底部，那么就拿后继节点替换</span><br>            <span class="hljs-keyword">if</span>(key.compareTo(h.key)==<span class="hljs-number">0</span>)&#123;<br>                h.val=get(root,min(h.right).key);<br>                h.key=min(h.right).key;<br>                h.right=deleteMin(h.right);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//否则继续向右边走</span><br>                h.right=delete(h.right,key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//balance中会调整节点大小</span><br>        <span class="hljs-keyword">return</span> balance(h);<br>    &#125;<br></code></pre></div></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>普林斯顿原始论文与代码:</p><p>(<a href="https://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf">https://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf</a>)</p><p>(<a href="https://algs4.cs.princeton.edu/33balanced/RedBlackBST.java.html">https://algs4.cs.princeton.edu/33balanced/RedBlackBST.java.html</a>)</p><p>他人博客笔记:</p><p>(<a href="https://deserts.io/red-black-tree-deletion/">https://deserts.io/red-black-tree-deletion/</a>)</p><p>(<a href="https://www.jianshu.com/p/41f092a42ec1">https://www.jianshu.com/p/41f092a42ec1</a>)</p><p>(<a href="https://www.jianshu.com/p/48331a5a11f4">https://www.jianshu.com/p/48331a5a11f4</a>)</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>完整代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> tools;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LLRBTImpl</span>&lt;<span class="hljs-title">Key</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Key</span>&gt;,<span class="hljs-title">Value</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> RED =<span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> BLACK =<span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span></span>&#123;<br>        Key key;<br>        Value val;<br>        Node left;<br>        Node right;<br>        <span class="hljs-keyword">boolean</span> color;<br>        <span class="hljs-keyword">int</span> size;<br>        Node(Key key,Value val,<span class="hljs-keyword">boolean</span> color,<span class="hljs-keyword">int</span> size)&#123;<br>            <span class="hljs-keyword">this</span>.key=key;<br>            <span class="hljs-keyword">this</span>.val=val;<br>            <span class="hljs-keyword">this</span>.color=color;<br>            <span class="hljs-keyword">this</span>.size=size;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> Node root;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">(Node x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x.size;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRed</span><span class="hljs-params">(Node x)</span></span>&#123;<br>        <span class="hljs-comment">//因为有可能需要判断不存在的叶子节点的颜色</span><br>        <span class="hljs-keyword">if</span>(x==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> BLACK;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x.color== RED;<br>    &#125;<br>    <span class="hljs-comment">//左旋x的右节点必然是红色的，返回的是旋转的根节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">rotateLeft</span><span class="hljs-params">(Node h)</span></span>&#123;<br>        Node x=h.right;<br>        h.right=x.left;<br>        x.left=h;<br>        x.color=h.color;<br>        h.color=RED;<br>        x.size=h.size;<br>        h.size=size(h.left)+size(h.right)+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">rotateRight</span><span class="hljs-params">(Node h)</span></span>&#123;<br>        Node x=h.left;<br>        h.left=x.right;<br>        x.right=h;<br>        x.color=h.color;<br>        h.color=RED;<br>        x.size=h.size;<br>        h.size=size(h.left)+size(h.right)+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flipColor</span><span class="hljs-params">(Node x)</span></span>&#123;<br>        x.left.color=!x.left.color;<br>        x.right.color=!x.right.color;<br>        x.color=!x.color;<br>    &#125;<br>    <span class="hljs-comment">//返回的是插入节点后红黑树新的根节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Key key,Value val)</span></span>&#123;<br>        root=put(root,key,val);<br>        root.color=BLACK;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">put</span><span class="hljs-params">(Node x,Key key,Value val)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Node(key,val,RED,<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">int</span> cmp=key.compareTo(x.key);<br>        <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>)&#123;<br>            x.left=put(x.left,key,val);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp&gt;<span class="hljs-number">0</span>)&#123;<br>            x.right=put(x.right,key,val);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            x.val=val;<br>        &#125;<br>        <span class="hljs-comment">//修正红黑树的颜色</span><br>        <span class="hljs-comment">//感觉第二个条件也不一定需要吧，只是减少了旋转的次数</span><br>        <span class="hljs-keyword">if</span>(isRed(x.right)&amp;&amp; !isRed(x.left))&#123;<br>            x=rotateLeft(x);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(isRed(x.left) &amp;&amp; isRed(x.left.left))&#123;<br>            x=rotateRight(x);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(isRed(x.left) &amp;&amp; isRed(x.right))&#123;<br>            flipColor(x);<br>        &#125;<br>        x.size=size(x.left)+size(x.right)+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br><br>    <span class="hljs-comment">//删除操作的大小修正都在balance中了</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteMin</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//为啥要进行这步操作，仅仅是为了假装根节点为3-节点吗？？？</span><br>        <span class="hljs-comment">//做这步操作可能是因为flipColor的写法</span><br>        <span class="hljs-comment">//因为flipColor的操作是把当前节点和两个子节点的颜色取反，如果不把根节点的颜色设红，后面的子节点没法借</span><br>        <span class="hljs-keyword">if</span>(!isRed(root.left)&amp;&amp;!isRed(root.right))&#123;<br>            root.color=RED;<br>        &#125;<br><br>        root=deleteMin(root);<br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-keyword">null</span>)&#123;<br>            root.color=BLACK;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//能够进入这个函数的当前节点一定不是2节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">deleteMin</span><span class="hljs-params">(Node h)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(h.left==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//判断当前节点的左子节点是否为3节点</span><br>        <span class="hljs-keyword">if</span>(!isRed(h.left) &amp;&amp; !isRed(h.left.left))&#123;<br>            <span class="hljs-comment">//左子节点为黑，且它的子节点为黑，表示左子节点是一个2-节点，需要借</span><br>            h=moveRedLeft(h);<br>        &#125;<br>        h.left=deleteMin(h.left);<br>        <span class="hljs-comment">//因为前面借节点的时候，有可能只是从父节点借了一个，</span><br>        <span class="hljs-comment">// 这样就会导致存在right-leaning的红链接，需要修正</span><br>        <span class="hljs-keyword">return</span> balance(h);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteMax</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!isRed(root.left)&amp;&amp; !isRed(root.right))&#123;<br>            root.color=RED;<br>        &#125;<br>        root=deleteMax(root);<br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-keyword">null</span>)&#123;<br>            root.color=BLACK;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">deleteMax</span><span class="hljs-params">(Node h)</span></span>&#123;<br>        <span class="hljs-comment">//如果左链接是红色，那么就需要翻转到右边，不然右子节点下面的节点没法向它们的父节点借了</span><br>        <span class="hljs-keyword">if</span>(isRed(h.left))&#123;<br>            h=rotateRight(h);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(h.right==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!isRed(h.right) &amp;&amp; !isRed(h.right.left))&#123;<br>            h=moveRedRight(h);<br>        &#125;<br>        h.right=deleteMax(h.right);<br>        <span class="hljs-keyword">return</span> balance(h);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Key key)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!isRed(root.left) &amp;&amp; !isRed(root.right))&#123;<br>            root.color=RED;<br>        &#125;<br>        root=delete(root,key);<br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-keyword">null</span>) &#123;<br>            root.color = BLACK;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">delete</span><span class="hljs-params">(Node h,Key key)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> cmp=key.compareTo(h.key);<br>        <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(!isRed(h.left) &amp;&amp; !isRed(h.left.left))&#123;<br>                h=moveRedLeft(h);<br>            &#125;<br>            h.left=delete(h.left,key);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//把红链接转到右边,因为原来的红链接都是左斜的，如果最大键在3-节点中，删除会导致树的不平衡</span><br>            <span class="hljs-keyword">if</span>(isRed(h.left))&#123;<br>                h=rotateRight(h);<br>            &#125;<br>            <span class="hljs-comment">//目标节点在底部</span><br>            <span class="hljs-keyword">if</span>(h.key.compareTo(key)==<span class="hljs-number">0</span> &amp;&amp; h.right==<span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>            <span class="hljs-comment">//保证要删除的值所在节点必须不能是2-节点,</span><br>            <span class="hljs-keyword">if</span>(!isRed(h.right) &amp;&amp; !isRed(h.right.left))&#123;<br>                h=moveRedRight(h);<br>            &#125;<br>            <span class="hljs-comment">//如果删除的节点不是在底部，那么就拿后继节点替换</span><br>            <span class="hljs-keyword">if</span>(key.compareTo(h.key)==<span class="hljs-number">0</span>)&#123;<br>                h.val=get(root,min(h.right).key);<br>                h.key=min(h.right).key;<br>                h.right=deleteMin(h.right);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                h.right=delete(h.right,key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//balance中会调整节点大小</span><br>        <span class="hljs-keyword">return</span> balance(h);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">min</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> min(root);<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">min</span><span class="hljs-params">(Node h)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(h.left==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> h;<br>        &#125;<br>        <span class="hljs-keyword">return</span> min(h.left);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Value <span class="hljs-title">get</span><span class="hljs-params">(Key key)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> get(root,key);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Value <span class="hljs-title">get</span><span class="hljs-params">(Node h,Key key)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(h==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> cmp=key.compareTo(h.key);<br>        <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> get(h.left,key);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> get(h.right,key);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> h.val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//经过一系列反转，头节点必然发生变化，必须返回新的头节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">balance</span><span class="hljs-params">(Node x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(isRed(x.right))&#123;<br>            x=rotateLeft(x);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(isRed(x.left) &amp;&amp; isRed(x.left.left))&#123;<br>            x=rotateRight(x);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(isRed(x.left) &amp;&amp; isRed(x.right))&#123;<br>            flipColor(x);<br>        &#125;<br>        x.size=size(x.left)+size(x.right)+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-comment">//因为删除的节点必须是红节点，所以就必须把红节点往左侧移动</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">moveRedLeft</span><span class="hljs-params">(Node h)</span></span>&#123;<br>        delFlipColor(h);<br>        <span class="hljs-comment">//兄弟节点不是2-节点，可以借</span><br>        <span class="hljs-keyword">if</span>(isRed(h.right.left))&#123;<br>            h.right=rotateRight(h.right);<br>            h=rotateLeft(h);<br>            delFlipColor(h);<br>        &#125;<br>        <span class="hljs-comment">//经过上述一系列反转，头节点早就变化了</span><br>        <span class="hljs-keyword">return</span> h;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">moveRedRight</span><span class="hljs-params">(Node h)</span></span>&#123;<br>        delFlipColor(h);<br>        <span class="hljs-keyword">if</span>(isRed(h.left.left))&#123;<br>            h=rotateRight(h);<br>            delFlipColor(h);<br>        &#125;<br>        <span class="hljs-keyword">return</span> h;<br>    &#125;<br><br>    <span class="hljs-comment">//每调用一次就反转一遍当前节点及左右子节点的颜色</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delFlipColor</span><span class="hljs-params">(Node h)</span></span>&#123;<br>        h.color=!h.color;<br>        h.left.color=!h.left.color;<br>        h.right.color=!h.right.color;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>红黑树删除节点<br><a href="http://jackhuang.online/2019/08/09/red-black-tree%E7%AE%80%E4%BB%8B/">http://jackhuang.online/2019/08/09/red-black-tree%E7%AE%80%E4%BB%8B/</a></p>]]></content>
    
    
    <categories>
      
      <category>java集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>红黑树,map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArrayQueue与ArrayDeque源码分析</title>
    <link href="/2021-06-03/ArrayQueue-and-ArrayDeque-analysis.html"/>
    <url>/2021-06-03/ArrayQueue-and-ArrayDeque-analysis.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里将<code>ArrayQueue</code>与<code>ArrayDeque</code>放在一起分析是因为二者都是基于数组实现的队列。</p><h2 id="0x0-小试牛刀-ArrayQueue源码分析"><a href="#0x0-小试牛刀-ArrayQueue源码分析" class="headerlink" title="0x0 小试牛刀-ArrayQueue源码分析"></a>0x0 小试牛刀-ArrayQueue源码分析</h2><p>在进入主题之前我们思考一个问题,如果我们用数组实现一个传统的FIFO队列,是有可能出现数组未满,但是队列已满的假象的。这是因为我们在不断弹出元素的同时,队列的头指针就会不断朝着队列尾部的方向移动,那么头指针之前的空间就被浪费了,而采用链表实现的队列就不会出现这种情况。</p><p>为了解决上述的问题,我们采用循环数组的方式实现单项队列。所谓的循环数组,就是逻辑上数组的头和尾是连接在一起的,我们维护一个头指针和一个尾指针。那么为了我们能够知道什么时候数组被填充满了,我们需要使用额外的一个元素空间来标记队列是否真的满了。如果队列真的满了,那么头指针和尾指针就会重合。否则头指针和尾指针之间至少会有一个元素的空闲空间大小,如下图所示:</p><p><img src="images/circular-queue.drawio.svg" alt="循环队列示意图"></p><p>接下来进入主题,简要分析以下它的源码。</p><p>下面是<code>ArrayQueue</code>的构造函数:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayQueue</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br>    <span class="hljs-keyword">private</span> T[] queue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> head;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tail;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.capacity = capacity + <span class="hljs-number">1</span>;<span class="hljs-comment">//把额外用作标记的空间加上</span><br>        <span class="hljs-keyword">this</span>.queue = newArray(capacity + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">this</span>.head = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.tail = <span class="hljs-number">0</span>;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到,<code>ArrayQueue</code>是通过数组<code>queue</code>保存内容的。其中维持了两个指针<code>head</code>和<code>tail</code>。capacity表示队列的容量。在构造函数中,可以看到会对<code>capacity</code>加1,这是为什么?还记得上面说过的循环队列需要使用的额外的一个元素空间来标记队列是否满了?没错,这个加1就是把那个额外空间加上了。</p><p>接下来看看它的<code>add</code>函数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(T o)</span> </span>&#123;<br>    queue[tail] = o;<br>    <span class="hljs-keyword">int</span> newtail = (tail + <span class="hljs-number">1</span>) % capacity;<br>    <span class="hljs-keyword">if</span> (newtail == head)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">&quot;Queue full&quot;</span>);<br>    tail = newtail;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <span class="hljs-comment">// we did add something</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>ArrayQueue</code>因为是单项队列,所以只能从队尾进元素,然后tail指针取模向后移动一个。很可惜,<code>add</code>方法并不会自动扩容,在队列满后,会抛出指针异常,但是我们可以手动调用<code>resize()</code>方法进行扩容,很麻烦。所以没人用是正常的。接下来看看<code>resize()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newcapacity)</span> </span>&#123;<br>    <span class="hljs-comment">//获取当前队列内的元素个数</span><br>    <span class="hljs-keyword">int</span> size = size();<br>    <span class="hljs-keyword">if</span> (newcapacity &lt; size)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">&quot;Resizing would lose data&quot;</span>);<br>    <span class="hljs-comment">//仍然需要把标记空间加上</span><br>    newcapacity++;<br>    <span class="hljs-keyword">if</span> (newcapacity == <span class="hljs-keyword">this</span>.capacity)<br>        <span class="hljs-keyword">return</span>;<br>    T[] newqueue = newArray(newcapacity);<br>    <span class="hljs-comment">//将原始队列中的元素复制到新队列中,从新队列的0位置开始复制</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>        newqueue[i] = get(i);<br>    <span class="hljs-keyword">this</span>.capacity = newcapacity;<br>    <span class="hljs-keyword">this</span>.queue = newqueue;<br>    <span class="hljs-keyword">this</span>.head = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">this</span>.tail = size;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Can&#x27;t use % here because it&#x27;s not mod: -3 % 2 is -1, not +1.</span><br>    <span class="hljs-comment">//在java中负数取模的结果符号与被取模的数符号相同</span><br>    <span class="hljs-keyword">int</span> diff = tail - head;<br>    <span class="hljs-keyword">if</span> (diff &lt; <span class="hljs-number">0</span>)<br>        diff += capacity;<br>    <span class="hljs-keyword">return</span> diff;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> size = size();<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= size) &#123;<br>        <span class="hljs-keyword">final</span> String msg = <span class="hljs-string">&quot;Index &quot;</span> + i + <span class="hljs-string">&quot;, queue size &quot;</span> + size;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(msg);<br>    &#125;<br>    <span class="hljs-comment">//加上偏移量head,就能准确定位老队列中的元素了</span><br>    <span class="hljs-keyword">int</span> index = (head + i) % capacity;<br>    <span class="hljs-keyword">return</span> queue[index];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>单项队列<code>ArrayQueue</code>的源码还是比较简单的,下面才是这篇文章的核心。</p><h2 id="0x1-主菜-ArrayDeque源码分析"><a href="#0x1-主菜-ArrayDeque源码分析" class="headerlink" title="0x1  主菜-ArrayDeque源码分析"></a>0x1  主菜-ArrayDeque源码分析</h2><h3 id="0x1-1-重要字段与构造函数"><a href="#0x1-1-重要字段与构造函数" class="headerlink" title="0x1-1 重要字段与构造函数"></a>0x1-1 重要字段与构造函数</h3><p>双向队列<code>ArraDeque</code>底层也是数组实现的,当然与<code>ArrayQueue</code>一样,采用循环数组。下面是<code>ArrayDeque</code>的字段与构造方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayDeque</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractCollection</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">                           <span class="hljs-keyword">implements</span> <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span></span><br><span class="hljs-class"></span>&#123;<br><br>     <span class="hljs-comment">//底层采用object类型数组保存元素,双向队列的容量就是该数组的长度,并且总是2的倍数</span><br>     <span class="hljs-comment">//数组永远都不会填满,并且没有用于储存队列元素的数组元素都必定为null</span><br>    <span class="hljs-keyword">transient</span> Object[] elements; <span class="hljs-comment">// non-private to simplify nested class access</span><br><br>    <span class="hljs-comment">//双端队列的头指针,只有队列中没有存储元素时head才会与tail相遇</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> head;<br><br>    <span class="hljs-comment">//双端队列的尾指针,指向下一个元素的存储位置</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> tail;<br><br>    <span class="hljs-comment">//默认最小容量为8</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_INITIAL_CAPACITY = <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">//无参构造方法</span><br>    <span class="hljs-comment">//队列为空,那么就将队列扩充为16</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayDeque</span><span class="hljs-params">()</span> </span>&#123;<br>        elements = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">16</span>];<br>    &#125;<br><br>    <span class="hljs-comment">//指定初始容量的构造方法,但是都会把容量升级为最小的2的倍数</span><br>    <span class="hljs-comment">//allocateElements用于升级容量至最小的2的倍数,这将在后面详解</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayDeque</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numElements)</span> </span>&#123;<br>        allocateElements(numElements);<br>    &#125;<br><br>    <span class="hljs-comment">//使用一个集合初始化队列,但是还是首先会把容量扩充至最最近的2的倍数,</span><br>    <span class="hljs-comment">//然后再将原集合中的左右元素拷贝至队列中</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayDeque</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>        allocateElements(c.size());<br>        addAll(c);<br>    &#125;<br><br></code></pre></div></td></tr></table></figure><p>可以看到,最重要的就是扩充容量函数<code>allocateElements</code>,这个函数比较复杂,有点难理解。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//该函数内部调用了calculateSize计算新的容量(计算最近的2的倍数)</span><br><span class="hljs-comment">//然后分配数组</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">allocateElements</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numElements)</span> </span>&#123;<br>    elements = <span class="hljs-keyword">new</span> Object[calculateSize(numElements)];<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numElements)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> initialCapacity = MIN_INITIAL_CAPACITY;<br>    <span class="hljs-comment">// Find the best power of two to hold elements.</span><br>    <span class="hljs-comment">// Tests &quot;&lt;=&quot; because arrays aren&#x27;t kept full即可.</span><br>    <span class="hljs-comment">//如果目标容量还小于规定的最小容量8,那么直接返回即可</span><br>    <span class="hljs-keyword">if</span> (numElements &gt;= initialCapacity) &#123;<br>        initialCapacity = numElements;<br>        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="hljs-number">1</span>);<br>        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="hljs-number">2</span>);<br>        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="hljs-number">4</span>);<br>        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="hljs-number">8</span>);<br>        initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>        initialCapacity++;<br><br>        <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)   <span class="hljs-comment">// Too many elements, must back off</span><br>            initialCapacity &gt;&gt;&gt;= <span class="hljs-number">1</span>;<span class="hljs-comment">// Good luck allocating 2 ^ 30 elements</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> initialCapacity;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到<code>calculateSize()</code>的代码很魔性,很有必要好好解释一哈。以下面32bit的数(作为初始容量newElements)为例:</p><blockquote><p>0000 0010 1101 0011 0000 0000 0000 0000</p></blockquote><p><strong>目标数据</strong>为离newElements最近的2的整数:</p><blockquote><p>0000 0100 0000 0000 0000 0000 0000 0000</p></blockquote><p>操作步骤如下:</p><ol><li>先执行<code>initialCapacity |= (initialCapacity &gt;&gt;&gt;  1)</code>,即将<code>initialCapacity</code>无符号向右移动1位:</li></ol><blockquote><p>0000 0001 0110 1001 1000 0000 0000 0000</p></blockquote><p>然后与自身进行或操作更新<code>initialCapacity</code>,这样就保证了左边第1位和第2位都为1。</p><blockquote><p>0000 0011 1111 1011 1000 0000 0000 0000</p></blockquote><ol start="2"><li>再执行<code>initialCapacity |= (initialCapacity &gt;&gt;&gt;  2)</code>,将<code>initialCapacity</code>无符号向右移动2位:</li></ol><blockquote><p>0000 0000 1111 1110 1110 0000 0000 0000</p></blockquote><p>然后与自身进行或操作更新<code>initialCapacity</code>,这样就保证了从左侧第一个1开始,后四位都是1。</p><blockquote><p>0000 0011 1111 1111 1110 0000 0000 0000</p></blockquote><ol start="3"><li>执行<code>initialCapacity |= (initialCapacity &gt;&gt;&gt;  4)</code>,将<code>initialCapacity</code>无符号向右移动4位:</li></ol><blockquote><p>0000 0000 0011 1111 1111 1110 0000 0000</p></blockquote><p>然后与自身进行或操作更新<code>initialCapacity</code>,这样就保证了从左侧第一个1开始,后八位都是1。</p><blockquote><p>0000 0011 1111 1111 1111 1110 0000 0000</p></blockquote><ol start="4"><li>执行<code>initialCapacity |= (initialCapacity &gt;&gt;&gt;  8)</code>,将<code>initialCapacity</code>无符号向右移动8位:</li></ol><blockquote><p>0000 0000 0000 0011 1111 1111 1111 1110</p></blockquote><p>然后与自身进行或操作更新<code>initialCapacity</code>,这样就保证了从左侧第一个1开始,后十六位都是1。</p><blockquote><p>0000 0011 1111 1111 1111 1111 1111 1110</p></blockquote><ol start="5"><li>执行<code>initialCapacity |= (initialCapacity &gt;&gt;&gt;  16)</code>,将<code>initialCapacity</code>无符号向右移动16位:</li></ol><blockquote><p>0000 0000 0000 0000 0000 0011 1111 1111 </p></blockquote><p>然后与自身进行或操作更新<code>initialCapacity</code>,这样就保证了从左侧第一个1开始,后三十二位都是1(当然最右边会有些bit丢失,但是这并没有关系。)</p><blockquote><p>0000 0011 1111 1111 1111 1111 1111 1111</p></blockquote><p>6.最后将自身加1,就得到了目标数据:</p><blockquote><p>0000 0100 0000 0000 0000 0000 0000 0000</p></blockquote><p>是离<code>0000 0010 1101 0011 0000 0000 0000 0000</code>最近的2的整数倍容量。我只能说,这段代码是真的妙,太妙了。</p><p>然后如果传进来的目标容易第31为1,那么求得的新容量第32位就会变为1,变成了负数2^31,所以还需要处理以下,如果新容量发生溢出,那么就将2^32向右移一位,返回<br>2^30,这已经是<code>ArrayDeque</code>的极限容量。</p><h3 id="0x1-2-ArrayDeque的增删查"><a href="#0x1-2-ArrayDeque的增删查" class="headerlink" title="0x1-2 ArrayDeque的增删查"></a>0x1-2 ArrayDeque的增删查</h3><p>对于<code>ArrayDeque</code>的增删查方法也值得我们关注,下面我们先来看看add方法。</p><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><p><code>ArrayDeque</code>是直接继承<code>AbstractCllecetion</code>的,所以并没由在add中调用offer类方法。相反,在add类中调用了offer类。在<code>ArrayDeque</code>中,add类和offer类并没有差别。因为<code>ArrayDeque</code>会自动扩容,永远也不会出现插入失败的情况。这里就以add类的方法为例,代码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>        elements[head = (head - <span class="hljs-number">1</span>) &amp; (elements.length - <span class="hljs-number">1</span>)] = e;<br>        <span class="hljs-keyword">if</span> (head == tail)<br>            doubleCapacity();<br>    &#125;<br><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>        elements[tail] = e;<br>        <span class="hljs-keyword">if</span> ( (tail = (tail + <span class="hljs-number">1</span>) &amp; (elements.length - <span class="hljs-number">1</span>)) == head)<br>            doubleCapacity();<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offerFirst</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        addFirst(e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offerLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        addLast(e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p><code>addFirst()</code>首先会判断元素是否为<code>null</code>,<code>ArrayDeque</code>中是允许存在null元素的,但是不允许我们存储<code>null</code>。注意下面真正进行存储的代码:</p><blockquote><p>elements[head = (head - 1) &amp; (elements.length - 1)] = e;</p></blockquote><p>这里首先会将head减1,为什么要减呢?因为我们是采用循环数组存储的,如果当前head指向0,调用<code>addFirst</code>是将元素往头部存的,自然需要将head往前移动。指针移动如下图所示:</p><p><img src="images/ArrayDeque-ciecular.drawio.svg" alt="指针移动"></p><p>但是减1有可能会将head变为负数。所以需要与<code>elements.length - 1</code>进行与操作。这里举个例子好理解:</p><p>以32位计算机为例,如果当前我们的队列容量为<code>128</code>,也就是<code>1 0000 0000</code>，减1后会变为<code>1111 1111</code>:</p><ul><li><p>如果head移动后为负数:假设为-1,也就是<code>1000,...,000 0000</code>(最高位符号位为1,中间有许多1就不写了),与<code>1111 1111</code>相与,那么结果就还是127,刚好是队列中的最后一个位置。</p></li><li><p>如果head减1后仍为正数:那么就是对head取模,结果仍然是head,非常巧妙。</p></li></ul><p>最后,如果再添加新元素完成后,队列容量已满(头指针head与尾指针tail相遇),那么就调用<code>doubleCapacity</code>使容量翻倍。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doubleCapacity</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">assert</span> head == tail;<br>    <span class="hljs-keyword">int</span> p = head;<br>    <span class="hljs-keyword">int</span> n = elements.length;<br>    <span class="hljs-comment">//r就是尾指针到数组最后一个位置之间的元素数量</span><br>    <span class="hljs-keyword">int</span> r = n - p; <span class="hljs-comment">// number of elements to the right of p</span><br>    <span class="hljs-keyword">int</span> newCapacity = n &lt;&lt; <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//容量无法扩充,已到达2^31,抛出状态异常</span><br>    <span class="hljs-keyword">if</span> (newCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Sorry, deque too big&quot;</span>);<br>    <span class="hljs-comment">//否则就申请新数组并将元素拷贝至此</span><br>    Object[] a = <span class="hljs-keyword">new</span> Object[newCapacity];<br>    <br>    System.arraycopy(elements, p, a, <span class="hljs-number">0</span>, r);<br>    <span class="hljs-comment">//最后一位为长度</span><br>    System.arraycopy(elements, <span class="hljs-number">0</span>, a, r, p);<br>    elements = a;<br>    head = <span class="hljs-number">0</span>;<br>    tail = n;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里仍然以下图为例(队列容量为8):</p><p><img src="images/ArrayDeque-double-cap.drawio.svg" alt="double-cap"></p><p>首先从新队列的头开始复制r个元素,然后接着再r后面复制p个元素,完成扩容。</p><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>从下面的代码可以得知:remove系列在底层是调用了poll系列的方法,所以还是直接调用remove系列方法方便。调用poll系列是如果队列为空时则返回null,否则返回弹出的元素。没有什么特别的。查头尾元素也非常普通,这里就不单列出来了。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span> </span>&#123;<br>    E x = pollFirst();<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">removeLast</span><span class="hljs-params">()</span> </span>&#123;<br>    E x = pollLast();<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">pollFirst</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h = head;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    E result = (E) elements[h];<br>    <span class="hljs-comment">// Element is null if deque empty</span><br>    <span class="hljs-comment">//如果队列为空,那么还是可以查到null的</span><br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    elements[h] = <span class="hljs-keyword">null</span>;     <span class="hljs-comment">// Must null out slot</span><br>    head = (h + <span class="hljs-number">1</span>) &amp; (elements.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">pollLast</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> t = (tail - <span class="hljs-number">1</span>) &amp; (elements.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    E result = (E) elements[t];<br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    elements[t] = <span class="hljs-keyword">null</span>;<br>    tail = t;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="occurrence方法"><a href="#occurrence方法" class="headerlink" title="occurrence方法"></a>occurrence方法</h3><p>occurrence系列有两个方法,<code>removeFirstOccurrence</code>是删除第一次出现的指定元素,对应的<code>removeLastOccurrence</code>就是删除最后一次出现的元素。具体的删除操作由<code>delete</code>完成,为了在删除时移动最少的元素,所以<code>delete</code>还是有点小复杂。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeFirstOccurrence</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">int</span> mask = elements.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> i = head;<br>    Object x;<br>    <span class="hljs-keyword">while</span> ( (x = elements[i]) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (o.equals(x)) &#123;<br>            delete(i);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//从head开始,往tail方向遍历</span><br>        i = (i + <span class="hljs-number">1</span>) &amp; mask;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeLastOccurrence</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">int</span> mask = elements.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> i = (tail - <span class="hljs-number">1</span>) &amp; mask;<br>    Object x;<br>    <span class="hljs-keyword">while</span> ( (x = elements[i]) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (o.equals(x)) &#123;<br>            delete(i);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//从tail开始,往head方向遍历</span><br>        i = (i - <span class="hljs-number">1</span>) &amp; mask;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面是delete的源码,为了实现最小次数的移动还真是费心了,具体的解释见注释吧。其中检查函数的作用就是检查还能不能在原数组中进行了移动数据的操作。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//如果是移动i后面的那部分数据,就返回true</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    checkInvariants();<br>    <span class="hljs-keyword">final</span> Object[] elements = <span class="hljs-keyword">this</span>.elements;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mask = elements.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> h = head;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> t = tail;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> front = (i - h) &amp; mask;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> back  = (t - i) &amp; mask;<br><br>    <span class="hljs-comment">// Invariant: head &lt;= i &lt; tail mod circularity</span><br>    <span class="hljs-keyword">if</span> (front &gt;= ((t - h) &amp; mask))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br><br>    <span class="hljs-comment">//下面这么复杂完全是为了减少移动次数</span><br>    <span class="hljs-comment">//如果前半段少于后半段数据,那么就移动前半段</span><br>    <span class="hljs-keyword">if</span> (front &lt; back) &#123;<br>        <span class="hljs-comment">//此时h和i之间并没有跨越下标0</span><br>        <span class="hljs-keyword">if</span> (h &lt;= i) &#123;<br>            System.arraycopy(elements, h, elements, h + <span class="hljs-number">1</span>, front);<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// Wrap around</span><br>        <span class="hljs-comment">//h和i之间跨域了下标0</span><br>            <span class="hljs-comment">//先将下标0~i之间的元素从0~i-1移动至1~i</span><br>            System.arraycopy(elements, <span class="hljs-number">0</span>, elements, <span class="hljs-number">1</span>, i);<br>            <span class="hljs-comment">//把数组中的最后一个元素拷贝至数组下标0位置</span><br>            elements[<span class="hljs-number">0</span>] = elements[mask];<br>            <span class="hljs-comment">//把数组中h~mask-1移动至h+1~mask</span><br>            System.arraycopy(elements, h, elements, h + <span class="hljs-number">1</span>, mask - h);<br>        &#125;<br>        elements[h] = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//更新head</span><br>        head = (h + <span class="hljs-number">1</span>) &amp; mask;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//后半段数据少于前半段,那么就移动后半段,并返回true</span><br>        <span class="hljs-keyword">if</span> (i &lt; t) &#123; <span class="hljs-comment">// Copy the null tail as well</span><br>            System.arraycopy(elements, i + <span class="hljs-number">1</span>, elements, i, back);<br>            tail = t - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// Wrap around</span><br>            System.arraycopy(elements, i + <span class="hljs-number">1</span>, elements, i, mask - i);<br>            elements[mask] = elements[<span class="hljs-number">0</span>];<br>            System.arraycopy(elements, <span class="hljs-number">1</span>, elements, <span class="hljs-number">0</span>, t);<br>            tail = (t - <span class="hljs-number">1</span>) &amp; mask;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//就是检查有没有移动数据的空间</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkInvariants</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">assert</span> elements[tail] == <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">assert</span> head == tail ? elements[head] == <span class="hljs-keyword">null</span> :<br>        (elements[head] != <span class="hljs-keyword">null</span> &amp;&amp;<br>         elements[(tail - <span class="hljs-number">1</span>) &amp; (elements.length - <span class="hljs-number">1</span>)] != <span class="hljs-keyword">null</span>);<br>    <span class="hljs-keyword">assert</span> elements[(head - <span class="hljs-number">1</span>) &amp; (elements.length - <span class="hljs-number">1</span>)] == <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="0x3-课后总结"><a href="#0x3-课后总结" class="headerlink" title="0x3 课后总结"></a>0x3 课后总结</h2><p>ArrayDeque采用数组实现循环队列,容量始终是2次幂。在单线程中:</p><ul><li>作为栈,比<code>Stack</code>快,因为不需要保证线程安全</li><li>作为队列比LinkedList快,因为不需要构造节点</li></ul><p>不过一般没啥人用吧,就当为分析LinkedList提前开路了。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.jianshu.com/p/1c1c3f24762e">https://www.jianshu.com/p/1c1c3f24762e</a></p>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Queue</tag>
      
      <tag>ArrayQueue</tag>
      
      <tag>ArrayDeque</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021-06-03/Collection-interface-analysis.html"/>
    <url>/2021-06-03/Collection-interface-analysis.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021-06-03/List-interface-analysis.html"/>
    <url>/2021-06-03/List-interface-analysis.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>volatile关键字</title>
    <link href="/2021-06-03/volatile-keyword.html"/>
    <url>/2021-06-03/volatile-keyword.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-volatile是什么"><a href="#1-volatile是什么" class="headerlink" title="1. volatile是什么"></a>1. volatile是什么</h2><p>volatile被称为轻量级的<code>synchronzied</code>，它保证了内存的可见性、指令的有序性。我们通过经典的懒汉单例模式看看这个关键字的作用。</p><figure class="highlight java"><figcaption><span>"线程不安全"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DraconianSingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DraconianSingleton instance;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  DraconianSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>            synchronzied(<span class="hljs-keyword">this</span>)&#123;<br>                <span class="hljs-keyword">if</span>(instance==<span class="hljs-keyword">null</span>)&#123;<br>                    instance = <span class="hljs-keyword">new</span> DraconianSingleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>虽然使用了双锁，但是上述代码仍然是线程不安全的，因为<code>new DraconianSingleton()</code>并不是原子操作。这句代码的正常操作是：</p><ol><li>分配内存空间</li><li>初始化对象</li><li>将对象地址赋给引用instance</li></ol><p>但是因为操作2和操作3之间没有数据依赖，编译器有理由将这两条指令进行重排。重拍后的操作为：</p><ol><li>分配内存空间</li><li>将对象地址赋给引用instance</li><li>初始化对象</li></ol><p>重排后的指令在单线程环境下执行是没有问题的。但是在多线程环境下，如果thread1获得锁并且在执行了第二步之后，<code>instance != null</code>,但是对象并没有完成初始化。此时如果thread1时间片到期，切换到thread2。thread2调用<code>getInstace()</code>后获得的是一个部分初始化的对象，此时thread2在使用这个对象时很可能会出现意外的错误。</p><p>但是使用<code>volatile</code>修饰<code>instance</code>后，就能够禁止上述的重排现象发生，从而变成线程安全。</p><figure class="highlight java"><figcaption><span>"线程安全"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DraconianSingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> DraconianSingleton instance;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  DraconianSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>            synchronzied(<span class="hljs-keyword">this</span>)&#123;<br>                <span class="hljs-keyword">if</span>(instance==<span class="hljs-keyword">null</span>)&#123;<br>                    instance = <span class="hljs-keyword">new</span> DraconianSingleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-volatile做了什么"><a href="#2-volatile做了什么" class="headerlink" title="2.volatile做了什么"></a>2.volatile做了什么</h2><p>volatile能够禁止上述指令重排的原因是因为它在volatile write操作之前插入了内存屏障，禁止volatile write操作之前任何的read/write操作重排序到volatile write之后。在执行<code>new DraconianSingleton()</code>时，构造函数(构造函数可以会执行写操作，例如写变量的初值)肯定会执行write操作，所以构造函数的write操作一定不会被重排序到volatile write操作之后，从而保证了只会在实例化对象完成后才会<code>instance</code>赋值。</p><p>网上许多文章都说volatile会执行上述的操作禁止指令重排，但是几乎没有人说它为什么这么做。我尝试使用如下代码解释一下我的理解：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">volatile</span> b;<br>write()&#123; <span class="hljs-comment">//thread 1</span><br>    a=<span class="hljs-number">1</span>; <span class="hljs-comment">//opreation 1</span><br>    <span class="hljs-comment">//StoreStore memory barrier</span><br>    b=<span class="hljs-number">2</span>; <span class="hljs-comment">//opreation 2</span><br>    <span class="hljs-comment">//StoreLoad memory barrier</span><br>&#125;<br><br>read()&#123; <span class="hljs-comment">//thread 2</span><br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">2</span>)&#123; <span class="hljs-comment">//opreation 3</span><br>        sout(a);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>根据happens before的程序次序原则，o1 hb o2，那么JMM保证o1的执行结果必须被o2看到。我们可以延伸一下，volatile write之前所有的动作结果都应该在volatile write执行时被看到。所以为了实现这个效果，JMM会在volatile write之前插入StoreStore、StoreLoad内存屏障（这是最笨、最稳妥的办法，具体实现时肯定会有相应的优化。<br>根据happens before的volatile变量规则，o2 hb o3，JMM保证o2（volatile写）的执行结果必须被o3（volatile读）看到。为了实现这个效果，需要借助StoreLoad内存屏障的力量。</p><p><strong>所以volatile做这些工作都是为了实现happens before relation</strong>。内存屏障只是volatile实现happens before的<strong>技术手段</strong>。并且volatile并不会刷新内存，那不是它的责任，刷新内存是内存屏障的作用。</p><hr><p><strong>对于volatile的一些小疑问：</strong></p><p><strong>Q1：对于volatile write(A) hb volatile read(B)，是不是只有A先比B发生，JMM才会使用内存屏障达到B一定能够看到A的效果（即实现 A hb B）。也就是说，如果A没有比B先发生，JMM就不会使用内存屏障实现A hb B了？</strong></p><p>很明显这个表述是有问题的，但是我一直不知道如何否定这个逻辑。经过几天的思考，我给出我的理解：<br>对于volatile write(A) hb volatile read(B)，JMM不管A与B谁先发生，它只管使用内存屏障达到：如果A发生，B就能看到结果的效果（换言之，JMM按照理想情况，A先发生B后发生的情形插入内存屏障）。这样就会有：</p><ul><li>如果A比B先发生，那么就能实现A hb B的效果</li><li>如果B比A先发生，那么虽然插入了内存屏障，但是也没有产生什么负面效果</li></ul><p><strong>Q2：volatile真的禁止重排序了吗？</strong></p><p>我认为volatile并没有这么做，volatile它只是借助内存屏障禁止volatile write之前的任何read/write重排序到volatile write之后，至于那些read/write操作到底如何重排序，volatile并不care</p><hr><h2 id="3-volatile如何使用"><a href="#3-volatile如何使用" class="headerlink" title="3. volatile如何使用"></a>3. volatile如何使用</h2><p>首先我们需要知道volatile只有read/write操作具有原子性，剩余的基于volatile的算数运算并没有原子性。例如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clac</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>        <span class="hljs-keyword">new</span> Thread()&#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">1000</span>;j++)<br>                    j++;<br>            &#125;;<br>        &#125;.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述<code>j++</code>并不具有原子性。想象以下多线程的场景：</p><p><code>j</code>默认初始化为0。首先thread读取到<code>j=0</code>，然后进行<code>+1</code>操作，但是在将1赋给<code>j</code>之前，时间片用完，所以此时并没有volatile write操作。切换到thread2，thread2读取到的<code>j</code>仍然为0，并且完成了<code>+1</code>的动作。这样在thread2完成之后，其他所有的线程读取到的<code>j</code>肯定都为<code>1</code>。但是thread1此时不需要读取<code>j</code>了，它只会完成最后一步的volatile write动作。出现了线程安全问题。所以说volatile只有read/write操作具有原子性。</p><p>上面出现问题的原因是什么呢？</p><blockquote><p>多个线程都能够修改同一个volatile的值，并且目标修改值依赖volatile变量的前一个值</p></blockquote><p>所以为了避免上述缺陷，volatile的理想使用场景是：</p><ol><li><p>可以有多个线程修改volatile变量，但是修改后的值不应该依赖volatile变量之前的值</p></li><li><p>volatile变量不需要与其他变量构成约束条件（我理解的约束条件是导致控制流发生改变的条件）</p></li></ol><p>规则1很好理解，对于规则2的理解见如下代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//代码摘自：http://kael-aiur.com/java/java%E4%B8%ADvolatile%E5%85%B3%E9%94%AE%E5%AD%97.html</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberRange</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> lower, upper;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLower</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> lower; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getUpper</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> upper; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLower</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123; <br>        <span class="hljs-keyword">if</span> (value &gt; upper) <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(...);<br>        lower = value;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUpper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123; <br>        <span class="hljs-keyword">if</span> (value &lt; lower) <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(...);<br>        upper = value;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在上面的代码中，如果lower与upper初始化为(0,5)。两个线程分别调用<code>setLower</code>和<code>setUpper</code>，将（lower,upper）设置为（4，3），例如调用<code>setLower</code>通过if检查后，让出cpu，<code>setUpper</code>通过if检查后，继续执行，就能够成功将区间设置为（4，3）。这样的区间是没有意义的，之所以会出现这样的错误是因为约束条件为<code>value&gt;upper</code>，<code>volatile</code>与<code>value</code>共同参与了不变约束。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://stackoverflow.com/questions/11639746/what-is-the-point-of-making-the-singleton-instance-volatile-while-using-double-l/11640026#11640026">What is the point of making the singleton instance volatile while using double lock?</a></p></li><li><p><a href="https://stackoverflow.com/questions/51647337/java-volatile-reordering-prevention-scope">Java volatile reordering prevention scope</a></p></li><li><p><a href="https://blog.csdn.net/xdzhouxin/article/details/81236356">volatile为什么不能保证原子性</a></p></li><li><p><a href="https://developpaper.com/memory-barrier-and-its-application-in-jvm-2/">Memory barrier and its application in – JVM (2)</a></p></li><li><p><a href="https://stackoverflow.com/questions/45151763/analyzing-of-x86-output-generated-by-jit-in-the-context-of-volatile">Analyzing of x86 output generated by JIT in the context of volatile</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>多线程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>volatile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程为什么会不安全</title>
    <link href="/2021-06-03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%B8%8D%E5%AE%89%E5%85%A8.html"/>
    <url>/2021-06-03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%B8%8D%E5%AE%89%E5%85%A8.html</url>
    
    <content type="html"><![CDATA[<p>在聊多线程为什么不安全之前，需要说一哈学习多线程编程的路线。多线程说到底就是为了提高效率，而这个效率的提高是有安全风险的，这也是多线程为啥这么难的原因。而编写一个多线程的程序可以分为三个部分：分工、同步、互斥。</p><p>分工更偏向于<strong>设计</strong>，这里是提高性能的关键。相当于项目经理分配任务。与现实世界非常相似, <strong>不过是一个线程执行完了一个任务，如何通知执行后续任务的线程开工而已。</strong> 这里多说一句，计算机里的这个模型那个模型我认为都是为了更好的模拟现实世界。</p><p>而同步是偏向于<strong>实现</strong>，同步就是为了线程之间的更好的有序协作，这与现实世界的分工合作并无不同。线程之间的协作问题都可以认为时：当某个线程不满足条件时，需要怎么样，满足条件了，又怎么样。<strong>在Java并发编程领域，解决协作问题的核心技术是管程</strong>。</p><p>而互斥则是为了<strong>安全</strong>。线程不安全是因为线程之间执行的顺序是不确定的，导致不确定的因素有三点：可见性问题、有序性问题和原子性问题。java引入了JMM(内存模型，一组规则)解决前两个问题，这还不够。还需要解决互斥问题，所谓的互斥就是指<strong>同一时刻，只能有一个线程访问共享变量</strong>。解决互斥的关键还是锁。</p><p>下面贴出一张大佬总结并发学习的思路：</p><p><img src="images/learn-route.png" alt="并发学习架构"></p><p>ok,我们开始进入正题：并发安全的三大问题是：可见性问题、原子性问题、有序性问题。在普通的计算机模型中，cpu通常采用三级缓存，之后才是内存，所以如果有多个核心，它们的一二级缓存是不共享的，但是它们对变量的操作都会在缓存里进行，显而易见，各个核心在自己缓存里的操作是隔离的，别人看不到的，这也就是所谓的可见性问题。</p><p>那么在java中，因为有JMM，堆是共享的，每个线程都有自己的逻辑工作内存，当然这个工作内存也是互不可见的。这就与上面的缓存问题是等价的。那么如果我们想在java中解决可见性，就需要对共享变量加上volatile关键字，注意，<strong>volatile只保证可见性与有序性，不保证原子性</strong>。volatile的工作原理时如果一个线程对共享变量做了改变，那么就会将改变强制刷新到堆中，同理如果有另外的线程想要操作共享变量，只能强制从堆中读取最新的数据。这里还有一点需要注意：<strong>JMM规定，线程的操作只能在自己的工作内存中完成</strong>。</p><p>原子性没啥好解释的。</p><p>有序性就是汇编指令的执行顺序不定，但是保证结果是一样的。</p><p>下面是一个存在线程安全的单例模式：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> Singleton instance;<br>  <span class="hljs-function"><span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)<br>          instance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>问题在于 <code>new Singlrton()</code>的指令重排问题。可能的步骤是先分配内存，然后设置地址引用，最后初始化。如果线程A在设置完地址引用后，时间到了，此时不会释放锁。如果线程B此时才进入第一个if判断，因为已经设置过引用了，会直接返回。此时的对象还未创建后，会出现非法引用的错误。</p><p>在评论区看到一个正确的解答：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySingleton</span> </span>&#123;<br><br>    <span class="hljs-comment">//内部类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySingletonHandler</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> MySingleton instance = <span class="hljs-keyword">new</span> MySingleton();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">MySingleton</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> MySingletonHandler.instance;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><a href="https://blog.csdn.net/mnb65482/article/details/80458571">静态内部类实现的单例模式为什么是线程安全的</a></p>]]></content>
    
    
    <categories>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基本概念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java视角下的Linux IO API</title>
    <link href="/2021-06-03/basic-API.html"/>
    <url>/2021-06-03/basic-API.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>思考java中的访问控制</title>
    <link href="/2021-06-03/access-control-of-Java.html"/>
    <url>/2021-06-03/access-control-of-Java.html</url>
    
    <content type="html"><![CDATA[<p>java中权限修饰符作用于两个地方，一个是类，另一个是类的成员。下面将分别详细讲解。</p><h2 id="java中的类权限修饰符"><a href="#java中的类权限修饰符" class="headerlink" title="java中的类权限修饰符"></a>java中的类权限修饰符</h2><p>在讲解类的权限的修饰符前，我们需要明确一个概念。在java中，任何可执行的语句都必须<strong>放在一个类中的方法</strong>，比如调用方法。不像c++，在类外也能定义函数，在java中，我们say no。不管你是创建别的类的对象，还是创建方法，成员，等等，这都必须放在一个类中。</p><p>java中的类只能有两种权限修饰符：<code>public</code>和默认的包权限，即什么都不写。</p><p>这里的类的访问控制是指在包A中能否使用导入的包B中的类。对于public类，就是放开了，只要导入public class所在的包，就能使用该类。而包权限的类是只能在所定义的包中使用，也就是所谓的包权限，例如class A所在的包为A。在包B中导入了包A，也就是把A中的所有类导入了包B然后使用，这里注意使用的地方是在包B，包A的包权限类只能在所定义的包A中使用。<strong>这里的使用指的是能够解析类名</strong>，至于能不能创建具体的对象是另外一回事。</p><h2 id="java中的成员权限修饰符"><a href="#java中的成员权限修饰符" class="headerlink" title="java中的成员权限修饰符"></a>java中的成员权限修饰符</h2><p>能修饰成员的权限描述符为：<code>public</code>、<code>private</code>、<code>protected</code>和包权限。这里有一个前提：<br>访问类的成员和方法的前提是能够访问该类！所以不同包下的包权限类中的成员设置成什么权限都无所谓。使用权限修饰符成员是为了隔离同一包下的类和不同包的public类。</p><p>成员修饰符的存在是为了什么？是为了阻止在<strong>不同类</strong>下访问不该访问的东西。什么意思？也就是说，即使类把自己的数据成员私有化，在自己类中创建自己的对象时仍能够访问类的私有数据成员。l例如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> </span>&#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-comment">//protected static int c;</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>show();<br>        <span class="hljs-comment">//输出为10tim</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cat</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br><span class="hljs-keyword">super</span>();<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>Cat cat=<span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;tim&quot;</span>,<span class="hljs-number">10</span>);<br>System.out.println(cat.age+cat.name);<br>&#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述代码仍能够正常运行，即使Cat类的<code>name</code>、<code>age</code>都是私有化的，但是对象<code>cat</code>仍能访问。所以我们可以得出一个结论：能否访问类的成员关键在于我们是在哪访问。在类本身中我们可以访问一切属于该类的资源。比如上述代码中的<code>cat</code>对象。</p><p>所以接下来理解成员的四种访问权限修饰符就很容易了。</p><p><strong>private</strong></p><p>对于private成员，只要出了成员被定义的类，那么我们就不能访问。</p><p><strong>包权限</strong></p><p>对于包权限的成员，只要在同一包下，无论是在成员被定义的类中，还是在同一包下的其他类都可以访问。</p><p><strong>public</strong></p><p>在任何类下都可随意访问，但是前提是：能否访问public成员所在的类，否则一切都是白搭。</p><p><strong>protected</strong></p><p>对于<code>protected</code>，这个是包权限的增强版。被<code>protected</code>修饰的成员，只要在同一包下就能访问，不管是不是在成员被定义的类中。这一点与包权限相同。增强是增强在在不同包下的子类。</p><p>当在不同包下时：如果是非子类，只能访问public成员。如果是子类，则能访问protected成员。这里的能访问指的是什么？</p><p>对于protected的成员函数，指的是<strong>在子类中</strong>子类有资格去访问、重写这个父类的protected函数。注意访问、重写是在<strong>子类</strong>中,而不能在别的类中。在别的类中，不管是通过子类对象，还是父类对象，都不能访问protected成员。下面的代码给出了一个很好的栗子。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Cat</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show3</span><span class="hljs-params">()</span> </span>&#123;<br>Dog d=<span class="hljs-keyword">new</span> Dog();<br>        <span class="hljs-comment">//编译成功，因为是在子类本身中，这里的父类指的Object类</span><br>d.clone();<br>&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">lion</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show5</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>Dog d=<span class="hljs-keyword">new</span> Dog();<br>        <span class="hljs-comment">//编译失败，在其他类中就不能访问Dog类中的protected成员了</span><br>d.clone();<br>&#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>如果在子类中重写了父类的protected函数，在其他类中又可以通过子类的对象来访问，这是为什么？</p><p>因为你一旦在子类中重写了父类的protected成员函数，在子类中就显示有了自己的protected函数，那么在一个包下的其他类当然可以访问本包内的所有protected成员。对应的如果类B与子类又不在同一包内，仍然不能访问子类的proteced函数。</p><p>简而言之，记住一句话，就可以通杀这些问题：</p><blockquote><p>权限修饰符是<strong>针对类的、针对类的、针对类的</strong>！而不是针对对象的。重要的话说三遍。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>访问控制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态代理的原理</title>
    <link href="/2021-06-03/analysis-of-dynamic-proxy.html"/>
    <url>/2021-06-03/analysis-of-dynamic-proxy.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>代理分为静态代理和动态代理。静态代理就是我们手动地将代理类写出来，而动态代理就是由虚拟机在运行时自动地将代理类构造出来。下面我就简单地阐述静态代理的用法以及缺点。</p><p>首先在下面声明需要代理的类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//实体类实现的接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">search</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//实体类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the add method.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the delete method&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the update method&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">search</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the search method&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>被代理的类<code>UserDaoImpl</code>实现了接口<code>UserDao</code>。</p><h2 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2. 静态代理"></a>2. 静态代理</h2><p>所谓的静态代理就是手动地构造一个类，并实现被代理类的所有接口，在代理类调用被代理类的目标方法，下面我们构造一个实现<code>UserDao</code>接口的方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.learn.proxy;<br><br><span class="hljs-keyword">import</span> com.learn.dao.UserDao;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">staticProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span></span>&#123;<br>    <span class="hljs-keyword">private</span> UserDao user;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUser</span><span class="hljs-params">(UserDao user)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.user = user;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the method:add&quot;</span>);<br>        user.add();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the method:delete&quot;</span>);<br>        user.delete();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the method:update&quot;</span>);<br>        user.update();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">search</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the method:search&quot;</span>);<br>        user.search();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，如果被代理的类方法过多，在每个代理类的方法都得写上同样的代码，太冗余，而且容易出错，是个体力活。所谓为了解决这个缺点，产生了动态代理。</p><h2 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3. 动态代理"></a>3. 动态代理</h2><p>动态代理有两种实现方式：</p><ul><li>使用Java原生API：Proxy+InvocationHandler</li><li>使用cglib</li></ul><p>这里先讲讲Java原生API是怎么用的，有什么缺点。</p><h3 id="3-1-基于原生API的动态代理"><a href="#3-1-基于原生API的动态代理" class="headerlink" title="3.1 基于原生API的动态代理"></a>3.1 基于原生API的动态代理</h3><p>原生API要求被代理的类必须实现接口，动态代理由<code>Proxy</code>类的静态方法<code>newProxyInstance</code>生成，并且要求用于生成动态代理的类必须实现接口<code>InvocationHandler</code>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> UserDao user;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUser</span><span class="hljs-params">(UserDao user)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.user = user;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxyObject</span><span class="hljs-params">()</span></span>&#123;<br>        System.getProperties().put(<span class="hljs-string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<span class="hljs-keyword">this</span>.getClass().getClassLoader(), user.getClass().getInterfaces(),<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;using &quot;</span>+method.getName());<br>        <span class="hljs-comment">//去user对象中查找有没有method对应的方法</span><br>        Object result=method.invoke(user, args);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中<code>public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code>需要我们提供四个参数：</p><ol><li>loader：用于定义动态代理类的ClassLoader</li><li>interfaces：被代理的类已经实现的接口</li><li>h：InvocationHandler对象</li></ol><p>这三个参数没有什么难理解的，我们需要主要关注<code>invoke</code>方法的构成。我们需要在方法调用前执行的操作以及在方法调用后执行的操作都需要在书写在<code>invoke</code>函数。其中最重要就是不能忘记调用<code>method.invoke</code>，这一句完成了实际方法的调用。</p><p>那么为什么要这么写，动态生成的代理类到底长什么样？我们来瞅瞅（如果没有找到动态代理类，一般是因为没有保存至磁盘，只需要添加虚拟机启动参数<code>-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true</code>即可）。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//动态代理类继承了Proxy类，并且实现了我们传递的接口参数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">Proxy0</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m1;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m2;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m3;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m5;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m6;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m0;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m4;<br><br>    <span class="hljs-keyword">public</span> $Proxy0(InvocationHandler var1) <span class="hljs-keyword">throws</span>  &#123;<br>        <span class="hljs-keyword">super</span>(var1);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object var1)</span> <span class="hljs-keyword">throws</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Boolean)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m1, <span class="hljs-keyword">new</span> Object[]&#123;var1&#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var3) &#123;<br>            <span class="hljs-keyword">throw</span> var3;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var4) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var4);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (String)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m2, (Object[])<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Integer)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m0, (Object[])<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);<br>        &#125;<br>    &#125;<br>    ...<br><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m3, (Object[])<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);<br>        &#125;<br>    &#125;<br>    <br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            m1 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;equals&quot;</span>, Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>));<br>            m2 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;toString&quot;</span>);<br>            m3 = Class.forName(<span class="hljs-string">&quot;com.learn.dao.UserDao&quot;</span>).getMethod(<span class="hljs-string">&quot;add&quot;</span>);<br>            m5 = Class.forName(<span class="hljs-string">&quot;com.learn.dao.UserDao&quot;</span>).getMethod(<span class="hljs-string">&quot;delete&quot;</span>);<br>            m6 = Class.forName(<span class="hljs-string">&quot;com.learn.dao.UserDao&quot;</span>).getMethod(<span class="hljs-string">&quot;search&quot;</span>);<br>            m0 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;hashCode&quot;</span>);<br>            m4 = Class.forName(<span class="hljs-string">&quot;com.learn.dao.UserDao&quot;</span>).getMethod(<span class="hljs-string">&quot;update&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException var2) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchMethodError(var2.getMessage());<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoClassDefFoundError(var3.getMessage());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看出，动态代理类继承了<code>Proxy</code>类，并且实现了我们传递的接口，也就是被代理类实现的接口<code>UserDao</code>。所以也就实现了该接口的所有方法。对于<code>add</code>方法，仅仅只有一句代码：<code>super.h.invoke(this, m3, (Object[])null);</code>，调用了父类属性<code>InvocationHandler</code>的<code>invoke</code>方法。而这个<code>InvocationHandler</code>就是我们在调用<code>newProxyInstance</code>时传递进去的参数<code>this</code>。所以其<code>invoke</code>的方法就是我们<code>UserDaoProxy</code>类中实现的<code>invoke</code>方法。</p><p>上述就是基于JDK的动态代理原理。可以看到，我们在生成代理对象时，必须传递被代理类实现的接口。如果我们想代理一个没有实现接口的参数怎么办？cglib解决了这个问题。</p><h3 id="3-2-基于cglib的代理"><a href="#3-2-基于cglib的代理" class="headerlink" title="3.2 基于cglib的代理"></a>3.2 基于cglib的代理</h3><p>cglib是基于ASM框架的一个高性能代码生成库，而ASM是一个Java字节码操控框架。它能被用来动态生成类或者增强现有类的功能。那么cglib到底是如何使用的呢？</p><p>第一步当然是导入对应的jar包，很简单，在maven respo中搜索即可：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>在cglib中，想要实现代理最重要的一步就是设置回调函数（callback），所谓的回调函数就是在调用目标方法之前或者之后设置需要实现的代理操作。并且在callback中调用真正的目标方法。cglib的callback有很多种类型，最常用的就是实现callback的子接口<code>MethodInterceptor</code>，这个接口会拦截被代理的所有方法，如下面的代码所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the method before:&quot;</span> + method.getName());<br>        <span class="hljs-comment">//调用被代理类的方法</span><br>        Object o1 = methodProxy.invokeSuper(o, objects);<br>        System.out.println(<span class="hljs-string">&quot;call the method after:&quot;</span> + method.getName());<br>        <span class="hljs-keyword">return</span> o1;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Proxy&#123;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>然后构造一个代理类，这需要借助工具类<code>Enhancer</code>（意为增强，比较好理解），cglib实现代理的原理是继承被代理类，所以需要完成的操作包括：</p><ol><li>生成工具类Enhancer</li><li>设置父类</li><li>设置回调函数callback</li><li>生成被代理类</li></ol><p>如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">testCG</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="hljs-string">&quot;D:\\cglib&quot;</span>);<br>        Enhancer enhancer=<span class="hljs-keyword">new</span> Enhancer();<br>        <span class="hljs-comment">//设置父类</span><br>        enhancer.setSuperclass(DaoImpl.class);<br>        <span class="hljs-comment">//设置回调函数callback</span><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> Proxy());<br>        <span class="hljs-comment">//生成被代理类</span><br>        DaoImpl en = (DaoImpl)enhancer.create();<br>        en.add();<br>        en.toString();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>cglib代理的实现原理较复杂，目前没有时间深究，列出两篇原理的讲解，以后有时间在学习。但是有一点值得我们注意：<strong>对于从Object中继承的方法，cglib也会进行动态代理。</strong></p><ol><li><a href="https://blog.csdn.net/P19777/article/details/103998918">CGLIB入门系列三，CGLIB生成的代理类详解</a></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1.<a href="https://objectcomputing.com/resources/publications/sett/november-2005-create-proxies-dynamically-using-cglib-library">CREATE PROXIES DYNAMICALLY USING CGLIB LIBRARY</a></p><ol start="2"><li><a href="https://www.cnblogs.com/xrq730/p/6661692.html">Cglib及其基本使用</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dynamic proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的GC</title>
    <link href="/2021-06-03/the-GC-of-Java.html"/>
    <url>/2021-06-03/the-GC-of-Java.html</url>
    
    <content type="html"><![CDATA[<p>Java中的自动垃圾回收是其一大优点。本文将从以下三个方面简介相关知识：</p><ol><li>如何定义垃圾</li><li>垃圾回收的时机</li><li>垃圾回收的策略</li><li>具体的垃圾回收器</li></ol><p>在介绍相关的知识前，我们需要知道一个词：<code>stop-the-world</code>，这个词专门为GC而生，因为Java会在进行垃圾回收的时候除了GC线程外，会暂停所有工作线程，也就是所谓的“停止世界运转”。那么GC优化时，我们的目标可能就是减少GC时<code>stop-the-world</code>的时间（这句话网上抄的，当然大部分内容都是）。</p><h2 id="1-如何定义垃圾"><a href="#1-如何定义垃圾" class="headerlink" title="1. 如何定义垃圾"></a>1. 如何定义垃圾</h2><p>在Java中，定义一个对象为垃圾的策略分为两种：</p><ol><li>引用计数法</li><li>可达性算法</li></ol><p>所谓的<strong>引用计数法</strong>，也就是说：对于一个对象A，如果它的被引用次数为0，就说明没有别的对象在使用A，那么A自然而然地称为垃圾。但是这种会存在循环引用的问题。我们看看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>    <span class="hljs-keyword">private</span> B b;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setB</span><span class="hljs-params">(B b)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.b=b;<br>    &#125;<br>    ...<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;<br>    <span class="hljs-keyword">private</span> A a;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setA</span><span class="hljs-params">(A a)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.a=a;<br>    &#125;<br>    ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    A a=<span class="hljs-keyword">new</span> A();<br>    B b=<span class="hljs-keyword">new</span> B();<br>    a.setB(b);<br>    b.setA(a);<br>    a=<span class="hljs-keyword">null</span>;<br>    b=<span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面的代码中，在将a、b设置为null后，看似会被回收，但是实例a中仍然持有实例b的引用，实例b同理。这样实例a和b的引用计数各位1。如果以后不再使用这两个实例，那么就会造成内存泄漏。</p><p>可达性算法就是为了解决上述循环引用的问题。按照我的理解，所谓的可达性分析，是指一个实例的调用链，而调用链又是通过一个名叫<code>GCRoot</code>的数据结构维持的。所谓的<code>GCRoot</code>可以由以下四种中任意一个组成：</p><ol><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>虚拟机栈中引用的对象</li><li>本地native栈中引用的对象</li></ol><h2 id="2-垃圾回收的时机"><a href="#2-垃圾回收的时机" class="headerlink" title="2. 垃圾回收的时机"></a>2. 垃圾回收的时机</h2><p>Java把它的内存区域在逻辑上划分为三类：新生代、老年代、永久代。Java对这三类采用了不同的垃圾回收时机。</p><h3 id="2-1-新生代"><a href="#2-1-新生代" class="headerlink" title="2.1 新生代"></a>2.1 新生代</h3><p>所谓的新生代就是Java在构造实例的时候会使用这块内存，大对象（需要使用连续内存的对象）会直接放在老年代。</p><p>Java又把新生代划分为三个区域：Eden、survivor0和survivor1，每次只会使用Eden区和某一个survivor。假设在初始时，我们使用的Eden区和survivor0区，那么当这两个子区满了之后，会将它们中存活的对象复制到survivor1，这个过程叫做<strong>MinorGC</strong>，也就是次要的垃圾回收，当然MinorGC并不一定要Eden区满了才执行，有可能会经常执行（存疑）。此后survivor1和survivor0的角色交换。JVM使用Eden和survivor1。满了之后重复上述过程。</p><p><strong>特别的，当survivor1区也不足以存放eden区和survivor0区的存活对象时，就将存活对象直接存放到老年代。</strong></p><p><strong>新生代的回收时机就是Eden和某一个survivor内存用尽。</strong></p><h3 id="2-2-老年代"><a href="#2-2-老年代" class="headerlink" title="2.2 老年代"></a>2.2 老年代</h3><p>至于老年代，存放的都是一些生命周期较长的对象，就像上面所叙述的那样，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。</p><p>如果老年代也满了，就会触发一次<strong>FullGC</strong>，也就是<strong>新生代、老年代都进行回收</strong>。当然FullGC执行的频率比较低。导致FullGC的原因包括：老年代被写满、永久代（Perm）被写满和System.gc()被显式调用等。</p><h3 id="2-3-永久代"><a href="#2-3-永久代" class="headerlink" title="2.3 永久代"></a>2.3 永久代</h3><p>永久代主要用于存放静态文件，如Java类、方法等。</p><h2 id="3-垃圾回收的策略"><a href="#3-垃圾回收的策略" class="headerlink" title="3. 垃圾回收的策略"></a>3. 垃圾回收的策略</h2><p>Java的垃圾回收策略主要有三种：</p><ol><li>标记清除</li><li>复制交换</li><li>标记整理</li></ol><h3 id="3-1-标记清除算法"><a href="#3-1-标记清除算法" class="headerlink" title="3.1 标记清除算法"></a>3.1 标记清除算法</h3><p>标记-清除算法分为标记和清除两个阶段。该算法首先从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象并进行回收，</p><p>标记-清除算法的主要不足有两个：</p><ol><li><strong>效率问题</strong>：标记和清除两个过程的效率都不高;</li><li><strong>空间问题</strong>：标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，因此标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ol><h3 id="3-2-复制算法"><a href="#3-2-复制算法" class="headerlink" title="3.2 复制算法"></a>3.2 复制算法</h3><p>所谓的复制算法就是将堆区一分为二，分为A和B。每次只使用一个，当A满了之后，将A中存活的对象复制到B中。这种算法非常适用于存活率低的对象。因为需要复制的内容不会很多，并且复制时只需要调整指针，也不需要考虑内存碎片的问题，并且这种策略已经用于商业虚拟机中的新生代回收算法，<strong>因为研究发现，新生代中的对象每次回收都基本上只有10%左右的对象存活，所以需要复制的对象很少，效率还不错。</strong></p><h3 id="3-3-标记整理算法"><a href="#3-3-标记整理算法" class="headerlink" title="3.3 标记整理算法"></a>3.3 标记整理算法</h3><p>标记整理算法与标记清除算法类似，唯一的不同时，前者会在清除完毕后，有一个整理内存碎片的操作。这样就解决了标记清除算法中的空间问题。</p><h2 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4. 垃圾回收器"></a>4. 垃圾回收器</h2><p>可以按照垃圾回收器作用的内存区域分类：</p><p>作用于新生代的包括：</p><ul><li>ParNew收集器 (复制算法)，<strong>并行</strong></li><li>Parallel Scavenge收集器，<strong>并行</strong>，追求高吞吐量</li></ul><p>作用于老年代的包括：</p><ul><li>CMS，<strong>并行</strong>，使用标记清除策略，追求最短GC回收停顿时间。</li><li>Parallel Old收集器，<strong>并行</strong>，使用标记-整理策略，追求高吞吐量</li></ul><p>作用于两者的包括：</p><ul><li>G1收集器，<strong>并行</strong>，使用标记整理策略</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://segmentfault.com/a/1190000023637649">java面试官最爱问的垃圾回收机制，这位阿里P7大佬分析的属实到位</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>garbage collection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java的字符串</title>
    <link href="/2021-06-03/the-String-of-Java.html"/>
    <url>/2021-06-03/the-String-of-Java.html</url>
    
    <content type="html"><![CDATA[<p>java的所有字符串都会保存在全局字符串池中，在了解全局字符串池之前，我们需要明白：在java中，所有的字符串字面值都会被解释为一个字符串对象。</p><blockquote><p>All string literals in Java programs, such as “abc”, are implemented as instances of this class</p></blockquote><p>接下来我们聊聊全局字符串池。全局字符串池在jdk1.7后也是堆的一部分，不属于某个类，被所有线程共享。那么这个字符串池有啥用？</p><blockquote><p>String pool helps in saving a lot of space for Java Runtime although it takes more time to create the String.</p></blockquote><p>由上可知，字符串池的创建是为了在运行时节省空间。字符串常量池跟创建字符串的方式息息相关。首先创建字符串的方式有两种：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String s1=<span class="hljs-string">&quot;test&quot;</span>;<br>String s2=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;test&quot;</span>);<br>String s3=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br>String s4=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;bc&quot;</span>);<br>String s5=<span class="hljs-string">&quot;a&quot;</span>+s4;<br><br>System.out.println()<br></code></pre></div></td></tr></table></figure><p>首先我们应该明白一个理念：就是所有能够在编译时确定的常量都会放在<code>constant_pool table</code>中，相对应的任何引用在编译期都无法确定。比如上面代码中的<code>test</code>、<code>abc</code>字面值都会作为String对象并在编译后加入当前class的<code>constant_pool table</code>中。在运行时会被解释为String对象加入字符串常量池。String的intern方法非常特殊。下面来详解关于String intern的一切。</p><h2 id="Intern的用法"><a href="#Intern的用法" class="headerlink" title="Intern的用法"></a>Intern的用法</h2><p>在解释关于intern的相关操作时，我们首先需要知道什么是intern。</p><blockquote><p>String.intern()是一个Native方法，它的作用是 ： 如果字符串常量池已经包含一个内容等于当前String对象的字符串对象，则返回代表字符串常量池中的内容相同的字符串的对象；否则将此 String对象的引用地址（堆中）添加到字符串常量池中。<strong>jdk 1.7 后的字符串常量池存在于堆中。</strong></p></blockquote><h3 id="字符串已加入字符串池后Intern"><a href="#字符串已加入字符串池后Intern" class="headerlink" title="字符串已加入字符串池后Intern"></a>字符串已加入字符串池后Intern</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String s1=<span class="hljs-string">&quot;abc&quot;</span>;<br>String s2=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br>String s2Intern=s2.intern();<br>System.out.println(<span class="hljs-string">&quot;s2Intern==s2: &quot;</span>+(s2Intern==s2));<span class="hljs-comment">//flase</span><br>System.out.println(<span class="hljs-string">&quot;s1==s2Intern: &quot;</span>+(s1==s2Intern));<span class="hljs-comment">//true</span><br></code></pre></div></td></tr></table></figure><p>在加载类后，<code>abc</code>这个字面值已经加入字符串池。因为这个在编译时就能确定。</p><p>在执行第一句后，<code>abc</code>会加入字符串池中，s1是指向该字符串的引用。</p><p>在执行第二句时，会在堆内创建一个String对象。该对象的字面值为<code>abc</code>。</p><p>第三句s2调用Intern时，会使用<code>equals</code>方法在字符串池中找与s2内容相同的字符串，能找到吗？当然，因为前一句执行完，<code>abc</code>这个字面值已经加入字符串池中。</p><p>第四句比较<code>s2</code>与<code>s2Intern</code>，<code>s2</code>是堆中<code>abc</code>的引用，<code>s2Intern</code>是字符串池中<code>abc</code>的引用。结果自然为false，因为都不是一个东西。</p><p>而第五句比较<code>s1``s2Intern</code>是否相等。<code>s1</code>是字符串池中<code>abc</code>的引用，<code>s2Intern</code>得到的也是字符串池中<code>abc</code>的引用，结果自然为true。</p><h3 id="字符串未加入字符串池Intern"><a href="#字符串未加入字符串池Intern" class="headerlink" title="字符串未加入字符串池Intern"></a>字符串未加入字符串池Intern</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String bb = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;123&quot;</span>) + <span class="hljs-string">&quot;456&quot;</span>;<br>String bbIntern = bb.intern();<br>System.out.println(<span class="hljs-string">&quot;bb==bbIntern    &quot;</span> + (bb == bbIntern));<span class="hljs-comment">//true</span><br><br>String str=<span class="hljs-string">&quot;123456&quot;</span>;<br>System.out.println(<span class="hljs-string">&quot;str== bb: &quot;</span>+(str==bb));<span class="hljs-comment">//true</span><br>System.out.println(<span class="hljs-string">&quot;str==bbIntern: &quot;</span>+(str==bbIntern));<span class="hljs-comment">//true</span><br><br>String cc=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;12&quot;</span>)+<span class="hljs-string">&quot;3&quot;</span>;<br>String ccIntern=cc.intern();<br>System.out.println(<span class="hljs-string">&quot;ccIntern==cc: &quot;</span>+(ccIntern==cc));<span class="hljs-comment">//false</span><br></code></pre></div></td></tr></table></figure><p>仍然对每句进行解读：</p><p>第一句：<code>123</code>、<code>456</code>这两个字面值会加入字符串池，但是<code>123456</code>并没有字符串池。</p><p>第二句：bb调用intern()查看在字符串池中是否有<code>123456</code>，当然没有。那就把堆中包含<code>123456</code>的对象bb的引用加入字符串池中并返回该引用。</p><p>第三句：<code>bb</code>和<code>bbIntern</code>保存的都是堆中<code>123456</code>对象的引用，地址自然相等。</p><p>第四句：<code>str</code>中保存的是字符串池<code>123456</code>的引用，也就是对象bb的引用，二者自然相等。</p><p>第五句：在字符串池中查找<code>123456</code>找到了，就是执行第二句时新添加到池中引用。二者自然相同。</p><p>第六句：把<code>12</code>、<code>3</code>两个字面值加入字符串池中，和<code>123</code>还是有区别的。</p><p>第七句：<code>cc</code>调用intern(),返回的当然是早已在第一句已经添加到池中的<code>123</code>的引用。</p><p>第八句：<code>ccIntern</code>保存的是池中<code>123</code>引用，而<code>cc</code>保存的是堆中<code>123</code>的引用，地址自然不相同</p><h3 id="字符串到底创建几次的经典问题"><a href="#字符串到底创建几次的经典问题" class="headerlink" title="字符串到底创建几次的经典问题"></a>字符串到底创建几次的经典问题</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String str=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;123&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>上述代码中到底创建了几个对象?<br>这得看常量池中有没有<code>123</code>这个String对象，如果有，那么只会在堆中创建一个String对象，然后该String对象中的<code>123</code>字符串对象会引用字符串常量池中的<code>123</code>String对象。如果没有，那么<code>123</code>这个String对象会被添加到字符串池中，然后在堆中也会创建一个包含<code>123</code>的String对象。<strong>注意这两个对象一个在堆里面，一个在字符串池里面，肯定不是一个东西</strong></p><p>可以看出，字符串池相当于一个共享缓存，如果引用的字符串的字面值相同，那么它们就会引用字符串池中的同一个字符串。(前提是使用intern()方法)</p><h3 id="intern-方法小结"><a href="#intern-方法小结" class="headerlink" title="intern()方法小结"></a>intern()方法小结</h3><p>如果查询的字符串在字符串池中有，那么就返回字符串池中引用。如果没有，就把堆中的字符串对象引用加入字符串池中，然后返回该引用。</p><h3 id="字符串进入字符串池的时机"><a href="#字符串进入字符串池的时机" class="headerlink" title="字符串进入字符串池的时机"></a>字符串进入字符串池的时机</h3><p>我觉的如果时<code>String s1=&quot;abc&quot;</code>这种形式构造字符串，那么就确定了s1中的内容，不需要等到运行时解决，应该直接会加入字符串池中。反之，如果使用<code>String s2=new String(&quot;123&quot;)</code>这种形式构造字符串，s2的值是没办法编译时解决的，但是<code>123</code>这个字面值还是会放到类常量池中。</p><p>这个问题我现在还没有答案，待定。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>constant_pool table是<code>.class</code>文件的一部分，run time constant table是类的一部分，而类又被放在方法区中，方法区又是堆的一部分。String pool也是堆的一部分<br>常量池是为了避免频繁的创建和销毁对象而影响系统性能。</p><p><strong>参考文献</strong><br><a href=https://www.journaldev.com/797/what-is-java-string-pool>字符串池解析</a><br><a href=https://examples.javacodegeeks.com/core-java/lang/string/java-string-pool-example/>字符串简单剖析</a><br><a href=https://juejin.im/entry/5a4ed02a51882573541c29d5>深度解析字符串池,必看</a><br><a href=https://cloud.tencent.com/developer/article/1450501>深度解析java常量池</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinkedList源码分析</title>
    <link href="/2021-06-03/LinkedList-source-code-analysis.html"/>
    <url>/2021-06-03/LinkedList-source-code-analysis.html</url>
    
    <content type="html"><![CDATA[<p><code>LinkedList</code>弥补了<code>ArrayList</code>插入元素慢的缺点,当然也带了查找元素慢的缺点。<code>LinkedList</code>同时实现了<code>List</code>和<code>Queue</code>接口,其底层采用双向链表实现。当然<code>LinkedList</code>也有一个父类<code>AbstractSequentialList</code>用于实现一般的方法。下面是<code>LinkedList</code>的继承图:</p><p><img src="images/LinkedList-hierarchy.png" alt="LinkedList-hierarchy"></p><p>可以看到<code>LinkedList</code>实现了<code>Cloneable</code>、<code>Serializable</code>接口,当然也是其<code>clone()</code>实现的也是shadow copy(浅拷贝)。并且<code>LinkedList</code>支持序列化。</p><h2 id="0x0-LinkedList的属性"><a href="#0x0-LinkedList的属性" class="headerlink" title="0x0 LinkedList的属性"></a>0x0 LinkedList的属性</h2><p><code>LinkedList</code>的属性非常简单,就三个:</p><ul><li>链表长度</li><li>链表头指针</li><li>链表尾指针</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//双向链表的头指针</span><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<br>    <span class="hljs-comment">//双向链表的尾指针</span><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br><br>    <span class="hljs-comment">//链表的节点定义</span><br>    <span class="hljs-comment">//非常简单,前向和后向指针,再加一个数据项</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>        E item;<br>        Node&lt;E&gt; next;<br>        Node&lt;E&gt; prev;<br><br>        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>            <span class="hljs-keyword">this</span>.item = element;<br>            <span class="hljs-keyword">this</span>.next = next;<br>            <span class="hljs-keyword">this</span>.prev = prev;<br>        &#125;<br>    &#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="0x1-LinkedList的构造方法"><a href="#0x1-LinkedList的构造方法" class="headerlink" title="0x1 LinkedList的构造方法"></a>0x1 LinkedList的构造方法</h2><p><code>LinkedList</code>的构造方法就两,一个是不带参的构造方法,另一个是使用集合初始化的构造函数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>();<br>    <span class="hljs-comment">//addAll函数应该跟ArrayList差不多</span><br>    addAll(c);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="0x2-LinkedList的重要方法"><a href="#0x2-LinkedList的重要方法" class="headerlink" title="0x2 LinkedList的重要方法"></a>0x2 LinkedList的重要方法</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>因为<code>LinkedList</code>同时实现了<code>List</code>和<code>Queue</code>接口,势必有一大堆<code>addXXX</code>、<code>offerXXX</code>、<code>removeXXX</code>、<code>pollXXX</code>方法。实现都非常简单,这里挑一些内部方法看看。</p><p>比如<code>offerLast()</code>方法内部调用<code>linkLast()</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Links e as last element.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(l, e, <span class="hljs-keyword">null</span>);<br>        last = newNode;<br>        <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)<br>            first = newNode;<br>        <span class="hljs-keyword">else</span><br>            l.next = newNode;<br>        size++;<br>        modCount++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkFirst</span><span class="hljs-params">()</span></span>&#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-comment">//在指定节点之前插入</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkBefore</span><span class="hljs-params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;<br>        ...<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>这里的<code>modCount</code>和<code>ArrayList</code>中的<code>modCount</code>差不多,每当对<code>LinkedList</code>做出结构性改变时,就会改变modCount。当然<code>LinkedList</code>也是线程不安全的,也同时实现了fast-fail机制。</p><p>回到主题,<code>linkLast</code>就是把新节点链到双向链表末尾。<code>linkFirst</code>当然同理咯。</p><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>删除头尾的方法也非常简单,没有什么特别值得关注：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//移除头节点</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">unlinkFirst</span><span class="hljs-params">(Node&lt;E&gt; f)</span> </span>&#123;<br>    <span class="hljs-comment">// assert f == first &amp;&amp; f != null;</span><br>    <span class="hljs-keyword">final</span> E element = f.item;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; next = f.next;<br>    f.item = <span class="hljs-keyword">null</span>;<br>    f.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>    first = next;<br>    <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>)<br>        last = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">else</span><br>        next.prev = <span class="hljs-keyword">null</span>;<br>    size--;<br>    modCount++;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br><br><span class="hljs-comment">//移除尾节点</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">unlinkLast</span><span class="hljs-params">(Node&lt;E&gt; l)</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-comment">//指定移除某节点</span><br><span class="hljs-function">E <span class="hljs-title">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> </span>&#123;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>在增和删的方法中我们都看到了,在指定某节点前插入、删除某个指定节点。那么这个指定是怎么获取的?</p><p>当然<code>LinkedList</code>还是贴心的实现了查找某个位置的节点:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-comment">//检查下标是否越界</span><br>    checkElementIndex(index);<br>    <span class="hljs-comment">//获取指定位置的node的value</span><br>    <span class="hljs-keyword">return</span> node(index).item;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkElementIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!isElementIndex(index))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isElementIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; size;<br>&#125;<br><span class="hljs-comment">//可以看出,node只在第一次找位置时使用了一次二分,</span><br><span class="hljs-comment">//然后使用for循环遍历一半元素,是非常慢的</span><br><span class="hljs-function">Node&lt;E&gt; <span class="hljs-title">node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-comment">// assert isElementIndex(index);</span><br><br>    <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>        Node&lt;E&gt; x = first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)<br>            x = x.next;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;E&gt; x = last;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size - <span class="hljs-number">1</span>; i &gt; index; i--)<br>            x = x.prev;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="0x3-小结"><a href="#0x3-小结" class="headerlink" title="0x3 小结"></a>0x3 小结</h2><p>因为之前分析过了<code>ArrayList</code>与<code>ArrayDeque</code>,再来分析<code>LinkedList</code>就比较简单了。</p><ul><li><code>LinkedList</code>虽然插入元素非常快,但是都快在头尾插入。如果在中间插入,就需要找到某一位置的节点,而插入操作又是非常慢的。</li><li>因为<code>LinkedList</code>没有实现<code>RandomAccess</code>接口,所以使用它实现的迭代器或者for-each遍历都比普通的for循环快。并且在遍历时不允许对<code>LinkedList</code>做出结构性改变,除非使用它自己的迭代器来改变。</li><li><code>LinkedList</code>是线程不安全的,支持fast-fail机制</li></ul>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LinkedList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal源码解析</title>
    <link href="/2021-06-03/threadlocal-analysis.html"/>
    <url>/2021-06-03/threadlocal-analysis.html</url>
    
    <content type="html"><![CDATA[<p>顾名思义，<code>ThreadLocal</code>就是基于线程粒度的私有变量，跟我们以往认知中基于函数、类粒度的私有变量不同。而且<code>ThreadLocal</code>的使用频率非常高，但是如若使用不当，则可能会发生内存泄漏，所以好好研究一下其实现原理是非常有必要的。内容分为三个部分：<code>ThreadLocalMap</code>是什么，<code>ThreadLocal</code>是如何插入变量的，<code>ThreadLocal</code>是如何删除变量的。</p><h2 id="ThreadLocalMap是什么"><a href="#ThreadLocalMap是什么" class="headerlink" title="ThreadLocalMap是什么"></a><code>ThreadLocalMap</code>是什么</h2><p>在<code>ThreadLocal</code>中，其自己实现了一个名为<code>ThreadLocalMap</code>的静态类，从名字就可以看出，其功能类似于map，用于维护形如&lt;key=<code>ThreadLocal</code>弱引用，value=’Corresponding value’&gt;的键值对，但是它没有用在<code>ThreadLocal</code>中，反而<code>Thread</code>类中维护了一个<code>ThreadLocalMap</code>对象，我认为这是理解<code>ThreadLocal</code>的关键。<code>ThreadLocal</code>中维护的<code>ThreadLocalMap</code>如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    ...<br>    <br>    <span class="hljs-comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="hljs-comment">     * by the ThreadLocal class. */</span><br>    <span class="hljs-comment">// 因为ThreadLocal和Thread处于同一个包，可以直接使用</span><br>    ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * InheritableThreadLocal values pertaining to this thread. This map is</span><br><span class="hljs-comment">     * maintained by the InheritableThreadLocal class.</span><br><span class="hljs-comment">     */</span><br>    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="hljs-keyword">null</span>;<br>    ...<br></code></pre></div></td></tr></table></figure><p><code>ThreadLocal</code>不像网上大部分文章说的，在<code>ThreadLocal</code>中维护了一个HashMap，key为ThreadID，value为对应值。而是通过<code>Thread</code>中的<code>ThreadLocalMap</code>维护多个<code>ThreadLocal</code>对象，每个<code>ThreadLocal</code>对象维护其自己对应的值。</p><p>如果有多个<code>ThreadLocal</code>对象作用于同一个线程A，那么这些<code>ThreadLocal</code>共享线程A的<code>ThreadLocalMap</code>，或者同一个<code>ThreadLocal</code>对象B同时作用于多个线程，例如线程C、D。那么在C、D的<code>ThreadLocalMap</code>会维护两组key相同但值不同的键值对，例如&lt;key=B.hashcode,value=C.value&gt;，&lt;key=B.hashcode,value=D.value&gt;，不会相互干扰。所以<code>ThreadLocalMap</code>才是<code>ThreadLocal</code>的关键，那么<code>ThreadLocalMap</code>到底是如何实现的？先来看看其部分实现源码：</p><figure class="highlight java"><figcaption><span>"ThreadLocalMap"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* ThreadLocalMap is a customized hash map suitable only for</span><br><span class="hljs-comment">* maintaining thread local values. No operations are exported</span><br><span class="hljs-comment">* outside of the ThreadLocal class. The class is package private to</span><br><span class="hljs-comment">* allow declaration of fields in class Thread.  To help deal with</span><br><span class="hljs-comment">* very large and long-lived usages, the hash table entries use</span><br><span class="hljs-comment">* WeakReferences for keys. However, since reference queues are not</span><br><span class="hljs-comment">* used, stale entries are guaranteed to be removed only when</span><br><span class="hljs-comment">* the table starts running out of space.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//静态内部类是可以实例化的哦</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalMap</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;<br>        <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>        Object value;<br><br>        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>            <span class="hljs-keyword">super</span>(k);<br>            value = v;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * TThreadLocalMap的初始容量，必须是2的指数倍</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INITIAL_CAPACITY = <span class="hljs-number">16</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 用于存放Entry的table，长度必须是2的指数倍</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> Entry[] table;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * table的初始大小</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 下一次扩容的阈值</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> threshold; <span class="hljs-comment">// Default to 0</span><br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>跟HashMap类似，ThreadLocalMap也是通过静态内部类<code>Entry</code>来维护键值对，其中key为<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>，value为具体的值。这里存在一个问题：为何使用要使用弱引用？用意何在？这个问题先留着，后续再讨论。从上面的代码我们可以看出，<code>ThreadLocalMap</code>通过数组<code>table</code>来维护插入的键值对，并且同样的，数组大小必须是2的次方，这里的理由与hashMap容量必须是2的整数幂一样。</p><h2 id="ThreadLocal的插入操作"><a href="#ThreadLocal的插入操作" class="headerlink" title="ThreadLocal的插入操作"></a>ThreadLocal的插入操作</h2><p>我们一般使用<code>ThreadLocal</code>的<code>set(T)</code>方法进行插入操作：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    Thread t = Thread.currentThread();<br>    <span class="hljs-comment">//首先获取当前线程内部的ThreadLocalMap</span><br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-comment">// 如果map为空，说明当前线程中的ThreadLocalMap还未创建</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)<br>        map.set(<span class="hljs-keyword">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;<br><br><span class="hljs-comment">//getMap的实现原理也非常简单，直接返回线程的内部变量</span><br><span class="hljs-function">ThreadLocalMap <span class="hljs-title">getMap</span><span class="hljs-params">(Thread t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从上面代码我们能够得知：往<code>ThreadLocal</code>中插入元素的第一步就是获取当前线程内部的<code>ThreadLocalMap</code>。如果map已经存在，则直接调用<code>set(ThreadLocal&lt;?&gt;, Object)</code>存储值。否则调用<code>createMap(Thread, Object)</code>创建map并存储。我们先来分析<code>createMap</code>:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>&#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>createMap</code>的逻辑很简单，就是调用<code>ThreadLocalMap</code>的构造函数生成对象后，赋值给当前线程的<code>threadLocals</code>变量。</p><figure class="highlight java"><figcaption><span>"constructor method"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br>ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>    table = <span class="hljs-keyword">new</span> Entry[INITIAL_CAPACITY];<br>    <span class="hljs-keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//我们先分析前两句，注释的部分先不看</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    table[i] = new Entry(firstKey, firstValue);</span><br><span class="hljs-comment">    size = 1;</span><br><span class="hljs-comment">    setThreshold(INITIAL_CAPACITY);</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这个构造函数，会首先初始化table，然后利用当前<code>Threadlocal</code>对象的hash值计算索引。首先这句代码就会产生两个问题：<code>ThreadLocal</code>对象的hash值是如何产生的？索引计算为何使用<code>&amp;</code>运算符？</p><h3 id="ThreadLocal的hash值计算原理"><a href="#ThreadLocal的hash值计算原理" class="headerlink" title="ThreadLocal的hash值计算原理"></a>ThreadLocal的hash值计算原理</h3><p>对于第一个问题，首先我们需要知道，<code>ThreadLocal</code>对象的hash值是在<code>new</code>的时候就构造好了。hash值构造方法如下所示：</p><figure class="highlight java"><figcaption><span>"ThreadLocal哈希码生成部分"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocal</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    ...<br>    <br>    <span class="hljs-comment">//每次生成ThreadLocal对象时会自动调用nextHashCode</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threadLocalHashCode = nextHashCode();<br><br>    <span class="hljs-comment">//静态变量，第一次加载该类时threadLocalHashCode会被初始化为0</span><br>    <span class="hljs-comment">//随后每生成一个ThreadLocal对象，nextHashCode的值都为上一个ThreadLocal对象的HashCode</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicInteger nextHashCode =<br>        <span class="hljs-keyword">new</span> AtomicInteger();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The difference between successively generated hash codes - turns</span><br><span class="hljs-comment">     * implicit sequential thread-local IDs into near-optimally spread</span><br><span class="hljs-comment">     * multiplicative hash values for power-of-two-sized tables.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HASH_INCREMENT = <span class="hljs-number">0x61c88647</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextHashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>    &#125;<br>    ...<br></code></pre></div></td></tr></table></figure><p><code>threadLocalHashCode</code>是通过<code>nextHashCode()</code>完成计算的，而在<code>nextHashCode()</code>中，它会将<code>nextHashCode</code>加上<code>HASH_INCREMENT</code>，并返回原始的<code>nextHashCode</code>。<code>nextHashCode</code>是一个静态变量，被所有<code>ThreadLocal</code>对象共享。所以每当有新的<code>ThreadLocal</code>对象生成时，就会使用上一个<code>ThreadLocal</code>改变的<code>nextHashCode</code>。至于为什么<code>nextHashCode</code>的增量<code>HASH_INCREMENT</code>是魔数<code>0x61c88647</code>，理由是计算出的hash值足够离散，能够均匀地分布在<code>table</code>数组中。</p><p>对于第二个问题：使用<code>&amp;</code>计算索引是因为如果n是2的整数次幂，那么则有<code>hash % n == (n-1)&amp; hash</code>，这样做是为了加速运算。</p><p>了解了如何计算<code>ThreadLocal</code>对象的hash值后，我们的视角回到<code>ThreadLocalMap</code>的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    table = new Entry[INITIAL_CAPACITY];</span><br><span class="hljs-comment">    int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="hljs-comment">    */</span><br>    table[i] = <span class="hljs-keyword">new</span> Entry(firstKey, firstValue);<br>    size = <span class="hljs-number">1</span>;<br>    setThreshold(INITIAL_CAPACITY);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在<code>table</code>中安置好新加入的entry后，则会调用<code>setThreshold</code>设置扩容阈值，阈值大小为<code>table</code>容量的<strong>2/3</strong>，而不是HashMap的3/4。</p><h3 id="set-方法原理"><a href="#set-方法原理" class="headerlink" title="set()方法原理"></a>set()方法原理</h3><p>那么如果线程的<code>ThreadLocalMap</code>已经构造好了，添加元素是怎么样一个过程呢？来看看私有的<code>set(ThreadLocal&lt;?&gt;, Object)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;<br>    <span class="hljs-comment">// 我们不像get()那样使用哈希值快速查找Entry</span><br>    <span class="hljs-comment">// 因为使用set()创建新条目和替换现有条目至少是一样普遍的</span><br>    <span class="hljs-comment">// 在这种情况下，使用哈希值失败的可能性通常会更高</span><br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    <span class="hljs-comment">// 计算ThreadLocal对象的索引</span><br>    <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 遍历table，这里一定会找到一个Entry==null的索引</span><br>    <span class="hljs-comment">// 因为有提前扩容机制，不可能把table填满</span><br>    <span class="hljs-keyword">for</span> (Entry e = tab[i];<br>            e != <span class="hljs-keyword">null</span>;<br>            e = tab[i = nextIndex(i, len)]) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//找到一个失效的Entry</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//stale是陈旧的意思</span><br>            replaceStaleEntry(key, value, i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    tab[i] = <span class="hljs-keyword">new</span> Entry(key, value);<br>    <span class="hljs-keyword">int</span> sz = ++size;<br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在<code>set(ThreadLocal&lt;?&gt;, Object)</code>中，首先会计算当前<code>ThreadLocal</code>对象的索引<code>i</code>，然后使用<code>for</code>循环从<code>i</code>之后遍历<code>table</code>数组，直到找到一个空的位置，for循环调用了<code>nextIndex(int,int)</code>进行变量自增，那么<code>nextIndex</code>做了什么？看看它的实现代码：</p><figure class="highlight java"><figcaption><span>"nextIndex"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ((i + <span class="hljs-number">1</span> &lt; len) ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>含义很简单，就是从索引<code>i</code>开始计算下一个位置，如果已经<code>i</code>已经到达尾部，那么循环到头部开始。所以可以把<code>ThreadLocalMap</code>中的<code>table</code>当作一个环形数组，如下图所示：</p><p><img src="images/circular-ThreadLocalMap.drawio.svg" alt="table"></p><p><code>set(ThreadLocal&lt;?&gt;, Object)</code>的for循环含义很简单：</p><ol><li>如果当前<code>ThreadLocal</code>对象已经在<code>table</code>中，那么就更新其对应的value</li><li>如果找到了一个无效Entry，那么就会从当前Entry开始，调用<code>replaceStaleEntry(ThreadLocal&lt;?&gt;,Object,int)</code></li><li>尝试在table中找到我们的目标Entry，并将目标Entry和无效Entry交换，然后进行一些清除无效Entry的操作。replaceStaleEntry的实现源码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* @param  key the key</span><br><span class="hljs-comment">* @param  value key对应的value</span><br><span class="hljs-comment">* @param  staleSlot 当前Entry的key==null的索引，表示这个Entry是需要被清除的</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">replaceStaleEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-keyword">int</span> staleSlot)</span> </span>&#123;<br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    Entry e;<br>    <br>    <span class="hljs-comment">// slotToExpunge表示的含义是从当前索引值开始清理无效Entry</span><br>    <span class="hljs-comment">// 做法是从staleSlot开始向前，也就histaleSlot的左边，找到最远离staleSlot的，Entry不为空的，但是Entry.weakReference==null的Entry索引</span><br>    <span class="hljs-comment">// 如果在遇到空Entry之前，还未找到失效的Entry，那么slotToExpunge将会等于staleSlot</span><br>    <span class="hljs-keyword">int</span> slotToExpunge = staleSlot;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = prevIndex(staleSlot, len);<br>            (e = tab[i]) != <span class="hljs-keyword">null</span>;<br>            i = prevIndex(i, len))<br>        <span class="hljs-keyword">if</span> (e.get() == <span class="hljs-keyword">null</span>)<br>            slotToExpunge = i;<br><br>    <span class="hljs-comment">//从staleSlot开始向后遍历，直到遇到空Entry为止</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nextIndex(staleSlot, len);<br>            (e = tab[i]) != <span class="hljs-keyword">null</span>;<br>            i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br><br>        <span class="hljs-comment">//如果找到了我们的目标Entry的索引i</span><br>        <span class="hljs-comment">//那么就将索引staleSlot和i表示的Entry相互相互</span><br>        <span class="hljs-comment">//交换之后，索引i表示的Entry就失效了</span><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-comment">//交换Entry</span><br>            tab[i] = tab[staleSlot];<br>            tab[staleSlot] = e;<br><br>            <span class="hljs-comment">//如果在第一个for循环中没有找到失效的Entry，那么下面的if条件就会成立</span><br>            <span class="hljs-comment">//因为i现在表示的失效Entry索引，所以就将slotToExpunge设为i</span><br>            <span class="hljs-keyword">if</span> (slotToExpunge == staleSlot)<br>                slotToExpunge = i;<br>            <span class="hljs-comment">//然后开始使用两种方法清理无效Entry</span><br>            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果还未找到目标Entry，所以尝试找到staleSlot右边最近的失效Entry</span><br>        <span class="hljs-comment">// 因为我们是从staleSlot开始向后遍历，还是有可能遇到Entry.weakReference==null的情况</span><br>        <span class="hljs-comment">// 这个if只可能执行一次，表示staleSlot左边最远没有失效的Entry，只找到了右边最近的失效Entry</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)<br>            slotToExpunge = i;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果在table根本就不存在key</span><br>    <span class="hljs-comment">// 那么直接在当前失效Entry的槽位上新建Entry</span><br>    <span class="hljs-comment">// 在新建之前，会将原来Entry的value设为null，这是为了防止内存泄漏</span><br>    tab[staleSlot].value = <span class="hljs-keyword">null</span>;<br>    tab[staleSlot] = <span class="hljs-keyword">new</span> Entry(key, value);<br><br>    <span class="hljs-comment">// 如果存在失效Entry但是索引不是staleSlot，那么就从slotToExpunge开始清除无效Entry</span><br>    <span class="hljs-keyword">if</span> (slotToExpunge != staleSlot)<br>        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>replaceStaleEntry</code>函数的主要思想就是：</p><ol><li>如果在<code>table</code>中找到了目标Entry的索引<code>i</code>，那么就将我们索引<code>staleSlot</code>和<code>i</code>对应的Entry交换</li><li>如果在<code>table</code>中没有找到目标Entry，那么就直接在索引<code>staleSlot</code>对应的槽位构建新的Entry</li><li>期望在当前<code>staleSlot</code>的最远左边或者最近右边找到一个失效Entry以便最大化清除失效Entry的效果，具体的清除原理我们放到<code>ThreadLocal</code>删除操作一节中讲解。</li></ol><p>现在我们的视角回到<code>set(ThreadLocal&lt;?&gt;, Object)</code>:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;<br>    <span class="hljs-comment">// 我们不像get()那样使用哈希值快速查找Entry</span><br>    <span class="hljs-comment">// 因为使用set()创建新条目和替换现有条目至少是一样普遍的</span><br>    <span class="hljs-comment">// 在这种情况下，使用哈希值失败的可能性通常会更高</span><br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    <span class="hljs-comment">// 计算ThreadLocal对象的索引</span><br>    <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 遍历table，这里一定会找到一个Entry==null的索引</span><br>    <span class="hljs-comment">// 因为有提前扩容机制，不可能把table填满</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    for (Entry e = tab[i];</span><br><span class="hljs-comment">            e != null;</span><br><span class="hljs-comment">            e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="hljs-comment">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        if (k == key) &#123;</span><br><span class="hljs-comment">            e.value = value;</span><br><span class="hljs-comment">            return;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        //找到一个失效的Entry</span><br><span class="hljs-comment">        if (k == null) &#123;</span><br><span class="hljs-comment">            replaceStaleEntry(key, value, i);</span><br><span class="hljs-comment">            return;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br><br>    tab[i] = <span class="hljs-keyword">new</span> Entry(key, value);<br>    <span class="hljs-keyword">int</span> sz = ++size;<br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果在set中在找到空槽位之前没有找到目标Entry或者失效Entry，那么就会直接在空槽位上构建Entry对象。新构建之后第一步需要考虑的就是扩容问题。这个问题由<code>rehash</code>来解决。当然扩容也是有条件的：需要在调用<code>cleanSomeSlots</code>进行一波清理操作后，<code>table</code>内的Entry个数仍然大于扩容阈值才会调用<code>rehash</code>。<code>rehash</code>的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rehash</span><span class="hljs-params">()</span> </span>&#123;<br>    expungeStaleEntries();<br><br>    <span class="hljs-comment">// Use lower threshold for doubling to avoid hysteresis</span><br>    <span class="hljs-keyword">if</span> (size &gt;= threshold - threshold / <span class="hljs-number">4</span>)<br>        resize();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">expungeStaleEntries</span><span class="hljs-params">()</span> </span>&#123;<br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>        Entry e = tab[j];<br>        <span class="hljs-comment">//找到每个失效Entry，并对每个失效Entry调用expungeStaleEntry实施清除操作</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span> &amp;&amp; e.get() == <span class="hljs-keyword">null</span>)<br>            expungeStaleEntry(j);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>rehash</code>内部又会调用<code>expungeStaleEntries()</code>进行一波清理操作，如果<code>table</code>内的<code>Entry</code>数量仍然大于等于<code>table</code>容量得1/2(计算公式：threshold*2/3*capacity*3/4)，才会真正调用调用<code>resize()</code>进行扩容。所以这里有一个小点我们容易忽略：<strong>并不是table中的Entry数量大于等于容量的2/3就会进行扩容，而是在进行两类清除操作之后，Entry数量仍然大于等于容量的1/2，才会进行扩容</strong>。具体扩容的原理就很简单，简单的扩容<strong>两倍</strong>并复制了Entry。</p><h2 id="ThreadLocal的删除操作"><a href="#ThreadLocal的删除操作" class="headerlink" title="ThreadLocal的删除操作"></a>ThreadLocal的删除操作</h2><p>在插入操作的<code>set(ThreadLocal&lt;?&gt;, Object)</code>函数中，我们不止一次提到了两种清除操作:<code>cleanSomeSlots(int,int)</code>和<code>expungeStaleEntry(j)</code>，那么这两种清除操作最大的区别就是前者为<strong>启发式</strong>清除操作，后者为<strong>线性</strong>清除操作，为何这么说？首先来看看<code>cleanSomeSlots(int,int)</code>的实现代码：</p><figure class="highlight java"><figcaption><span>"启发式清除操作"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//参数i表示当前Entry必有效的索引，所以清除要从下一个index开始</span><br><span class="hljs-comment">//参数n表示清除操作的执行次数</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">cleanSomeSlots</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> removed = <span class="hljs-keyword">false</span>;<br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    <span class="hljs-keyword">do</span> &#123;<br>        i = nextIndex(i, len);<br>        Entry e = tab[i];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span> &amp;&amp; e.get() == <span class="hljs-keyword">null</span>) &#123;<br>            n = len;<br>            removed = <span class="hljs-keyword">true</span>;<br>            i = expungeStaleEntry(i);<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> ( (n &gt;&gt;&gt;= <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> removed;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>根据代码<code>n&gt;&gt;&gt;=1</code>可知，<code>cleanSomeSlots</code>总共会执行log2(n)次操作，而每次操作时会尝试找到失效Entry，然后从失效Entry的索引开始，调用<code>expungeStaleEntry</code>进行线程清除操作，来看看其实现源码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 参数staleSlot表示失效Entry的索引</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> staleSlot)</span> </span>&#123;<br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br><br>    <span class="hljs-comment">// 将value置为空，避免内存泄漏</span><br>    tab[staleSlot].value = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 将失效Entry移出</span><br>    tab[staleSlot] = <span class="hljs-keyword">null</span>;<br>    size--;<br><br>    <span class="hljs-comment">// Rehash until we encounter null</span><br>    Entry e;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-comment">//从staleSlot开始遍历table，直到遇到空槽位</span><br>    <span class="hljs-comment">//所以是一个线程清除操作</span><br>    <span class="hljs-keyword">for</span> (i = nextIndex(staleSlot, len);<br>            (e = tab[i]) != <span class="hljs-keyword">null</span>;<br>            i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-comment">//遇到失效Entry，进行移出操作</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span>) &#123;<br>            e.value = <span class="hljs-keyword">null</span>;<br>            tab[i] = <span class="hljs-keyword">null</span>;<br>            size--;<br>        &#125;<br>        <span class="hljs-comment">//遇到正常的Entry，那么就尝试重新计算索引</span><br>        <span class="hljs-comment">//因为在此之前这个Entry是因为哈希冲突才来到当前位置的</span><br>        <span class="hljs-comment">// 这么做的目的是让Entry更接近它的理想位置h</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (h != i) &#123;<br>                tab[i] = <span class="hljs-keyword">null</span>;<br><br>                <br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                * 以下解析摘自参考文章[1]</span><br><span class="hljs-comment">                * 在原代码的这里有句注释值得一提，原注释如下：</span><br><span class="hljs-comment">                *</span><br><span class="hljs-comment">                * Unlike Knuth 6.4 Algorithm R, we must scan until</span><br><span class="hljs-comment">                * null because multiple entries could have been stale.</span><br><span class="hljs-comment">                *</span><br><span class="hljs-comment">                * 这段话提及了Knuth高德纳的著作TAOCP（《计算机程序设计艺术》）的6.4章节（散列）</span><br><span class="hljs-comment">                * 中的R算法。R算法描述了如何从使用线性探测的散列表中删除一个元素。</span><br><span class="hljs-comment">                * R算法维护了一个上次删除元素的index，当在非空连续段中扫到某个entry的哈希值取模后的索引</span><br><span class="hljs-comment">                * 还没有遍历到时，会将该entry挪到index那个位置，并更新当前位置为新的index，</span><br><span class="hljs-comment">                * 继续向后扫描直到遇到空的entry。</span><br><span class="hljs-comment">                *</span><br><span class="hljs-comment">                * ThreadLocalMap因为使用了弱引用，所以其实每个slot的状态有三种也即</span><br><span class="hljs-comment">                * 有效（value未回收），无效（value已回收），空（entry==null）。</span><br><span class="hljs-comment">                * 正是因为ThreadLocalMap的entry有三种状态，所以不能完全套高德纳原书的R算法。</span><br><span class="hljs-comment">                *</span><br><span class="hljs-comment">                * 因为expungeStaleEntry函数在扫描过程中还会对无效slot清理将之转为空slot，</span><br><span class="hljs-comment">                * 如果直接套用R算法，可能会出现具有相同哈希值的entry之间断开（中间有空entry）。</span><br><span class="hljs-comment">                */</span><br>                <span class="hljs-comment">//从h之后线性探测一个空槽位</span><br>                <span class="hljs-keyword">while</span> (tab[h] != <span class="hljs-keyword">null</span>)<br>                    h = nextIndex(h, len);<br>                tab[h] = e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>线性操作的原理比较简单：</p><ol><li>如果遇到了失效Entry，就将其移除</li><li>如果遇到了正常Entry，那么就对其进行冲哈希定位，目的是尽可能地将当前Entry放在它应该在的位置上</li><li>如果遇到了空槽位，那么就直接返回当前空槽位的索引</li></ol><p>在了解了两种清除操作之后，再去看<code>ThreadLocal</code>的移出操作就非常简单了，我们一般都会调用<code>remove</code>进行移出，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 即使没有在ThreadLocal中存入值，也可以调用remove方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>    ThreadLocalMap m = getMap(Thread.currentThread());<br>    <span class="hljs-keyword">if</span> (m != <span class="hljs-keyword">null</span>)<br>        m.remove(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 寻找目标Entry进行移出，并会顺带调用expungeStaleEntry进行线性清除</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;<br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (Entry e = tab[i];<br>            e != <span class="hljs-keyword">null</span>;<br>            e = tab[i = nextIndex(i, len)]) &#123;<br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;<br>            e.clear();<br>            expungeStaleEntry(i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>所以经过以上学习，我们可以总结出：</p><ol><li>启发式清除操作会在<code>set(ThreadLocal&lt;?&gt;, Object)</code>中的两个地方被调用：<ul><li>table中存在目标Entry，那么就从找到的失效Entry开始启发式清除</li><li>table中不存在目标Entry，那么就从新插入的Entry开始启发式清除</li></ul></li><li>线性清除操作出现的地方比较多：<ul><li>在启发式清除中会开始线性清除</li><li>在<code>replaceStaleEntry</code>中，会先进行线性清除，之后进行启发式清除</li></ul></li></ol><h3 id="ThreadLocal中的内存泄漏问题"><a href="#ThreadLocal中的内存泄漏问题" class="headerlink" title="ThreadLocal中的内存泄漏问题"></a>ThreadLocal中的内存泄漏问题</h3><p>在前面我们曾提出了一个问题，为什么要对<code>ThreadLocal</code>使用弱引用，首先我们需要直到什么是弱引用：</p><blockquote><p>使用WeakReference修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收</p></blockquote><p>也就是说，当一个对象只存在弱引用时，无论内存空间是否足够，都会将其回收。那么试想如下一个场景：</p><p>如果对于一个<code>ThreadLocal</code>对象引用<code>a=new ThreadLocal&lt;&gt;()</code>，当我们不再需要这个<code>ThreadLocal</code>对象时，那么就会将<code>a</code>设为null。但是曾经使用过该<code>ThreadLocal</code>对象的线程A内部的<code>ThreadLocalMap</code>仍然持有该<code>ThreadLocal</code>对象的引用，所以如果不使用虚引用，那么否则直到线程A死亡，该<code>ThreadLocal</code>对象都不会被回收。当线程A运行时间特别长时，可能由于<code>ThreadLocal</code>对象无法被回收的问题，可能内存空间会越来越小。</p><p>所以这种类型的内存泄漏已经被大牛们解决了。那么我们常说的ThreadLocal内存泄漏是什么呢？</p><p>不知大家是否还记得<code>Entry</code>的结构，其内部属性<code>value</code>仍然是一个强引用，就会出现key无效但是value有效的<code>Entry</code>对象，导致<code>Entry</code>对象仍然无法会回收。所以虽然在调用<code>set</code>方法时，大概率会将无效<code>Entry</code>对象清除，但这种清除并不是百分百生效的。所以当我们不在需要一个<code>ThreadLocal</code>对象时，最后手动调用<code>remove</code>方法清除无效Entry，防止内存泄漏。</p><h2 id="ThreadLocal的获取操作"><a href="#ThreadLocal的获取操作" class="headerlink" title="ThreadLocal的获取操作"></a>ThreadLocal的获取操作</h2><p>实现获取操作的<code>get()</code>方法很简单，如下所示：</p><figure class="highlight java"><figcaption><span>"get()实现源码"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    Thread t = Thread.currentThread();<br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;<br>        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            T result = (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果没有存入value，那么则会初始化默认value并返回</span><br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="InheritableThreadLocal原理"><a href="#InheritableThreadLocal原理" class="headerlink" title="InheritableThreadLocal原理"></a>InheritableThreadLocal原理</h2><p>除了<code>ThreadLocal</code>，还有一种用于实现父子线程数据共享的<code>ThreadLocal</code>:<code>InheritableThreadLocal</code>，它的具体实现是在Thread类中除了threadLocals外还有一个inheritableThreadLocals对象。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="hljs-comment">     * by the ThreadLocal class. */</span><br>    ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * InheritableThreadLocal values pertaining to this thread. This map is</span><br><span class="hljs-comment">     * maintained by the InheritableThreadLocal class.</span><br><span class="hljs-comment">     */</span><br>    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="hljs-keyword">null</span>;<br></code></pre></div></td></tr></table></figure><p>在线程对象初始化的时候，会调用ThreadLocal的createInheritedMap从父线程的inheritableThreadLocals中把有效的entry都拷过来，做的事情就是以父线程的inheritableThreadLocalMap为数据源，过滤出有效的entry，初始化到自己的inheritableThreadLocalMap中。其中childValue可以被重写。需要注意的地方是InheritableThreadLocal只是在子线程创建的时候会去拷一份父线程的inheritableThreadLocals。如果父线程是在子线程创建后再set某个InheritableThreadLocal对象的值，对子线程是不可见的。</p><h2 id="ThreadLocal的基本使用"><a href="#ThreadLocal的基本使用" class="headerlink" title="ThreadLocal的基本使用"></a>ThreadLocal的基本使用</h2><p>下面是一个在线程中简单使用<code>ThreadLocal</code>的例子：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalExample1</span> </span>&#123;<br><br>    <span class="hljs-comment">// (1) 创建ThreadLocal变量</span><br>    <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; localVariable = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br><br>    <span class="hljs-comment">// (2)print函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str)</span></span>&#123;<br>        <span class="hljs-comment">// 打印当前线程本地内存中localVariable变量的值</span><br>        System.out.println(str + <span class="hljs-string">&quot;:&quot;</span> + localVariable.get());<br>        <span class="hljs-comment">// 2.1 清楚当前线程本地内存变量</span><br><span class="hljs-comment">//        localVariable.remove();</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">// (3) 创建线程one</span><br>        Thread threadOne = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">// 设置threadOne中的本地变量localVariable的值</span><br>                localVariable.set(<span class="hljs-string">&quot;threadOne local variable&quot;</span>);<br>                <span class="hljs-comment">// 调用打印函数</span><br>                print(<span class="hljs-string">&quot;threadOne&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;threadOne remove after&quot;</span> + localVariable.get());<br>            &#125;<br>        &#125;);<br><br><br>        <span class="hljs-comment">// 创建线程two</span><br>        Thread threadTwo = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">// 设置threadTwo线程中的本地线程变量</span><br>                localVariable.set(<span class="hljs-string">&quot;threadTwo local variable&quot;</span>);<br>                <span class="hljs-comment">// 调用打印函数</span><br>                print(<span class="hljs-string">&quot;threadTwo&quot;</span>);<br>                <span class="hljs-comment">// 打印本地线程变量</span><br>                System.out.println(<span class="hljs-string">&quot;threadTwo remove after&quot;</span> + <span class="hljs-string">&quot;:&quot;</span> + localVariable.get());<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// (5)启动线程</span><br>        threadOne.start();<br>        threadTwo.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以如果想要在每个线程都维护一个线程级的变量，那么只需要一个<code>ThreadLocal</code>对象即可，如果想要为一个线程维护多个线程级的私有变量，那么就需要多个<code>ThreadLocal</code>对象。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://www.cnblogs.com/micrari/p/6790229.html">ThreadLocal源码解读</a></li></ol><p>2.<a href="https://segmentfault.com/a/1190000022663697">面试官：小伙子，听说你看过ThreadLocal源码？</a></p><p>3.<a href="https://zhuanlan.zhihu.com/p/88133406">面试官连环炮轰炸的ThreadLocal 吃透源码的每一个细节和设计原理</a></p>]]></content>
    
    
    <categories>
      
      <category>多线程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ThreadLocal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程基础</title>
    <link href="/2021-06-03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.html"/>
    <url>/2021-06-03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.html</url>
    
    <content type="html"><![CDATA[<p>多进程是为了提高CPU效率，而多线程是为了提高程序使用率？我咋感觉不对啊，多线程通信方便，资源浪费小。并且多线程能不能提高效率得看是什么任务。</p><p>总而言之：<strong>多进程为操作系统提供了并发的可能，多进程为单个程序提供了并发的能力</strong>。</p><p>简而言之：多线程就是程序内部有多条执行路径，这句话至少我认为是没有错的。</p><p>并且并发是在某一时间段同时发生，<strong>并行</strong>是在某一<strong>时间点</strong>同时发生。不要记混了。所以记住java搞高并发就不会错了。</p><p>在java中，启动一个java程序，也就是启动一个JVM进程，然后进程会自动运行一个<strong>主线程</strong>来调用某个类的main方法。</p><blockquote><p>那么JVM的启动是单线程的还是多线程的？</p></blockquote><p>是多线程的，因为至少会启动一个gc线程和主线程。</p><h3 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h3><p>在java中，实现多线程的方法主要就分为三种，一种是继承Thread类，override它的run方法，第二种就是实现Runnable接口下的run方法。或者实现Callable<V>下的run方法。</p><h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><p>这是第一种实现多线程方式。</p><ol><li>首先我们需要自定义类并继承自Thread类</li><li>重写<code>run()</code>方法：因为<strong>不是类中的所有代码都需要被线程执行</strong>，所以为了区别哪些代码被线程执行，java提供了<code>run()</code>来包含那些需要被线程执行的代码。</li><li>创建对象</li><li>启动线程：如果直接使用<code>run()</code>启动线程，那么就相当直接调用线程，也就是只实现了单线程效果。</li></ol><blockquote><p>run()与start()有什么区别？</p></blockquote><p>run()仅仅是封装了需要执行的代码，直接调用就相当于调用普通方法。而<code>start()</code>是启动了线程，使线程处于就绪状态，然后再由JVM调用线程的<code>run()</code>方法。</p><blockquote><p>如何获取与设置线程的名称？</p></blockquote><p>很简单，调用线程的<code>getName()</code>与<code>setName()</code>即可。或者直接在构造线程对象时设置名称。</p><figure class="highlight java"><figcaption><span>"多线程入门栗子"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-comment">//super.run();</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;++i) &#123;<br>            System.out.println(getName()+<span class="hljs-string">&quot;:&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    MyThread my=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;tom&quot;</span>);<br>    my.start();<br>    MyThread my1=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;bob&quot;</span>);<br>    my1.start();<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>调用自己写的线程子类很容易获取名称。但是如何获取不是我们自定义的线程的名称呢？例如main线程？</p></blockquote><p>很简单，调用Thread类的静态方法：<code>public static Thread currentThread()</code>获得当前线程的引用。然后在调用该线程的<code>getName()</code>即可。在哪个线程里调<code>currentThread()</code>，就是获得了哪个线程的Thread对象引用。</p><h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><ol><li>自定义类实现Runnable接口，<code>Runnable</code>接口只有一个抽象方法<code>run</code>，无法取消</li><li>实现<code>run()</code>方法</li><li>创建MyRunnable对象</li><li>创建Thread对象并将第三步的对象作为参数传进去</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">500</span>;++i) &#123;<br>            System.out.println(Thread.currentThread().getName()+i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    MyRunnable my=<span class="hljs-keyword">new</span> MyRunnable();<br>    Thread t1=<span class="hljs-keyword">new</span> Thread(my,<span class="hljs-string">&quot;tom&quot;</span>);<br>    Thread t2=<span class="hljs-keyword">new</span> Thread(my,<span class="hljs-string">&quot;candy&quot;</span>);<br>    t1.start();<br>    t2.start();<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="实现callable接口"><a href="#实现callable接口" class="headerlink" title="实现callable接口"></a>实现callable接口</h4><p>这种实现多线程的方式必须配合线程池使用。这种方式与实现Runnable接口的区别就是这种方法可以返回一个值。由泛型指定类型。调用<code>submit()</code>后会返回一个Future，可以通过Future的<code>get()</code>方法获得返回值，但是该方法会阻塞当前线程，直到得到结果。下面是一个使用的栗子：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mycallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Mycallable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>        <span class="hljs-keyword">this</span>.num = num;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++) &#123;<br>            sum+=i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    ExecutorService pool=Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>    Future&lt;Integer&gt; f1=pool.submit(<span class="hljs-keyword">new</span> Mycallable(<span class="hljs-number">50</span>));<br>    Future&lt;Integer&gt; f2=pool.submit(<span class="hljs-keyword">new</span> Mycallable(<span class="hljs-number">100</span>));<br>    <span class="hljs-keyword">try</span> &#123;<br>        System.out.println(f1.get()+f2.get());<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-comment">// TODO Auto-generated catch block</span><br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>        <span class="hljs-comment">// TODO Auto-generated catch block</span><br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        pool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面提到了Future，这是个啥？其实它是一个接口，它只有五个非常简单的方法。</p><figure class="highlight java"><figcaption><span>"Future接口"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">cancel</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> mayInterruptIfRunning)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCancelled</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;<br><br>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>cancel()</code>表示<strong>试图</strong>取消当前线程的执行，但注意仅仅是试图，到底能不能取消还不知道，因为当前线程或许已经执行完了，或者已经取消了，或者一些其他不可控的因素。唯一的参数表示是否以中断的方式取消。</p><blockquote><p>所以有时候，为了让任务有能够取消的功能，就使用Callable来代替Runnable。如果为了可取消性而使用 Future但又不提供可用的结果，则可以声明 Future&lt;?&gt;形式类型、并返回 null作为底层任务的结果。<a href="http://concurrent.redspider.group/article/01/2.html">参考</a>。</p></blockquote><p>但是自定义Future接口中的<code>cancel</code>、<code>get</code>方法又非常困难，所以jdk为我们提供了一个Future的实现类<code>FutureTask</code>类。<code>FutureTask</code>实现了<code>RunnableFuture&lt;V&gt;</code>接口，而<code>RunnableFuture&lt;V&gt;</code>又继承了<code>Runnable</code>与<code>Future&lt;V&gt;</code>接口。</p><figure class="highlight java"><figcaption><span>"FutureTask简单使用"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService service= Executors.newCachedThreadPool();<br>        FutureTask&lt;Integer&gt; futureTask=<span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> CreateThread3());<br>        service.submit(futureTask);<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(futureTask.get());<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面使用线程池<code>submit()</code>提交一个FutureTask实例后，并不像提交Callable的实例后，有一个返回值。并且获取返回值的时候是直接通过FutureTask的实例获取。这里的submit原型为<code>submit(Runnable task)</code>，因为FutureTask就是Runnable接口的实现类。提交Callable的函数原型为<code>submit(Callable&lt;V&gt; task)</code>。</p><h4 id="java中实现线程的方式到底有几个？"><a href="#java中实现线程的方式到底有几个？" class="headerlink" title="java中实现线程的方式到底有几个？"></a>java中实现线程的方式到底有几个？</h4><p>这是一个值得思考的问题。上面我们看到定义一个线程的方法主要有三种。</p><p>第一种就是实现<code>Runnable</code>run方法。这种方式是怎么执行我们定义的线程代码的？源码给出了答案：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span>) &#123;<br>            target.run();<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>虚拟机会调用Thread实例的run方法执行线程代码，而在run方法中，又会调用target的<code>run()</code>方法，这个target就是我们传进去的RUnnable实例。</p><p>第二种就是继承Thread类，重写Thread的类的run方法。那么运行时会调用该实例重写的<code>run</code>方法。</p><p>第三种就是实现Callable接口的run方法，然后提交到线程池中。注意线程池中的线程是怎么来的？还是通过new一个Thread来实现的。</p><blockquote><p>无论是 Callable 还是 FutureTask，它们首先和 Runnable 一样，都是一个任务，是需要被执行的，而不是说它们本身就是线程。它们可以放到线程池中执行，如代码所示， submit() 方法把任务放到线程池中，并由线程池创建线程，不管用什么方法，最终都是靠线程来执行的。线程池里的线程还是new Thread创建出来的。</p></blockquote><p>所以说创建线程的方式就一种：<strong>创建一个Thread实例</strong>，而定义线程执行的内容有两种，实现Runnable、Callable等的run方法，或者重写Thread类的run方法。</p><p>那么我们应该选取哪种方式实现线程执行内容?</p><p>实现Runnable比继承Thread更好，理由如下：</p><ol><li>实现Runnable接口可以解决单继承的局限性</li><li>把线程和程序代码更好的分离。也就是如果使用继承Thread的方式实现，如果自定义类中有成员数据，就得创建多个MyThread对象才能实现多线程，数据成员也会出现多次。<br>而采用接口实现，只创建一个MyRunnabe对象就可实现多线程。数据成员只会出现一次。实现了Runnable与Thread类的解耦，Thread类只负责设置一些线程的参数。</li><li>在某些情况下Runnable的效率更好，比如我们需要重复执行一些小而短的程序，不停的创建Thread实例代价太高了，实现一个Runnable丢给线程池执行就好。</li></ol><h3 id="线程组的基本知识"><a href="#线程组的基本知识" class="headerlink" title="线程组的基本知识"></a>线程组的基本知识</h3><p>在java中，运行的线程必然属于某一个线程组，如果没有设置，默认线程组是当前启动新线程的线程所在的线程组，就是线程A启动了线程B，默认B的线程组为A所在的线程组。线程组的属性非常多，比如其他的线程组，当前组里的线程等等。</p><blockquote><p>ThreadGroup管理着它下面的Thread，ThreadGroup是一个标准的向下引用的树状结构，这样设计的原因是防止”上级”线程被”下级”线程引用而无法有效地被GC回收。</p></blockquote><h3 id="线程不安全的经典案例"><a href="#线程不安全的经典案例" class="headerlink" title="线程不安全的经典案例"></a>线程不安全的经典案例</h3><p>下面以电影院买票为例阐述多线程编程时的经典问题：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTickets</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tickets=<span class="hljs-number">10</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-keyword">while</span>(tickets&gt;<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-comment">// TODO Auto-generated catch block</span><br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;正在卖出第： &quot;</span>+(tickets--)+<span class="hljs-string">&quot;张票&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>买票时会出现售出同票或者售出负数票，这是为什么？</p><ol><li><p>首先解释同票的问题：因为<code>--</code>不是一个原子操作，所以有可能窗口1读到的tickets为100，此时时间片结束，窗口2读到的也为100，窗口3同理。由于不是原子性操作，所以可能会出现同票问题。</p></li><li><p>售出负数票是因为线程调度是随意的，没有顺序的。有可能tickets为1，t1、t2、t3三个线程都进入了循环，然后分别依次执行，就会出现负数票问题。</p></li></ol><p>综上，由于不是原子性操作和线程调度随意性。</p><h3 id="解决线程安全"><a href="#解决线程安全" class="headerlink" title="解决线程安全"></a>解决线程安全</h3><p>首先我们需要判断是否会出现线程不安全的问题。有以下几个标准：</p><ol><li>是否为多线程环境</li><li>是否线程间<strong>共享</strong>了数据</li><li>处理共享数据的操作是否为<strong>原子</strong>操作</li></ol><p>综上所述，只要将线程同步了，就可以解决线程安全的问题。那么同步有什么特征吗?</p><ol><li>必须是多线程环境</li><li>多个线程必须使用的同一把锁</li><li>当线程过多时，由于需要判断锁的情况，效率地下</li></ol><p>那么如何实现同步？使用<code>synchronized</code>关键字的方法有三种：</p><ol><li><p>使用同步代码块，并且同步代码块能够解决线程安全的关键在于对象，这个对象就相当于一把锁。锁对象可以是<strong>任意对象</strong>。必须共享同一个对象。</p></li><li><p>使用对象同步方法：锁对象就是<strong>该实例对象</strong>本身，将这个对象都锁住了。</p></li><li><p>使用静态同步方法：锁就是<strong>class对象</strong>本身</p></li></ol><p>显而易见，锁的范围越小越好，所以同步代码块的代价是最低的。</p><p>如果采用实例同步方法：同时有两个不相关的实例同步方法。当某个线程在调用其中一个同步实例方法的时候，其他的线程就无法继续调用另外的一个实例同步方法。因为锁只有一个，就是这个实例本身，导致没有关系的两个方法却不能同时进行。<a href=http://www.tianshouzhi.com/api/tutorials/mutithread/284>哪种同步方法好解析</a>。</p><figure class="highlight java"><figcaption><span>"同步代码块实例"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTickets</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tickets = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">private</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-keyword">synchronized</span> (obj) &#123;<span class="hljs-comment">//同步代码块的对象必须是同一对象</span><br>        <span class="hljs-keyword">while</span> (tickets &gt; <span class="hljs-number">0</span>) &#123;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-comment">// TODO Auto-generated catch block</span><br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在卖出第： &quot;</span> + (tickets--) + <span class="hljs-string">&quot;张票&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><figure class="highlight java"><figcaption><span>"实例同步方法"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTickets</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tickets = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (tickets &gt; <span class="hljs-number">0</span>) &#123;<br>        sell();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tickets &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在卖出第： &quot;</span> + (tickets--) + <span class="hljs-string">&quot;张票&quot;</span>);<br>    &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="解决死锁问题"><a href="#解决死锁问题" class="headerlink" title="解决死锁问题"></a>解决死锁问题</h3><p>死锁问题归根到底就是锁的嵌套问题。下面是一个死锁的栗子：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//公共锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLock</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj1=<span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj2=<span class="hljs-keyword">new</span> Object();<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> flag;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MultiThread</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> flag)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>();<br>    <span class="hljs-keyword">this</span>.flag = flag;<br>&#125;;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-comment">// super.run();</span><br>        <span class="hljs-keyword">if</span>(flag) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-comment">// TODO Auto-generated catch block</span><br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (MyLock.obj1) &#123;<br>                System.out.println(Thread.currentThread().getName()+<br>                        <span class="hljs-string">&quot;get lock obj1&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (MyLock.obj2) &#123;<br>                    System.out.println(Thread.currentThread().getName()+<br>                            <span class="hljs-string">&quot;get lock obj2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (MyLock.obj2) &#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;get lock obj2&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (MyLock.obj1) &#123;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;get lock obj1&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面的代码由于锁的相互嵌套，造成了死锁问题。这是由线程间通信方式不当而造成的。</p><blockquote><p>什么是线程间的通信问题？</p></blockquote><p>就是不同<strong>种类</strong>的线程针对同一资源的操作。</p><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p>场景：</p><ol><li>共同资源：学生对象</li><li>设置学生数据：setThread(生产者)</li><li>获得学生数据： getThread(消费者)</li><li>测试demo</li></ol><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>线程调度有两种模型，分别为：</p><ul><li>分时调度模型：所有线程轮流使用CPU，并且分配的时间片都相同</li><li>抢占式调度模型：优先级高的线程优先获得CPU使用权，并且时间片也会比低级线程的多一些。如果线程优先级相同，则随机选一个。</li></ul><p><strong>java使用抢占式调度模式。</strong></p><p>那么如何设置优先级呢？没有设置优先级之前，在java中所有线程的优先级都为5。线程优先级范围为1-10。注意：</p><blockquote><p>线程优先级高仅仅代表线程获取时间片的几率较高，而不是这个线程最先执行完毕。并且要多次执行才能看出效果。</p></blockquote><p>而且这里设置的优先级也仅仅是建议，到底优不优先还得看操作系统。并且线程一定属于线程组，那么如果线程的优先级高于所在线程组的优先级，会怎么样呢？</p><figure class="highlight java"><figcaption><span>"线程组优先级"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ThreadGroup t=<span class="hljs-keyword">new</span> ThreadGroup(<span class="hljs-string">&quot;t&quot;</span>);<br>    Thread t1= <span class="hljs-keyword">new</span> Thread(t,<span class="hljs-keyword">new</span> CreateThread2(<span class="hljs-string">&quot;tom&quot;</span>));<br>    Thread t2=<span class="hljs-keyword">new</span> Thread(t,<span class="hljs-keyword">new</span> CreateThread2(<span class="hljs-string">&quot;bob&quot;</span>));<br>    t.setMaxPriority(<span class="hljs-number">6</span>);<br>    t1.setPriority(<span class="hljs-number">9</span>);<br>    t2.setPriority(<span class="hljs-number">2</span>);<br>    t1.start();<br>    t2.start();<br>    System.out.println(<span class="hljs-string">&quot;线程组优先级:&quot;</span>+t.getMaxPriority());<br>    System.out.println(<span class="hljs-string">&quot;t1优先级:&quot;</span>+t1.getPriority());<br>    System.out.println(<span class="hljs-string">&quot;t2优先级:&quot;</span>+t2.getPriority());<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>结果如下：</p><blockquote><p>线程组优先级:6<br>t1优先级:6<br>t2优先级:2</p></blockquote><ul><li>设置优先级：<ul><li>setPriority()</li></ul></li><li>获取优先级：<ul><li>getPriority()</li></ul></li></ul><h3 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h3><ul><li><p>线程休眠：<code>public static void sleep(long time)</code>，time表示休眠的毫秒值</p></li><li><p>线程加入：<code>public final void join()</code>,这个方法的作用就是调用该方法的线程先执行完了，其他的线程才能加进来，进入就绪状态。这个join方法有点意思，后序会更新。现在先列一些参考：<a href="https://blog.csdn.net/u013425438/article/details/80205693">参考1</a>,<a href="https://blog.csdn.net/qq_20919883/article/details/100695018">参考2</a><a href="https://www.cnblogs.com/techyc/p/3286678.html">参考3</a></p></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    MyThread my=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;tom&quot;</span>);<br><br>    MyThread my1=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;bob&quot;</span>);<br><br>    MyThread my2=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;candy&quot;</span>);<br>    my.start();<br>    my.join();<br>    my1.start();<br>    my2.start();<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p><del>注意：调用join的位置很重要，必须放在其他线程对象调用<code>start()</code>之前才起作用。</del> 前面这句话完全是在扯淡。在使用join方法，我们需要考虑一个更高的维度，就是当前代码的执行环境。我们可以看到<code>my.join()</code>是在主线程里被调的，虽然调的是<code>MyThread</code>的join方法，但是执行的线程环境是在执行这句代码的线程中。所以这就解释了为什么是<code>my</code>在调用，而阻塞的是<code>main</code>线程，之所以与位置有关，是为主线程被阻塞了，<code>my1.start()</code>、<code>my2.start()</code>还没执行呢，线程当然不会启动。</p><p>这里多说一句，<code>join()</code>方法底层调用的还是<code>wait(0)</code>。</p><ul><li>线程礼让：<code>public static void yield()</code>:暂停当前执行的线程对象，并之情其他线程，让多个线程执行更和谐，但不能保证一人一次。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-comment">//super.run();</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;++i) &#123;<br>            System.out.println(getName()+<span class="hljs-string">&quot;:&quot;</span>+i);<br>            Thread.yield();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>守护线程：简而言之就是守护线程是与其守护的线程的同生死的。被守护的线程死了，守护线程必须得死，但不是立即死。反之则不一定。被守护的线程没死，守护线程可以死。</li></ul><p>那么守护线程到底守护的是谁？是所有的非守护线程，只要还有非守护线程，那么守护线程就会一直工作。</p><p>通过使用成员方法<code>public final void setDaemon()</code>。并且一定要在线程启动前调用。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    MyThread my=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;tom&quot;</span>);<br><br>    MyThread my1=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;bob&quot;</span>);<br><br>    MyThread my2=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;candy&quot;</span>);<br>    my.setDaemon(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//必须在就绪前设为守护线程</span><br>    my1.setDaemon(<span class="hljs-keyword">true</span>);<br>    my2.setDaemon(<span class="hljs-keyword">true</span>);<br>    my.start();<br>    my1.start();<br>    my2.start();<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++) &#123;<br>        System.out.println(Thread.currentThread().getName()+i);<br>    &#125;<br>    <span class="hljs-comment">//System.out.println(my.getPriority());</span><br>    <span class="hljs-comment">//Thread curThread=Thread.currentThread();</span><br>    <span class="hljs-comment">//System.out.println(curThread.getName());</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><ul><li>线程终止：有两种方法，<code>stop()</code>,<code>public void interrupt()</code>。前者已经过时。主要使用后者。后者中断的原理时抛出<code>InterruptedException</code>异常，使用<code>try-catch</code>捕捉后，后续代码仍可执行。</li></ul>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五种IO模型</title>
    <link href="/2021-06-03/five-IO-model.html"/>
    <url>/2021-06-03/five-IO-model.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信对于很多新人来说，同步、异步、阻塞、与非阻塞这四个概念非常容易混淆。那是因为我们没有搞清楚我们看待问题的视角。对于这四个概念，站在不同的角度，如何区别是不同的。我在此将所有的资料汇总，总结，并提出我自己的见解。</p><p>我将分两种维度讨论这四种概念，分别是广义上的同步与阻塞，以及狭义上的同步与阻塞。</p><h2 id="1-广义维度下的区分"><a href="#1-广义维度下的区分" class="headerlink" title="1. 广义维度下的区分"></a>1. 广义维度下的区分</h2><p>相信很多人在编写多线程程序最大的难度就是让各个线程之间同步合作。那么根据&lt;&lt;操作系统概念&gt;&gt;(第九版)一书中关于进程之间通信部分小节的同步异步概念:(<a href="https://www.zhihu.com/question/19732473">怎样理解阻塞非阻塞与同步异步的区别?</a>)<br><img src="images/os.jpg" alt="os"></p><p>其中说到进程之间的消息传递可以分为阻塞或者非阻塞的，也即是同步或者异步的。发送和接受动作分别可以细分为两种情况：</p><ul><li>阻塞发送：发送进程会被阻塞直到消息被接受</li><li>非阻塞发送：发送进程发送完毕后可以进行其他操作</li><li>阻塞接受：接收进程会被阻塞直到消息可用</li><li>非阻塞接受：接收进程收到消息或返回空</li></ul><p>那么站在我们多线程程序的角度，我们可以认为同步即阻塞，异步即非阻塞。无论底层是如何实现的。</p><h2 id="2-狭义维度下的区分"><a href="#2-狭义维度下的区分" class="headerlink" title="2. 狭义维度下的区分"></a>2. 狭义维度下的区分</h2><p>所谓的狭义维度即我们进行IO操作的角度。因为IO操作的特殊性，阻塞是可能发生的。那么下面我将通过介绍五种linux平台的IO模型来区分这四种概念：</p><ul><li>阻塞IO模型</li><li>非阻塞IO模型</li><li>IO多路复用模型</li><li>信号通知模型</li><li>异步IO模型</li></ul><p>首先我们肯定是要通过内核与外部设备进行IO交互，那么一次IO操作基本上可以分为三个步骤：</p><ol><li>用户进程等待IO设备的数据</li><li>通知用户进程所需数据已经准备好</li><li>用户进程把IO数据从内核空间拷贝至用户空间</li></ol><p>了解这三个步骤后，很自然地会想到第一部分的等待是如何等待，是占用CPU空等还是进行睡眠操作？第二部分的通知什么时候通知？（我们上面的IO操作基于单线程网络IO）下面的四种模型很好地回答了上述这两个问题。</p><h3 id="2-1-阻塞IO模型"><a href="#2-1-阻塞IO模型" class="headerlink" title="2.1 阻塞IO模型"></a>2.1 阻塞IO模型</h3><p>首先阻塞IO模型最符合我们的惯性思维，模型如下图所示(图片应该来自unix网络编程一书，未经本人考证):</p><p><img src="images/blocking-IO.jpg" alt="blocking-IO"></p><p>在linux的世界里，一切皆文件。那么我们也可以将socket当作一种特殊的文件来进行独写。在默认情况下socket为<strong>阻塞</strong>模式，那么当用户进程调用<code>recvfrom</code>后，由于此时IO数据尚未准备完成，用户进程会被阻塞(处于等待阶段)，直到数据准备完成。此时用户进程还是会被阻塞至数据拷贝至用户空间（处于拷贝阶段）。</p><p>可以看到，在一次IO操作中用户线程是全程被阻塞的，所以这是最基本的阻塞IO模型。</p><h3 id="2-2-非阻塞IO模型"><a href="#2-2-非阻塞IO模型" class="headerlink" title="2.2 非阻塞IO模型"></a>2.2 非阻塞IO模型</h3><p><img src="images/non-blocking-IO.jpg" alt="non-blocking-IO"></p><p>上图为非阻塞IO模型的基本示意图。</p><p>在进行网络IO时，我们可以将socket设置为<strong>非阻塞</strong>模式。这个设置就是告诉内核对于这个socket，调用<code>recvfrom</code>读取该socket时，如果数据尚未准备完成，那么直接返回，不必等待至数据准备好。所以在第一阶段我们不必等待。</p><p>那么什么时候用户进程会得知内核完成数据准备呢(即第二阶段)?在这个模型中，用户进程会不断进行轮循操作，即不断调用<code>recvfrom</code>来得知数据是否准备完毕，从而完成第二个阶段。</p><p>第三个阶段与阻塞IO模型类型，都是从内核空间将数据拷贝出来。可以看到第二阶段的轮循操作是非常浪费资源的，因为大多时候我们在做无用功。从而产生了IO多路复用模型。</p><h3 id="2-3-IO多路复用模型"><a href="#2-3-IO多路复用模型" class="headerlink" title="2.3 IO多路复用模型"></a>2.3 IO多路复用模型</h3><p>所谓的<strong>多路</strong>是指多个socket的读写，<strong>复用</strong>是指所有的IO都可以通过复用一个或几个线程来完成。基本模型如下图所示：</p><p><img src="images/multiplexing-IO.jpg" alt="IO-multixing"></p><p>IO多路复用模型的工作场景如下：</p><p>假设我们现在有socket A、B需要进行IO操作，有三种方案：</p><ol><li>单线程，采用阻塞IO模型：这就是将所有的IO操作串行，当两个socket流量都非常低且不活跃时，效率非常低，有可能排在后面的socket已经准备好了，但是当前处理线程仍然在等待第一个socket的数据</li><li>单线程，采用非阻塞IO模型，不断对A、B进行轮循操作，当然仍然会浪费大量的时间，并且不断使用<strong>多次使用系统调用</strong>查看一个socket，代价也比较高昂</li><li>采用多线程，阻塞IO模型，将A、B的IO轮循任务分配两个子线程。虽然这样效率比前面两种方案都高，但是线程是非常宝贵的资源，<strong>不停的切换线程</strong>、创建与销毁线程的代价都昂贵。</li></ol><p>难道我们就不能通过一次系统调用查看多个socket，让socket完成数据准备后自己通知用户线程吗？当然这是可行的，就是使用linux平台的select、poll、epoll等系统调用。对应于java中的NIO。<strong>一次系统调用监控多个socket</strong>就是多路IO复用模型出现的原因。</p><p>这里我首先以<code>select</code>作为例子。基本的流程如下：</p><ol><li>我们将需要操作的socket注册到<code>select</code>函数中，并绑定我们感兴趣的操作，例如是读还是写。然后调用<code>select</code>。<strong>注意：在没有socket准备好时，<code>select</code>仍然会阻塞用户进程</strong>。</li><li><code>select</code>会不断的对注册的socket进行轮循操作，直至有可用的socket出现，此时该函数会返回，但剩余未准备好的socket仍然可以继续准备。</li><li>对可用的socket进行感兴趣的操作。然后继续调用<code>select</code></li></ol><p>那么我们节省的时间在哪里？很简单，就是在当我们select出一些socket后进行数据处理操作时，剩余的socket仍然可以继续准备。可能当我们下一次调用<code>select</code>时又有新的socket已经准备好了。这样就避免对多个socket进行轮循时，已经准备好的socket后轮循，没准备好的先轮循，浪费了不必要的时间。</p><p>当然对于<code>select</code>,还有更多的细节需要注意。这里只需要记住，对于第一个等待数据的阶段同样会<strong>产生阻塞</strong>，第三阶段拷贝数据时也会<strong>产生阻塞</strong>。</p><h3 id="2-4-信号通知模型"><a href="#2-4-信号通知模型" class="headerlink" title="2.4 信号通知模型"></a>2.4 信号通知模型</h3><p>信号模型如下图所示：</p><p><img src="images/signal-IO.png" alt="signal-IO"></p><p>信号IO模型似乎用的不是很多，所以对于其的介绍我引用自<a href="https://segmentfault.com/a/1190000007355931">Unix 网络 IO 模型: 同步异步, 傻傻分不清楚?</a>：</p><blockquote><p>当文件描述符就绪时, 我们可以让内核以信号的方式通知我们.<br>我们首先需要开启套接字的信号驱动式 IO 功能, 并通过 sigaction 系统调用安装一个信号处理函数. sigaction 系统调用是异步的, 它会立即返回. 当有数据时, 内核会给此进程发送一个 SIGIO 信号, 进而我们的信号处理函数就会被执行, 我们就可以在这个函数中调用 recvfrom 读取数据</p></blockquote><h3 id="2-5-异步IO模型"><a href="#2-5-异步IO模型" class="headerlink" title="2.5 异步IO模型"></a>2.5 异步IO模型</h3><p>所谓的异步IO模型，是在我们进行系统调用后直接返回，但并不像阻塞IO模型返回<code>EWOULDBLOCK</code>，具体返回什么有待学习。然后当数据准备完毕并拷贝至用户空间时，内核会发送信号通知用户进程处理数据。模型如下所示：<br><img src="images/asynchronus-IO.jpg" alt="asyn-IO"></p><p>可以看到，异步IO模型甚至不需要我们拷贝数据，当然异步IO在网络编程中很少用到，可能会用在文件IO中。</p><h3 id="2-6-IO维度下的同步与异步"><a href="#2-6-IO维度下的同步与异步" class="headerlink" title="2.6 IO维度下的同步与异步"></a>2.6 IO维度下的同步与异步</h3><p>根据IEEE针对<a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html">POSIX相关规定</a>中的第3.30条异步I/O操作定义：</p><blockquote><p>3.30条：Asynchronous I/O Operation<br>An I/O operation that does not of itself cause the thread requesting the I/O to be blocked from further use of the processor.<br>This implies that the process and the I/O operation may be running concurrently.</p></blockquote><p>与第3.387条同步I/O操作的定义:</p><blockquote><p>3.387 Synchronous I/O Operation<br>An I/O operation that causes the thread requesting the I/O to be blocked from further use of the processor until that I/O operation completes.<br>Note:<br>A synchronous I/O operation does not imply synchronized I/O data integrity completion or synchronized I/O file integrity completion.</p></blockquote><p>我们可以得知在I/O视角下：</p><ul><li>同步IO：由于请求IO而导致当前进程丧失处理器使用权直至操作结束</li><li>异步IO：请求IO并不会导致当前进程对处理器的使用权</li></ul><p>那么我们就可以对上述五种IO模型进程同步与异步的划分了。</p><ul><li>阻塞IO模型：在第一阶段和第三阶段都会由于系统调用而当值当前线程被阻塞</li><li>非阻塞IO模型：在第三阶段拷贝数据时会导致当前线程被阻塞</li><li>IO多路复用模型：在第一阶段和第三阶段线程都会被阻塞</li><li>信号通知模型：在第三阶段拷贝数据时当前线程会被阻塞</li><li>异步模型：三个阶段线程都不会被阻塞</li></ul><p>那么我就可以得知，阻塞IO模型、非阻塞IO模型、多路复用IO模型、信号通知模型都是同步I/O操作。下图很好地进行了总结：</p><p><img src="images/IO-model-summary.jpg" alt="IO-model-summary"></p><h3 id="2-7-小节"><a href="#2-7-小节" class="headerlink" title="2.7 小节"></a>2.7 小节</h3><p>在网络I/O视角下，是否同步与是否采用阻塞模型无关。那么当我们将视角提高至线程之间通信时，此时的同步基本上可以与阻塞划等号。比如我们当前调用了一个异步API，与这个API底层怎么实现的无关。</p><p>所以说，要想分清同步异步与阻塞非阻塞这四个概念，不在一定的维度讨论是没有办法分清楚的。</p><h2 id="3-详解多路复用IO模型"><a href="#3-详解多路复用IO模型" class="headerlink" title="3. 详解多路复用IO模型"></a>3. 详解多路复用IO模型</h2><p>上面简要描述了linux平台下的五种I/O模型，其中多路复用模型其实才是我们最有可能采用的。在linux下，有三个API可以帮助我们实现这个模型，分别是：<code>select</code>、<code>poll</code>、<code>epoll</code>。这三个API的效率基本上按照从左到右由低到高。</p><p>在详细介绍这三种方法前，我们需要了解一个阻塞的socket和一个非阻塞的socket有什么区别：</p><ul><li>阻塞的socket：读取时如果数据尚未准备好，那么当前线程会一直被阻塞直至数据准备完成</li><li>未阻塞的socket：读取时如果数据尚未准备好，那么当前线程并不会被阻塞，会执行后续的操作</li></ul><p><strong>并且我们可以将socket当作文件处理，使用文件描述符fd指代向应socket。</strong></p><h3 id="3-1-select方法"><a href="#3-1-select方法" class="headerlink" title="3.1 select方法"></a>3.1 select方法</h3><p>函数签名如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nfds, fd_set *rdfds, fd_set *wtfds, fd_set *exfds, struct timeval *timeout)</span></span><br></code></pre></div></td></tr></table></figure><ul><li>ndfs：监听的fd(file descriptor)总数</li><li>rdfds：需要监听可读事件的socket集合</li><li>wtfds：需要监听可写事件的socket集合</li><li>exfds：需要监听异常事件的socket集合</li></ul><p>那么<code>select</code>的工作原理很简单，我们将需要监听的socket集合传入该函数后：</p><ol><li><code>select</code>会将相应的socket集合<strong>拷贝至内核空间</strong>(注意每次调用都会拷贝)</li><li><code>select</code>轮循探测监听的socket，如果有对应的socket完成事件，那么<code>select</code>就会返回，否则会保持阻塞状态</li><li>那么在函数返回后，我们并不知道是哪个socket的什么事件准备好了，所以我们需要<strong>遍历我们的socket</strong>，依次探测所有类型的事件是否完成，不管这个socket到底对当前探测的事件是否感兴趣，并且又会把相应的socket拷贝至用户空间</li><li>在进行新一轮的<code>select</code>调用时,又得重新设置socket集合，因为上一轮已经改变了集合</li></ol><p>当然<code>select</code>存在很多缺点：</p><ol><li>在<strong>每次</strong>调用<code>select</code>时都会将目标socket集合<code>fd_set</code>从用户空间拷贝至内核空间，所以当socket集合很大时，每次拷贝的效率会非常低</li><li><code>select</code>内部每次使用<strong>轮询操作</strong>探查是否有socket的对应事件准备完毕，因为其使用的<code>fd_set</code>由数组组成，大小一般限制为1024(因为操作系统对每个进程可用的最大描述符数限制了上限，可在编译时重新设置)，所以每次轮询都需要完整遍历，这又会使<code>select</code>效率变低</li><li>在找到准备好的socket集合后，<code>select</code>又会将所有的<code>fd_set</code>再从内核拷贝至用户空间，再次将<code>select</code>效率变低</li><li> 在每次调用<code>select</code>时，之前设置的<code>fd_set</code>都会失效，所以每次循环前都需要重新设置<code>fd_set</code>.</li></ol><h3 id="3-2-poll方法"><a href="#3-2-poll方法" class="headerlink" title="3.2 poll方法"></a>3.2 poll方法</h3><p><code>poll</code>与<code>select</code>并无大的差别，只不过<code>poll</code>使用的socket集合<code>pollfd</code>没有大小的限制，因为底层是采用链表实现的，所以<code>select</code>有的缺点<code>poll</code>都会存在</p><h3 id="3-3-epoll机制"><a href="#3-3-epoll机制" class="headerlink" title="3.3 epoll机制"></a>3.3 epoll机制</h3><p><strong>epoll的基本玩法</strong></p><p><code>epoll</code>是<code>poll</code>的升级版，<code>epoll</code>的API分为三个部分：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epfd, <span class="hljs-keyword">int</span> op, <span class="hljs-keyword">int</span> fd, struct epoll_event *event)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epfd, struct epoll_event * events, <span class="hljs-keyword">int</span> maxevents, <span class="hljs-keyword">int</span> timeout)</span></span>;<br></code></pre></div></td></tr></table></figure><ol><li>epoll_create：首先调用<code>epoll_create</code>创建<code>poll</code>对象。并且会开辟一个红黑树与就绪队列。红黑树用来保存我们需要监听的socket结合，就绪队列用来保存已经准备就绪的socket集合</li><li>epoll_ctl：注册要监听的事件类型。在每次注册新的事件到epoll句柄中时，会把对应的socket复制到内核中，注意对于一个socket，在<code>epoll</code>中<strong>只会被复制一次</strong>，不像<code>select</code><strong>每次调用</strong>时都会复制。并且同时会向内核注册回调函数，大致功能是当该socket关注的事件完成时将其加入就绪队列。</li><li>epoll_wait：等待事件的就绪，其只用遍历就绪队列，所以<code>epoll</code>的复杂度只与活跃的连接数有关。<del>并且返回就绪socket集合<strong>采用了内存映射</strong>，进一步减少了拷贝fds的操作</del>，好吧，这句话是错的，并没有内存映射，<a href="https://www.zhihu.com/question/39792257">参考</a>。但是同时<code>epoll_wait</code>返回后，会将就绪socket对应事件清空，如果后续仍想关注当前处理的socket，那么就需要用epoll_ctl(epfd,EPOLL_CTL_MOD,listenfd,&amp;ev)来重新设置socket fd的关注事件类型，<strong>而不需要重新注册fd</strong></li></ol><p><strong>epoll解决了什么问题：</strong></p><p>1. epoll通过回调机制实现了知道哪个socket的哪些事件准备完成，这在<code>select</code>中需要通过轮询完成(这里并不是指在<code>epoll_wait</code>返回后不需要遍历小于返回值的fd，仍然需要循环遍历socket进行处理)<br>2. epoll只会在fd初次注册使用<code>epoll_ctl</code>时拷贝至内核,而<code>select</code>每次都需要完整的拷贝所有fd，并且每次都需要重新设置描述符结合，因为每次<code>select</code>返回后都会修改描述符集合</p><p><strong>epoll的LT与ET模式：</strong></p><p>epoll有EPOLLLT和EPOLLET两种触发模式。它们主要的区别有两点：</p><ol><li>LT模式下，只要有socket活跃，那么就会向用户进程发送信号，通知进程对数据进行操作。而ET模式只会在socket无法存放数据时才会通知进程对数据进程操作，例如读时没有内存存储数据</li><li>LT模式下，如果一个socket的数据未使用完毕，那么下一轮通知中还会包含未处理完毕的socket，ET模式下，一个socket的数据未使用完毕，那么epoll会认为当前socket的状态未发生改变，下轮通知时不会包含当前socket</li></ol><p>那么LT模式的缺点是很明显的，因为有可能会有大量的我们并不关心的socket对我们发送通知，所以我们一般都会采用ET模式。</p><p>但是ET模式下，如果一个socket的数据不能一次处理完毕，该socket就会被认为状态未发生改变。所以我们一般会采用循环处理socket的所有数据。这又产生了新的问题。如果该socket被设置阻塞模式，在循环进行最后一次读取时，读取到的数据必然为空，当前线程会被阻塞，直到该socket收到数据。<br>那么LT模式如果有阻塞socket的数据一次不能处理完呢？解决方法就是我们就不需要使用循环读取所有数据，只需调用一次，因为LT模式下该socket还会出现在就绪队列中。</p><p>所以我们一般<strong>建议</strong>在使用ET模式将socket设置为<strong>非阻塞模式</strong>。但是这并不说明ET模式下不能将socket设置为阻塞模式。如果socket的数据一次能够读取完毕，那么也不会阻塞当前线程。所以我们说建议，因为ET模式的阻塞socket可能会产生预想不到的问题。<strong>同时也说明是否阻塞socket并不影响多路复用IO模型的使用。</strong></p><h3 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h3><p>其实我们可以发现多路复用IO模型其实就是在完成两件事：</p><ul><li>维护需要监听的fd集合</li><li>等待目标事件的完成</li></ul><p><code>select</code>就是把这两件事放在一起做，每次调用时都要重新注册需要监听的集合，并且每次都会进行阻塞操作。</p><p>而<code>epoll</code>就将维护操作放在了第二步，只需第一次注册，然后使用<code>wait</code>函数完成阻塞的操作。</p><p>那么<code>epoll</code>比<code>select</code>快是理由的：</p><ol><li>因为在大部分情况下我们需要监听的fd集合是固定的，<code>epoll</code>不会进行重复注册</li><li>在每次设置fd的目标事件时，因为<code>epoll</code>内部采用的红黑树保存需要监听的fd集合，查找对应的<code>socket</code>都是<code>o(lgn)</code>的复杂度。而<code>select</code>需要设置所有的带监听的fd集合。</li></ol><p><strong>那么在任何时候都应该优选选择<code>epoll</code>吗？</strong></p><p>答案当然是否定的。如果当前服务器的连接数较少并且都很活跃，<code>epoll</code>不一定会优于<code>select</code>，因为<code>epoll</code>注册回调函数等操作都需要代价。</p><h2 id="4-java世界中的多路复用模型"><a href="#4-java世界中的多路复用模型" class="headerlink" title="4. java世界中的多路复用模型"></a>4. java世界中的多路复用模型</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://cllc.fun/2019/03/07/synchronous-asynchronous-io/">同步I/O(阻塞I/O，非阻塞I/O)，异步I/O</a></p></li><li><p><a href="https://medium.com/@liakh.aliaksandr/java-sockets-i-o-blocking-non-blocking-and-asynchronous-fb7f066e4ede">Java sockets I/O: blocking, non-blocking and asynchronous</a></p></li><li><p><a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html">POSIX的一些相关定义</a></p></li><li><p><a href="https://www.zhihu.com/question/19732473">怎样理解阻塞非阻塞与同步异步的区别？</a></p></li><li><p><a href="https://imageslr.github.io/2020/02/27/select-poll-epoll.html">I/O 多路复用，select / poll / epoll 详解</a></p></li><li><p><a href="https://www.cnblogs.com/skyfsm/p/7079458.html">Linux编程之select</a></p></li><li><p><a href="https://www.cnblogs.com/upnote/p/12017212.html">关于非阻塞I/O、多路复用、epoll的杂谈</a></p></li><li><p><a href="https://www.cnblogs.com/aspirant/p/9166944.html">select、poll、epoll之间的区别(搜狗面试)</a></p></li><li><p><a href="https://blog.csdn.net/daaikuaichuan/article/details/83862311">poll原理详解及epoll反应堆模型</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArrayList源码分析</title>
    <link href="/2021-06-03/ArrayList-source-code-analysis.html"/>
    <url>/2021-06-03/ArrayList-source-code-analysis.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分析源码初体验，第一次分析个比较简单的集合类ArrayList。我把重点放在了ArrayList实现的接口、继承的类以及几个主要的类方法上。</p><h2 id="0x0-ArrayList继承图"><a href="#0x0-ArrayList继承图" class="headerlink" title="0x0 ArrayList继承图"></a>0x0 ArrayList继承图</h2><p>我们首先来看看ArrayList中的继承图。</p><p><img src="images/arrayList-hierarchy.png" alt="ArrayList继承图"></p><p><code>ArrayList</code>继承自抽象类<code>AbstractList</code>,并且实现了<code>RandomAccess</code>、<code>Cloneable</code>、<code>Seriablizable</code>、<code>List</code>接口。</p><p>这里我首先有了两个疑惑:</p><ul><li>接口与ArrayList之间为什么隔了一个抽象类<code>AbstractList</code>?</li><li>抽象类<code>AbstractList</code>已经实现了<code>List</code>接口，为什么ArrayList又实现了一遍？</li></ul><p>对于<strong>第一个</strong>问题可以从设计模式的角度回答，因为接口<code>List</code>中的抽象方法是非常多的，如果<code>ArrayList</code>直接实现了该接口，那么<code>ArrayList</code>必须实现<code>List</code>中的所有抽象方法，尽管有些方法用不到。那么为了解决这个问题，JDK在接口与实现类中间添加一个抽象类，虽然抽象类不能生成对象，但是也可以实现接口中的抽象方法的，JDK中的AbstractList实现了一些非常非常通用的方法。ArrayList来继承上述的抽象类，这样ArrayList仅需实现AbstractList中没有实现的抽象方法，对于AbstractList已经实现的抽象方法，ArrayList可以自由选择实现与否。</p><p>也就是说抽象类AbstractList给了ArrayList需要实现的抽象方法的选择空间。</p><p>对于<strong>第二个</strong>问题,答案获取有些不那么令人信服，经过网上资料查阅，说是JDK的开发人员人为ArrayList实现List接口可能会对后序的开发有帮助，久而久之，就一直延续下来，造成了现在的局面。</p><p>ok，这两个问题解决了，我们继续向下探索。</p><h2 id="0x1-ArrayList实现的接口"><a href="#0x1-ArrayList实现的接口" class="headerlink" title="0x1 ArrayList实现的接口"></a>0x1 ArrayList实现的接口</h2><p>ArrayList实现了<code>RandomAccess</code>、<code>List</code>、<code>Cloneable</code>、<code>Serializable</code>接口。</p><p><strong>RandomAccess接口:</strong></p><p>这个<code>RandomAccess</code>是一个marker interface(该接口内什么都没有实现，仅仅是作为一个标记接口)。简单来说，实现了该接口的类就一定拥有随机访问的能力。所以我们在遍历一个类的时候，建议我们首先使用<code>instanceOf</code>判断当前类是否为<code>RandomAccess</code>的实现类，如果时，那么采用for循环(普通for循环，而不是增强型for循环，因为增强型内部也是使用迭代器)遍历比采用迭代器的平均性能更好。</p><p><strong>List接口:</strong></p><p>上一小节已经回答了该问题，开发人员的笔误。 :)</p><p><strong>Cloneable接口:</strong></p><p>虽然官方文档没有说明该接口是marker interface,但我感觉作用差不多，实现了该接口的类，那么该类的<code>clone</code>方法就是可用的，允许对象的字段复制。</p><p><strong>Serializable接口:</strong></p><p>作用也相当于一个marker interface，标识实现类是可序列化与反序列化的。</p><h2 id="0x2-ArrayList中的重要属性与方法"><a href="#0x2-ArrayList中的重要属性与方法" class="headerlink" title="0x2 ArrayList中的重要属性与方法"></a>0x2 ArrayList中的重要属性与方法</h2><h3 id="0x2-1-ArrayList的属性"><a href="#0x2-1-ArrayList的属性" class="headerlink" title="0x2-1 ArrayList的属性"></a>0x2-1 ArrayList的属性</h3><p>ArrayList的属性不是很多，但是有一个非常重要的属性<code>modCount</code>，继承自抽象类<code>AbstractList</code>，这个属性保证了fast-fail机制,这会在后面讲解方法的时候提到。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//序列化ID</span><br><span class="hljs-meta">@java</span>.io.Serial<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">8683452581122892189L</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Default initial capacity.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//ArrayList的默认大小为10</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Shared empty array instance used for empty instances.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//这个和下面的区别就是采用无参构造函数时使用这个，大小为0的Object数组</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Shared empty array instance used for default sized empty instances. We</span><br><span class="hljs-comment"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span><br><span class="hljs-comment"> * first element is added.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//下面这个数组是在采用提供大小的构造函数但是提供的参数有误时使用的</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The array buffer into which the elements of the ArrayList are stored.</span><br><span class="hljs-comment"> * The capacity of the ArrayList is the length of this array buffer. Any</span><br><span class="hljs-comment"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="hljs-comment"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">//这个数组是实际存储元素的数组，不知道为什么不是private的啊，按道理来说即使是private也不影响内部类访问啊。</span><br><span class="hljs-comment">//注意这个数组是不参与序列化的</span><br><span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// non-private to simplify nested class access</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The size of the ArrayList (the number of elements it contains).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//List的大小是参与序列化的哦</span><br><br> <span class="hljs-comment">//存储的是数组实际的元素个数,并不是数组的长度</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br></code></pre></div></td></tr></table></figure><h3 id="0x2-2-ArrayList中的重要方法"><a href="#0x2-2-ArrayList中的重要方法" class="headerlink" title="0x2-2 ArrayList中的重要方法"></a>0x2-2 ArrayList中的重要方法</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>ArrayList中的构造方法有三个:</p><ul><li>默认无参构造方法</li><li>初始化容量的构造方法</li><li>使用集合初始化的构造方法</li></ul><p>第一个构造方法没什么好说的,就是使用<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>初始化一个空的Object数组。数组的默认长度为10.</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>第二个构造方法提供了一个容量参数,参数必须&gt;=0,否则会抛出非法参数异常。如果容量大小为0,那么则使用<code>EMPTY_ELEMENTDATA</code>初始化数组,容量为0。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                               initialCapacity);<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>最后一个构造方法使用一个Collection初始化ArrayList,</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>        elementData = c.toArray();<br>        <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br>            <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>                <span class="hljs-comment">//如果c.toArray返回的不是Object数组,那么则需要使用数组工具类的copy方法一个一个复制元素</span><br>                elementData = Arrays.copyOf(elementData, size, Object[].class);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// replace with empty array.</span><br>            <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>这里需要提一嘴Arrays中的<code>copyOf</code>方法,其中的一个小问题困扰了我很长时间,下面是Arrays中其中一个的<code>copyOf</code>的源码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="hljs-keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    T[] copy = ((Object)newType == (Object)Object[].class) ?<br>            (T[]) <span class="hljs-keyword">new</span> Object[newLength] :<br>            (T[]) Array.newInstance(newType.getComponentType(), newLength);<br>    System.out.println((Object)newType.toString());<br>    System.arraycopy(original, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>,<br>                        Math.min(original.length, newLength));<br>    <span class="hljs-keyword">return</span> copy;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我一直不理解为什么需要加上<code>((Object)newType == (Object)Object[].class)</code>这一句判断，在stackoverflow上看到了一个<a href="https://stackoverflow.com/questions/29494800/do-not-understand-the-source-code-of-arrays-copyof">答案</a>,回答说这句话的目的就是检查<code>newType</code>是否持有一个<code>Object[]</code>类型的引用,可是这里的newType只有非基本类型的Class对象传进来才能编译成功,否则就会出现无法推断泛型的准确类型???</p><p>我好像又懂了,虽然代码里写的是强转Object,但是在运行时<code>==</code>比较的是等号两边指的是否为同一个对象,并不是说,我们在代码里把它转成Object了,在运行时两边比较的就是Object。</p><p>所以<code>((Object)newType == (Object)Object[].class)</code>之所以要进行强转,是因为由于泛型的原型，两边本身就不是同一个type,所以使用<code>==</code>比较编译根本就无法通过(所以说<code>==</code>的两侧必须是同一个类型编译才能通过?)。</p><p>ok,第二个困惑我的原因就很搞笑了,我原来调试的时候这句代码的执行结果一直是true,尽管我传进来的是<code>Integer[].class</code>,这我就纳了闷了,我就寻思那这句代码不是废话?既然只能传对象的Class,那不是恒成立,后来再调试的偶然瞬间发现,在调试copyOf的时候,调用这个api的函数根本就不是我写的,怪不得一直Object,不管传进来的是什么…这个错误着实搞笑,后来我直接从用户代码step into,嗯，结果对了，上述这句代码的结果为false,舒服了。</p><p>最后说说为什么要有这句代码,是因为直接new比采用newInstance快,因为newInstance使用了反射,<a href="https://stackoverflow.com/questions/29494800/do-not-understand-the-source-code-of-arrays-copyof">参考：</a></p><blockquote><p>new Object[…] creates an array the normal way, of a type that is statically known. Remember, the code has just checked that T[] is Object[].</p></blockquote><blockquote><p>Array.newInstance(…) uses reflection to dynamically create an array of the Class type passed in.</p></blockquote><p><code>copyOf</code>方法是会构建一个新的数组来存放元素的拷贝,当然需要说明:<strong>copyOf是浅拷贝!!!</strong></p><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>ArrayList的add方法挺多的，我将按照我的使用频率依次讲解。</p><p>首先是<code>add (E e)</code>方法:</p><figure class="highlight java"><figcaption><span>"add(E e)"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        modCount++;<br>        add(e, elementData, size);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>该方法首先将modCount加1,因为add方法使ArrayList发生了结构性改变,这会在后面说到,方法内部又调用了add的重载函数,</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e, Object[] elementData, <span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s == elementData.length)<br>        elementData = grow();<br>    elementData[s] = e;<br>    size = s + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先判断ArrayList的属性<code>size</code>是否达到了<code>elementData</code>的长度,这说明<code>size</code>属性并不是实时更新,size是数组实际存储的元素个数，应该会在elemeData扩张的时候更新。如果已经没有空间存放新元素了,就调用<code>grow</code>函数。其又会调用grow的带参重载函数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//此时size==elementData.length</span><br><span class="hljs-keyword">private</span> Object[] grow() &#123;<br>    <span class="hljs-keyword">return</span> grow(size + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//minCapacity是我们能够允许的最小的新的数组空间,也就是多一个</span><br><span class="hljs-keyword">private</span> Object[] grow(<span class="hljs-keyword">int</span> minCapacity) &#123;<br>    <span class="hljs-keyword">int</span> oldCapacity = elementData.length;<br>    <span class="hljs-comment">//如果数组中已经存在元素或者并不是调用默认构造函数创建对象</span><br>    <span class="hljs-comment">//那么我们可能会扩充至原始的1.5倍,为什么用可能,需要看具体的获取大小的函数</span><br>    <span class="hljs-keyword">if</span> (oldCapacity &gt; <span class="hljs-number">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        <span class="hljs-keyword">int</span> newCapacity = ArraysSupport.newLength(oldCapacity,<br>                minCapacity - oldCapacity, <span class="hljs-comment">/* minimum growth */</span><br>                oldCapacity &gt;&gt; <span class="hljs-number">1</span>           <span class="hljs-comment">/* preferred growth */</span>);<br>        <span class="hljs-keyword">return</span> elementData = Arrays.copyOf(elementData, newCapacity);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//否则如果我们原始大小为0,那么就扩充为10个长度</span><br>        <span class="hljs-keyword">return</span> elementData = <span class="hljs-keyword">new</span> Object[Math.max(DEFAULT_CAPACITY, minCapacity)];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>获取数组新容量的函数如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">newLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span> oldLength, <span class="hljs-keyword">int</span> minGrowth, <span class="hljs-keyword">int</span> prefGrowth)</span> </span>&#123;<br>        <span class="hljs-comment">// assert oldLength &gt;= 0</span><br>        <span class="hljs-comment">// assert minGrowth &gt; 0</span><br><br>        <span class="hljs-comment">//在最小增长大小和最适应增当大小之间选一个,并加上原来的大小,不出意外就是扩充为原来的1.5倍</span><br>        <span class="hljs-keyword">int</span> newLength = Math.max(minGrowth, prefGrowth) + oldLength;<br>        <span class="hljs-comment">//如果计算出的新大小没有超过MAX_ARRAY_LENGTH=Integer.MAX_VALUE-8</span><br>        <span class="hljs-comment">//那么就返回新计算出的大小</span><br>        <span class="hljs-comment">//否则就继续扩充,最大扩容至Integer.MAX_VALUE</span><br>        <span class="hljs-keyword">if</span> (newLength - MAX_ARRAY_LENGTH &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> newLength;<br>        &#125;<br>        <span class="hljs-keyword">return</span> hugeLength(oldLength, minGrowth);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span> oldLength, <span class="hljs-keyword">int</span> minGrowth)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> minLength = oldLength + minGrowth;<br>        <span class="hljs-keyword">if</span> (minLength &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError(<span class="hljs-string">&quot;Required array length too large&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (minLength &lt;= MAX_ARRAY_LENGTH) &#123;<br>            <span class="hljs-keyword">return</span> MAX_ARRAY_LENGTH;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Integer.MAX_VALUE;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>上面的ArrayList源码是JDK14的,和JDK8还是有点区别的,不过差别不大,都是将容量扩充到原来的1.5倍，而size只是简单的记录数组中元素的数量。</p><h4 id="toArray方法"><a href="#toArray方法" class="headerlink" title="toArray方法"></a>toArray方法</h4><p>还有一个我经常使用的方法<code>toArray</code>,这下顺便看到了真面目,如果使用无参的<code>toArray</code>,那么因为调用的是copyOf,返回了原始数组的浅拷贝副本,<del>也是Object数组</del>。该方法不一定会返回Object[]。<br>因为子类对象是可以使用父类引用保持的。具体类型取决于list中的数据类型。如下 代码所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object[] toArray() &#123;<br>    <span class="hljs-keyword">return</span> Arrays.copyOf(elementData, size);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="hljs-keyword">int</span> newLength) &#123;<br>    <span class="hljs-comment">//这里的original就是elementData</span><br>    <span class="hljs-keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果使用的是带参的<code>toArray</code>,那么参数就是我们想要该函数返回的数组类型,比如<code>toArray(new Integer[0])</code>,这里的数组长度无所谓了,反正都会创建一个数组,还有这个传入数组的类型,应该必须是非基本类型,不然又会出现类型无法推导的错误。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object[] toArray() &#123;<br>        <span class="hljs-keyword">return</span> Arrays.copyOf(elementData, size);<br>    &#125;<br><br><span class="hljs-keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;<br>        <span class="hljs-keyword">if</span> (a.length &lt; size)<br>            <span class="hljs-comment">// Make a new array of a&#x27;s runtime type, but my contents:</span><br>            <span class="hljs-keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());<br>        System.arraycopy(elementData, <span class="hljs-number">0</span>, a, <span class="hljs-number">0</span>, size);<br>        <span class="hljs-keyword">if</span> (a.length &gt; size)<br>            a[size] = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="0x3-ArrayList中的迭代器"><a href="#0x3-ArrayList中的迭代器" class="headerlink" title="0x3 ArrayList中的迭代器"></a>0x3 ArrayList中的迭代器</h2><p>为什么要讲迭代器呢?因为我想讲讲不能在使用迭代器遍历list时删除元素的原因。<code>AbstractList</code>中有一个叫做<code>modCount</code>的属性,在初次构建list对象时初始化为0。</p><blockquote><p>protected transient int modCount = 0;</p></blockquote><p>在我们对list做出结构性改变时,modCount也会改变。所谓的结构性改变是指list中元素个数发生了变化。</p><figure class="highlight java"><figcaption><span>"JDK8"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//add函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-comment">//每次增加元素时都需要确保仍然有空间保存元素</span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    <span class="hljs-comment">//添加元素时modCount加1</span><br>    modCount++;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br><br><span class="hljs-comment">//remove函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    rangeCheck(index);<br>    <span class="hljs-comment">//list元素减少时,modCount加1</span><br>    modCount++;<br>    E oldValue = elementData(index);<br><br>    <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                         numMoved);<br>    elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br><br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到只要对list做增删操作,那么就会使modCount发生改变。ok,那我们接下来看看ArrayList内部类实现的迭代器。</p><figure class="highlight java"><figcaption><span>"ArrayList内部实现的迭代器"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">int</span> cursor;       <span class="hljs-comment">// index of next element to return</span><br>    <span class="hljs-keyword">int</span> lastRet = -<span class="hljs-number">1</span>; <span class="hljs-comment">// index of last element returned; -1 if no such</span><br>    <span class="hljs-comment">//使用modCount初始化expectedModCount</span><br>    <span class="hljs-keyword">int</span> expectedModCount = modCount;<br><br>    Itr() &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cursor != size;<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        checkForComodification();<br>        <span class="hljs-keyword">int</span> i = cursor;<br>        <span class="hljs-keyword">if</span> (i &gt;= size)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>        Object[] elementData = ArrayList.<span class="hljs-keyword">this</span>.elementData;<br>        <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>        cursor = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>    &#125;<br><br>    <span class="hljs-comment">//检查expectedModCount的值是否发生改变</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkForComodification</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>    &#125;<br>...<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到,在使用迭代器的<code>next()</code>时,代码会首先检查modCount是否发生改变,那么在什么情况下modCount会发生改变?就是我们在自己额外调用例如<code>add()</code>、<code>remove()</code>改变list元素个数的方法时会改变modCount,所以如果在使用迭代器遍历的时候如果改变list的元素个数时,会抛出ConcurrentModificationException。<strong>这就是所谓的fail-fast</strong>。</p><p>如果在多线程环境下,其他线程有可能在当前线程遍历的同时对list做出结构性改变,所以ArrayList不是线程安全的。也会抛出同样的异常。</p><p>在使用迭代器遍历时,注意如果我们仅仅是改变元素的内容,而不改变元素个数的操作是允许的。ok,问题提出来了,那么如何再使用迭代器遍历的时候增删元素?</p><p>当然是调用迭代器的自己的<code>remove</code>方法了奥。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//这个单向迭代器只能删除当前获取的元素</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();<br>    checkForComodification();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//在检查完modCount之后,再调用remove方法</span><br>        ArrayList.<span class="hljs-keyword">this</span>.remove(lastRet);<br>        cursor = lastRet;<br>        lastRet = -<span class="hljs-number">1</span>;<br>        expectedModCount = modCount;<br>    &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面是一个使用的小栗子👀</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testRemove</span><span class="hljs-params">()</span></span>&#123;<br>    ArrayList&lt;Integer&gt; t=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    t.add(<span class="hljs-number">1</span>);<br>    t.add(<span class="hljs-number">2</span>);<br>    t.add(<span class="hljs-number">3</span>);<br>    Iterator&lt;Integer&gt; it=t.iterator();<br>    <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>        <span class="hljs-keyword">if</span>(it.next()==<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-comment">//</span><br>            it.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="0x4-小结"><a href="#0x4-小结" class="headerlink" title="0x4 小结"></a>0x4 小结</h2><p>关于ArrayList的源码就分析到这里了,后续如果有什么没想到的应该会补充的奥。👼</p>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ArrayList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>synchronized关键字</title>
    <link href="/2021-06-03/synchronized-keyword.html"/>
    <url>/2021-06-03/synchronized-keyword.html</url>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>Java提供的同步机制有许多，<code>synchronized</code>是其中最经常使用、最万能的机制之一。<br>为了学习<code>synchronized</code>的实现原理，进而了解到<code>monior object</code>模式。在java中<code>synchronized</code>辅助实现了该模式。</p><h1 id="1-monitor机制的起源与定义"><a href="#1-monitor机制的起源与定义" class="headerlink" title="1. monitor机制的起源与定义"></a>1. monitor机制的起源与定义</h1><p>在早期，编写并发程序时使用的同步原语是信号量semaphore与互斥量mutex。程序员需要手动操作信号量的数值与线程的唤醒与挂起，想想这也是一个十分麻烦的工作。所以提出了更高层次的同步机制<code>monitor</code>封装了信号量的操作。但是值得注意的是<code>monitor</code>并未在操作系统层面实现，而是在软件层次完成了这一机制。</p><p>下面描述了<code>monitor</code>机制之所以会出现的一个应用场景（摘自<a href="https://developer.ibm.com/zh/articles/j-lo-synchronized/">探索Java同步机制</a>）：</p><blockquote><p>我们在开发并发的应用时，经常需要设计这样的对象，该对象的方法会在多线程的环境下被调用，而这些方法的执行都会改变该对象本身的状态。为了防止竞争条件 (race condition，等同于死锁) 的出现，对于这类对象的设计，需要考虑解决以下问题：<br>1.在任一时间内，只有唯一的公共的成员方法，被唯一的线程所执行。<br>2.对于<strong>对象的调用者</strong>来说，如果总是需要在调用方法之前进行拿锁，而在调用方法之后进行放锁，这将会使并发应用编程变得更加困难。合理的设计是，该对象本身确保任何针对它的方法请求的会同步并且透明的进行，而<strong>不需要调用者的介入</strong>。<br>3.如果一个对象的方法执行过程中，由于某些条件不能满足而阻塞，应该允许其它的客户端线程的方法调用可以访问该对象。</p></blockquote><p>我们使用 Monitor Object 设计模式来解决这类问题：<strong>将被客户线程并发访问的对象定义为一个 monitor 对象</strong>。客户线程仅仅通过 monitor 对象的同步方法才能使用 monitor 对象定义的服务。为了防止陷入死锁，在任一时刻只能有一个同步方法被执行。每一个monitor对象包含一个 monitor锁，被同步方法用于串行访问对象的行为和状态。此外，同步方法可以根据一个或多个与monitor对象相关的monitor conditions 来决定在何种情况下挂起或恢复他们的执行。</p><p>根据上述定义，monitor object模式分为四个组成部分：</p><ul><li><strong>监视者对象 (Monitor Object):</strong> 负责定义公共的接口方法，这些公共的接口方法会在多线程的环境下被调用执行。</li><li><strong>同步方法：</strong> 这些方法是<strong>监视者对象</strong>所定义。为了防止死锁，无论是否同时有多个线程并发调用同步方法，还是监视者对象含有多个同步方法，在任一时间内只有监视者对象的一个同步方法能够被执行（所谓的同步方法也就是我们经常说的临界区）</li><li><strong>监视锁 (Monitor Lock):</strong> 每一个监视者对象都会拥有一把监视锁。</li><li><strong>监视条件 (Monitor Condition):</strong> 同步方法使用监视锁和监视条件来决定方法是否需要阻塞或重新执行。这里的监视条件可以来自程序本身也可来自monitor object内部。</li></ul><p>这四个部分完成了两个动作：</p><ol><li>线程互斥的进入同步方法</li><li>完成线程的一些调度动作，例如线程的挂起与唤醒</li></ol><h1 id="2-Java中的monitor-object模式"><a href="#2-Java中的monitor-object模式" class="headerlink" title="2. Java中的monitor object模式"></a>2. Java中的monitor object模式</h1><p>按照定义，Java下基于<code>synchronized</code>的<code>monitor object</code>模式也应该由四个部分组成,包括监视者对象、监视锁、监视条件、同步方法（临界区）。那么首先来看看我们一般使用<code>synchronized</code>来实现同步的代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">demo</span></span>&#123;<br>    Object lock=<span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(lock)&#123;<br>            ...<br>        &#125;<br>        ...<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在我看到的大部分资料中，都认为上述代码中的<code>lock</code>对象是监视者对象，监视条件上面没有展示出来，<code>synchronized</code>后跟的代码块就是同步方法。但是这个同步方法并不是在<code>lock</code>所在的类<code>Object</code>中定义的啊，这如何解释？</p><blockquote><p>我的理解是这里的“定义”并不是诸如在类<code>A</code>中定义一个方法<code>test</code>之类的定义，而是规定了某些代码作为同步方法，例如规定字母<code>A</code>代表学校，字母<code>B</code>代表公司之类的将两个事物联系到一起的定义，就像在上面代码中规定了<code>&#123;&#125;</code>中的代码作为<code>lock</code>的同步方法</p></blockquote><p>那么监视锁呢？上面完全没有锁的痕迹。原因是基于<code>monitor object</code>模式的<code>synchronized</code>，监视锁是由监视对象自带的，也被称为<code>intrinsic lock</code>。这个锁在java中是由<code>objectmonitor</code>实现的。</p><p>那么监视者对象、监视锁和线程这三者如何产生联系的呢？这就跟Java中对象的内存布局有关了。在jvm中，任何一个对象都会持有一个对象头用来存储一些对象的信息,下图中是一个对象的内存布局，由对象头、对象数据和填充数据组成。</p><p><img src="images/object_header.png" alt="object memory layout"></p><p>其中对象头由<code>markword</code>和<code>klass pointer</code>组成，如果当前对象是数组，那么在<code>klass pointer</code>后面还会追加数组的长度。</p><p><code>klass point</code>指针指向它的类元数据，用于判断当前对象属于哪个类(Points to another object (a metaobject) which describes the layout and behavior of the original object.)，<code>markword</code>在32位和64位的机器上略有不同，32bit长的<code>markword</code>布局如下所示（图片出自<a href="https://deecyn.com/java-synchronized-and-lock.html">Synchronized与锁</a>）：</p><p><img src="images/32-MarkWord.png" alt="32-markword"></p><p>因为空间有限，所以这32bit是复用的，在不同状态下存储的信息是不同的。对于Java1.6之前的<code>synchronized</code>对应于图中的重量级锁状态（其他三种锁状态在Java1.6后出现），该状态下<code>markword</code>存储了指向了重量级锁的指针，这个重量级锁就是<code>monitor object</code>模式中的监视锁。这个重量级锁是在JVM中通过<code>ObjectMonitor</code>类实现的，<strong>而该类本质上又是基于系统的mutex创建的</strong>。其部分代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectMonitor</span> </span>&#123;<br>...<br>  <span class="hljs-comment">//省略一些代码</span><br>  <span class="hljs-function">bool      <span class="hljs-title">try_enter</span> <span class="hljs-params">(TRAPS)</span> </span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span>      <span class="hljs-title">enter</span><span class="hljs-params">(TRAPS)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span>      <span class="hljs-title">exit</span><span class="hljs-params">(bool not_suspended, TRAPS)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span>      <span class="hljs-title">wait</span><span class="hljs-params">(jlong millis, bool interruptable, TRAPS)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span>      <span class="hljs-title">notify</span><span class="hljs-params">(TRAPS)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span>      <span class="hljs-title">notifyAll</span><span class="hljs-params">(TRAPS)</span></span>;<br>  ...<br><br>  <span class="hljs-comment">// WARNING: this must be the very first word of ObjectMonitor</span><br>  <span class="hljs-comment">// This means this class can&#x27;t use any virtual member functions.</span><br><br>  <span class="hljs-keyword">volatile</span> markOop   _header;       <span class="hljs-comment">// displaced object header word - mark</span><br>  <span class="hljs-keyword">void</span>*     <span class="hljs-keyword">volatile</span> _object;       <span class="hljs-comment">// backward object pointer - strong root</span><br><br>  <span class="hljs-comment">// All the following fields must be machine word aligned</span><br>  <span class="hljs-comment">// The VM assumes write ordering wrt these fields, which can be</span><br>  <span class="hljs-comment">// read from other threads.</span><br><br> <span class="hljs-keyword">protected</span>:                         <span class="hljs-comment">// protected for jvmtiRawMonitor</span><br>  <span class="hljs-keyword">void</span> *  <span class="hljs-keyword">volatile</span> _owner;          <span class="hljs-comment">// pointer to owning thread OR BasicLock</span><br>...<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">int</span> OwnerIsThread ;               <span class="hljs-comment">// _owner is (Thread *) vs SP/BasicLock</span><br>...<br> <span class="hljs-keyword">protected</span>:<br>  ObjectWaiter * <span class="hljs-keyword">volatile</span> _EntryList ;     <span class="hljs-comment">// Threads blocked on entry or reentry.</span><br><br> <span class="hljs-keyword">protected</span>:<br>  ObjectWaiter * <span class="hljs-keyword">volatile</span> _WaitSet; <span class="hljs-comment">// LL of threads wait()ing on the monitor</span><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> _WaitSetLock;        <span class="hljs-comment">// protects Wait Queue - simple spinlock</span><br>  <span class="hljs-comment">//省略一些代码</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中：</p><ul><li><code>_header</code>存储了指向属于<code>monitor object</code>的<code>object header</code>的指针，也就是指向对象头的指针</li><li><code>_object</code>存储了指向<code>monitor object</code>的指针</li><li><code>_owner</code>存储了指向获得监视锁的线程</li><li><code>_EntryList</code>存储了访问同一临界区但是被阻塞的线程集合</li><li><code>_WaitList</code>存储了调用<code>wait()</code>方法主动释放锁的线程集合</li></ul><p>并且<code>ObjectMonitor</code>实现了<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>等方法。</p><p>那么监视对象、监视锁、线程的关系是：监视对象内存存储了监视锁，而监视锁中又存储了获得当前锁的线程。并且由于每个对象都会有对象头，而对象头中自带监视锁，所以Java中任何一个对象都可以用作监视对象，所以<code>wait()</code>、<code>notify()</code>等方法在顶级父类<code>Object</code>中实现。</p><h1 id="3-Java1-6后的synchronized"><a href="#3-Java1-6后的synchronized" class="headerlink" title="3. Java1.6后的synchronized"></a>3. Java1.6后的synchronized</h1><p>因为Java的线程模型采用的是1:1模型，一个Java线程映射到系统的一个线程，所以Java线程的切换、阻塞、唤醒都需要在内核模式中完成，频繁地切换用户模式与内核模式代价非常高（所以<code>synchronzied</code>被称为重锁）。那么如果同步区非常短，执行同步区的时间比切换内核模式的时间还短，程序的效率就比较低了。所以在Java1.6之后，<code>synchronzied</code>进行了大量优化。对于<code>synchronized</code>，不会再一开始就使用<code>objectMonitor</code>完成同步。而是根据线程对锁的竞争程度不断升级获取锁的难度。</p><p>升级后的<code>synchronized</code>分为四个阶段：无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁。这四个状态通过<code>markword</code>中的两位标记来区分，再次搬出32位下的<code>markword</code>结构图：</p><p><img src="images/32-MarkWord.png" alt="32-markword"></p><p>可以看到，偏向锁和无锁状态的锁标志位都是<code>01</code>，他们是通过1bit的标志位来区分。</p><p>同时JVM会使用<code>Lock Record</code>在线程中保存锁的一些信息，其组成如下所示：<br><img src="images/lock-record.png" alt="lock record"></p><p>其中：</p><ul><li><code>displaced hdr(displaced markword)</code>:一般用来保存<code>monitor object</code>对象头中的<code>markword</code>信息副本</li><li><code>owner</code>：指向<code>monitor object</code>的指针。</li></ul><p>在三种锁状态中，都会使用<code>Lock Record</code>。但是在偏向锁状态中并不会使用<code>Lock Record</code>的<code>displaced markword</code>。</p><h2 id="3-1-偏向锁"><a href="#3-1-偏向锁" class="headerlink" title="3.1 偏向锁"></a>3.1 偏向锁</h2><p>偏向锁，将锁的归属权偏向给第一个获得该锁的线程。说人话，就是如果有一个线程threadA第一次成功获得了偏向锁lock，那么lock默认认为以后能够成功获得锁的线程都会是线程A。</p><blockquote><p>注意：“偏向第一个获得该锁的线程”并不是指在偏向锁的生命周期内只会有一个线程获得锁。<br>比如在最开始，threadA获得了偏向锁lock，此时lock偏向threadA。使用完毕后，threadB请求lock。虽然lock发现此时请求的线程不是threadA，但是由于此时没有发生竞争，所以lock重新设置其偏向的线程为threadB。<strong>而不是说从头到尾lock都只偏向threadA。</strong></p></blockquote><p> 偏向锁的使用场景是同步区只被同一个线程访问。那么在使用偏向锁时<del>只会在第一次申请时</del>，使用CAS将<code>markword</code>中的线程ID（默认为0，表示匿名偏向状态）替换为当前获得锁的线程ID（当然如果不停地出现新线程成功获取锁的情况，那么每次新线程都会使用CAS替换ThreadID。但是并不是简单的替换而已，JVM同时也会在当前线程的<code>Lock Record</code>列表中插入一个<code>Lock Record</code>结构。</p><h3 id="3-1-1-偏向锁的获取流程"><a href="#3-1-1-偏向锁的获取流程" class="headerlink" title="3.1.1 偏向锁的获取流程"></a>3.1.1 偏向锁的获取流程</h3><p>下图中是偏向锁的工作流程：</p><p><img src="images/biased-lock.jpg" alt="biased-lock"></p><p>偏向锁的<strong>开启</strong>需要锁对象头开启以及klass属性头开启才算，单方面无法进入重偏向。其中有几点需要注意，在一个线程每次成功获取偏向锁时，<strong>会在当前线程的<code>Lock Record</code>队列中插入一个<code>Lock Record(LR)</code></strong>,并且设置新插入LR中的owner指向当前监视器对象（monitor object），具体的实现代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//代码分析摘自：Synchronized 源码分析（http://itliusir.com/2019/11-Synchronized/）</span><br><span class="hljs-comment">//源码地址：http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1816</span><br><br>CASE(_monitorenter): &#123;<br>  oop lockee = STACK_OBJECT(-<span class="hljs-number">1</span>);<br>  CHECK_NULL(lockee);<br>  <span class="hljs-comment">// 寻找空闲的锁记录(Lock Record) 空间</span><br>  BasicObjectLock* limit = istate-&gt;monitor_base();<br>  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();<br>  BasicObjectLock* entry = NULL;<br>  <span class="hljs-keyword">while</span> (most_recent != limit ) &#123;<br>  <span class="hljs-keyword">if</span> (most_recent-&gt;obj() == NULL) entry = most_recent;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (most_recent-&gt;obj() == lockee) <span class="hljs-keyword">break</span>;<br>  most_recent++;<br>  &#125;<br>  <span class="hljs-comment">// 存在空闲的Lock Record</span><br>  <span class="hljs-keyword">if</span> (entry != NULL) &#123;<br>    <span class="hljs-comment">/***********************************/</span><br>    <span class="hljs-comment">// 设置Lock Record 的 obj指针(owner)指向锁对象(monitor object)</span><br>    <span class="hljs-comment">//无论是轻量锁还是偏向锁都会设置这个指针</span><br>    <span class="hljs-comment">//这句代码完成了线程每次获取锁时向LR集合中插入新LR的动作</span><br>    entry-&gt;set_obj(lockee);<br>    <span class="hljs-comment">/***********************************/</span><br><br>    <span class="hljs-keyword">int</span> success = <span class="hljs-keyword">false</span>;<br>    uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;<br>    markOop mark = lockee-&gt;mark();<br>    intptr_t hash = (intptr_t) markOopDesc::no_hash;<br><br>    <span class="hljs-comment">/*****************************************************/</span><br>    <span class="hljs-comment">// 如果锁对象的对象头标志是偏向模式,即判断锁标志为101</span><br><br>    <span class="hljs-keyword">if</span> (mark-&gt;has_bias_pattern()) &#123;<br>      uintptr_t thread_ident;<br>      uintptr_t anticipated_bias_locking_value;<br>      thread_ident = (uintptr_t)istate-&gt;thread();<br>      <span class="hljs-comment">// 通过或运算计算anticipated_bias_locking_value</span><br>      anticipated_bias_locking_value =<br>      <span class="hljs-comment">// 将线程id与prototype_header(epoch、分代年龄、偏向模式、锁标志)部分相或</span><br>      (((uintptr_t)lockee-&gt;klass()-&gt;prototype_header() | thread_ident) <br>      <span class="hljs-comment">// 与锁对象的markword异或，相等为0</span><br>          ^ (uintptr_t)mark) <br>      <span class="hljs-comment">// 将上面结果中的分代年龄忽略掉</span><br>      &amp;~((uintptr_t) markOopDesc::age_mask_in_place);<br>      <span class="hljs-comment">// ① 为0代表偏向线程是当前线程 且 对象头的epoch与class的epoch相等，什么也不做</span><br>      <span class="hljs-keyword">if</span>  (anticipated_bias_locking_value == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (PrintBiasedLockingStatistics) &#123;<br>          (* BiasedLocking::biased_lock_entry_count_addr())++;<br>        &#125;<br>        success = <span class="hljs-keyword">true</span>;<br>      &#125;<br>      <span class="hljs-comment">// ② 代表class的prototype_header或对象的mark word中偏向模式是关闭的</span><br>      <span class="hljs-comment">//又因为能走到这已经通过了mark-&gt;has_bias_pattern()判断</span><br>      <span class="hljs-comment">//即对象的mark word中偏向模式是开启的，那也就是说class的prototype_header不是偏向模式。</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// try revoke bias</span><br>        markOop header = lockee-&gt;klass()-&gt;prototype_header();<br>        <span class="hljs-keyword">if</span> (hash != markOopDesc::no_hash) &#123;<br>            header = header-&gt;copy_set_hash(hash);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), mark) == mark) &#123;<br>          <span class="hljs-keyword">if</span> (PrintBiasedLockingStatistics)<br>            (*BiasedLocking::revoked_lock_entry_count_addr())++;<br>        &#125;<br>      &#125;<br><br>        <span class="hljs-comment">/*****************************************************/</span><br>        <span class="hljs-comment">// ③ 锁对象头的 epoch 与 class 的 epoch 不相等，尝试重偏向</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((anticipated_bias_locking_value &amp; epoch_mask_in_place) !=<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// try rebias</span><br>        markOop new_header = (markOop) ( (intptr_t) lockee-&gt;klass()-&gt;prototype_header() | thread_ident);<br>        <span class="hljs-keyword">if</span> (hash != markOopDesc::no_hash) &#123;<br>          new_header = new_header-&gt;copy_set_hash(hash);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Atomic::cmpxchg_ptr((<span class="hljs-keyword">void</span>*)new_header, lockee-&gt;mark_addr(), mark) == mark) &#123;<br>          <span class="hljs-keyword">if</span> (PrintBiasedLockingStatistics)<br>          (* BiasedLocking::rebiased_lock_entry_count_addr())++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 有竞争重偏向失败，调用 monitorenter 锁升级</span><br>          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);<br>        &#125;<br>        success = <span class="hljs-keyword">true</span>;<br>      &#125;<br><br>      <span class="hljs-comment">/*****************************************************/</span><br>      <span class="hljs-comment">// ④ 未偏向任何线程或者偏向的不是当前线程，尝试重新偏向</span><br>      <span class="hljs-keyword">else</span> &#123;<br>        markOop header = (markOop) ((uintptr_t) mark &amp; ((uintptr_t)markOopDesc::biased_lock_mask_in_place |<br>                                                        (uintptr_t)markOopDesc::age_mask_in_place |<br>                                                        epoch_mask_in_place));<br>        <span class="hljs-keyword">if</span> (hash != markOopDesc::no_hash) &#123;<br>            header = header-&gt;copy_set_hash(hash);<br>        &#125;<br>        markOop new_header = (markOop) ((uintptr_t) header | thread_ident);<br>        <span class="hljs-comment">// debugging hint</span><br>        DEBUG_ONLY(entry-&gt;lock()-&gt;set_displaced_header((markOop) (uintptr_t) <span class="hljs-number">0xdeaddead</span>);)<br>        <span class="hljs-comment">// CAS 尝试修改</span><br>        <span class="hljs-keyword">if</span> (Atomic::cmpxchg_ptr((<span class="hljs-keyword">void</span>*)new_header, lockee-&gt;mark_addr(), header) == header) &#123;<br>            <span class="hljs-keyword">if</span> (PrintBiasedLockingStatistics)<br>            (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;<br>        &#125;<br>        <span class="hljs-comment">// 有竞争偏向失败，调用 monitorenter 锁升级</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);<br>        &#125;<br>        success = <span class="hljs-keyword">true</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*****************************************************/</span><br>    <span class="hljs-comment">//能走到这说明当前没有开启偏向模式，而不可能出现偏向的不是当前线程的情况</span><br>    <span class="hljs-comment">//那么就走轻量锁的逻辑</span><br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>      <span class="hljs-comment">// 轻量级锁逻辑 start</span><br>      <span class="hljs-comment">// 构造无锁状态 Mark Word 的 copy(Displaced Mark Word)</span><br><br>      <span class="hljs-comment">/**************************************************/</span><br>      <span class="hljs-comment">//如果是第一次获取轻量锁，那么mark()-&gt;set_unlocked()</span><br>      <span class="hljs-comment">//lockee中的markword期望值最后两位必是01（无锁或偏向锁），所以一定会CAS成功</span><br>      markOop displaced = lockee-&gt;mark()-&gt;set_unlocked();<br>      <span class="hljs-comment">/*************************************************/</span><br>      <br>      <span class="hljs-comment">// 将锁记录空间(Lock Record)指向Displaced Mark Word</span><br>      entry-&gt;lock()-&gt;set_displaced_header(displaced);<br>      <span class="hljs-comment">// 是否禁用偏向锁和轻量级锁</span><br>      bool call_vm = UseHeavyMonitors;<br>      <span class="hljs-keyword">if</span> (call_vm || Atomic::cmpxchg_ptr(entry, lockee-&gt;mark_addr(), displaced) != displaced) &#123;<br>        <span class="hljs-comment">// 判断是不是锁重入，是的话把Displaced Mark Word设置为null来表示重入</span><br>        <span class="hljs-comment">// 置null的原因是因为要记录重入次数，但是mark word大小有限，所以每次重入都在栈帧中新增一个Displaced Mark Word为null的记录</span><br>        <span class="hljs-keyword">if</span> (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced-&gt;clear_lock_bits())) &#123;<br>          entry-&gt;lock()-&gt;set_displaced_header(NULL);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 若禁用则锁升级</span><br>          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);<br>        &#125;<br>      &#125;<br>    &#125;<br>    UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br>  &#125; <br>  <span class="hljs-keyword">else</span> &#123;<br>    istate-&gt;set_msg(more_monitors);<br>    UPDATE_PC_AND_RETURN(<span class="hljs-number">0</span>); <span class="hljs-comment">// Re-execute</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>对偏向锁的获取流程总结如下：</strong></p><ol><li><p>如果当前线程有空闲的LockRecord（LR），那么设置当前使用的LR的<code>owner</code>指针指向当前<code>monitor object</code>（也就相当于添加了一个新的LR到当前线程中）</p></li><li><p>检查monitor object是否处于可偏向状态（在开启偏向锁后，markword中的锁标志默认为可偏向状态，如果存储的线程ID为0，则称其为匿名可偏向状态）</p></li><li><p>如果处于可偏向状态，检查偏向锁偏向的线程是否为当前线程，如果是，那么则执行（6），否则执行（4）</p></li><li><p>如果偏向模式被关闭，那么执行（8）</p></li><li><p>对偏向锁设置重偏向，如果成功，那么则执行（7），否则产生竞争，执行（8）</p></li><li><p>对偏向锁第一次设置偏向线程，如果成功，那么则执行（7），否则产生竞争，执行（8）</p></li><li><p>执行临界区代码</p></li><li><p>进行一系列判断，决定是否能够保留偏向锁，或者升级为轻量级锁</p></li></ol><h3 id="3-1-2-偏向锁的撤销流程"><a href="#3-1-2-偏向锁的撤销流程" class="headerlink" title="3.1.2 偏向锁的撤销流程"></a>3.1.2 偏向锁的撤销流程</h3><p>对于偏向锁获取流程中第（8）步的判断，其执行的检查十分复杂，调用链如下：</p><p>InterpreterRuntime::monitorenter –&gt; ObjectSynchronizer::fast_enter –&gt; BiasedLocking::revoke_and_rebias –&gt; (safepoint调用)BiasedLocking::revoke_bias</p><p>我们着重分析<code>revoke_and_rebias</code>与<code>revoke_bias</code></p><p><code>revoke_bias</code>的部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//源码链接:http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/runtime/biasedLocking.cpp#l146</span><br><span class="hljs-keyword">static</span> BiasedLocking::<span class="hljs-function">Condition <span class="hljs-title">revoke_bias</span><span class="hljs-params">(oop obj, bool allow_rebias, bool is_bulk, JavaThread* requesting_thread)</span> </span>&#123;<br>  markOop mark = obj-&gt;mark();<br>  <span class="hljs-comment">// 如果对象不是偏向锁，直接返回 NOT_BIASED</span><br>  <span class="hljs-keyword">if</span> (!mark-&gt;has_bias_pattern()) &#123;<br>    ...<br>    <span class="hljs-keyword">return</span> BiasedLocking::NOT_BIASED;<br>  &#125;<br><br>  uint age = mark-&gt;age();<br>  <span class="hljs-comment">// 构建两个 mark word，一个是匿名偏向模式（101），一个是无锁模式（001）</span><br>  markOop   biased_prototype = markOopDesc::biased_locking_prototype()-&gt;set_age(age);<br>  markOop unbiased_prototype = markOopDesc::prototype()-&gt;set_age(age);<br><br>  ...<br><br>  JavaThread* biased_thread = mark-&gt;biased_locker();<br>  <span class="hljs-keyword">if</span> (biased_thread == NULL) &#123;<br>     <span class="hljs-comment">// 匿名偏向。当调用锁对象原始的 hashcode() 方法会走到这个逻辑</span><br>     <span class="hljs-comment">// 如果不允许重偏向，则将对象的 mark word 设置为无锁模式</span><br>    <span class="hljs-keyword">if</span> (!allow_rebias) &#123;<br>      obj-&gt;set_mark(unbiased_prototype);<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">return</span> BiasedLocking::BIAS_REVOKED;<br>  &#125;<br><br>  <span class="hljs-comment">// 判断偏向线程是否还存活</span><br>  bool thread_is_alive = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-comment">// 如果当前线程就是偏向线程 </span><br>  <span class="hljs-keyword">if</span> (requesting_thread == biased_thread) &#123;<br>    thread_is_alive = <span class="hljs-keyword">true</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-comment">// 遍历当前 jvm 的所有线程，如果能找到，则说明偏向的线程还存活</span><br>    <span class="hljs-keyword">for</span> (JavaThread* cur_thread = Threads::first(); cur_thread != NULL; cur_thread = cur_thread-&gt;next()) &#123;<br>      <span class="hljs-keyword">if</span> (cur_thread == biased_thread) &#123;<br>        thread_is_alive = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 如果偏向的线程已经不存活了</span><br>  <span class="hljs-keyword">if</span> (!thread_is_alive) &#123;<br>    <span class="hljs-comment">// 如果允许重偏向，则将对象 mark word 设置为匿名偏向状态，否则设置为无锁状态</span><br>    <span class="hljs-keyword">if</span> (allow_rebias) &#123;<br>      obj-&gt;set_mark(biased_prototype);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      obj-&gt;set_mark(unbiased_prototype);<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">return</span> BiasedLocking::BIAS_REVOKED;<br>  &#125;<br><br>  <span class="hljs-comment">// 线程还存活则遍历线程栈中所有的 lock record</span><br>  GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(biased_thread);<br>  BasicLock* highest_lock = NULL;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cached_monitor_info-&gt;length(); i++) &#123;<br>    MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);<br>    <span class="hljs-comment">// 如果能找到对应的 lock record，说明偏向所有者正在持有锁</span><br>    <span class="hljs-keyword">if</span> (mon_info-&gt;owner() == obj) &#123;<br>      ...<br>      <span class="hljs-comment">// 升级为轻量级锁，修改栈中所有关联该锁的 lock record</span><br>      <span class="hljs-comment">// 先处理所有锁重入的情况，轻量级锁的 displaced mark word 为 NULL，表示锁重入</span><br>      markOop mark = markOopDesc::encode((BasicLock*) NULL);<br>      highest_lock = mon_info-&gt;lock();<br>      highest_lock-&gt;set_displaced_header(mark);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      ...<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (highest_lock != NULL) &#123; <br>    <span class="hljs-comment">// highest_lock 如果非空，则它是最早关联该锁的 lock record</span><br>    <span class="hljs-comment">// 这个 lock record 是线程彻底退出该锁的最后一个 lock record</span><br>  <br>    <span class="hljs-comment">//关闭偏向模式，这样后面的线程再次抢锁时直接走轻量锁流程</span><br>    highest_lock-&gt;set_displaced_header(unbiased_prototype);<br>    <span class="hljs-comment">//设置锁对象的markword指向displaced header</span><br>    obj-&gt;release_set_mark(markOopDesc::encode(highest_lock));<br>    ...<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 走到这里说明偏向所有者没有正在持有锁</span><br>    ...<br>    <span class="hljs-keyword">if</span> (allow_rebias) &#123;<br>       <span class="hljs-comment">// 设置为匿名偏向状态</span><br>      obj-&gt;set_mark(biased_prototype);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 将 mark word 设置为无锁状态</span><br>      obj-&gt;set_mark(unbiased_prototype);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> BiasedLocking::BIAS_REVOKED;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述代码中只有一点需要注意：在判断线程是否处于同步状态时，遍历的<code>Lock Record</code>正是线程在获取锁时添加到线程中的只有<code>owner</code>指针的<code>Lock Record</code>。</p><ol><li><p>所以当偏向锁产生锁的竞争时，JVM会首先JVM中所有存活的线程中是否存在偏向锁偏向的线程。如果存在，执行（2），否则执行（4）</p></li><li><p>判断偏向锁偏向的线程当前是否处于同步区，这通过遍历目标线程的<code>Lock Record</code>集合实现（为什么能这么做呢？这跟偏向锁的释放有关，见后文）。如果处于同步区，则执行（3），否则执行（4）</p></li><li><p>将最先关联到线程的<code>Lock Record</code>结构中的<code>Displace markword</code>设置为无锁模式，然后将monitor object对象头的markdown设置为指向<code>Displace markword</code>的指针（处于safepoint，所有线程终止）。至此，完成轻量锁的升级。注意，此时轻量锁的归属权仍然属于原来获得偏向锁的线程</p></li><li><p>如果开启可重偏向，那么则将monitor object对象的markword设置为匿名偏向模式，否则执行（5）</p></li><li><p>将将monitor object对象头的markword设置为无锁模式</p></li></ol><h3 id="3-1-3-偏向锁的释放流程"><a href="#3-1-3-偏向锁的释放流程" class="headerlink" title="3.1.3 偏向锁的释放流程"></a>3.1.3 偏向锁的释放流程</h3><p>偏向锁的释放流程比较简单，只是简单地把添加到线程<code>LockRecord</code>列表中的<code>Lock Record</code>删除，当然这里仅是逻辑删除，将<code>Lock Record</code>的owner指针设为null即可。实现源码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//代码来自：http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1923</span><br>CASE(_monitorexit): &#123;<br>  oop lockee = STACK_OBJECT(-<span class="hljs-number">1</span>);<br>  CHECK_NULL(lockee);<br>  <span class="hljs-comment">// derefing&#x27;s lockee ought to provoke implicit null check</span><br>  <span class="hljs-comment">// find our monitor slot</span><br>  BasicObjectLock* limit = istate-&gt;monitor_base();<br>  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();<br>  <span class="hljs-comment">// 从低往高遍历栈的Lock Record</span><br>  <span class="hljs-keyword">while</span> (most_recent != limit ) &#123;<br>    <span class="hljs-comment">// 如果Lock Record关联的是该锁对象</span><br>    <span class="hljs-keyword">if</span> ((most_recent)-&gt;obj() == lockee) &#123;<br>      BasicLock* lock = most_recent-&gt;lock();<br>      markOop header = lock-&gt;displaced_header();<br>      <span class="hljs-comment">// 释放Lock Record</span><br>      most_recent-&gt;set_obj(NULL);<br>      <span class="hljs-comment">// 如果是偏向模式，仅仅释放Lock Record就好了。否则要走轻量级锁or重量级锁的释放流程</span><br>      <span class="hljs-keyword">if</span> (!lockee-&gt;mark()-&gt;has_bias_pattern()) &#123;<br>        bool call_vm = UseHeavyMonitors;<br>        <span class="hljs-comment">// header!=NULL说明不是重入，则需要将Displaced Mark Word CAS到对象头的Mark Word</span><br>        <span class="hljs-keyword">if</span> (header != NULL || call_vm) &#123;<br>          <span class="hljs-keyword">if</span> (call_vm || Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), lock) != lock) &#123;<br>            <span class="hljs-comment">// CAS失败或者是重量级锁则会走到这里，先将obj还原，然后调用monitorexit方法</span><br>            most_recent-&gt;set_obj(lockee);<br>            CALL_VM(InterpreterRuntime::monitorexit(THREAD, most_recent), handle_exception);<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">//执行下一条命令</span><br>      UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//处理下一条Lock Record</span><br>    most_recent++;<br>  &#125;<br>  <span class="hljs-comment">// Need to throw illegal monitor state exception</span><br>  CALL_VM(InterpreterRuntime::throw_illegal_monitor_state_exception(THREAD), handle_exception);<br>  ShouldNotReachHere();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于偏向锁，代码从低往高的遍历<code>Lock Record</code>，因为加进去的时候就是按照从高往低加入的。它将当前遍历的<code>Lock Record</code>中的owner指针都置为null，表示当前线程释放了偏向锁。这也就是为什么在偏向锁撤销的过程中，通过查看线程中的<code>Lock Record</code>的owner指针是否指向monitor object就能判断当前持有偏向锁的线程是否处于同步区。因为如果不处于同步区，线程肯定会释放将owner置为null偏向锁。</p><h3 id="3-1-4-批量重偏向与撤销"><a href="#3-1-4-批量重偏向与撤销" class="headerlink" title="3.1.4 批量重偏向与撤销"></a>3.1.4 批量重偏向与撤销</h3><p>批量重偏向是指对于大量来自同一个类的锁对象，如果频繁的对这个类的锁对象进行重偏向操作（<strong>在偏向锁模式下抢锁失败才会对重偏向次数计数</strong>），撤销偏向锁的代价也是不能被忽略的。所以如果对一个类的偏向锁撤销次数达到二十次。那么后续使用这种锁的线程都会直接重偏向到目标线程，略去了恢复到匿名偏向状态的过程，这叫<strong>批量重偏向</strong>。</p><p>如果在批量重偏向的基础上，还在对这个这个类的锁对象进行重偏向或者升级锁的操作，重偏向达到40次（20+20）。那么以后这个类生成的锁对象就再也不会有作为偏向锁的机会，直接关闭偏向选项（这叫<strong>批量撤销</strong>，后续新生成的锁对象再不也能作为偏向锁），也就是说批量重偏向只有一次机会。但是如果总的重偏向次数在20次到40次之间，那么经过一段时间，该类的重偏向计数会归为0。之后重复上述的操作。</p><p>那么上述两个操作是如何实现的呢？其实它们是基于Class对象和锁对象头中<code>markword</code>字段中的<code>epoch</code>属性。</p><p>批量重偏向操作开启后，对类C的epcho值加1，以后这个类新生成的对象的mark字段里就是这个epoch值了，同时还要对当前已经获得偏向锁的对象的epoch值加1(通过遍历所有线程中的<code>Lock Record</code>字段中的<code>displace markword</code>并+1)。那么以后有线程再竞争类C的锁对象时，如果有锁对象.epoch!=Class.epoch。说明该锁对象的epoch字段没有更改，也就是说在对epoch+1时，该锁对象没有被使用。竞争这种锁时直接使用CAS替换threadID进行重偏向，，不走撤销这一步。</p><blockquote><p>所以我个人认为，批量重偏向只适用于那些没有被统一修改epoch字段的锁对象</p></blockquote><p>具体的函数调用链为：InterpreterRuntime::monitorenter –&gt; ObjectSynchronizer::fast_enter –&gt; BiasedLocking::revoke_and_rebias –&gt;update_heuristics。下面代码片段是对批量偏向和批量撤销前的阈值判断。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> HeuristicsResult <span class="hljs-title">update_heuristics</span><span class="hljs-params">(oop o, bool allow_rebias)</span> </span>&#123;<br>  markOop mark = o-&gt;mark();<br>  <span class="hljs-comment">// 如果不是偏向模式直接返回</span><br>  <span class="hljs-keyword">if</span> (!mark-&gt;has_bias_pattern()) &#123;<br>    <span class="hljs-keyword">return</span> HR_NOT_BIASED;<br>  &#125;<br> <br>  <span class="hljs-comment">// 获取锁对象的类元数据</span><br>  Klass* k = o-&gt;klass();<br>  <span class="hljs-comment">// 当前时间</span><br>  jlong cur_time = os::javaTimeMillis();<br>  <span class="hljs-comment">// 该类上一次批量重偏向的时间</span><br>  jlong last_bulk_revocation_time = k-&gt;last_biased_lock_bulk_revocation_time();<br>  <span class="hljs-comment">// 该类单个偏向撤销的计数</span><br>  <span class="hljs-keyword">int</span> revocation_count = k-&gt;biased_lock_revocation_count();<br><br>  <span class="hljs-comment">// 按默认参数来说：</span><br>  <span class="hljs-comment">// 如果撤销计数大于等于 20，且小于 40，</span><br>  <span class="hljs-comment">// 且距上次批量撤销的时间大于等于 25 秒，就会重置计数。</span><br>  <span class="hljs-keyword">if</span> ((revocation_count &gt;= BiasedLockingBulkRebiasThreshold) &amp;&amp;<br>      (revocation_count &lt;  BiasedLockingBulkRevokeThreshold) &amp;&amp;<br>      (last_bulk_revocation_time != <span class="hljs-number">0</span>) &amp;&amp;<br>      (cur_time - last_bulk_revocation_time &gt;= BiasedLockingDecayTime)) &#123;<br>    <span class="hljs-comment">// This is the first revocation we&#x27;ve seen in a while of an</span><br>    <span class="hljs-comment">// object of this type since the last time we performed a bulk</span><br>    <span class="hljs-comment">// rebiasing operation. The application is allocating objects in</span><br>    <span class="hljs-comment">// bulk which are biased toward a thread and then handing them</span><br>    <span class="hljs-comment">// off to another thread. We can cope with this allocation</span><br>    <span class="hljs-comment">// pattern via the bulk rebiasing mechanism so we reset the</span><br>    <span class="hljs-comment">// klass&#x27;s revocation count rather than allow it to increase</span><br>    <span class="hljs-comment">// monotonically. If we see the need to perform another bulk</span><br>    <span class="hljs-comment">// rebias operation later, we will, and if subsequently we see</span><br>    <span class="hljs-comment">// many more revocation operations in a short period of time we</span><br>    <span class="hljs-comment">// will completely disable biasing for this type.</span><br>    k-&gt;set_biased_lock_revocation_count(<span class="hljs-number">0</span>);<br>    revocation_count = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (revocation_count &lt;= BiasedLockingBulkRevokeThreshold) &#123;<br>    <span class="hljs-comment">// 自增计数</span><br>    revocation_count = k-&gt;atomic_incr_biased_lock_revocation_count();<br>  &#125;<br>  <span class="hljs-comment">// 此时，如果达到批量撤销阈值，则进行批量撤销。</span><br>  <span class="hljs-keyword">if</span> (revocation_count == BiasedLockingBulkRevokeThreshold) &#123;<br>    <span class="hljs-keyword">return</span> HR_BULK_REVOKE;<br>  &#125;<br>  <span class="hljs-comment">// 此时，如果达到批量重偏向阈值，则进行批量重偏向。</span><br>  <span class="hljs-keyword">if</span> (revocation_count == BiasedLockingBulkRebiasThreshold) &#123;<br>    <span class="hljs-keyword">return</span> HR_BULK_REBIAS;<br>  &#125;<br>  <span class="hljs-comment">// 否则，仅进行单个对象的撤销偏向</span><br>  <span class="hljs-keyword">return</span> HR_SINGLE_REVOKE;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="3-2-轻量锁"><a href="#3-2-轻量锁" class="headerlink" title="3.2 轻量锁"></a>3.2 轻量锁</h2><p>轻量锁是代价比偏向锁稍高的轻量级的锁。那么轻量锁和偏向锁的区别在哪呢？我认为有以下两点：</p><ol><li><p>偏向锁只需要在第一次请求锁使用CAS设置ThreadID，而轻量锁需要在每次请求锁时都使用CAS修改markword</p></li><li><p>偏向锁只适用于一个线程进入临界区，轻量锁适用于多个线程交替地进入临界区（交替是指不会发生争夺锁的冲突）</p></li></ol><h3 id="3-2-1-轻量锁的申请流程"><a href="#3-2-1-轻量锁的申请流程" class="headerlink" title="3.2.1 轻量锁的申请流程"></a>3.2.1 轻量锁的申请流程</h3><p>轻量锁的获取流程比较简单，假设现在有线程A，监视锁lock。</p><p>JVM会在线程A的<code>Lock Record</code>列表中添加一个<code>Lock Record</code>结构。并将其<code>displaced hdr</code>设置为<code>markword</code>无锁状态时的内容。同时JVM会将lock对象的<code>markword</code>修改为指向刚添加的<code>Lock Record</code>的指针。</p><p><strong>并且并且并且，lock的<code>markword</code>最后两位为<code>00</code>，表示轻量锁状态。</strong> 结构如下所示：</p><p><img src="images/light-lock.png" alt="light-lock"></p><p>在具体的JVM中，轻量锁的来源有两处：</p><ol><li>通过偏向锁升级而来</li><li>关闭偏向模式</li></ol><p>这二者的实现方式和偏向锁的获取都在同一个源文件中：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//代码分析摘自：Synchronized 源码分析（http://itliusir.com/2019/11-Synchronized/）</span><br><span class="hljs-comment">//源码地址：http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1816</span><br><br>CASE(_monitorenter): &#123;<br>  oop lockee = STACK_OBJECT(-<span class="hljs-number">1</span>);<br>  CHECK_NULL(lockee);<br>  <span class="hljs-comment">// 寻找空闲的锁记录(Lock Record) 空间</span><br>  BasicObjectLock* limit = istate-&gt;monitor_base();<br>  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();<br>  BasicObjectLock* entry = NULL;<br>  <span class="hljs-keyword">while</span> (most_recent != limit ) &#123;<br>    <span class="hljs-keyword">if</span> (most_recent-&gt;obj() == NULL) entry = most_recent;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (most_recent-&gt;obj() == lockee) <span class="hljs-keyword">break</span>;<br>    most_recent++;<br>  &#125;<br>  <span class="hljs-comment">// 存在空闲的Lock Record</span><br>  <span class="hljs-keyword">if</span> (entry != NULL) &#123;<br>    <span class="hljs-comment">/***********************************/</span><br>    <span class="hljs-comment">// 设置Lock Record 的 obj指针(owner)指向锁对象(monitor object)</span><br>    <span class="hljs-comment">//这句代码完成了线程每次获取锁时向LR集合中插入新LR的动作</span><br>    entry-&gt;set_obj(lockee);<br>    <span class="hljs-comment">/***********************************/</span><br><br>    <span class="hljs-keyword">int</span> success = <span class="hljs-keyword">false</span>;<br>    uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;<br>    markOop mark = lockee-&gt;mark();<br>    intptr_t hash = (intptr_t) markOopDesc::no_hash;<br><br>    <span class="hljs-comment">/*****************************************************/</span><br>    <span class="hljs-comment">// 如果锁对象的对象头标志是偏向模式(1 01)</span><br>    <span class="hljs-keyword">if</span> (mark-&gt;has_bias_pattern()) &#123;<br>      uintptr_t thread_ident;<br>      uintptr_t anticipated_bias_locking_value;<br>      thread_ident = (uintptr_t)istate-&gt;thread();<br>      <span class="hljs-comment">// 通过位运算计算anticipated_bias_locking_value</span><br>      anticipated_bias_locking_value =<br>        <span class="hljs-comment">// 将线程id与prototype_header(epoch、分代年龄、偏向模式、锁标志)部分相或</span><br>        (((uintptr_t)lockee-&gt;klass()-&gt;prototype_header() | thread_ident) <br>        <span class="hljs-comment">// 与锁对象的markword异或，相等为0</span><br>         ^ (uintptr_t)mark) <br>        <span class="hljs-comment">// 将上面结果中的分代年龄忽略掉</span><br>        &amp;~((uintptr_t) markOopDesc::age_mask_in_place);<br>        <span class="hljs-comment">// ① 为0代表偏向线程是当前线程 且 对象头的epoch与class的epoch相等，什么也不做</span><br>        ...<br>      <span class="hljs-comment">// ② 偏向模式关闭，则尝试撤销(0 01)</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// try revoke bias</span><br>        markOop header = lockee-&gt;klass()-&gt;prototype_header();<br>        <span class="hljs-keyword">if</span> (hash != markOopDesc::no_hash) &#123;<br>          header = header-&gt;copy_set_hash(hash);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), mark) == mark) &#123;<br>          <span class="hljs-keyword">if</span> (PrintBiasedLockingStatistics)<br>            (*BiasedLocking::revoked_lock_entry_count_addr())++;<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-comment">/*****************************************************/</span><br>      <span class="hljs-comment">// ③ 锁对象头的 epoch 与 class 的 epoch 不相等，尝试重偏向</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((anticipated_bias_locking_value &amp; epoch_mask_in_place) !=<span class="hljs-number">0</span>) &#123;<br>        ...<br>        <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 有竞争重偏向失败，调用 monitorenter 锁升级</span><br>          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);<br>        &#125;<br>        success = <span class="hljs-keyword">true</span>;<br>      &#125;<br><br>      <span class="hljs-comment">/*****************************************************/</span><br>      <span class="hljs-comment">// ④ 未偏向任何线程，尝试偏向</span><br>      <span class="hljs-keyword">else</span> &#123;<br>        markOop header = (markOop) ((uintptr_t) mark &amp; ((uintptr_t)markOopDesc::biased_lock_mask_in_place |<br>                                                        (uintptr_t)markOopDesc::age_mask_in_place |<br>                                                        epoch_mask_in_place));<br>        ...<br>        <span class="hljs-comment">// 有竞争偏向失败，调用 monitorenter 锁升级</span><br>        <span class="hljs-keyword">else</span> &#123;<br>          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);<br>        &#125;<br>        success = <span class="hljs-keyword">true</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*****************************************************/</span><br>    <span class="hljs-comment">// 走到这里说明没有开启偏向锁等原因</span><br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>      <span class="hljs-comment">// 轻量级锁逻辑 start</span><br>      <span class="hljs-comment">// 构造无锁状态 Mark Word 的 copy(Displaced Mark Word)</span><br>      <span class="hljs-comment">// 注意displaced markword是无锁状态!无锁状态!无锁状态！</span><br>      markOop displaced = lockee-&gt;mark()-&gt;set_unlocked();<br>      <span class="hljs-comment">// 将锁记录空间(Lock Record)的Displaced Mark Word设为无锁状态markword</span><br>      entry-&gt;lock()-&gt;set_displaced_header(displaced);<br>      <span class="hljs-comment">// 是否禁用偏向锁和轻量级锁</span><br>      bool call_vm = UseHeavyMonitors;<br>      <span class="hljs-comment">// exchange ,addr,compare</span><br>      <span class="hljs-comment">//return compare value</span><br>      <span class="hljs-keyword">if</span> (call_vm || Atomic::cmpxchg_ptr(entry, lockee-&gt;mark_addr(), displaced) != displaced) &#123;<br>        <span class="hljs-comment">// 判断是不是锁重入，是的话把Displaced Mark Word设置为null来表示重入</span><br>        <span class="hljs-comment">// 置null的原因是因为要记录重入次数，但是mark word大小有限，所以每次重入都在栈帧中新增一个Displaced Mark Word为null的记录</span><br>        <span class="hljs-keyword">if</span> (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced-&gt;clear_lock_bits())) &#123;<br>          entry-&gt;lock()-&gt;set_displaced_header(NULL);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 若禁用则锁升级</span><br>          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);<br>        &#125;<br>      &#125;<br>    &#125;<br>    UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    istate-&gt;set_msg(more_monitors);<br>    UPDATE_PC_AND_RETURN(<span class="hljs-number">0</span>); <span class="hljs-comment">// Re-execute</span><br>  &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>通过上面的源码我们能够知道：</p><p>如果没有开启偏向模式，JVM会初次构造轻量级锁，也就是执行<code>if (!success)&#123;...&#125;</code>后的内容第一次申请轻量锁，如果此时的请求是重入，那么则会在当前线程的<code>Lock Record</code>列表中插入一个新的<code>Lock Record</code>，其中<code>displaced hdr</code>指向null，这么做的原因是因为要记录重入次数。如果此时还发生锁竞争，那么则会调用<code>CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception)</code>升级成重量锁。</p><p>如果偏向锁偏向失败，会调用<code>CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception)</code>决定要不要升级成轻量锁。这部分的代码在偏向锁的撤销中都有提及过。</p><hr><p><strong>存在的问题：</strong></p><p><strong>Q1：在代码中，到底在什么时候将lock对象的<code>markword</code>最后两位设置为<code>00</code>？</strong></p><p>我阅读了很久的源码，都没有发现设置的地方，网上有人说是通过<a href="https://github.com/farmerjohngit/myblog/issues/14">字节填充对齐来解决的</a>。然而我不是很懂。</p><p>也就是说：执行<code>Atomic::cmpxchg_ptr(entry, lockee-&gt;mark_addr(), displaced)</code>时，entry是一个四字节的指针，由于对齐操作，entry的第31~32bit一定为<code>00</code>，如果CAS成功，那么锁对象头的<code>markword</code>就指向了栈中的<code>Lock Record</code>。</p><p><strong>Q2：在轻量锁状态时，CAS算法如何保证锁互斥的获取？</strong></p><p>首先，我们看看核心代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//code1</span><br>markOop displaced = lockee-&gt;mark()-&gt;set_unlocked();<br><span class="hljs-comment">//</span><br>entry-&gt;lock()-&gt;set_displaced_header(displaced);<br><span class="hljs-comment">// 是否禁用偏向锁和轻量级锁</span><br>bool call_vm = UseHeavyMonitors;<br><span class="hljs-comment">//code2</span><br><span class="hljs-keyword">if</span> (call_vm || Atomic::cmpxchg_ptr(entry, lockee-&gt;mark_addr(), displaced) != displaced) &#123;...&#125;<br></code></pre></div></td></tr></table></figure><p>CAS算法需要预期的值和目标修改值。预期值就是上述代码中的<code>displaced</code>。而这个<code>displaced</code>是如何构造出来的呢？见如下代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> </span>&#123; <br>    locked_value             = <span class="hljs-number">0</span>,<br>    unlocked_value           = <span class="hljs-number">1</span>,<br>    monitor_value            = <span class="hljs-number">2</span>,<br>    marked_value             = <span class="hljs-number">3</span>,<br>    biased_lock_pattern      = <span class="hljs-number">5</span><br>&#125;;<br><span class="hljs-function">markOop <span class="hljs-title">set_unlocked</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> markOop(value() | unlocked_value);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>lock</code>就是当前的锁对象，调用<code>set_unlocked()</code>后，会将当前对象头的<code>markword</code>(上述代码中的<code>value()</code>)与<code>unlocked_value</code>进行<strong>或</strong>操作。这样就能构造出一个无锁状态的<code>markword</code>（也就是最后两位为<code>01</code>）。所以CAS算法的旧预期值displaced<strong>肯定</strong>是一个无锁状态的<code>markword</code>，这跟锁对象的锁状态没有关系。</p><p>假设现在有threadA，<strong>第一次</strong>请求轻量锁时，锁对象头的<code>markword</code>第31~32位一定是<code>01</code>（因为如果走到这个CAS，锁对象头的markword一定是无锁状态）。<code>lockee-&gt;mark()</code>(CAS的真实值)与<code>displaced</code>(CAS的预期值)1~30位bit一定是相同的，因为<code>displaced</code>只改变了<code>lockee-&gt;mark()</code>的第32位bit。所以CAS算法的预期值和实际值符合，threadA成功获取锁。</p><p>在threadA执行同步区的过程中，如果有threadB请求轻量锁，因为<code>lockee-&gt;mark()</code>最后两位一定为<code>00</code>(详情见Q1)，但是我们构建的预期值<code>displaced</code>最后两位一定为<code>01</code>。所以CAS算法调用失败，保证了轻量锁的互斥获取。</p><hr><h3 id="3-2-2-轻量锁的释放流程"><a href="#3-2-2-轻量锁的释放流程" class="headerlink" title="3.2.2 轻量锁的释放流程"></a>3.2.2 轻量锁的释放流程</h3><p>轻量锁的释放只需要使用CAS算法将请求锁时，添加的<code>Lock Record</code>的<code>displaced markword</code>复制到锁对象头的<code>markword</code>即可，复制完成后，锁对象目前的状态是<code>001</code>，无锁状态。如果失败，则说明有锁竞争，会调用重锁的退出方法<code>monitorexit</code>。</p><p>轻量锁的释放代码和偏向锁的释放代码糅合在一起，详情见如下代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">CASE(_monitorexit): &#123;<br>  oop lockee = STACK_OBJECT(-<span class="hljs-number">1</span>);<br>  CHECK_NULL(lockee);<br>  <span class="hljs-comment">// derefing&#x27;s lockee ought to provoke implicit null check</span><br>  <span class="hljs-comment">// find our monitor slot</span><br>  BasicObjectLock* limit = istate-&gt;monitor_base();<br>  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();<br>  <span class="hljs-comment">// 从低往高遍历栈的Lock Record</span><br>  <span class="hljs-keyword">while</span> (most_recent != limit ) &#123;<br>    <span class="hljs-comment">// 如果Lock Record关联的是该锁对象</span><br>    <span class="hljs-keyword">if</span> ((most_recent)-&gt;obj() == lockee) &#123;<br>      BasicLock* lock = most_recent-&gt;lock();<br>      markOop header = lock-&gt;displaced_header();<br>      <span class="hljs-comment">// 释放Lock Record</span><br>      most_recent-&gt;set_obj(NULL);<br>      <span class="hljs-comment">// 如果是偏向模式，仅仅释放Lock Record就好了。否则要走轻量级锁or重量级锁的释放流程</span><br>      <span class="hljs-keyword">if</span> (!lockee-&gt;mark()-&gt;has_bias_pattern()) &#123;<br>        bool call_vm = UseHeavyMonitors;<br>        <span class="hljs-comment">// header!=NULL说明不是重入，则需要将Displaced Mark Word CAS到对象头的Mark Word</span><br>        <span class="hljs-keyword">if</span> (header != NULL || call_vm) &#123;<br>          <span class="hljs-keyword">if</span> (call_vm || Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), lock) != lock) &#123;<br>            <span class="hljs-comment">// CAS失败或者是重量级锁则会走到这里，先将obj还原，然后调用monitorexit方法</span><br>            most_recent-&gt;set_obj(lockee);<br>            CALL_VM(InterpreterRuntime::monitorexit(THREAD, most_recent), handle_exception);<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">//执行下一条命令</span><br>      UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//处理下一条Lock Record</span><br>    most_recent++;<br>  &#125;<br>  <span class="hljs-comment">// Need to throw illegal monitor state exception</span><br>  CALL_VM(InterpreterRuntime::throw_illegal_monitor_state_exception(THREAD), handle_exception);<br>  ShouldNotReachHere();<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-3-重量锁"><a href="#3-3-重量锁" class="headerlink" title="3.3 重量锁"></a>3.3 重量锁</h2><p>重量级锁就是使用<code>objectmonitor</code>（使用操作系统的mutex）完成同步的工具。</p><h3 id="3-3-1-重量锁的获取流程"><a href="#3-3-1-重量锁的获取流程" class="headerlink" title="3.3.1 重量锁的获取流程"></a>3.3.1 重量锁的获取流程</h3><p>获取重量锁的地方有两个：</p><ol><li>如果在<code>fast_enter</code>中偏向锁升级轻量级锁失败，那么会调用<code>slow_enter</code></li><li>在不开启偏向模式的情况下，直接调用<code>slow_enter</code>。在<code>slow_enter</code>中先尝试是否能够使用轻量级锁，如果失败，则直接调用<code>inflate</code>方法直接膨胀为重量级锁</li></ol><p>我们知道，重锁是需要一个<code>objectmonitor</code>维护互斥锁的。这个对象就是<code>inflate</code>中构建的。<code>inflate</code>主要流程如下：</p><ol><li>如果锁已经达到重量级状态，则直接返回</li><li>如果是轻量级锁状态，那么则需要膨胀，包括设置一些record</li><li>如果锁是膨胀中状态，那么则通过<strong>自旋</strong>操作完成忙等待</li><li>如果是无锁状态，那么则需要进行膨胀</li></ol><p>锁膨胀完成后，那么各个线程则尝试通过调用<code>enter</code>方法获取锁进入临界区，分析如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> ATTR ObjectMonitor::enter(TRAPS) &#123;<br>   <br>  Thread * <span class="hljs-keyword">const</span> Self = THREAD ;<br>  <span class="hljs-keyword">void</span> * cur ;<br>  <span class="hljs-comment">// owner为null代表无锁状态，如果能CAS设置成功，则当前线程直接获得锁</span><br>  cur = Atomic::cmpxchg_ptr (Self, &amp;_owner, NULL) ;<br>  <span class="hljs-keyword">if</span> (cur == NULL) &#123;<br>     ...<br>     <span class="hljs-keyword">return</span> ;<br>  &#125;<br>  <span class="hljs-comment">// 如果是重入的情况</span><br>  <span class="hljs-keyword">if</span> (cur == Self) &#123;<br>     <span class="hljs-comment">// TODO-<span class="hljs-doctag">FIXME:</span> check for integer overflow!  BUGID 6557169.</span><br>     _recursions ++ ;<br>     <span class="hljs-keyword">return</span> ;<br>  &#125;<br>  <span class="hljs-comment">// 当前线程是之前持有轻量级锁的线程。由轻量级锁膨胀且第一次调用enter方法，那cur是指向Lock Record的指针</span><br>  <span class="hljs-keyword">if</span> (Self-&gt;is_lock_owned ((address)cur)) &#123;<br>    <span class="hljs-keyword">assert</span> (_recursions == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;internal state error&quot;</span>);<br>    <span class="hljs-comment">// 重入计数重置为1</span><br>    _recursions = <span class="hljs-number">1</span> ;<br>    <span class="hljs-comment">// 设置owner字段为当前线程（之前owner是指向Lock Record的指针）</span><br>    _owner = Self ;<br>    OwnerIsThread = <span class="hljs-number">1</span> ;<br>    <span class="hljs-keyword">return</span> ;<br>  &#125;<br><br>  ...<br><br>  <span class="hljs-comment">// 在调用系统的同步操作之前，先尝试自旋获得锁</span><br>  <span class="hljs-keyword">if</span> (Knob_SpinEarly &amp;&amp; TrySpin (Self) &gt; <span class="hljs-number">0</span>) &#123;<br>     ...<br>     <span class="hljs-comment">//自旋的过程中获得了锁，则直接返回</span><br>     Self-&gt;_Stalled = <span class="hljs-number">0</span> ;<br>     <span class="hljs-keyword">return</span> ;<br>  &#125;<br><br>  ...<br><br>  &#123; <br>    ...<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      jt-&gt;set_suspend_equivalent();<br>      <span class="hljs-comment">// 在该方法中调用系统同步操作</span><br>      EnterI (THREAD) ;<br>      ...<br>    &#125;<br>    Self-&gt;set_current_pending_monitor(NULL);<br>    <br>  &#125;<br><br>  ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在<code>enter()</code>中，只能完成三种获取锁的动作，包括无锁状态获取锁（即锁没有被占有）、通过轻量级锁升级来获取锁、重入锁这三种情况。超出这三种情况，需要调用<code>enterI()</code>完成系统同步的操作。当然在调用系统同步操作之前，会尝试自旋获取锁。</p><p>在前面说过，监视锁<code>objectmonitor</code>维护了两个队列<code>_EntryList</code>、<code>_WaitList</code>用来保存被阻塞等待锁的线程和主动调用<code>wait()</code>等待锁的线程。其实在源码中， <code>objectmonitor</code> 还维护了一个队列<code>_cxq</code>,用来给<code>_EntryList</code>提供被阻塞的线程。这三者的关系如下图所示：</p><p><img src="images/synchronized.png" alt="syn"></p><p>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到cxq队列的队首，然后调用park函数挂起当前线程。在linux系统上，park函数底层调用的是gclib库的pthread_cond_wait。</p><p>当线程释放锁时，会从cxq或EntryList中挑选一个线程唤醒，被选中的线程叫做Heir presumptive即假定继承人（即图中的ready thread），假定继承人被唤醒后会尝试获得锁，但synchronized是非公平的，所以假定继承人不一定能获得锁（这也是它叫”假定”继承人的原因）。</p><p>如果线程获得锁后调用Object.wait方法，则会将线程加入到WaitSet中，当被Object#notify唤醒后，会将线程从WaitSet移动到cxq或EntryList中去。需要注意的是，<strong>当调用一个锁对象的wait或notify方法时，如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁。</strong> 源码分析如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> ATTR ObjectMonitor::EnterI (TRAPS) &#123;<br>    Thread * Self = THREAD ;<br>    ...<br>    <span class="hljs-comment">// 尝试获得锁</span><br>    <span class="hljs-keyword">if</span> (TryLock (Self) &gt; <span class="hljs-number">0</span>) &#123;<br>        ...<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    DeferredInitialize () ;<br> <br><span class="hljs-comment">// 自旋</span><br>    <span class="hljs-keyword">if</span> (TrySpin (Self) &gt; <span class="hljs-number">0</span>) &#123;<br>        ...<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <br>    ...<br><br>    <span class="hljs-comment">// 将线程封装成node节点中</span><br>    <span class="hljs-function">ObjectWaiter <span class="hljs-title">node</span><span class="hljs-params">(Self)</span> </span>;<br>    Self-&gt;_ParkEvent-&gt;reset() ;<br>    node._prev   = (ObjectWaiter *) <span class="hljs-number">0xBAD</span> ;<br>    node.TState  = ObjectWaiter::TS_CXQ ;<br><br>    <span class="hljs-comment">// 将node节点插入到_cxq队列的头部，cxq是一个单向链表</span><br>    ObjectWaiter * nxt ;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        node._next = nxt = _cxq ;<br>        <span class="hljs-keyword">if</span> (Atomic::cmpxchg_ptr (&amp;node, &amp;_cxq, nxt) == nxt) <span class="hljs-keyword">break</span> ;<br><br>        <span class="hljs-comment">// CAS失败的话 再尝试获得锁，这样可以降低插入到_cxq队列的频率</span><br>        <span class="hljs-keyword">if</span> (TryLock (Self) &gt; <span class="hljs-number">0</span>) &#123;<br>            ...<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// SyncFlags默认为0，如果没有其他等待的线程，则将_Responsible设置为自己</span><br>    <span class="hljs-keyword">if</span> ((SyncFlags &amp; <span class="hljs-number">16</span>) == <span class="hljs-number">0</span> &amp;&amp; nxt == NULL &amp;&amp; _EntryList == NULL) &#123;<br>        Atomic::cmpxchg_ptr (Self, &amp;_Responsible, NULL) ;<br>    &#125;<br><br><br>    TEVENT (Inflated enter - Contention) ;<br>    <span class="hljs-keyword">int</span> nWakeups = <span class="hljs-number">0</span> ;<br>    <span class="hljs-keyword">int</span> RecheckInterval = <span class="hljs-number">1</span> ;<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br><br>        <span class="hljs-keyword">if</span> (TryLock (Self) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span> ;<br>        <span class="hljs-keyword">assert</span> (_owner != Self, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br><br>        ...<br><br>        <span class="hljs-comment">// park self</span><br>        <span class="hljs-keyword">if</span> (_Responsible == Self || (SyncFlags &amp; <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-comment">// 当前线程是_Responsible时，调用的是带时间参数的park</span><br>            TEVENT (Inflated enter - park TIMED) ;<br>            Self-&gt;_ParkEvent-&gt;park ((jlong) RecheckInterval) ;<br>            <span class="hljs-comment">// Increase the RecheckInterval, but clamp the value.</span><br>            RecheckInterval *= <span class="hljs-number">8</span> ;<br>            <span class="hljs-keyword">if</span> (RecheckInterval &gt; <span class="hljs-number">1000</span>) RecheckInterval = <span class="hljs-number">1000</span> ;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//否则直接调用park挂起当前线程</span><br>            TEVENT (Inflated enter - park UNTIMED) ;<br>            Self-&gt;_ParkEvent-&gt;park() ;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (TryLock(Self) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span> ;<br><br>        ...<br>        <br>        <span class="hljs-keyword">if</span> ((Knob_SpinAfterFutile &amp; <span class="hljs-number">1</span>) &amp;&amp; TrySpin (Self) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span> ;<br><br>       ...<br>        <span class="hljs-comment">// 在释放锁时，_succ会被设置为EntryList或_cxq中的一个线程</span><br>        <span class="hljs-keyword">if</span> (_succ == Self) _succ = NULL ;<br><br>        <span class="hljs-comment">// Invariant: after clearing _succ a thread *must* retry _owner before parking.</span><br>        OrderAccess::fence() ;<br>    &#125;<br><br>   <span class="hljs-comment">// 走到这里说明已经获得锁了</span><br><br>    <span class="hljs-keyword">assert</span> (_owner == Self      , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>    <span class="hljs-keyword">assert</span> (object() != NULL    , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>  <br><span class="hljs-comment">// 将当前线程的node从cxq或EntryList中移除</span><br>    UnlinkAfterAcquire (Self, &amp;node) ;<br>    <span class="hljs-keyword">if</span> (_succ == Self) _succ = NULL ;<br><span class="hljs-keyword">if</span> (_Responsible == Self) &#123;<br>        _Responsible = NULL ;<br>        OrderAccess::fence();<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>主要步骤有3步：</p><ol><li>将当前线程插入到cxq队列的队首</li><li>然后park当前线程</li><li>当被唤醒后再尝试获得锁</li></ol><p>这里需要特别说明的是_Responsible和_succ两个字段的作用：</p><p>当竞争发生时，选取一个线程作为_Responsible，_Responsible线程调用的是有时间限制的park方法，其目的是防止出现搁浅现象。</p><p>_succ线程是在线程释放锁是被设置，其含义是Heir presumptive，也就是我们上面说的假定继承人。</p><h3 id="3-3-2-重量锁的释放流程"><a href="#3-3-2-重量锁的释放流程" class="headerlink" title="3.3.2 重量锁的释放流程"></a>3.3.2 重量锁的释放流程</h3><p>重量级锁释放的代码在ObjectMonitor::exit,在释放锁时，JVM需要提供下一个需要准备获取锁的线程（如果有线程需要的话），代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> ATTR ObjectMonitor::exit(bool not_suspended, TRAPS) &#123;<br>   Thread * Self = THREAD ;<br>   <span class="hljs-comment">// 如果_owner不是当前线程</span><br>   <span class="hljs-keyword">if</span> (THREAD != _owner) &#123;<br>     <span class="hljs-comment">// 当前线程是之前持有轻量级锁的线程。由轻量级锁膨胀后还没调用过enter方法，_owner会是指向Lock Record的指针。</span><br>     <span class="hljs-keyword">if</span> (THREAD-&gt;is_lock_owned((address) _owner)) &#123;<br>       <span class="hljs-keyword">assert</span> (_recursions == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>       _owner = THREAD ;<br>       _recursions = <span class="hljs-number">0</span> ;<br>       OwnerIsThread = <span class="hljs-number">1</span> ;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-comment">// 异常情况:当前不是持有锁的线程</span><br>       TEVENT (Exit - Throw IMSX) ;<br>       <span class="hljs-keyword">assert</span>(<span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;Non-balanced monitor enter/exit!&quot;</span>);<br>       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">false</span>) &#123;<br>          THROW(vmSymbols::java_lang_IllegalMonitorStateException());<br>       &#125;<br>       <span class="hljs-keyword">return</span>;<br>     &#125;<br>   &#125;<br>   <span class="hljs-comment">// 重入计数器还不为0，则计数器-1后返回</span><br>   <span class="hljs-keyword">if</span> (_recursions != <span class="hljs-number">0</span>) &#123;<br>     _recursions--;        <span class="hljs-comment">// this is simple recursive enter</span><br>     TEVENT (Inflated exit - recursive) ;<br>     <span class="hljs-keyword">return</span> ;<br>   &#125;<br><br>   <span class="hljs-comment">// _Responsible设置为null</span><br>   <span class="hljs-keyword">if</span> ((SyncFlags &amp; <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>) &#123;<br>      _Responsible = NULL ;<br>   &#125;<br><br>   ...<br><br>   <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-keyword">assert</span> (THREAD == _owner, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br><br>      <span class="hljs-comment">// Knob_ExitPolicy默认为0</span><br>      <span class="hljs-keyword">if</span> (Knob_ExitPolicy == <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-comment">// code 1：先释放锁，这时如果有其他线程进入同步块则能获得锁</span><br>         OrderAccess::release_store_ptr (&amp;_owner, NULL) ;   <span class="hljs-comment">// drop the lock</span><br>         OrderAccess::storeload() ;                         <span class="hljs-comment">// See if we need to wake a successor</span><br>         <span class="hljs-comment">// code 2：如果没有等待的线程或已经有假定继承人</span><br>         <span class="hljs-comment">//有假定继承人表示可能会选择假定继承人作为唤醒对象，以便争夺锁</span><br>         <span class="hljs-keyword">if</span> ((intptr_t(_EntryList)|intptr_t(_cxq)) == <span class="hljs-number">0</span> || _succ != NULL) &#123;<br>            TEVENT (Inflated exit - simple egress) ;<br>            <span class="hljs-keyword">return</span> ;<br>         &#125;<br>         TEVENT (Inflated exit - complex egress) ;<br><br>         <span class="hljs-comment">// code 3：要执行之后的操作需要重新获得锁，即设置_owner为当前线程</span><br>         <span class="hljs-keyword">if</span> (Atomic::cmpxchg_ptr (THREAD, &amp;_owner, NULL) != NULL) &#123;<br>            <span class="hljs-keyword">return</span> ;<br>         &#125;<br>         TEVENT (Exit - Reacquired) ;<br>      &#125; <br>      ...<br><br>      ObjectWaiter * w = NULL ;<br>      <span class="hljs-comment">// code 4：根据QMode的不同会有不同的唤醒策略，默认为0</span><br>      <span class="hljs-keyword">int</span> QMode = Knob_QMode ;<br>      <span class="hljs-keyword">if</span> (QMode == <span class="hljs-number">2</span> &amp;&amp; _cxq != NULL) &#123;<br>          <span class="hljs-comment">// QMode == 2 : cxq中的线程有更高优先级，直接唤醒cxq的队首线程</span><br>          w = _cxq ;<br>          <span class="hljs-keyword">assert</span> (w != NULL, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>          <span class="hljs-keyword">assert</span> (w-&gt;TState == ObjectWaiter::TS_CXQ, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>          ExitEpilog (Self, w) ;<br>          <span class="hljs-keyword">return</span> ;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (QMode == <span class="hljs-number">3</span> &amp;&amp; _cxq != NULL) &#123;<br>          <span class="hljs-comment">// 将cxq中的元素插入到EntryList的末尾</span><br>          w = _cxq ;<br>          <span class="hljs-keyword">for</span> (;;) &#123;<br>             <span class="hljs-keyword">assert</span> (w != NULL, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>             ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL, &amp;_cxq, w) ;<br>             <span class="hljs-keyword">if</span> (u == w) <span class="hljs-keyword">break</span> ;<br>             w = u ;<br>          &#125;<br>          <span class="hljs-keyword">assert</span> (w != NULL              , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br><br>          ObjectWaiter * q = NULL ;<br>          ObjectWaiter * p ;<br>          <span class="hljs-keyword">for</span> (p = w ; p != NULL ; p = p-&gt;_next) &#123;<br>              guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>              p-&gt;TState = ObjectWaiter::TS_ENTER ;<br>              p-&gt;_prev = q ;<br>              q = p ;<br>          &#125;<br><br>          <span class="hljs-comment">// Append the RATs to the EntryList</span><br>          <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> organize EntryList as a CDLL so we can locate the tail in constant-time.</span><br>          ObjectWaiter * Tail ;<br>          <span class="hljs-keyword">for</span> (Tail = _EntryList ; Tail != NULL &amp;&amp; Tail-&gt;_next != NULL ; Tail = Tail-&gt;_next) ;<br>          <span class="hljs-keyword">if</span> (Tail == NULL) &#123;<br>              _EntryList = w ;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              Tail-&gt;_next = w ;<br>              w-&gt;_prev = Tail ;<br>          &#125;<br><br>          <span class="hljs-comment">// Fall thru into code that tries to wake a successor from EntryList</span><br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (QMode == <span class="hljs-number">4</span> &amp;&amp; _cxq != NULL) &#123;<br>          <span class="hljs-comment">// 将cxq插入到EntryList的队首</span><br>          w = _cxq ;<br>          <span class="hljs-keyword">for</span> (;;) &#123;<br>             <span class="hljs-keyword">assert</span> (w != NULL, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>             ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL, &amp;_cxq, w) ;<br>             <span class="hljs-keyword">if</span> (u == w) <span class="hljs-keyword">break</span> ;<br>             w = u ;<br>          &#125;<br>          <span class="hljs-keyword">assert</span> (w != NULL              , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br><br>          ObjectWaiter * q = NULL ;<br>          ObjectWaiter * p ;<br>          <span class="hljs-keyword">for</span> (p = w ; p != NULL ; p = p-&gt;_next) &#123;<br>              guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>              p-&gt;TState = ObjectWaiter::TS_ENTER ;<br>              p-&gt;_prev = q ;<br>              q = p ;<br>          &#125;<br><br>          <span class="hljs-comment">// Prepend the RATs to the EntryList</span><br>          <span class="hljs-keyword">if</span> (_EntryList != NULL) &#123;<br>              q-&gt;_next = _EntryList ;<br>              _EntryList-&gt;_prev = q ;<br>          &#125;<br>          _EntryList = w ;<br><br>          <span class="hljs-comment">// Fall thru into code that tries to wake a successor from EntryList</span><br>      &#125;<br><br>      w = _EntryList  ;<br>      <span class="hljs-keyword">if</span> (w != NULL) &#123;<br>          <span class="hljs-comment">// 如果EntryList不为空，则直接唤醒EntryList的队首元素</span><br>          <span class="hljs-keyword">assert</span> (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>          ExitEpilog (Self, w) ;<br>          <span class="hljs-keyword">return</span> ;<br>      &#125;<br><br>      <span class="hljs-comment">// EntryList为null，则处理cxq中的元素</span><br>      w = _cxq ;<br>      <span class="hljs-keyword">if</span> (w == NULL) <span class="hljs-keyword">continue</span> ;<br><br>      <span class="hljs-comment">// 因为之后要将cxq的元素移动到EntryList，所以这里将cxq字段设置为null</span><br>      <span class="hljs-keyword">for</span> (;;) &#123;<br>          <span class="hljs-keyword">assert</span> (w != NULL, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>          ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL, &amp;_cxq, w) ;<br>          <span class="hljs-keyword">if</span> (u == w) <span class="hljs-keyword">break</span> ;<br>          w = u ;<br>      &#125;<br>      TEVENT (Inflated exit - drain cxq into EntryList) ;<br><br>      <span class="hljs-keyword">assert</span> (w != NULL              , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>      <span class="hljs-keyword">assert</span> (_EntryList  == NULL    , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br><br><br>      <span class="hljs-keyword">if</span> (QMode == <span class="hljs-number">1</span>) &#123;<br>         <span class="hljs-comment">// QMode == 1 : 将cxq中的元素转移到EntryList，并反转顺序</span><br>         ObjectWaiter * s = NULL ;<br>         ObjectWaiter * t = w ;<br>         ObjectWaiter * u = NULL ;<br>         <span class="hljs-keyword">while</span> (t != NULL) &#123;<br>             guarantee (t-&gt;TState == ObjectWaiter::TS_CXQ, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>             t-&gt;TState = ObjectWaiter::TS_ENTER ;<br>             u = t-&gt;_next ;<br>             t-&gt;_prev = u ;<br>             t-&gt;_next = s ;<br>             s = t;<br>             t = u ;<br>         &#125;<br>         _EntryList  = s ;<br>         <span class="hljs-keyword">assert</span> (s != NULL, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">// QMode == 0 or QMode == 2‘</span><br>         <span class="hljs-comment">// 将cxq中的元素转移到EntryList</span><br>         _EntryList = w ;<br>         ObjectWaiter * q = NULL ;<br>         ObjectWaiter * p ;<br>         <span class="hljs-keyword">for</span> (p = w ; p != NULL ; p = p-&gt;_next) &#123;<br>             guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>             p-&gt;TState = ObjectWaiter::TS_ENTER ;<br>             p-&gt;_prev = q ;<br>             q = p ;<br>         &#125;<br>      &#125;<br><br><br>      <span class="hljs-comment">// _succ不为null，说明已经有个继承人了，所以不需要当前线程去唤醒，减少上下文切换的比率</span><br>      <span class="hljs-keyword">if</span> (_succ != NULL) <span class="hljs-keyword">continue</span>;<br><br>      w = _EntryList  ;<br>      <span class="hljs-comment">// 唤醒EntryList第一个元素</span><br>      <span class="hljs-keyword">if</span> (w != NULL) &#123;<br>          guarantee (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>          ExitEpilog (Self, w) ;<br>          <span class="hljs-keyword">return</span> ;<br>      &#125;<br>   &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>代码中的<code>QMode</code>表示唤醒下一个线程的策略。</p><p>code 1 设置owner为null，即释放锁，这个时刻其他的线程能获取到锁。这里是一个非公平锁的优化；</p><p>code 2 如果当前没有等待的线程则直接返回就好了，因为不需要唤醒其他线程。或者如果说succ不为null，代表当前已经有个”醒着的”继承人线程，那当前线程不需要唤醒任何线程；</p><p>code 3 当前线程重新获得锁，因为之后要操作cxq和EntryList队列以及唤醒线程；</p><p>code 4根据QMode的不同，会执行不同的唤醒策略。</p><p>根据QMode的不同，有不同的处理方式：</p><p>QMode = 2且cxq非空：取cxq队列队首的ObjectWaiter对象，调用ExitEpilog方法，该方法会唤醒ObjectWaiter对象的线程（即cxq队列首元素），然后立即返回，后面的代码不会执行了；<br>QMode = 3且cxq非空：把cxq队列插入到EntryList的尾部；<br>QMode = 4且cxq非空：把cxq队列插入到EntryList的头部；<br>QMode = 0：暂时什么都不做，继续往下看；</p><p>只有QMode=2的时候会提前返回，等于0、3、4的时候都会继续往下执行：</p><ol><li>如果EntryList的首元素非空，就取出来调用ExitEpilog方法，该方法会唤醒ObjectWaiter对象的线程（EntryList首元素），然后立即返回；</li><li>如果EntryList的首元素为空，就将cxq的所有元素放入到EntryList中，然后再从EntryList中取出来队首元素执行ExitEpilog方法，然后立即返回；</li></ol><h1 id="4-synchronized锁的大体流程"><a href="#4-synchronized锁的大体流程" class="headerlink" title="4. synchronized锁的大体流程"></a>4. synchronized锁的大体流程</h1><p>偏向锁-&gt;轻量锁-&gt;重量锁三者转换的大体逻辑如下图：</p><p>图片来自<a href="https://blog.csdn.net/DBC_121/article/details/105453101">看完这篇恍然大悟，理解Java中的偏向锁，轻量级锁，重量级锁</a></p><p><img src="images/lock.png" alt="lock"></p><p>但是图片中存在错误：轻量级锁发生竞争时没有自旋操作，直接膨胀为重量级锁</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://segmentfault.com/a/1190000016417017">Java中的Monitor机制</a></p></li><li><p><a href="https://developer.ibm.com/zh/articles/j-lo-synchronized/">探索Java同步机制</a></p></li><li><p><a href="http://itliusir.com/2019/11-Synchronized/">Synchronized 源码分析</a></p></li><li><p><a href="https://juejin.cn/post/6844903726554038280">死磕Synchronized底层实现–偏向锁</a></p></li><li><p><a href="https://github.com/farmerjohngit/myblog/issues/14">死磕Synchronized底层实现–轻量级锁</a></p></li><li><p><a href="https://github.com/farmerjohngit/myblog/issues/15">死磕Synchronized底层实现–重量级锁</a></p></li><li><p><a href="https://blog.csdn.net/L__ear/article/details/106369509">源码解析-偏向锁撤销流程解读</a></p></li><li><p><a href="https://www.jianshu.com/p/fd780ef7a2e8">Lock Record–锁记录</a></p></li><li><p><a href="https://www.mdeditor.tw/pl/2Z1b">偏向锁到底是怎么回事啊啊啊啊</a></p></li><li><p><a href="https://blog.weghos.com/openjdk/OpenJDK/src/hotspot/">在线看JDK源码的网站</a></p></li><li><p><a href="https://blog.csdn.net/L__ear/article/details/106365869">源码解析-触发批量撤销或批量重偏向的条件</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/302874340">关于synchronized批量重偏向和批量撤销的一个小实验</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>多线程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>synchronized</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadPoolExecutor线程池解析</title>
    <link href="/2021-06-03/ThreadPoolExecutor.html"/>
    <url>/2021-06-03/ThreadPoolExecutor.html</url>
    
    <content type="html"><![CDATA[<h2 id="0-预备知识"><a href="#0-预备知识" class="headerlink" title="0. 预备知识"></a>0. 预备知识</h2><p>在了解<code>ThreadPoolExecutor</code>之前，我们首先需要了解一些基本概念，下图是<code>ThreadPoolExecutor</code>的部分核心字段。我先依次对其进行解释。</p><p><img src="images/ThreadPoolExecutor-fields.png" alt="ThreadPoolExecutor"></p><h3 id="0-1-线程池状态"><a href="#0-1-线程池状态" class="headerlink" title="#0.1 线程池状态"></a>#0.1 线程池状态</h3><p>JUC为线程池规定了5种状态，如下图所示：<br><img src="images/Executor-state.drawio.svg" alt="executor-state"></p><p>对于每种状态，含义如下：</p><ol><li>RUNNING: 线程池能够接受任务并处理阻塞队列中的任务</li><li>SHUTDOWN: 不再接受新的任务，但是会把阻塞队列中的任务全部执行完毕</li><li>STOP: 不再接受新的任务，不再处理阻塞队列中的任务，并且会中断正在执行的任务</li><li>TIDYING:  所有的任务都被终止，工作线程的数量为0，并且在转化为该状态时，线程池会执行<code>terminated()</code>方法</li><li>TERMINATED: <code>terminated()</code>方法执行完毕</li></ol><p>了解了线程池的五种状态后，那么它底层到底是如何实现的呢？其实也不复杂。<code>ThreadPoolExecutor</code>通过一个<code>AtomicInterger</code>维护了这五种状态。实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY   = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// runState is stored in the high-order bits</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING    = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br></code></pre></div></td></tr></table></figure><p>对于一个32为的<code>AtomicInteger</code>来说，它的信息分为两部分：</p><ul><li>第30~32位：线程池的状态</li><li>第1~29位，线程池中的线程数量</li></ul><p>从上面的定义中我们得知：<code>ctl</code>属性维护上述的两组信息，并且在初始化时会将线程数量设为0。获取状态时只需要通过<code>runStateOf(int)</code>方法获取<code>ctl</code>属性的高3位即可，对于线程数量的获取同理。</p><h3 id="0-2-线程池互斥锁"><a href="#0-2-线程池互斥锁" class="headerlink" title="#0.2 线程池互斥锁"></a>#0.2 线程池互斥锁</h3><p><code>ThreadPoolExecutor</code>内部维护了一个<code>ReentrantLock</code>用来实现对工作线程集合的互斥访问，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">new</span> ReentrantLock();<br></code></pre></div></td></tr></table></figure><p>因为在多线程环境，操作一个hashSet可能会出现线程不安全的问题。至于为什么不适用一个线程安全的set，是因为使用锁可以对<code>interruptIdleWorkers()</code>的操作进行序列化，从而避免了不必要的中断风暴，尤其是在关闭线程池期间。并且还能够简化一些数据的统计。</p><h3 id="0-3-线程包装类Worker"><a href="#0-3-线程包装类Worker" class="headerlink" title="#0.3 线程包装类Worker"></a>#0.3 线程包装类Worker</h3><p>在<code>ThreadPoolExecutors</code>中，定义了一个不可变对象<code>Worker</code>作为线程的wrapper，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span></span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * This class will never be serialized, but we provide a</span><br><span class="hljs-comment">    * serialVersionUID to suppress a javac warning.</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">6138294804551838833L</span>;<br><br>    <span class="hljs-comment">//具体执行任务的线程，为null表示出现错误</span><br>    <span class="hljs-keyword">final</span> Thread thread;<br>    <span class="hljs-comment">//worker执行的第一个任务，可能为null</span><br>    Runnable firstTask;<br><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> completedTasks;<br><br>    Worker(Runnable firstTask) &#123;<br>        <span class="hljs-comment">//防止在当前线程执行runWorker之前，就收到中断</span><br>        setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>        <span class="hljs-keyword">this</span>.firstTask = firstTask;<br>        <span class="hljs-keyword">this</span>.thread = getThreadFactory().newThread(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        runWorker(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Lock methods</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// The value 0 represents the unlocked state.</span><br>    <span class="hljs-comment">// The value 1 represents the locked state.</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>            setExclusiveOwnerThread(Thread.currentThread());<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br>        setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>        setState(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span>        </span>&#123; acquire(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span>  </span>&#123; <span class="hljs-keyword">return</span> tryAcquire(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span>      </span>&#123; release(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLocked</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> isHeldExclusively(); &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">interruptIfStarted</span><span class="hljs-params">()</span> </span>&#123;<br>        Thread t;<br>        <span class="hljs-keyword">if</span> (getState() &gt;= <span class="hljs-number">0</span> &amp;&amp; (t = thread) != <span class="hljs-keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.interrupt();<br>            &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>之所以要包装呢，是因为<code>Worker</code>可以比<code>Thread</code>提供更多的信息。例如当前<code>worker</code>累计执行了多少个任务。其实我们还可以注意到<code>Worker</code>继承了AQS。那么这里就会出现两个问题：</p><ol><li>为什么要继承AQS？一个<code>Worker</code>要锁干嘛？一个<code>Worker</code>不是自己负责一个任务吗？难道会有多个线程访问同一个<code>Worker</code>？</li><li>使用线程的锁不行吗？为什么要自己实现一个锁？</li></ol><p>那么对于第一个问题，其实这个问题在注释中已经说明了：</p><blockquote><p>Class Worker mainly <strong>maintains interrupt control state</strong> for threads running tasks, along with other minor bookkeeping. This class opportunistically extends AbstractQueuedSynchronizer to simplify acquiring and releasing a lock <strong>surrounding each task execution</strong>. This protects against interrupts that are intended to wake up a worker thread waiting for a task from instead interrupting a task being run. </p></blockquote><blockquote><p>We implement a simple <strong>non-reentrant mutual exclusion lock</strong> rather than use ReentrantLock because we do not want worker tasks to be able to reacquire the lock when they invoke pool control methods like setCorePoolSize. Additionally, to suppress interrupts until the thread actually starts running tasks, we initialize lock state to a negative value, and clear it upon start (in runWorker).</p></blockquote><p>大致意思是说：<br><code>Worker</code>类会管理线程在执行任务时的中断状态，以及一些其他的信息。<code>Worker</code>继承AQS是为了实现一个简单的不可重入的锁，用来在执行任务前上锁，在任务完毕后后释放锁。<strong>上锁的原因是因为如果有中断发生，那么只希望中断那些正在等待任务的<code>Worker</code>，而不是中断那些正在执行任务的<code>Worker</code>。</strong></p><p>自己实现一个简单的<strong>不可重入</strong>的锁是因为已有的锁都是可重入的，线程池需要一个不可重入锁的才能达到上面的目的。那么为什么不可重入的就能达到目的呢？考虑下面一个场景：假设主线程调用了<code>setCorePoolSize(int)</code>调整线程池的大小，那么<code>ThreadPoolExecutor</code>希望这个调整的动作不要影响那些正在执行任务的<code>Worker</code>，所以就通过能否获取<code>Worker</code>对应的锁来判断当前<code>Worker</code>是否处于空闲状态，那么这里的锁只能是独占锁。若是可重入锁，那么，无论是等待任务的，还是正在执行的，都会被中断。<code>setCorePoolSize(int)</code>如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//调用该函数需要中断那些空闲的线程</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCorePoolSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (workerCountOf(ctl.get()) &gt; corePoolSize)<br>        interruptIdleWorkers();<br>    ...<br>&#125;<br><br><span class="hljs-comment">//判断一个线程是否空闲就是看能否获取对应worker的不可重入独占锁</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> onlyOne)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (Worker w : workers) &#123;<br>            Thread t = w.thread;<br>            <span class="hljs-comment">//能够成功获取不可重入锁就表示当前Worker没有执行任务，自然可以执行中断</span><br>            <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    t.interrupt();<br>                &#125;<br>                ...<br>            &#125;<br>            ...<br>        &#125;<br>    &#125;<br>    ...<br></code></pre></div></td></tr></table></figure><h3 id="0-4-线程工厂-ThreadFactory"><a href="#0-4-线程工厂-ThreadFactory" class="headerlink" title="#0.4 线程工厂:ThreadFactory"></a>#0.4 线程工厂:ThreadFactory</h3><p>所谓的线程的工厂，JUC提供了一个线程工厂接口<code>ThreadFactory</code>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ThreadFactory</span> </span>&#123;<br>    <span class="hljs-function">Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>唯一需要重写的方法就是生产新线程的方法<code>newThread(Runnable)</code>。对<code>ThreadPoolExecutor</code>，它内部实现了两种工厂类：<code>DefaultThreadFactory</code>和<code>PrivilegedThreadFactory</code>。</p><p>区别就是前者生产的线程优先级默认为5，后者对于新生产的线程和调用线程工厂的线程具有相同优先级，并具有相同的线程上下文类加载器。下面只列出默认工厂的代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ThreadFactory</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicInteger poolNumber = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadGroup group;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger threadNumber = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String namePrefix;<br><br>    DefaultThreadFactory() &#123;<br>        SecurityManager s = System.getSecurityManager();<br>        group = (s != <span class="hljs-keyword">null</span>) ? s.getThreadGroup() :<br>                                Thread.currentThread().getThreadGroup();<br>        namePrefix = <span class="hljs-string">&quot;pool-&quot;</span> +<br>                        poolNumber.getAndIncrement() +<br>                        <span class="hljs-string">&quot;-thread-&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(group, r,<br>                                namePrefix + threadNumber.getAndIncrement(),<br>                                <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (t.isDaemon())<br>            t.setDaemon(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-comment">//设置新线程的默认优先级为5</span><br>        <span class="hljs-keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)<br>            t.setPriority(Thread.NORM_PRIORITY);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="0-5-拒绝策略-defaultHandler"><a href="#0-5-拒绝策略-defaultHandler" class="headerlink" title="#0.5 拒绝策略:defaultHandler"></a>#0.5 拒绝策略:defaultHandler</h3><p>对于拒绝策略，我在讲解<a href="executor-interface.md">Executor框架</a>时曾说过，自带的拒绝策略有四种，而<code>ThreadPoolExecutor</code>默认采用的是AbortPolicy，直接拒绝提交的任务，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbortPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(<span class="hljs-string">&quot;Task &quot;</span> + r.toString() +<br>                                                <span class="hljs-string">&quot; rejected from &quot;</span> +<br>                                                e.toString());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="0-6-阻塞队列-workQueue"><a href="#0-6-阻塞队列-workQueue" class="headerlink" title="#0.6 阻塞队列:workQueue"></a>#0.6 阻塞队列:workQueue</h3><h2 id="1-任务添加流程"><a href="#1-任务添加流程" class="headerlink" title="1. 任务添加流程"></a>1. 任务添加流程</h2><p>阅读过源码的同学都知道，<code>ThreadPoolExecutor</code>并没有重写<code>ExecutorService</code>的<code>submit(Runnable)</code>的方法。当我们调用<code>submit</code>时实际调用的是<code>AbstractExecutorService</code>重写的<code>submit</code>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-keyword">null</span>);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在<code>submit</code>中又会调用<code>ThreadPoolExecutor</code>重写的<code>execute(Runnable)</code>方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <br>    <span class="hljs-keyword">int</span> c = ctl.get();<br>    <span class="hljs-comment">//如果当前线程池的线程数量小于核心线程数</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-comment">//尝试设置线程的第一个任务，因为通过execute调用addWorker，那么一定是</span><br>        <span class="hljs-comment">//因为有新任务进来了</span><br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br>    <span class="hljs-comment">//走到这说明线程数已经不小于核心线程数了</span><br>    <br>    <span class="hljs-comment">//如果线程池处于running状态，但是无法向阻塞队列中添加任务</span><br>    <span class="hljs-comment">//那么尝试添加新的worker</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-keyword">int</span> recheck = ctl.get();<br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))<br>        reject(command);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>主要的流程分为三步：</p><ol><li>如果当前活跃的线程的数量小于核心线程数，那么就尝试调用<code>addWaiter(Runnable,boolean)</code>增加一个线程，如果成功直接返回，否则执行2</li><li>走到这里说明线程数至少不小于核心线程数，那么尝试向阻塞队列中添加任务，如果添加成功，我们仍然需要通过双重检查是否应该增加线程（因为有可能在上次检查之后，线程池中的线程全部死亡），如果线程全部死亡，那么则尝试添加一个Worker。</li><li>如果无法向阻塞队列中添加任务，说明阻塞队列已满，如果此时无法增加worker，那么则会根据拒绝策略拒绝当前任务</li></ol><p>添加<code>worker</code>的方法<code>addWaiter(Runnable,boolean)</code>如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">返回true表示成功添加了工作线程并启动</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">但是返回false的情况有很多，但是都会进行回滚操作：</span><br><span class="hljs-comment">1. 表示线程池已经stop或者即将关闭</span><br><span class="hljs-comment">2. 线程创建失败，要么是因为线程工厂返回null，或者在启动线程的时候内存溢出，</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//第一个参数表示当前worker是否有第一个任务</span><br><span class="hljs-comment">//第二个参数core表示当前线程数量的上限是选核心线程数还是最大线程数</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;<br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-comment">//获取线程池状态</span><br>        <span class="hljs-keyword">int</span> rs = runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-comment">//如果当前线程池已经shutdown及之后的状态</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            <span class="hljs-comment">//线程不是shutdown状态，表示已经进入stop或tidying</span><br>            <span class="hljs-comment">//线程池是shutdown状态，并且firstTask不为空，但是shutdown状态不再接受任务，所以返回false</span><br>            <span class="hljs-comment">//线程池是shutdown状态，并且firstTask为空，并且阻塞队列为空，没有任务要执行，自然返回false</span><br><br>            ! (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span> &amp;&amp; ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br>            <span class="hljs-comment">//如果线程池的线程数量已经超过了最大容量，返回false</span><br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                <span class="hljs-comment">//如果以核心线程数作界限，那么就看当前线程数是否超过了核心线程数</span><br>                <span class="hljs-comment">//只有在队列满之后core才会为false</span><br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">//线程数没超标，那么添加线程</span><br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            <span class="hljs-comment">//cas失败说明有多个线程在同时添加任务</span><br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-comment">//如果线程池的状态发生改变，那么retry</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;<br>    Worker w = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//生成一个Worker</span><br>        w = <span class="hljs-keyword">new</span> Worker(firstTask);<br>        <span class="hljs-keyword">final</span> Thread t = w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck while holding lock.</span><br>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                <span class="hljs-comment">// shut down before lock acquired.</span><br>                <span class="hljs-keyword">int</span> rs = runStateOf(ctl.get());<br>                <span class="hljs-comment">//检查线程池是否已经关闭</span><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;<br>                    <span class="hljs-comment">//判断线程工厂创建线程是否成功</span><br>                    <span class="hljs-keyword">if</span> (t.isAlive())<br>                        <span class="hljs-comment">//预先检查新worker的状态</span><br>                        <span class="hljs-comment">//如果在我们没有启动线程的情况，线程就alive肯定要抛出异常</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();<br>                    <span class="hljs-comment">//将新生成的worker添加到线程池中，其实就是一个HashSet</span><br>                    workers.add(w);<br>                    <span class="hljs-keyword">int</span> s = workers.size();<br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                <span class="hljs-comment">//启动线程</span><br>                t.start();<br>                workerStarted = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中逻辑还是比较清晰的，在生成线程后如果能成功启动，那么则返回true，否则会调用<code>addWorkerFailed</code>进行回滚操作。</p><p>值得注意的是在访问<code>worker</code>集合<code>workers</code>的时候，需要保证互斥访问。具体原理在预备知识中已经介绍过。</p><h2 id="2-线程工作流程"><a href="#2-线程工作流程" class="headerlink" title="2. 线程工作流程"></a>2. 线程工作流程</h2><p>在启动<code>worker</code>之后，最后在<code>worker</code>的<code>run()</code>方法中会调用<code>runWorker(Worker)</code>实现不断的从阻塞队列中获取任务，并调用任务的<code>run()</code>执行。</p><p>值得注意的是：在当前<code>worker</code>获取到新任务时，会使用自身的不可重入独占锁进行一个加锁操作，这个操作标志着当前<code>worker</code>已经开始执行具体的任务了，暂时屏蔽线程池发出的中断。</p><p><code>runWorker(Worker)</code>代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runWorker</span><span class="hljs-params">(Worker w)</span> </span>&#123;<br>    Thread wt = Thread.currentThread();<br>    Runnable task = w.firstTask;<br>    w.firstTask = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//需要首先解锁一次，因为一个worker最初始的状态为-1，这么做是为了防止</span><br>    <span class="hljs-comment">//worker在执行runWorker之前就收到了中断，例如在主函数关闭了线程池，</span><br>    w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>    <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//如果获取不到新的任务，那么就会退出循环</span><br>        <span class="hljs-comment">//getTask在线程池至少处于shutdown时，会返回null</span><br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = getTask()) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//使用worker的锁，表示当前worker已经获得新任务，暂时屏蔽中断</span><br>            w.lock();<br><br>            <span class="hljs-comment">//如果线程池进入stopping状态，那么必须保证当前worker被中断</span><br>            <span class="hljs-comment">//否则，必须保证当前worker不能被中断</span><br>            <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>            <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>            <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>            <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                    <span class="hljs-comment">//这里做的是二次检查，有可能用户突然调用了shutdownNow</span><br>                    (Thread.interrupted() &amp;&amp;<br>                    runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())<br>                wt.interrupt();<br>            <span class="hljs-keyword">try</span> &#123;<br>                beforeExecute(wt, task);<br>                Throwable thrown = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//执行任务自己的run方法</span><br>                    task.run();<br>                <span class="hljs-comment">//捕捉任务可能抛出的异常，然后从线程池抛出</span><br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(x);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    afterExecute(task, thrown);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-keyword">null</span>;<br>                w.completedTasks++;<br>                w.unlock();<br>            &#125;<br>        &#125;<br>        completedAbruptly = <span class="hljs-keyword">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//如果一个线程无法再获取新的任务，那么就会将当前线程销毁</span><br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-1-获取新任务的流程"><a href="#2-1-获取新任务的流程" class="headerlink" title="2.1 获取新任务的流程"></a>2.1 获取新任务的流程</h3><p>每当<code>worker</code>完成一个任务后，会尝试调用<code>getTask()</code>从我们提供的阻塞队列中获取新的任务。当阻塞队列为空时，该函数可以无限时等待或者有限等待，这需要根据是否允许核心线程过期来抉择。</p><p>如果该函数返回null就表示当前worker已经结束使命了，可以终结了。返回null的情况很多：</p><ol><li>线程池已经处于STOPING状态</li><li>线程池已经处于SHUTDOWN状态并且阻塞队列为空</li><li>线程数已经超过最大值</li><li>当前worker等待新任务的时间过长，也就是说等待的时长超过了一个核心线程的存活时长</li></ol><p>否则返回一个新的任务具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title">getTask</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> timedOut = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-keyword">int</span> rs = runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-comment">//如果线程已经至少处于SHUTDOWN状态并且empty为空，因为后续都不可能有新任务提交，那么直接返回null</span><br>        <span class="hljs-comment">//表示当前worker的工作可以结束了</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            <span class="hljs-comment">//将线程数减1</span><br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br><br>        <span class="hljs-comment">// Are workers subject to culling?</span><br>        <span class="hljs-keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;<br><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Runnable r = timed ?<br>                <span class="hljs-comment">//收到中断时take会抛出InterruptException</span><br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-2-worker退出流程"><a href="#2-2-worker退出流程" class="headerlink" title="2.2 worker退出流程"></a>2.2 worker退出流程</h3><p>从上面<code>runWorker(Worker)</code>的处理流程可以看到，当一个<code>Worker</code>无法获得新任务时，那么就会调用<code>processWorkerExit(Worker,boolean)</code>将当前<code>Worker</code>移出线程集合，并根据当前池内的线程数量来决定是否要添加新的<code>Worker</code>，实现逻辑如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-keyword">boolean</span> completedAbruptly)</span> </span>&#123;<br>    <span class="hljs-comment">//如果工作线程的结束是因为用户的代码产生了异常</span><br>    <span class="hljs-keyword">if</span> (completedAbruptly) <span class="hljs-comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span><br>        decrementWorkerCount();<br><br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    <span class="hljs-comment">//对线程集合进行互斥访问</span><br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        completedTaskCount += w.completedTasks;<br>        <span class="hljs-comment">//将当前线程移出工作队列</span><br>        workers.remove(w);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br><br>    <span class="hljs-comment">//尝试关闭线程池</span><br>    tryTerminate();<br><br>    <span class="hljs-keyword">int</span> c = ctl.get();<br>    <span class="hljs-comment">//如果当前线程池处于RUNNING/SHUTDOWN状态</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 那么这里可能会产生一个问题：如果处于SHUTDOWN状态，我们应该将所有的Worker移出集合</span><br><span class="hljs-comment">    * 但是SHUTDOWN是可以通过下面的if条件，那么最后又会执行addWorker()，又往集合中添加一个新的worker</span><br><span class="hljs-comment">    * 那岂不是集合内的worker永远都无法彻底移出？</span><br><span class="hljs-comment">    * 其实这种担心是多虑的，因为addWorker()会首先检查当前线程池的状态，如果为SHUTDOWN，直接返回false</span><br><span class="hljs-comment">    * 并不会构造新的worker</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;<br>        <span class="hljs-comment">//如果工作线程是正常地结束</span><br>        <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;<br>            <span class="hljs-keyword">int</span> min = allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;<br>            <span class="hljs-comment">//如果核心线程有失效时间限制并且阻塞队列不为空</span><br>            <span class="hljs-comment">//那么线程池中至少要保留一个线程</span><br>            <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.isEmpty())<br>                min = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// replacement not needed</span><br>        &#125;<br>        <span class="hljs-comment">//如果线程数量小于min，那么需要补上一个新的worker</span><br>        addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在将无法获得任务的线程移出集合后，会根据当前是否允许核心线程过期获得线程池的最低线程数量：</p><ol><li>如果当前线程数量仍然不小于最低限度，直接返回即可，不需要重新补充<code>Worker</code></li><li>如果当前线程数小于最低限度，那么需要最后调用<code>addWorker()</code>重新补充一个<code>Worker</code></li></ol><h2 id="3-线程池终止流程"><a href="#3-线程池终止流程" class="headerlink" title="3. 线程池终止流程"></a>3. 线程池终止流程</h2><p><strong>对于线程池来说，关闭线程池（shutdown）和终止线程池（terminate）完全是两码事</strong>。所谓的关闭，是指线程池不再接受新的任务，而终止则是线程池中的所有工作线程都已经正确地关闭。</p><h3 id="3-1-shutdown-的执行逻辑"><a href="#3-1-shutdown-的执行逻辑" class="headerlink" title="3.1 shutdown()的执行逻辑"></a>3.1 shutdown()的执行逻辑</h3><p><code>ThreadPoolExectuor</code>提供了两种方法<code>shutdown</code>和<code>shutdownNow</code>用来关闭线程池。对于前者，它会保证已经提交到阻塞队列的任务被执行，并不是等到任务都执行完毕才会关闭线程池。在关闭的流程中，一直有一个问题困扰着我：为什么要通过调用<code>interrupt()</code>抛出中断当作线程池关闭的信号？带着这个问题，我首先梳理了<code>shutdown()</code>的逻辑。首先我们来看看<code>shutdown()</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//检查是否有权限关闭线程池</span><br>        checkShutdownAccess();<br>        <span class="hljs-comment">//将当前线程池升级到SHUTDOWN状态</span><br>        advanceRunState(SHUTDOWN);<br>        <span class="hljs-comment">//中断空闲的线程</span><br>        interruptIdleWorkers();<br>        <span class="hljs-comment">//为周期任务线程池准备的hook函数</span><br>        onShutdown();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    <span class="hljs-comment">//尝试真正地终止线程</span><br>    tryTerminate();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从源码中我们得知：当调用<code>shutdown()</code>方法后，首先会将线程池状态转化到SHUTDOWN。然后中断空闲的线程。那么这里就有两个问题：</p><ol><li>为什么要中断空闲线程？</li><li>为什么关闭线程池需要通过中断这个操作？</li></ol><p>对于第一个问题，先说说我的理解：所谓的关闭关闭线程池就是将每个工作线程正确关闭，又因为<code>shutdown()</code>不影响正在执行任务的线程，所以就先关闭空闲的线程。那么我们来看看<code>interruptIdleWorkers()</code>到底是如何运作的：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> onlyOne)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//遍历工作线程集合，找出空闲的线程并抛出中断</span><br>        <span class="hljs-keyword">for</span> (Worker w : workers) &#123;<br>            Thread t = w.thread;<br>            <span class="hljs-comment">//如果线程没有被中断并且能够获取worker的独占锁</span><br>            <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    t.interrupt();<br>                &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    w.unlock();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (onlyOne)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在分析<code>Worker</code>的工作流程时，曾说到，当一个<code>worker</code>正在执行任务时，会使用自身的独占不可重入锁上锁。那么在查询空闲<code>worker</code>时就利用了这个特点：<code>w.tryLock()</code>成功就说当前<code>worker</code>没有上锁，那也就是没有执行任务，自然可以关闭了。</p><p>那么这里的关闭的操作实际上调用当前<code>worker</code>的<code>interrupt()</code>函数发出一个中断，why？我们思考如下一个场景：</p><p>首先我们中断的都是空闲线程，那么空闲线程都在干嘛？是不是都在等待获取新的任务？那么如何等待？也就是通过调用阻塞队列的<code>take()</code>方法（无限等待场景下），当我们发生一个中断时，<code>take()</code>方法会抛出一个<code>InterruptException</code>，会在<code>getTask()</code>方法中被捕获。</p><p>捕获之后，也就说明被中断的<code>worker</code>已经被唤醒了。那么会重新执行循环，在循环初始部分，会判断当前线程池的状态，如果为SHUTDOWN或者类似的，会返回null。返回null表示什么？表示当前<code>worker</code>可以结束使命了，那么会跳出<code>runWorker()</code>中的循环，执行<code>processWorkerExit(Worker,boolean)</code>。在<code>processWorkerExit(Worker,boolean)</code>中，又会调用<code>tryTerminate()</code>尝试终止线程池。该函数的任务就是当线程池数量为0，将线程池状态转化为TIDYING状态，并执行hook函数<code>terminated()</code>。最后转化为TERMINATED状态。</p><p>值得注意的是，<code>tryTerminate()</code>中会调用<code>interruptIdleWorkers(ONLY_ONE)</code>传播线程池准备终止的信息。那么怎么传播呢？我们观察上述<code>interruptIdleWorkers()</code>函数的源码，因为我们传入的参数为true，那么会随机中断一个空闲线程<code>worker</code>。而空闲线程在被移出线程集合后，又会调用<code>processWorkerExit(Worker,boolean)</code>。周而复始，最后所有的空闲工作线程都会收到中断。<code>tryTerminate()</code>逻辑如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//这个方法只能在可能需要终止线程池的时候调用，例如剔除无用worker或者在shutdown状态移出队列任务</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryTerminate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-comment">//如果线程池处于RUNNING状态</span><br>        <span class="hljs-comment">//如果线程池正在处于终止状态</span><br>        <span class="hljs-comment">//或者线程池处于SHUTDOWN并且阻塞队列不为空</span><br>        <span class="hljs-comment">//那么就不需要再终止了，终止一次就够了</span><br>        <span class="hljs-keyword">if</span> (isRunning(c) ||<br>            runStateAtLeast(c, TIDYING) ||<br>            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//走到这说明线程池没有任务需要执行了，处于需要终止的状态</span><br><br>        <span class="hljs-comment">//如果线程数量不为0，那么就尝试中断最多一个空闲线程，并传播这个中断状态</span><br>        <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Eligible to terminate</span><br>            interruptIdleWorkers(ONLY_ONE);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//如果池中的线程数量为0，那么尝试将线程池状态转化为TIDYING</span><br>        <span class="hljs-comment">//如果转化成功，则会执行hook函数terminated()，并把线程池状态转化为TERMINATED</span><br>        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    terminated();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));<br>                    <span class="hljs-comment">//唤醒在awaitTermination条件上等待的线程</span><br>                    termination.signalAll();<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>        <span class="hljs-comment">// else retry on failed CAS</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么这里又有一个问题了，上面中断的都是空闲工作线程，如果我们执行<code>shutdown()</code>时，没有空闲线程怎么办？正在执行任务的线程如何被回收？岂不是会在<code>runWorker()</code>中，因为调用<code>getTask()</code>一直被阻塞直到获取新的任务，但是又永远都不会有新任务？我想了很久，最后发现答案竟然在<code>getTask()</code>的源码中。当我们的工作线程执行完当前任务后，会再次调用<code>getTask()</code>，而<code>getTask()</code>在一开始就会判断当前线程池的状态，如果状态为SHUTDOWN并且阻塞队列为空，那么直接返回，不会被阻塞。从而最后也会执行<code>processWorkerExit(Worker,boolean)</code>，传播中断状态。</p><h3 id="3-2-shutdownNow的区别"><a href="#3-2-shutdownNow的区别" class="headerlink" title="3.2 shutdownNow的区别"></a>3.2 shutdownNow的区别</h3><p>对于<code>shutdownNow()</code>方法，跟<code>shutdown()</code>流程差不多。唯一不同的是：<code>shutdownNow()</code>不管<code>worker</code>有没有执行任务，只要<code>worker</code>执行过<code>runWorker(Worker)</code>函数，就发出一个中断请求。我们需要注意的是：中断请求对于空闲线程来说是一定有限的；对于正在执行任务的线程，这需要用户任务的配合，也就说用户任务能够处理中断才能结束未完成的任务。后续的流程就跟<code>shutdown()</code>几乎一样。调用<code>tryTerminate()</code>尝试终止线程池。<code>shutdownNow()</code>方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Attempts to stop all actively executing tasks, halts the</span><br><span class="hljs-comment">* processing of waiting tasks, and returns a list of the tasks</span><br><span class="hljs-comment">* that were awaiting execution. These tasks are drained (removed)</span><br><span class="hljs-comment">* from the task queue upon return from this method.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* &lt;p&gt;This method does not wait for actively executing tasks to</span><br><span class="hljs-comment">* terminate.  Use &#123;<span class="hljs-doctag">@link</span> #awaitTermination awaitTermination&#125; to</span><br><span class="hljs-comment">* do that.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* &lt;p&gt;There are no guarantees beyond best-effort attempts to stop</span><br><span class="hljs-comment">* processing actively executing tasks.  This implementation</span><br><span class="hljs-comment">* cancels tasks via &#123;<span class="hljs-doctag">@link</span> Thread#interrupt&#125;, so any task that</span><br><span class="hljs-comment">* fails to respond to interrupts may never terminate.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span> </span>&#123;<br>List&lt;Runnable&gt; tasks;<br><span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>mainLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    checkShutdownAccess();<br>    advanceRunState(STOP);<br>    interruptWorkers();<br>    tasks = drainQueue();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    mainLock.unlock();<br>&#125;<br>tryTerminate();<br><span class="hljs-keyword">return</span> tasks;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="4-内置线程池"><a href="#4-内置线程池" class="headerlink" title="4. 内置线程池"></a>4. 内置线程池</h2><p>JUC中提供了四种基于<code>ThreadPoolExecutor</code>的内置线程池：</p><ol><li><p><strong>newFixedThreadPool</strong>：核心线程数和最大线程数相等的线程，阻塞队列无限长度。也就是说线程池的线程数量固定</p></li><li><p><strong>newCachedThreadPool</strong>：核心线程数为0的线程池，并且阻塞队列不存储任务。也就是说该线程池只会使用非核心线程来处理任务，如果超过60秒等不到新的任务，那么则会回收当前线程</p></li><li><p><strong>newSingleThreadExecutor</strong>：线程池的线程数量为1，阻塞队列无限长度。也就是线程数量固定为1的线程池。该线程池能够保证任务串行地完成</p></li><li><p><strong>newScheduledThreadPool</strong>：核心线程数固定地的周期任务线程池</p></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><p><a href="https://segmentfault.com/a/1190000016586578">Java多线程进阶（三九）—— J.U.C之executors框架：executors框架概述</a></p></li><li><p><a href="https://javamana.com/2021/02/20210228205934972L.html">Java并发之ThreadPoolExecutor源码解析（三）</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Executor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CopyOnWrite容器分析</title>
    <link href="/2021-06-03/CopyOnWrite-collections-analysis.html"/>
    <url>/2021-06-03/CopyOnWrite-collections-analysis.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-预备知识"><a href="#1-预备知识" class="headerlink" title="1. 预备知识"></a>1. 预备知识</h2><p><code>J.U.C</code>包提供了两种copy-on-wirte容器：<code>CopyOnWriteList</code>与<code>CopyOnWriteSet</code>。不了解copy-on-write技术的，可以去看<a href="http://wsfdl.com/algorithm/2016/09/29/Copy_on_write.html">理解 Copy On Write 技术</a>。</p><p><code>CopyOnWriteList</code>是<code>ArrayList</code>线程安全的版本。所有更改<code>CopyOnWriteList</code>内容的操作都基于copy-on-write，对于同一个元素，插入操作happens before读取操作。而<code>CopyOnWriteSet</code>与我们常见的set不同，它内部不是通过计算hash值找到对应的元素，而是内部维护了一个<code>CopyOnWriteList</code>。</p><p>本篇文章将分别解析<code>CopyOnWriteList</code>和<code>CopyOnWriteSet</code>。</p><h2 id="2-CopyOnWriteList解析"><a href="#2-CopyOnWriteList解析" class="headerlink" title="2. CopyOnWriteList解析"></a>2. CopyOnWriteList解析</h2><p>了解一个类，第一步应该是学习它的继承体系。<code>CopyOnWriteList</code>的继承体系比较简单，实现了<code>utils</code>包下的<code>List</code>接口，并支持随机访问、序列化、克隆等功能，继承关系如下所示：</p><p><img src="./images/CopyOnWriteList-arch.png" alt="CopyOnWriteList-arch"></p><p><code>CopyOnWriteList</code>本身的属性也比较简单，如下所示：</p><p><img src="./images/CopyOnWriteList-fields.png" alt="CopyOnWriteList-fields"></p><p>一般我们关注是独占锁与内部数组。内部数组是真正存储元素的地方，而独占锁保证了各线程互斥地访问。</p><h3 id="2-1-添加操作"><a href="#2-1-添加操作" class="headerlink" title="2.1 添加操作"></a>2.1 添加操作</h3><p><code>CopyOnWriteList</code>的增加逻辑主要由<code>add</code>方法完成，对于每次添加，都会上锁，否则会造成多个线程同时添加时复制出多份原数组。我这里就不细说了，下面的代码一看就懂：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Appends the specified element to the end of this list.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> e element to be appended to this list</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; (as specified by &#123;<span class="hljs-doctag">@link</span> Collection#add&#125;)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object[] elements = getArray();<br>        <span class="hljs-keyword">int</span> len = elements.length;<br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        newElements[len] = e;<br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-2-删除操作"><a href="#2-2-删除操作" class="headerlink" title="2.2 删除操作"></a>2.2 删除操作</h3><p>对于删除逻辑，其实和添加逻辑差不多。第一步先上锁，然后删除目标元素，最后再将剩余元素拷贝到新数组中，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Removes the element at the specified position in this list.</span><br><span class="hljs-comment">* Shifts any subsequent elements to the left (subtracts one from their</span><br><span class="hljs-comment">* indices).  Returns the element that was removed from the list.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object[] elements = getArray();<br>        <span class="hljs-keyword">int</span> len = elements.length;<br>        E oldValue = get(elements, index);<br>        <span class="hljs-keyword">int</span> numMoved = len - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//拷贝数组</span><br>        <span class="hljs-keyword">if</span> (numMoved == <span class="hljs-number">0</span>)<br>            setArray(Arrays.copyOf(elements, len - <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">else</span> &#123;<br>            Object[] newElements = <span class="hljs-keyword">new</span> Object[len - <span class="hljs-number">1</span>];<br>            System.arraycopy(elements, <span class="hljs-number">0</span>, newElements, <span class="hljs-number">0</span>, index);<br>            System.arraycopy(elements, index + <span class="hljs-number">1</span>, newElements, index,<br>                                numMoved);<br>            setArray(newElements);<br>        &#125;<br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-3-查询操作"><a href="#2-3-查询操作" class="headerlink" title="2.3 查询操作"></a>2.3 查询操作</h3><p>查询可以通过两种方法：</p><ol><li><code>get(int)</code>方法</li><li>迭代器</li></ol><p>第一种方法没什么好说的，不用上锁，直接读取即可，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> get(getArray(), index);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">get</span><span class="hljs-params">(Object[] a, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (E) a[index];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>迭代器遍历的方式还稍微有趣一点，<code>CopyOnWriteList</code>的迭代器会对当前内部数组做一个快照，所谓的快照并不是指真正的复制一份，而是持有一个旧数组的引用，在逻辑上做了一个“snapshot”，所以不会抛出<code>ConcurrentModificationException</code>，<strong>但是仍然不支持在迭代器修改</strong>。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">COWIterator</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">ListIterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/** Snapshot of the array */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] snapshot;<br>    <span class="hljs-comment">//游标</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cursor;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">COWIterator</span><span class="hljs-params">(Object[] elements, <span class="hljs-keyword">int</span> initialCursor)</span> </span>&#123;<br>        cursor = initialCursor;<br>        <span class="hljs-comment">//持有旧数组的引用，迭代器只会遍历旧数组的元素</span><br>        snapshot = elements;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-CopyOnWriteSet解析"><a href="#3-CopyOnWriteSet解析" class="headerlink" title="3. CopyOnWriteSet解析"></a>3. CopyOnWriteSet解析</h2><p><code>CopyOnWriteSet</code>通过内部维护的<code>CopyOnWriteList</code>实现了copy-on-write，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CopyOnWriteArraySet</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSet</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">5457747651344034263L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates an empty set.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CopyOnWriteArraySet</span><span class="hljs-params">()</span> </span>&#123;<br>        al = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么<code>CopyOnWriteSet</code>的插入、查询、操作完全依赖<code>CopyOnWriteList</code>。根本没有用到哈希的概念，所以这里就不再赘述了。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>CopyOnWriteArrayList的思想和实现整体上还是比较简单，它适用于处理“读多写少”的并发场景。通过上述对CopyOnWriteArrayList的分析，读者也应该可以发现该类存在的一些问题：</p><ol><li><p>内存的使用<br>由于CopyOnWriteArrayList使用了“写时复制”，所以在进行写操作的时候，内存里会同时存在两个array数组，如果数组内存占用的太大，那么可能会造成频繁GC,所以CopyOnWriteArrayList并不适合大数据量的场景。</p></li><li><p>数据一致性<br>CopyOnWriteArrayList只能保证数据的最终一致性，不能保证数据的实时一致性——读操作读到的数据只是一份快照。所以如果希望写入的数据可以立刻被读到，那CopyOnWriteArrayList并不适合。</p></li></ol><p>而CopyOnWriteSet因为内部维护了CopyOnWriteList，所以二者的优缺点差不多。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://coolshell.cn/articles/11175.html#%E4%BB%80%E4%B9%88%E6%98%AFCopyOnWrite%E5%AE%B9%E5%99%A8">JAVA中的COPYONWRITE容器</a></li><li><a href="https://segmentfault.com/a/1190000016214572">Java多线程进阶（二七）——J.U.C之collections框架：CopyOnWriteArrayList</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>concurrent collections</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BlockingQueue接口分析</title>
    <link href="/2021-06-03/interface-BlockingQueue-analysis.html"/>
    <url>/2021-06-03/interface-BlockingQueue-analysis.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><p><code>BlockingQueue</code>接口，提供了一组集合，一般用在生产者消费者模式中。它能搞保证在多线程环境下：当队列为空时，消费者线程会等待直到队列不空；当队列满时，生产者会等待直到队列不满。该接口提供了四种存储与删除模式：</p><table><thead><tr><th>/</th><th>操作失败抛出异常</th><th>操作失败返回特殊值</th><th>操作失败阻塞线程</th><th>操作具有时间限制</th></tr></thead><tbody><tr><td>插入操作</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>删除操作</td><td>remove()</td><td>poll(e)</td><td>take(e)</td><td>poll(time,unit)</td></tr><tr><td>查询操作</td><td>element()</td><td>peek(e)</td><td>/</td><td>/</td></tr></tbody></table><p>并且<code>BlockingQueue</code>和<code>ConcurrentHashMap</code>一样不允许插入<code>null</code>，因为<code>null</code>代表着<code>poll()</code>方法失败。同时对于同一元素，<code>BlockingQueue</code>的插入操作happens before获取操作。</p><h2 id="2-体系架构"><a href="#2-体系架构" class="headerlink" title="2. 体系架构"></a>2. 体系架构</h2><p><code>BlockingQueue</code>接口继承自<code>utils</code>包下的<code>Queue</code>接口，如下所示：</p><p><img src="./images/BlockingQueue-arch.png" alt="BlockingQueue-arch"></p><p>可以看到，所以的阻塞队列都继承了<code>utils</code>包下的抽象实现类<code>AbstracQueue</code>（负责实现一些队列的核心方法）。阻塞队列的种类非常丰富，我将其按照功能划分为三类：</p><ol><li>普通的阻塞队列：所谓的普通阻塞队列，它们的区别只是底层使用的存储结构不同<ul><li><code>LinkedBlockingQueue</code>:底层存储结构为链表</li><li><code>ArrayBlockingQueue</code>：底层存储为循环数组</li><li><code>PriorityBlockingQueue</code>：具备阻塞功能的优先级队列</li><li><code>LinkedBlockingDeque</code>：底层存储结构为链表的双向阻塞队列</li></ul></li><li>转移队列：消费者线程和生产者线程一一匹配，如果还没有消费，那么会将生产者阻塞在队列中，直到有匹配的消费者将节点取出<ul><li><code>LinkedTransferQueue</code></li><li><code>SynchronousQueue</code></li></ul></li><li>延迟队列：队列中的节点只有经过一定延时才能取出、<ul><li><code>DelayQueue</code></li><li><code>DelayedWorkQueue</code></li></ul></li></ol><p>划分标准还有很多，可以按照有锁、无锁、队列有限无限来区分，这里我直接抄个别人的，<a href="https://segmentfault.com/a/1190000016460411">分类来源</a>：</p><p>|   队列特性   | 有界队列  |  似无界队列  |  无界队列  |  特殊队列  |<br>|  —-  | —-  | —-  | —-  | —-  | —-  |<br>| 有锁算法  | ArrayBlockingQueue（单锁） | LinkedBlockingQueue（双锁），LinkedBlockingDeque（双锁） | / | PriorityBlockingQueue（单锁），DelayQueue（单锁） |<br>| 无锁算法  | / | / | / | LinkedTransferQueue | SynchronousQueue |</p><p>其中所谓的无锁是指实现中没有显示的使用其他同步锁，只使用了CAS；而有锁则一般都是使用<code>ReentrantLock</code>。</p><h2 id="3-已声明的方法"><a href="#3-已声明的方法" class="headerlink" title="3. 已声明的方法"></a>3. 已声明的方法</h2><p><code>BlockingQueue</code>与普通队列接口<code>Queue</code>所声明的抽象方法大差不差，都规定了一些增删查改的操作，如下所示：</p><p><img src="./images/BlockingQueue-methods.png" alt="BlockingQueue-methods"></p><p>其中一个比较新奇的就是<code>drainTo()</code>方法，该方法的主要作用就是将阻塞队列中的节点转移到一个集合中，如果在转移的时候出现错误，那么节点有可能存在于<code>BlockingQueue</code>和<code>Collection</code>或者都不存在或者仅存在于一处。并且在转移的时候不支持对传入的<code>Collection</code>进行修改。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>BlockingQueue的典型使用场景就是生产者与消费者模式，它的实现种类繁杂，后续我将简要分析各种类型的代表队列，文章列表如下所示：</p><ol><li>普通阻塞队列：<a href="./LinkedBlockingQueue-analysis.md">LinkedBlockingQueue源码分析</a></li><li>转移队列：<ul><li><a href="./LinkedTransferQueue-analysis.md">LinkedTransferQueue源码分析</a></li><li><a href="./SynchronousQueue-analysis.md">SynchronousQueue源码分析</a></li></ul></li><li>延迟队列：<a href="./DelayQueue-analysis.md">DelayQueue源码分析</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>concurrent collections</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Exectuor框架解析</title>
    <link href="/2021-06-03/Executor-interface.html"/>
    <url>/2021-06-03/Executor-interface.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-Executor接口"><a href="#1-Executor接口" class="headerlink" title="1. Executor接口"></a>1. Executor接口</h2><p>在JUC包中，还提供了Executor框架用来实现线程池，我们经常使用的线程池都是从Executor派生而来。我们可以看看整个Executor框架的继承结构：</p><p><img src="images/executor-framework.png" alt="executor-framework"></p><p>那么在这个框架中，我们第一步应该需要了解它的核心接口<code>Executor</code>。这个接口的作用在它的注释中说的很清楚：</p><blockquote><p>An object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An Executor is normally used instead of explicitly creating threads. For example, rather than invoking new Thread(new(RunnableTask())).start() for each of a set of tasks</p></blockquote><p>这个接口的作用就是让用户专注于线程的任务，至于线程怎么调用的，如何运行的，用户并不需要关心。具体的实现类可以任意实现线程之间的协作。唯一的抽象方法就是<code>execute</code>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Executor</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Executes the given command at some time in the future.  The command</span><br><span class="hljs-comment">     * may execute in a new thread, in a pooled thread, or in the calling</span><br><span class="hljs-comment">     * thread, at the discretion of the &#123;<span class="hljs-doctag">@code</span> Executor&#125; implementation.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> command the runnable task</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException if this task cannot be</span><br><span class="hljs-comment">     * accepted for execution</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NullPointerException if command is null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-ExecutorService接口"><a href="#2-ExecutorService接口" class="headerlink" title="2. ExecutorService接口"></a>2. ExecutorService接口</h2><p>那么对于Executor的增强类接口<code>ExecutorService</code>呢？我们看看它的注释：</p><blockquote><p>An Executor that provides methods to manage termination and methods that can produce a Future for tracking progress of one or more asynchronous tasks.<br>An ExecutorService can be shut down, which will cause it to reject new tasks. Two different methods are provided for shutting down an ExecutorService. The shutdown method will allow previously submitted tasks to execute before terminating, while the shutdownNow method prevents waiting tasks from starting and attempts to stop currently executing tasks. Upon termination, an executor has no tasks actively executing, no tasks awaiting execution, and no new tasks can be submitted. An unused ExecutorService should be shut down to allow reclamation of its resources.</p></blockquote><p>上述大致就是ExecutorService作为一个Executor，它提供一些方法用来终止当前对象提供服务以及一些方法用于产生一个<strong>Future</strong>表示异步任务执行的结果。并且一个ExecutorService可以被关闭，但是这可能会导致新任务被迫终止。它提供了两类方法用来终止自身。</p><ul><li>第一类是<code>shutdown</code>方法，这类方法会将停止之前已经提交的任务执行完毕</li><li>第二类是<code>shutdownNow</code>方法，这类方法会将已经提交但未执行的任务直接终止，并且尝试对终止正在执行的任务。</li></ul><p>终止后ExecutorService不会存在还在执行的任务，并且也无法提交任务。当我们不再需要ExecutorService时，就应将其关闭，避免资源浪费。</p><p>对ExecutorService有了一个初步的认识后，我们看看它提供的一些核心方法：</p><p><img src="images/ExecutorService.png" alt="ExecutorService"></p><p>其实还有一点可以值得关注，就是上述提到的<code>Future</code>。这其实也是一个顶级接口，简而言之就是用来保存异步线程执行的结果。后续再详细分析。</p><h3 id="2-1-AbstractExecuteService"><a href="#2-1-AbstractExecuteService" class="headerlink" title="2.1 AbstractExecuteService"></a>2.1 AbstractExecuteService</h3><p>对于ExecutorService接口，JUC提供了一个抽象实现类<code>AbstractExecutorService</code>负责实现了一些异步执行任务核心方法的实现，包括<code>submit</code>、<code>invokeAll</code>、<code>invokeAny</code>这三类。并且提供了一个包装函数，能够将提交的任务（callable或者runnable）包装为一个<code>FutureTask</code>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">RunnableFuture&lt;T&gt; <span class="hljs-title">newTaskFor</span><span class="hljs-params">(Callable&lt;T&gt; callable)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FutureTask&lt;T&gt;(callable);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>所谓的<code>FutureTask</code>其实是<code>Future</code>接口的实现类，这个我们后续在分析<code>Future</code>体系的时候再详细介绍。其实我们应该重点关注提交函数<code>submit</code>到底是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>   <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>   RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-keyword">null</span>);<br>   execute(ftask);<br>   <span class="hljs-keyword">return</span> ftask;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从上面得知，<code>submit</code>函数的逻辑比较简单，就是将提交后的<code>Runnable</code>或者<code>callable</code>实现类包装成<code>FutureTask</code>后，还是会调用顶级接口的<code>execute</code>方法来执行一个具体的任务。这里还是无法得知线程到底是如何调度的。</p><h3 id="2-2-ScheduledExecutorService"><a href="#2-2-ScheduledExecutorService" class="headerlink" title="2.2 ScheduledExecutorService"></a>2.2 ScheduledExecutorService</h3><p><code>ScheduledExecutorService</code>接口的最用其实很简单，正如在它的注释中所写的，用来执行一些定时任务或者周期任务：</p><blockquote><p>An ExecutorService that can schedule commands to run after a given delay, or to execute periodically.<br>The schedule methods create tasks with various delays and return a task object that can be used to cancel or check execution. The scheduleAtFixedRate and scheduleWithFixedDelay methods create and execute tasks that run periodically until cancelled.</p></blockquote><p>那么该接口定义四个抽象方法用来提交定时或周期任务：</p><p><img src="images/ScheduleExecutorService.png" alt="ScheduleExecutorService"></p><p>提交任务后同样会返回一个<code>Future</code>接口的实现类<code>ScheduleFuture</code>，根据不同的任务安排，<code>ScheduleFuture</code>代表的含义不同，具体可以查看API文档。</p><h2 id="3-线程池ThreadPoolExecutor"><a href="#3-线程池ThreadPoolExecutor" class="headerlink" title="3. 线程池ThreadPoolExecutor"></a>3. 线程池ThreadPoolExecutor</h2><p><code>ThreadPoolExecutor</code>是一个具体线程池类，它通过继承<code>AbstractExecutorService</code>来实现接口<code>Executor</code>。该类实现了具体调度线程的方法负责完成提交的任务。并且通过一组参数实现了很强的扩展性，包括：</p><ol><li>核心线程数与最大线程数</li><li>预先启动核心线程</li><li>新线程的生产方式</li><li>线程存活时间</li><li>阻塞队列</li><li>任务的拒绝策略</li><li>hook方法（在任务执行前后添加代理方法）</li><li>线程池的终止策略</li></ol><h3 id="3-1-核心线程数"><a href="#3-1-核心线程数" class="headerlink" title="3.1 核心线程数"></a>3.1 核心线程数</h3><p>因为线程池中的线程数量会根据参数<code>corePoolSize</code>和<code>maximumPoolSize</code>的大小进行动态调整。当在方法<code>execute(Runnable)</code>中提交新任务时：</p><ol><li>如果正在运行的线程数量<strong>少于</strong><code>corePoolSize</code>线程时，<strong>即使其他工作线程处于空闲状态</strong>，也会创建一个新线程来处理请求</li><li>如果运行的线程数<strong>大于</strong><code>corePoolSize</code>但小于<code>maximumPoolSize</code>，则<strong>仅在队列已满时才创建新线程</strong>。</li></ol><p>通过将corePoolSize和maximumPoolSize设置为相同的值，可以创建固定大小的线程池。 通过将maximumPoolSize设置为一个本质上不受限制的值（例如Integer.MAX_VALUE），可以允许池容纳任意数量的并发任务。通常，核心和最大池大小仅在构造时设置，但也可以使用setCorePoolSize和setMaximumPoolSize动态更改。</p><h3 id="3-2-预先启动核心线程"><a href="#3-2-预先启动核心线程" class="headerlink" title="3.2 预先启动核心线程"></a>3.2 预先启动核心线程</h3><p>所谓的预先启动核心线程是指：在默认情况下，核心线程的生产条件是有新的任务提交。但是有可能我们在不提交任务的情况下也有启动核心线程的需求。例如假设我们提供的阻塞队列非空，那么在不调用<code>submit</code>提交新任务的前提下，需要手动启动核心线程来处理阻塞队列中的任务。</p><p>那么手动启动核心线程的操作可以通过<code>prestartCoreThread</code>或者<code>prestartAllCoreThreads</code><br>来完成。</p><h3 id="3-3-线程的生产模式"><a href="#3-3-线程的生产模式" class="headerlink" title="3.3 线程的生产模式"></a>3.3 线程的生产模式</h3><p>所谓的线程的生产模式，也就是当我们存活的线程不足以处理提交的任务，那么我们就需要生产新的线程来处理。那么在<code>ThreadPoolExecutor</code>中，维护了一个线程工厂<code>threadFactory</code>来生产线程。</p><p>在Java中，线程工厂有许多种，如下图所示：</p><p><img src="images/ThreadFactory.png" alt="ThreadFactory"></p><p>对于<code>ThreadPoolExecutor</code>来说，采用的是默认的线程工厂<code>DefaultThreadFactory</code>，该线程池创建的所有线程全部都属于同一ThreadGroup中，并且具有相同的NORM_PRIORITY优先级和非守护程序状态。</p><p>通过提供不同的ThreadFactory，可以更改线程的名称，线程组，优先级，守护程序状态等。如果ThreadFactory在通过从newThread返回null返回要求时未能创建线程，执行器将继续执行，但可能无法执行 执行任何任务。 线程应具有“ modifyThread” RuntimePermission。 如果线程池的工作线程或其他线程不具有此许可权，则服务可能会降级：配置更改可能不会及时生效，并且关闭池可能保持在可能终止但未完成的状态。</p><h3 id="3-2-线程的存活时间"><a href="#3-2-线程的存活时间" class="headerlink" title="3.2 线程的存活时间"></a>3.2 线程的存活时间</h3><p>一般来说，线程的存活时间一般用来限制非核心线程的数量。</p><p>如果池当前具有的核心线程数超过corePoolSize，则多余的线程如果在keepAliveTime的时长内都没有处理任务，那么多余的线程将会被关闭。 我们可以使用<code>setKeepAliveTime(long，TimeUnit)</code>方法动态更改此参数。 使用<code>Long.MAX_VALUE TimeUnit.NANOSECONDS</code>可以有使空闲线程永远不会在线程池关闭之前终止。</p><p>对于线程的存活时间，有一点需要我们注意：<strong>只要keepAliveTime值不为零，调用方法<code>allowCoreThreadTimeOut(boolean)</code>可用于将此超时策略应用于核心线程</strong></p><h3 id="3-3-阻塞队列"><a href="#3-3-阻塞队列" class="headerlink" title="3.3 阻塞队列"></a>3.3 阻塞队列</h3><p>阻塞队列主要用来存储多余的任务，它与线程池交互的逻辑如下：</p><ol><li>如果正在运行的线程数量少于<code>corePoolSize</code>，则Executor会添加新线程而不是将任务添加到阻塞队列</li><li>如果正在运行的线程数量不少于<code>corePoolSize</code>，则Executor会选择将新任务添加到阻塞队列而不是创建新线程</li><li>如果阻塞队列已满，那么Executor会选择创建一个新线程。如果总的线程数量大于<code>maximumPoolSize</code>，那么线程池会执行拒绝策略。</li></ol><p>对于阻塞队列如何排队的逻辑，可以细分为三种：</p><ol><li><p><strong>直接交付</strong>。对于工作队列，一个很好的默认选择是SynchronousQueue，它可以将任务移交给线程，而不必另外保留它们。在这里，如果没有立即可用的线程来运行任务，则尝试将其排队的尝试将失败，因此将构造一个新线程。在处理可能具有内部依赖项的请求集时，此策略避免了锁定。直接切换通常需要无限制的maximumPoolSizes以避免拒绝新提交的任务。反过来，当平均而言，命令继续以比其可处理的速度更快到达时，这可能会带来无限线程增长的可能性。</p></li><li><p><strong>无界队列</strong>。使用无界队列（例如，没有预定义容量的LinkedBlockingQueue）将在所有corePoolSize线程繁忙时使新任务在队列中等待。因此，将仅创建corePoolSize线程。 （因此，maximumPoolSize的值没有任何作用。）当每个任务完全独立于其他任务时，这可能是适当的，因此任务不会影响彼此的执行。例如，在网页服务器中。尽管这种排队方式对于消除短暂的请求突发很有用，但它承认当命令平均继续以比处理速度更快的速度到达时，无限制的工作队列增长是可能的。</p></li><li><p><strong>有界队列</strong>。与有限的maximumPoolSizes一起使用时，有界队列（例如ArrayBlockingQueue）有助于防止资源耗尽，但调优和控制起来会更加困难。队列大小和最大池大小可能会相互折衷：使用大队列和小容量线程池可以最大程度地减少CPU使用率，操作系统资源和上下文切换开销，但会导致人为地降低吞吐量。如果任务频繁阻塞（例如都是I/O操作），则系统在完成任务时因为阻塞会花费更多的时间。使用小队列大容量线程池，CPU频繁切换线程的开销也是不可忽略的，这同样会降低吞吐量。</p></li></ol><h3 id="3-4-拒绝任务的策略"><a href="#3-4-拒绝任务的策略" class="headerlink" title="3.4 拒绝任务的策略"></a>3.4 拒绝任务的策略</h3><p>线程池拒绝任务的时机有两种：</p><ol><li>当线程池关闭后，线程会拒绝执行提交的任务</li><li>当线程池的线程数量已经达到最大，并且阻塞队列也没有空间的时候，线程池会拒绝执行提交的任务。</li></ol><p>拒绝的操作由线程池中的<code>RejectedExecutionHandler</code>属性来完成。那么具体的拒绝逻辑又可以分为四种：</p><ol><li><strong>ThreadPoolExecutor.AbortPolicy</strong>：这是线程池的<strong>默认</strong>拒绝策略。该策略在拒绝时会抛出运行时异常RejectedExecutionException。</li><li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>：该策略就是在线程池<strong>未关闭时</strong>直接调用<code>Runnable</code>实现类的<code>run</code>执行任务。这提供了一种简单的反馈控制机制，该机制将减慢新任务的提交速度。</li><li><strong>ThreadPoolExecutor.DiscardPolicy</strong>：直接忽略当前提交的任务</li><li><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong>：如果线程池未关闭，则会抛弃阻塞队列头部的任务，然后重新尝试让线程池执行当前任务（该操作可能再次失败，导致重复执行此操作）。</li></ol><p>当然我们自己也可以实现自定义拒绝策略，不过需要注意，策略只能在阻塞队列容量一定的情况下才生效。</p><h3 id="3-5-可hook方法"><a href="#3-5-可hook方法" class="headerlink" title="3.5 可hook方法"></a>3.5 可hook方法</h3><p><code>ThreadPoolExecutor</code>内部提供了可以被override的<code>beforeExecute(Thread,Runnable)</code>和<code>afterExecute(Runnable,Throwable)</code>，这两个方法会在每个任务执行前后调用。这两个hook函数可以用来执行一些特殊操作。 例如，重新初始化ThreadLocals，收集统计信息或添加日志。 另外，一旦执行程序完全终止，可以终止方法终止以执行需要执行的任何特殊处理。</p><p>并且<code>ThreadPoolExecutor</code>也提供了可被override的<code>terminated()</code>方法。这个方法一般用来进行一些特殊操作（当然只能一次），当Executor被完全关闭的时候。<br>如果钩子或回调方法引发异常，内部工作线程可能进而失败并突然终止。</p><p><strong>当然如果这些hook函数内部抛出了异常，那么工作线程可能会出现不可预知的错误。</strong></p><p>Queue maintenance<br>Method getQueue() allows access to the work queue for purposes of monitoring and debugging. Use of this method for any other purpose is strongly discouraged. Two supplied methods, remove(Runnable) and purge are available to assist in storage reclamation when large numbers of queued tasks become cancelled.</p><h3 id="3-6-线程池的回收"><a href="#3-6-线程池的回收" class="headerlink" title="3.6 线程池的回收"></a>3.6 线程池的回收</h3><p>如果一个线程池没有被引用，并且池内<strong>没有存活线程</strong>的情况下，线程池会自动关闭。那么如何保证在不使用线程池的情况下，池内没有存活线程才是关键。那么这个问题有两种解决方法：</p><ol><li>不设置线程池的核心线程数量，那么对于临时申请的工作线程会自动关闭。</li><li>调用<code>allowCoreThreadTimeOut(boolean)</code>，允许核心线程存在过期机制</li></ol><h2 id="4-系统提供的线程池"><a href="#4-系统提供的线程池" class="headerlink" title="4. 系统提供的线程池"></a>4. 系统提供的线程池</h2><p>可以看到，前文提到线程池的参数是多样化的，那么为了适用于不同的生产环境，JUC提供了一个<code>Executor</code>工厂：<code>Exexutors</code>类，这个类通过预定义不同的参数生产一些适用于不同场景的线程池，包括：</p><ol><li><code>Executors.newCachedThreadPool</code>：无限制线程池，并且可以自动回收</li><li><code>Executors.newFixedThreadPool</code>：线程数量固定</li><li><code>Executors.newSingleThreadExecutor</code>：只有一个线程的线程池</li></ol><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>本篇简要叙述了JUC中的Executor框架，以及两个核心接口<code>Executor</code>、<code>ExecutorService</code>。并且简单介绍了线程池实现类<code>ThreadPoolExecutor</code>的一部分配置参数以及一些内置的线程池。后续我们就需要详细研究<code>ThreadPoolExecutor</code>到底是如何工作的。</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Executor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中断机制</title>
    <link href="/2021-06-03/Interrupt-mechanism.html"/>
    <url>/2021-06-03/Interrupt-mechanism.html</url>
    
    <content type="html"><![CDATA[<p>在多线程环境下，终止一个线程的任务最好的方法是通过中断。而Java的中断类似于通知协作机制，被中断的线程并不会立即停止自己的任务，而是仅仅收到了中断的通知，具体怎么处理收到的中断，这需要用户自己定义。那么为什么说Java的中断类似于通知机制？我们首先需要了解中断到底做了什么。</p><h2 id="1-实施中断"><a href="#1-实施中断" class="headerlink" title="1. 实施中断"></a>1. 实施中断</h2><p>Java中的中断操作只需要调用目标线程的<code>interrupt()</code>方法即可完成。那么这个方法到底做了什么？我们来看看具体的实现源码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Interrupts this thread.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * &lt;p&gt; Unless the current thread is interrupting itself, which is</span><br><span class="hljs-comment">    * always permitted, the &#123;<span class="hljs-doctag">@link</span> #checkAccess() checkAccess&#125; method</span><br><span class="hljs-comment">    * of this thread is invoked, which may cause a &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment">    * SecurityException&#125; to be thrown.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * &lt;p&gt; If this thread is blocked in an invocation of the &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment">    * Object#wait() wait()&#125;, &#123;<span class="hljs-doctag">@link</span> Object#wait(long) wait(long)&#125;, or &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment">    * Object#wait(long, int) wait(long, int)&#125; methods of the &#123;<span class="hljs-doctag">@link</span> Object&#125;</span><br><span class="hljs-comment">    * class, or of the &#123;<span class="hljs-doctag">@link</span> #join()&#125;, &#123;<span class="hljs-doctag">@link</span> #join(long)&#125;, &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment">    * #join(long, int)&#125;, &#123;<span class="hljs-doctag">@link</span> #sleep(long)&#125;, or &#123;<span class="hljs-doctag">@link</span> #sleep(long, int)&#125;,</span><br><span class="hljs-comment">    * methods of this class, then its interrupt status will be cleared and it</span><br><span class="hljs-comment">    * will receive an &#123;<span class="hljs-doctag">@link</span> InterruptedException&#125;.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * &lt;p&gt; If this thread is blocked in an I/O operation upon an &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment">    * java.nio.channels.InterruptibleChannel InterruptibleChannel&#125;</span><br><span class="hljs-comment">    * then the channel will be closed, the thread&#x27;s interrupt</span><br><span class="hljs-comment">    * status will be set, and the thread will receive a &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment">    * java.nio.channels.ClosedByInterruptException&#125;.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * &lt;p&gt; If this thread is blocked in a &#123;<span class="hljs-doctag">@link</span> java.nio.channels.Selector&#125;</span><br><span class="hljs-comment">    * then the thread&#x27;s interrupt status will be set and it will return</span><br><span class="hljs-comment">    * immediately from the selection operation, possibly with a non-zero</span><br><span class="hljs-comment">    * value, just as if the selector&#x27;s &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment">    * java.nio.channels.Selector#wakeup wakeup&#125; method were invoked.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * &lt;p&gt; If none of the previous conditions hold then this thread&#x27;s interrupt</span><br><span class="hljs-comment">    * status will be set. &lt;/p&gt;</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span>  SecurityException</span><br><span class="hljs-comment">    *          if the current thread cannot modify this thread</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@revised</span> 6.0</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@spec</span> JSR-51</span><br><span class="hljs-comment">    */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interrupt</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != Thread.currentThread())<br>        checkAccess();<br><br>    <span class="hljs-keyword">synchronized</span> (blockerLock) &#123;<br>        Interruptible b = blocker;<br>        <span class="hljs-keyword">if</span> (b != <span class="hljs-keyword">null</span>) &#123;<br>            interrupt0();           <span class="hljs-comment">// Just to set the interrupt flag</span><br>            b.interrupt(<span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    interrupt0();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注释很长，我们分开慢慢细品。首先是第一段：</p><blockquote><p>Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.</p></blockquote><p>大意是说：任何一个线程都肯定能中断它自己，如果希望中断别的线程，那么需要通过<code>checkAccess()</code>方法检查权限，并且可能会抛出<code>SecurityException</code>异常。这很好理解。任何一个线程都可能接受到中断。</p><p>接着是第二段：</p><blockquote><p>If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.</p></blockquote><p>上面的注释中提到了两个新鲜玩意，<code>interrupt status</code>(中断状态)和<code>InterruptException</code>。中断状态就是实现中断通知机制的关键。当一个线程被中断后，它的中断标记可能会被改变。为什么说可能？<br>因为有些例外情况只会抛出中断异常而不是设置中断状态。而这些例外情况在第二段的注释已全部声明：如果中断目标是因为调用了以下的方法进入阻塞状态，那么目标线程的中断位会被<strong>清除</strong>，并且目标线程会收到<code>InterruptedException</code>异常：</p><ul><li><code>Object.wait()</code></li><li><code>Object.wait(long)</code></li><li><code>Object.wait(long,int)</code></li><li><code>Thread.join()</code></li><li><code>Thread.join(long)</code></li><li><code>Thread.join(long,int)</code></li><li><code>Thread.sleep(long)</code></li><li><code>Thread.sleep(long,int)</code></li></ul><p>接着是第三、四关于NIO的中断情况：</p><blockquote><p>If this thread is blocked in an I/O operation upon an InterruptibleChannel then the channel will be closed, the thread’s interrupt status will be set, and the thread will receive a java.nio.channels.ClosedByInterruptException.<br>If this thread is blocked in a java.nio.channels.Selector then the thread’s interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector’s wakeup method were invoked.</p></blockquote><p>如果中断目标是因为调用了<code>InterruotibleChannel()</code>而被阻塞，那么当收到中断时channel将被关闭，并且<strong>设置中断目标的中断状态</strong>，同时会收到<code>java.nio.channels.ClosedByInterruptException</code>。<br>或者中断目标是因为调用了<code>channels.Selector()</code>而被阻塞，那么当收到中断时该方法会立即返回，并且<strong>设置中断目标的中断状态</strong>。</p><p>接下来是最后一段：</p><blockquote><p>f none of the previous conditions hold then this thread’s interrupt status will be set.Interrupting a thread that is not alive need not have any effect.</p></blockquote><p>很简单，就是上面的情况除外，其他任何时候发生中断只会设置中断目标的中断标志。例如在运行时发起中断，目标线程只会设置中断标志。</p><h2 id="2-检测中断"><a href="#2-检测中断" class="headerlink" title="2. 检测中断"></a>2. 检测中断</h2><p>而检测中断的方法有两种：<code>interrupted</code>和<code>isInterrupted</code>。这两种方法都是检测当前当前线程的中断状态。唯一的区别就是：<code>interrupted</code>会清除调用线程的中断状态。也就是说如果连续调用两次该方法（在两次调用之间没有发生中断），中断标志一定是<code>false</code>。那么这两个方法一般用在哪里呢？这就跟中断发生的场景有关了，中断发生的情况一般只有两种：</p><ol><li>调用<code>wait</code>阻塞后，发生中断</li><li>线程运行时，发起中断</li></ol><p>对于第一种情况，因为会抛出中断异常，所以我们一般用以下模式检测中断：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// do some task</span><br>            <span class="hljs-comment">// blocked by calling wait/sleep/join</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;  <br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 这里使用break, 可以使我们在线程中断后退出死循环，从而终止线程。</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于第二种情况，因为只会设置中断标志，所以我们一般使用<code>interrupted</code>或者<code>isinterrupted</code>检测中断情况：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//isInterrupted() 用于终止一个正在运行的线程。</span><br>    <span class="hljs-keyword">while</span> (!isInterrupted()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//    do something</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;  <br>            <span class="hljs-comment">// 在这里不做任何处理，仅仅依靠isInterrupted检测异常</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>Java中的中断只是一种通知机制，并不会立即中断目标线程，被中断的线程如何响应中断完全是程序员自己的事。中断机制的核心内容就是中断标志<code>interrupted status</code>与中断异常<code>InterruptException</code>。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://segmentfault.com/a/1190000016083002">Thread类源码解读(3)——线程中断interrupt</a></p>]]></content>
    
    
    <categories>
      
      <category>多线程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interrupt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java内存模型</title>
    <link href="/2021-06-03/JMM.html"/>
    <url>/2021-06-03/JMM.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-内存模型-memory-model"><a href="#1-内存模型-memory-model" class="headerlink" title="1. 内存模型(memory model)"></a>1. 内存模型(memory model)</h2><h3 id="1-1-内存模型是什么"><a href="#1-1-内存模型是什么" class="headerlink" title="1.1. 内存模型是什么"></a>1.1. 内存模型是什么</h3><p>在编译和运行程序时，编译器和CPU都会为了效率而力所能及地对程序进行优化，例如编译器和CPU的指令重排、CPU的流水线执行等操作。但是这种优化不是没有限制的，如果不能及时保证<strong>内存的可见性</strong>，程序就有可能出现错误,这里的可见性是指如果有一个线程A对某个内存地址addr进行了写操作，那么其他线程一定能够看到A对地址addr的操作。</p><p>所以内存模型就应运而生了，它能够保证优化后的程序的执行结果仍然与程序串行执行时一样。其实现原理是保证多线程之间的内存可见性，编译器和CPU需要在不违背内存模型的前提下，尽可能地达到优化的最大程度。这里所说的内存模型是一组规则，是抽象的，而不是像jvm的内存布局是具体存在的。</p><p>内存模型的实现基于内存屏障（memory barrier）。内存屏障分为四种类型：</p><ol><li>LoadLoad</li><li>LoadStore</li><li>StoreStore</li><li>StoreLoad</li></ol><p>在此我仅解释<code>LoadLoad</code>内存屏障的含义，剩余三条可类推：</p><figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm"><span class="hljs-keyword">load</span> <span class="hljs-keyword">x</span><span class="hljs-number">1</span><span class="hljs-comment">;</span><br>LoadLoad memory barrier<br><span class="hljs-keyword">load</span> <span class="hljs-keyword">x</span><span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>LoadLoad表示的内容时load x1的操作必须发生在load x2操作之前。</p><p>这四种类型的内存屏障并不是完全需要，这需要根据底层架构的内存模型来决定。内存模型大体可以分为两种：</p><ul><li>强内存模型：一个CPU核的写操作对剩余的CPU都可见</li><li>若内存模型：该模型需要使用上面提到的所有内存屏障来确保优化操作的正确性</li></ul><p>x86架构采用的就是强内存模型，所以在汇编中最多使用<code>StoreLoad</code>这一种屏障就足够了，其对应的具体汇编指令就是<code>lock</code>。</p><h2 id="2-JMM是什么"><a href="#2-JMM是什么" class="headerlink" title="2. JMM是什么"></a>2. JMM是什么</h2><p>因为每一个架构都有它自己的内存模型，这就可能带来Java程序的移植性问题。所以为了屏蔽底层架构的内存模型的差异性，Java开发团队为Java在多架构的背景下提出了跨平台的、具有移植性的内存模型，即Java memory model。它同样是靠指令中插入内存屏障（memory barrier）来实现的。我们先不谈JMM内存屏障的插入策略。我们思考一个问题，插入策略是如何制定的。</p><p>在JSR-133之后，JMM是一组基于<code>happens before</code>关系（后文简称hb）的规则。hb通过保证<strong>部分</strong>指令的有序性达到内存可见性，并且极大地简化了并发编程的难度。如果<code>操作A hb 操作B</code>，那么编译器、处理器以及内存系统必须保证操作A的结果对操作B可见。</p><h3 id="2-1-happens-before-relation"><a href="#2-1-happens-before-relation" class="headerlink" title="2.1 happens before relation"></a>2.1 happens before relation</h3><p>hb规则总计下面6条（简而言之就是read/write,lock/unlock,start/join threads）：</p><ul><li><p>程序次序规则(single thread rule) ：一个线程内，按照原始书写的<strong>没有被重排序</strong>的代码<strong>控制流</strong>顺序，编码在前面的<code>action</code>（包括内存读写、解锁、上锁等） 先行发生于编码在后面的<code>action</code>(<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.3">action的定义</a>)；<br><img src="images/thread-start-rule.png" alt="single thread rule"></p></li><li><p>锁定规则(monitor lock rule)：对于一个monitor lock的unLock操作 <code>happens before</code> 后面所有的对同一个monitor lock的lock操作；<br><img src="images/monitor-lock-rule.png" alt="monitor lock rule"></p></li><li><p>volatile变量规则(volatile variable rule)：对一个volatile变量的写操作<code>happens before</code>后面所有的对这个变量的读操作；<br><img src="images/volatile-variable-rule.png" alt="volatile-variable-rule"></p></li><li><p>线程启动规则（thread start rule）：Thread对象的start()方法<code>happens before</code>当前被启动线程的<code>run()</code>方法中的每个一个动作；<br><img src="images/thread-start-rule.png" alt="thread-start-rule"></p></li><li><p>线程终结规则（thread join rule）：假定线程A在执行的过程中，通过调用ThreadB.join()等待线程B终止，那么在join()返回后，线程B在run()完成的操作在线程A都可见<br><img src="images/thread-join-rule.png" alt="thread-join-rule"></p></li><li><p>传递规则(thread start rule)：如果操作A<code>happens before</code>操作B，而操作B又<code>happens before</code>操作C，则可以得出操作A<code>happens before</code>操作C；但是如果有 operation1(o1) &amp; operation2(o2) <code>happens before</code> operation3，并不能推导出 o1 <code>happens before</code> o2。所以o1和o2之间有没有重排序JMM并不关心</p></li></ul><p>通过上面六条规则，可以总结出四个方面的hb关系：</p><ol><li>初始化<ul><li>将字段初始化为默认值（例如将int初始化为0、boolean初始化为false）的操作 <code>happens before</code> 任何线程对同一字段地访问操作</li><li>对<code>static final</code>字段的写操作 <code>happens before</code> 任何线程对该字段的读操作</li><li>对<code>non-static final</code>字段的写操作 <code>happens before</code> 该线程后续通过引用访问当前对象同一字段的操作</li></ul></li><li>内存访问<ul><li>对一个monitor lock的unlock操作或者volatile写操作（volatile就相当于unlock操作，因为完成volatile写后，volatile读能够读到新值，就像unlock时，unlock之前的操作对lock操作来说都是可见的） <code>happens before</code> 任意线程对同一个monitor lock的lock操作或者对同一字段的volatile读</li><li>volatile读或者lock操作 <code>happens before</code> 当前线程后续对内存的所有操作</li></ul></li><li>原子操作<ul><li><code>java.utl.concurrent.atmoic.get()</code>方法的效果相当于volatile读，<code>xxxx.set()</code>方法的效果相当于volatile写</li><li><code>weakCompareAndSet</code> <code>happens before</code> 当前线程后续所有对原子字段的操作</li></ul></li><li>线程<ul><li><code>Thread.start()</code>方法之前的所有操作 <code>happens before</code> 新线程<code>run()</code>方法中的所有操作</li><li>任何写操作 <code>happens before</code> 当前线程的终止操作</li></ul></li></ol><p>上面的规则有点难以理解，但是我们要记住一句话：</p><blockquote><p><strong>规则 A hb B，仅表示JMM保证（通过内存屏障实现）A的操作结果能被B看到，并不保证操作A一定在操作B之前发生。</strong><br>那么在JMM保证的基础上，如果（注意是如果）A发生了，那么B一定能看到。我们需要做的就是保证这个“如果”在某些特定情况下变成“必须”。想想如果没有hb规则，那么即使A先于B发生，B也有可能看不到A的操作结果。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">int</span> a=<span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">int</span> b=<span class="hljs-number">2</span>;<br><br></code></pre></div></td></tr></table></figure><p>如果对指令进行重排序后的结果和遵守A hb B的执行是一样的（简而言之就是操作A和B不会发生访问冲突，没有共享内存），那么JVM并不会禁止这样的重排序。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/happens-before.html#:~:text=Happens%2Dbefore%20relationship%20is%20a,another%20action%20in%20different%20thread.&text=Happens%2Dbefore%20is%20not%20just,read%20and%20write%20to%20memory%20.">Java - Understanding Happens-before relationship</a></p></li><li><p><a href="http://gee.cs.oswego.edu/dl/cpj/JMMsynopsis.html">JMM Synopsis</a></p></li><li><p><a href="https://www.waitingforcode.com/java-memory-model/java-memory-model/read">Java memory model</a></p></li><li><p><a href="https://dzone.com/articles/multithreading-and-java-memory">Multithreading and the Java Memory Model</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>多线程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JMM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程的状态转换</title>
    <link href="/2021-06-03/Thread-state-transition.html"/>
    <url>/2021-06-03/Thread-state-transition.html</url>
    
    <content type="html"><![CDATA[<p>因为线程是调度的基本单位，所以线程的状态转换与进程的状态转换是一致的。主要有五个状态：启动、就绪、执行、等待、销毁。这几个状态的转换图如下所示：</p><p><img src="images/java-thread-state.drawio.svg" alt="线程状态转换图"></p><p>可以看到，等待状态只能转换为就绪，再等CPU调度。这是一般的线程状态转换图。</p><p>在java中，又多了几个状态。</p><h2 id="java中的线程状态"><a href="#java中的线程状态" class="headerlink" title="java中的线程状态"></a>java中的线程状态</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">State</span> </span>&#123;<br>    NEW,<br><br>    RUNNABLE,<br><br>    BLOCKED,<br><br>    WAITING,<br><br>    TIMED_WAITING,<br><br>    TERMINATED;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在java中，自定义的线程状态有6个。</p><ul><li><code>NEW</code>:表示线程还未启动</li><li><code>RUNNABLE</code>：就绪或者运行状态</li><li><code>BLOCKED</code>：等待锁</li><li><code>WAITINTG</code>：无限时等待</li><li><code>TIMED_WAITING</code>：有限时间等待</li><li><code>TERMINATED</code>：线程终止</li></ul><h3 id="BLOCKED状态"><a href="#BLOCKED状态" class="headerlink" title="BLOCKED状态"></a>BLOCKED状态</h3><p>进入BOCKED状态是因为需要请求锁资源，注意请求锁资源不影响线程本身的调度，但是如果一直不停的处于BLOCKED,会浪费资源，应当转为等待状态。</p><h3 id="WAITING状态"><a href="#WAITING状态" class="headerlink" title="WAITING状态"></a>WAITING状态</h3><p>进入WAITING状态的方法有三个：</p><ul><li>Object.wait()</li><li>Thread.join():该方法底层就是调用了wait，阻塞了当前线程</li><li>LockSupport.park()：这个方法我也是第一次见，具体含义为：除非获得调用许可，否则禁用当前线程进行线程调度</li></ul><p>进入WAITING状态就不参与CPU的线程调度了，直到系统对线程进行唤醒。那么从WAITING进入RUNNABLE有三个方法。</p><ul><li>Object.notify()</li><li>Object.notifyAll()</li><li>LockSupport.uppark(THread)</li></ul><h3 id="TIMED-WAITING状态"><a href="#TIMED-WAITING状态" class="headerlink" title="TIMED_WAITING状态"></a>TIMED_WAITING状态</h3><p>进入TIMED_WAITING的方法有四个：</p><ul><li><code>Object.wait(long times)</code>：加入参数后表示我这个线程最多等待times毫秒，时间一到，不管锁能不能用，我都会进入RUNNABLE状态参与进程调度。</li><li><code>Thread.join(long time)</code>: 这个方法同理，在底层会调用wait(time)。</li><li><code>Thread。sleep(long time)</code>:指定睡眠时常</li><li><code>LockSupport.parkNanos(long nanos)</code>： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；</li><li><code>LockSupport.parkUntil(long deadline)</code>：同上，也是禁止线程进行调度指定时间；</li></ul><blockquote><p>在调用上面这些方法前，我们不要想，我们是通过哪些对象来调用的方法，而是要思考在哪个线程中会执行调用方法的代码！这样才不容易搞混到底让谁wait，让谁runnable。</p></blockquote><h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>线程转换图如下(<a href="http://concurrent.redspider.group/article/01/4.html">图片来源</a>)：</p><p><img src="images/java-thread-state.png" alt="java线程状态转换图"></p><h4 id="BLOCKED与RUNNABLE的转换"><a href="#BLOCKED与RUNNABLE的转换" class="headerlink" title="BLOCKED与RUNNABLE的转换"></a>BLOCKED与RUNNABLE的转换</h4><p>在java中，就绪和运行都属于RUNNABLE，BLOCKED与RUNNABLE之间的转换是非常简单的，只要一个线程先得到锁，然后另一个线程就会不断尝试取获取锁，这个不断尝试的状态就是<code>BLOCKED</code>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Thread t1=<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;t1 is running&quot;</span>);<br>                lockMethod();<br><br>            &#125;<br>        &#125;);<br><br>        Thread t2=<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;t2 is running&quot;</span>);<br>                lockMethod();<br>            &#125;<br>        &#125;);<br>        t1.start();<br>        t2.start();<br><br>        System.out.println(<span class="hljs-string">&quot;t1 state: &quot;</span>+t1.getState());<br>        System.out.println(<span class="hljs-string">&quot;t2 state:&quot;</span>+ t2.getState());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockMethod</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;in lockMethod&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>上面的代码不一定会出现BLOCKED状态，因为从线程启动到线程执行还是要花点时间的，并且谁先得到锁还不一定，那么如果我们想让第二个线程出现BLOCKED状态怎么办？那么就需要第一个线程必得到锁。那么只需要让主线程睡一会，调用<code>sleep(time)</code>还是<code>wait(time)</code>都行。</p><h4 id="WAITING与RUNNABLE的转换"><a href="#WAITING与RUNNABLE的转换" class="headerlink" title="WAITING与RUNNABLE的转换"></a>WAITING与RUNNABLE的转换</h4><p>进入WAITING状态有三个方法，但是最常用的只用两个，就是<code>wait()</code>和<code>join()</code>方法，wait会释放锁，但是join不会。从WAITING转为RUNNABLE主要有<code>notify()</code>、<code>notifyAll()</code>，注意这个notify，它只是通知等待当前锁的线程，可以醒了，你们可以参与进程调度了，但是不会释放锁直到离开同步区。</p><p>而且如果有多个线程等待的是同一个锁，<code>notify()</code>只会唤醒一个等待锁的线程，至于唤醒的是谁，这就不知道了。同理<code>notifyAll()</code>唤醒所有等待锁的线程，谁抢得到锁，这个也不一定。</p><p>而<code>join()</code>方法其实在调用<code>join(0)</code>，不会释放当前锁，值到这个锁对象代表的线程terminated。因为调用的方式为<code>t1.join()</code>，t1即是Thread对象，也是个锁对象。</p><h4 id="TIMED-WAITING与RUNNABLE的转换"><a href="#TIMED-WAITING与RUNNABLE的转换" class="headerlink" title="TIMED_WAITING与RUNNABLE的转换"></a>TIMED_WAITING与RUNNABLE的转换</h4><p>进入TIMED_WAITING的方法常用的有三个:<code>join(time)``sleep(time)``wait(time)</code>。sleep不会释放锁，join应该会，这里不确定。wait一定会释放锁。</p><h4 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h4><p>进入TERMINATED的方法有三个：</p><ul><li>Thread.interrupt()：中断线程。这里的中断线程并不会立即停止线程，而是设置线程的中断状态为true（默认是flase）；</li><li>Thread.interrupted()：测试当前线程是否被中断。线程的中断状态受这个方法的影响，意思是调用一次使线程中断状态设置为true，连续调用两次会使得这个线程的中断状态重新转为false；</li><li>Thread.isInterrupted()：测试当前线程是否被中断。与上面方法不同的是调用这个方法并不会影响线程的中断状态。</li></ul><p>注意java里的中断也是一种建议，跟设置线程的优先级一样，被通知请求中断的线程到底断不断需要由被请求中断的线程自己决定。可以中断、也可以不中断。</p><p><strong>中断机制和设置优先级一样，完全是个建议!!!</strong></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://concurrent.redspider.group/article/01/4.html">RedSpider</a></p>]]></content>
    
    
    <categories>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>状态转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AtomicInteger源码解析</title>
    <link href="/2021-06-03/AtomicInteger-analysis.html"/>
    <url>/2021-06-03/AtomicInteger-analysis.html</url>
    
    <content type="html"><![CDATA[<p>整数型原子类<code>AtomicInteger</code>，能够保证每次更新时都是原子操作。其中的CAS操作都需要依靠<code>Unsafe</code>类来完成，我们需要关注的一般就是构造方法、增加方法与删除方法。</p><h2 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1. 构造方法"></a>1. 构造方法</h2><p><code>AtomicInteger</code>首先会调用类构造器，初始化当前对象的<code>valueoffset</code>用于进行CAS操作，具体值由volatile变量<code>value</code>负责维护，字段定义如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicInteger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">6214790243416807050L</span>;<br><br>    <span class="hljs-comment">// setup to use Unsafe.compareAndSwapInt for updates</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> valueOffset;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            valueOffset = unsafe.objectFieldOffset<br>                (AtomicInteger.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(ex); &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AtomicInteger</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialValue)</span> </span>&#123;<br>        value = initialValue;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a new AtomicInteger with initial value &#123;<span class="hljs-doctag">@code</span> 0&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AtomicInteger</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    ...<br></code></pre></div></td></tr></table></figure><h2 id="2-增加方法"><a href="#2-增加方法" class="headerlink" title="2. 增加方法"></a>2. 增加方法</h2><p>增加方法与删除方法的逻辑基本一致，就是通过<code>Unsafe</code>类来完成，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Atomically increments by one the current value.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> the previous value</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndIncrement</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-keyword">this</span>, valueOffset, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">decrementAndGet</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-keyword">this</span>, valueOffset, -<span class="hljs-number">1</span>) - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>原子类<code>AtomicBoolean</code>、<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicReference</code>其实没有本质区别，所以我这里仅简单介绍了一下<code>AtomicInteger</code>，所有的工作都会通过<code>Unsafe</code>类来完成。</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>atomic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AtomicIntegerArray源码解析</title>
    <link href="/2021-06-03/AtomicIntegerArray-analysis.html"/>
    <url>/2021-06-03/AtomicIntegerArray-analysis.html</url>
    
    <content type="html"><![CDATA[<p><code>AtomicIntegerArray</code>能够保证数组中的每个元素原子地更新。构造方法、增加、减少方法都没什么好说，我认为值得关注的点是仅有计算偏移的方法。我们先来看看它的静态构造块：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicIntegerArray</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">2862133569453604235L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> base = unsafe.arrayBaseOffset(<span class="hljs-keyword">int</span>[].class);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> shift;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] array;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">//scale表示数组中每个元素的字节数，必须都是2的倍数</span><br>        <span class="hljs-keyword">int</span> scale = unsafe.arrayIndexScale(<span class="hljs-keyword">int</span>[].class);<br>        <span class="hljs-keyword">if</span> ((scale &amp; (scale - <span class="hljs-number">1</span>)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;data type scale not a power of two&quot;</span>);<br>        <span class="hljs-comment">//shift表示偏移量</span><br>        shift = <span class="hljs-number">31</span> - Integer.numberOfLeadingZeros(scale);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> <span class="hljs-title">checkedByteOffset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= array.length)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">&quot;index &quot;</span> + i);<br><br>        <span class="hljs-keyword">return</span> byteOffset(i);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">byteOffset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">long</span>) i &lt;&lt; shift) + base;<br>    &#125;<br>    ...<br></code></pre></div></td></tr></table></figure><p>首先静态构造块会计算当前数组元素类型的大小<code>scale</code>字段，要求类型只能是4的倍数，当然我们一般也只会用这个类存储int数组。接着会初始化单位偏移长度<code>shift</code>。那么对于每个元素在数组中的偏移就等于“元素个数 X 单位偏移长度”。比如我们的元素类型是int类型，那么单位偏移长度<code>shft</code>就为2。那么对应于索引为1的元素地址，就是<code>base + offset==1&lt;&lt;(shift==2)</code>。索引为i的元素地址同理。</p><p>那么我们如果想要更新数组中的某个元素，那么会调用<code>getAndSet()</code>，而该方法中又首先会调用<code>checkedByteOffset()</code>计算对应的偏移，最后使用<code>Unsafe</code>类的CAS操作完成更新。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> newValue)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndSetInt(array, checkedByteOffset(i), newValue);<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>atomic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AtomicStampedReference源码解析</title>
    <link href="/2021-06-03/AtomicStampedReference-analysis.html"/>
    <url>/2021-06-03/AtomicStampedReference-analysis.html</url>
    
    <content type="html"><![CDATA[<p><code>AtomicStampeddReference</code>解决了普通CAS操作的ABA问题，当然该类只能存储引用类型，因为泛型只支持引用。具体的解决方法就是为每个引用提供了一个时间戳（实际用int代替），这两个数据由内部静态类<code>Pair</code>封装，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicStampedReference</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">final</span> T reference;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> stamp;<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T reference, <span class="hljs-keyword">int</span> stamp)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.reference = reference;<br>            <span class="hljs-keyword">this</span>.stamp = stamp;<br>        &#125;<br><br>        <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Pair&lt;T&gt; <span class="hljs-title">of</span><span class="hljs-params">(T reference, <span class="hljs-keyword">int</span> stamp)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pair&lt;T&gt;(reference, stamp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Pair&lt;V&gt; pair;<br></code></pre></div></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><code>AtomicStampedReference</code>的构造函数只有一个，该构造方法要求我们必须提供一个初始时间戳，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AtomicStampedReference</span><span class="hljs-params">(V initialRef, <span class="hljs-keyword">int</span> initialStamp)</span> </span>&#123;<br>    pair = Pair.of(initialRef, initialStamp);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h2><p>对于<code>AtomicStampedReference</code>的更新，提供了两种方式<code>compareAndSet</code>和<code>weakCompareAndSet</code>。对于后者来说，它有可能会“虚假”的失败，也就是说，实际上更新成功但是却返回false，并且后者并不提供“happens before”效果，更难使用，尽管后者在某些平台上效率更高。所以一般还是使用<code>compareAndSet</code>吧。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Atomically sets the value of both the reference and stamp</span><br><span class="hljs-comment">* to the given update values if the</span><br><span class="hljs-comment">* current reference is &#123;<span class="hljs-doctag">@code</span> ==&#125; to the expected reference</span><br><span class="hljs-comment">* and the current stamp is equal to the expected stamp.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(V   expectedReference,</span></span><br><span class="hljs-params"><span class="hljs-function">                                V   newReference,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-keyword">int</span> expectedStamp,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-keyword">int</span> newStamp)</span> </span>&#123;<br>    Pair&lt;V&gt; current = pair;<br>    <span class="hljs-keyword">return</span><br>        expectedReference == current.reference &amp;&amp;<br>        expectedStamp == current.stamp &amp;&amp;<br>        ((newReference == current.reference &amp;&amp;<br>            newStamp == current.stamp) ||<br>            casPair(current, Pair.of(newReference, newStamp)));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Atomically sets the value of both the reference and stamp</span><br><span class="hljs-comment">* to the given update values if the</span><br><span class="hljs-comment">* current reference is &#123;<span class="hljs-doctag">@code</span> ==&#125; to the expected reference</span><br><span class="hljs-comment">* and the current stamp is equal to the expected stamp.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* &lt;p&gt;&lt;a href=&quot;package-summary.html#weakCompareAndSet&quot;&gt;May fail</span><br><span class="hljs-comment">* spuriously and does not provide ordering guarantees&lt;/a&gt;, so is</span><br><span class="hljs-comment">* only rarely an appropriate alternative to &#123;<span class="hljs-doctag">@code</span> compareAndSet&#125;.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">weakCompareAndSet</span><span class="hljs-params">(V   expectedReference,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    V   newReference,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">int</span> expectedStamp,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">int</span> newStamp)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> compareAndSet(expectedReference, newReference,<br>                            expectedStamp, newStamp);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当然，每次更新时都需要提供旧时间戳，如果旧的不符合说明产生了ABA。</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>atomic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LongAdder源码解析</title>
    <link href="/2021-06-03/LongAdder-analysis.html"/>
    <url>/2021-06-03/LongAdder-analysis.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-预备知识"><a href="#1-预备知识" class="headerlink" title="1. 预备知识"></a>1. 预备知识</h2><p>在Java1.5中，JUC就已经提供了大数原子类<code>AtomicLong</code>，但是在Java1.8中，又提供了相同功能的大数原子类<code>LongAdder</code>。why？答案是如此的纯粹：为了效率。难道前者的效率就不行了吗？如果在轻微冲突的情况下，二者的效率几乎差不多。但是如果竞争非常激烈，那么因为每次对<code>AtomicLong</code>更新时都会使用CAS，激烈竞争导致CAS的成功的概率不大，所以有可能会执行多次无效的CAS操作。那么后者<code>LongAdder</code>在更新时采用了分段计数的方法，它在每次更新时不再直接更新具体的数，而是在内部维护了一个基数<code>base</code>和增量数组<code>cells</code>。在竞争激烈的情况下，每个线程会只会在增量数组中更新自己得到增量。那么如果想要获得最后的结果，只需要将<code>base</code>与<code>sum(cells[i])</code>相加即可。</p><p>那么分段计数的方法就如此完美吗？没有任何缺点吗？在该类的注释中说到：</p><blockquote><p>This class is usually preferable to AtomicLong when multiple threads update a common sum that is used for purposes such as collecting statistics, not for fine-grained synchronization control.</p></blockquote><p>大意是说该类一般<strong>用于收集一些统计数据</strong>，而不应该用于线程同步，因为增量数组中的值是瞬息万变的，那么是有可能直接略过了我们的目标值，比如我们的目标值是1，但是有可能直接从1增加到3。</p><h2 id="2-体系结构"><a href="#2-体系结构" class="headerlink" title="2. 体系结构"></a>2. 体系结构</h2><p><code>LongAdder</code>中采用的分段计数逻辑其实是由<code>Stripe64</code>类完成的，<code>LongAdder</code>的继承结构如下所示：</p><p><img src="./images/Stripe64.png" alt="Stripe64"></p><p>实现分段计数的属性增量数组<code>cells</code>与基数<code>base</code>均由<code>Stripe64</code>类维护。</p><p>对于增量数组中的一个元素<code>CounterCell</code>，它代表的是一个线程更新的增量。所以类似于hashmap，<code>Stripe64</code>使用<code>ThreadLocalRandom</code>为每个线程维护了一个随机数当作线程的哈希值，熟悉hashmap的同学都知道，hashmap的table长度必须是2的整数幂。类似的，<code>Stripe64</code>也规定了增量数组<code>cells</code>的长度也必须是2的整数幂。但是长度是有限的，如果达到了最大核心数，那么<code>cells</code>不会再扩容。</p><p>自旋锁<code>cellsBusy</code>则是用来控制数组的初始化及扩容操作。下面罗列了<code>Stripe64</code>的重要字段：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Striped64</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span> </span>&#123;<br>    <span class="hljs-meta">@sun</span>.misc.Contended <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cell</span> </span>&#123;<br>        <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> value;<br>        Cell(<span class="hljs-keyword">long</span> x) &#123; value = x; &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">cas</span><span class="hljs-params">(<span class="hljs-keyword">long</span> cmp, <span class="hljs-keyword">long</span> val)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapLong(<span class="hljs-keyword">this</span>, valueOffset, cmp, val);<br>        &#125;<br><br>        <span class="hljs-comment">// Unsafe mechanics</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> sun.misc.Unsafe UNSAFE;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> valueOffset;<br>        <span class="hljs-keyword">static</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                UNSAFE = sun.misc.Unsafe.getUnsafe();<br>                Class&lt;?&gt; ak = Cell.class;<br>                valueOffset = UNSAFE.objectFieldOffset<br>                    (ak.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(e);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//有效的CPU核心数，也就是增量数组cells的容量上限</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Table of cells. When non-null, size is a power of 2.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//增量数组cells，容量必须为2的倍数，因为跟HashMap类似，需要依靠hash值计算对应的索引</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<br><br>    <span class="hljs-comment">//基数</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> base;<br><br>    <br>    <span class="hljs-comment">//自旋锁，用于互斥访问增量数组cells</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> cellsBusy;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-计算逻辑"><a href="#3-计算逻辑" class="headerlink" title="3. 计算逻辑"></a>3. 计算逻辑</h2><p>整个<code>longAccumulate()</code>的逻辑可以划分为三个case（详情见注释）：</p><ol><li>case1：如果<code>CounterCell</code>数组已经初始化好了，那么直接尝试在当前线程对应槽位更新<code>CounterCell</code>对象</li><li>case2：<code>CounterCell</code>数组没有初始化，也没有加锁，那么会构建一个长度为2的<code>CounterCell</code>数组，因为至少存在两个同时更新的线程才会发生冲突</li><li>case3：<code>CounterCell</code>正在进行初始化或扩容，那么则直接尝试更新<code>baseCount</code></li></ol><p>其中我认为<code>case1</code>的情况稍微复杂点，我这里展示一下它的流程图：</p><p><img src="./images/longAccumulate.drawio.svg" alt="longAccumulate"></p><p>流程图可能有疏漏，后续再精进吧。下面的代码中添加了详细的注释：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">这个函数作用就是在当前线程对应的槽位更新cell对象，但是并不负责计算map最后的大小</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">有很多场景能用到这个函数，包括：</span><br><span class="hljs-comment">1. CounterCell数组未初始化</span><br><span class="hljs-comment">2. 对应槽位的CounterCell未初始化</span><br><span class="hljs-comment">3. CounterCell初始化，但是修改value时CAS失败</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">其中属性cellBusy是专门为该函数准备的自旋锁，在扩容或者构造新cell时使用</span><br><span class="hljs-comment">wasCounttended表示进入这个函数原因是是否未更新对应CounterCell对象失败，true为不是因为失败</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> x the value</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> fn the update function, or null for add (this convention</span><br><span class="hljs-comment"> * avoids the need for an extra field or function in LongAdder).</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> wasUncontended false if CAS failed before call</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">longAccumulate</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, LongBinaryOperator fn,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">boolean</span> wasUncontended)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-comment">//如果当前线程的hash值还为准备好，那么强制初始化</span><br>    <span class="hljs-keyword">if</span> ((h = getProbe()) == <span class="hljs-number">0</span>) &#123;<br>        ThreadLocalRandom.current(); <span class="hljs-comment">// force initialization</span><br>        h = getProbe();<br>        wasUncontended = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">boolean</span> collide = <span class="hljs-keyword">false</span>;                <span class="hljs-comment">// True if last slot nonempty</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Cell[] as; Cell a; <span class="hljs-keyword">int</span> n; <span class="hljs-keyword">long</span> v;<br>        <span class="hljs-comment">//case1:如果CounterCell数组已经初始化好了</span><br>        <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//对应槽位的CounterCell对象没有初始化，或者正在扩容，那么尝试构造新的Cell</span><br>            <span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-keyword">null</span>) &#123;<br>                 <span class="hljs-comment">//如果当前没有线程持有自旋锁</span><br>                <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span>) &#123;       <span class="hljs-comment">// Try to attach new Cell</span><br>                    <span class="hljs-comment">//先构造好一个cell对象</span><br>                    Cell r = <span class="hljs-keyword">new</span> Cell(x);   <span class="hljs-comment">// Optimistically create</span><br>                     <span class="hljs-comment">//尝试获取自旋锁cellsBusy</span><br>                    <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;<br>                        <span class="hljs-keyword">boolean</span> created = <span class="hljs-keyword">false</span>;<br>                        <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">// Recheck under lock</span><br>                            Cell[] rs; <span class="hljs-keyword">int</span> m, j;<br>                            <span class="hljs-comment">//再次检查cell数组是否为空</span><br>                            <span class="hljs-keyword">if</span> ((rs = cells) != <span class="hljs-keyword">null</span> &amp;&amp;<br>                                (m = rs.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                                rs[j = (m - <span class="hljs-number">1</span>) &amp; h] == <span class="hljs-keyword">null</span>) &#123;<br>                                 <span class="hljs-comment">//在cell数组的对应槽位上赋值我们先构造好的cell对象</span><br>                                rs[j] = r;<br>                                <span class="hljs-comment">//cell对象创建成功，那么可以退出循环了，设置标志位create</span><br>                                created = <span class="hljs-keyword">true</span>;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            <span class="hljs-comment">//释放自旋锁</span><br>                            cellsBusy = <span class="hljs-number">0</span>;<br>                        &#125;<br>                        <span class="hljs-comment">//如果创建cell对象成功，那么则退出循环</span><br>                        <span class="hljs-keyword">if</span> (created)<br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">continue</span>;           <span class="hljs-comment">// Slot is now non-empty</span><br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">//设置扩容标志</span><br>                collide = <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-comment">//走到这说明对应槽位的cell对象已经构造好了</span><br>            <span class="hljs-comment">//那么就判断进入这个函数的原因是不是因为更新对应cell的时候发生冲突</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wasUncontended)       <span class="hljs-comment">// CAS already known to fail</span><br>                <span class="hljs-comment">//如果是因为更新时cas发生冲突，那么就尝试进行一次rehash更新线程的hash值，并且只会更新一次</span><br>                wasUncontended = <span class="hljs-keyword">true</span>;      <span class="hljs-comment">// Continue after rehash</span><br>            <br>            <span class="hljs-comment">//在rehash之后再次尝试使用cas进行更新</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.cas(v = a.value, ((fn == <span class="hljs-keyword">null</span>) ? v + x :<br>                                            fn.applyAsLong(v, x))))<br>                <span class="hljs-keyword">break</span>;<br>             <span class="hljs-comment">//如果cell数组扩容了，或者大小已经超过了核心处理器数量，那么对于当前线程来说不会再扩容了</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt;= NCPU || cells != as)<br>                collide = <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// At max size or stale</span><br>            <span class="hljs-comment">//设置扩容标志，设为false只会走下面的else-if，不可能到达后面的扩容逻辑</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide)<br>                collide = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-comment">//尝试加锁扩容</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//再次判断cell数组没有被初始化</span><br>                    <span class="hljs-keyword">if</span> (cells == as) &#123;      <span class="hljs-comment">// Expand table unless stale</span><br>                        <br>                        Cell[] rs = <span class="hljs-keyword">new</span> Cell[n &lt;&lt; <span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>                            rs[i] = as[i];<br>                        cells = rs;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    cellsBusy = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-comment">//设置扩容标志</span><br>                collide = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">continue</span>;                   <span class="hljs-comment">// Retry with expanded table</span><br>            &#125;<br>            <span class="hljs-comment">//重新计算当先线程的hash值</span><br>            h = advanceProbe(h);<br>        &#125;<br>        <span class="hljs-comment">//case2:CounterCell数组没有被加锁，并且没有初始化</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;<br>            <span class="hljs-keyword">boolean</span> init = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//那么则尝试进行初始化</span><br>                <span class="hljs-keyword">if</span> (cells == as) &#123;<br>                    <span class="hljs-comment">//构造一个长度为2的cell数组，因为至少有两个线程竞争更改容量，才会进入这个函数</span><br>                    Cell[] rs = <span class="hljs-keyword">new</span> Cell[<span class="hljs-number">2</span>];<br>                    <span class="hljs-comment">//在当前线程的槽位上构造cell对象</span><br>                    rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Cell(x);<br>                    cells = rs;<br>                    init = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">//释放自旋锁</span><br>                cellsBusy = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-comment">//如果成功初始化，说明cell对象也构造好了，那么则退出循环</span><br>            <span class="hljs-keyword">if</span> (init)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//case3:CounterCell数组正在初始化，因为获取自旋锁CELLBUSY失败，则尝试直接在原来的baseCount上累加</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casBase(v = base, ((fn == <span class="hljs-keyword">null</span>) ? v + x :<br>                                    fn.applyAsLong(v, x))))<br>            <span class="hljs-keyword">break</span>;                          <span class="hljs-comment">// Fall back on using base</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p><code>LongAdder</code>出现的原因是因为原来的<code>AtomicLong</code>在竞争激烈的情况下效率很低，所以<code>LongAdder</code>则是将热点数据分散，每个线程只负责自己的部分。<code>ConcurrentHashMap</code>计算容量时就采用了这种方法。</p><p>而<code>LongAccumulator</code>则实现了重载符号的逻辑。<code>LongAdder</code>只能实现加法，而<code>LongAccumulator</code>允许我们自定义符号功能，类似于cpp中的符号重载。</p><p>类似的，<code>DoubleAdder</code>和<code>DoubleAccumulator</code>实现了<code>Double</code>类型的大数原子类，与<code>long</code>类型的实现逻辑几乎没有任务区别。</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>atomic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原子类总览</title>
    <link href="/2021-06-03/atomic-class-overview.html"/>
    <url>/2021-06-03/atomic-class-overview.html</url>
    
    <content type="html"><![CDATA[<p>J.U.C包提供了许多原子类，我按照功能分了四类，如下所示：<br>|  普通原子类   | 原子更新的数组  | 原子更新对象字段的updater  | 大数原子类  |<br>|  —-  | —-  | —-  | —-  |<br>| AtomicBoolean AtomicInteger <br> AtomicLong AtomicReference atomicMarkableReference AtomicStampedReference | AtomicIntegerArray AtomicLongArray AtomicReferenceArray |  AtomicIntegerFiledUpdater AtomicLongFiledUpdater AtomicReferenceUpdater| LongAccumulator DoubleAccumulator LongAdder DoubleAdder |</p><p><strong>普通原子类</strong>下的六种，</p><h2 id="2-核心类Unsafe"><a href="#2-核心类Unsafe" class="headerlink" title="2. 核心类Unsafe"></a>2. 核心类Unsafe</h2><p>不管是原子类还是AQS锁以及其他的CAS操作，全都是依靠<code>sun.misc</code>包下的<code>Unsafe</code>类完成。之所以叫<code>Unsafe</code>，是因为该类的方法都是native方法，能够直接以类似于指针的方式操作对象中的数组，这样就破坏了Java程序所恪守的不使用指针，并且如果操作不当，可能会造成未知后果。所以只有通过启动类加载器加载的类才能使用该类。当然，我们可以通过反射破坏这一规则。</p><p><code>Unsafe</code>类采用的是饿汉单例模式，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Unsafe</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe theUnsafe;<br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Unsafe</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        registerNatives();<br>        Reflection.registerMethodsToFilter(Unsafe.class, <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;getUnsafe&quot;</span>&#125;);<br>        theUnsafe = <span class="hljs-keyword">new</span> Unsafe();<br>        ...<br>    &#125;<br>    <span class="hljs-meta">@CallerSensitive</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">getUnsafe</span><span class="hljs-params">()</span> </span>&#123;<br>        Class var0 = Reflection.getCallerClass();<br>        <span class="hljs-comment">//判断调用者的类加载器是否为null，因为null表示启动类加载器</span><br>        <span class="hljs-keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SecurityException(<span class="hljs-string">&quot;Unsafe&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> theUnsafe;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们可以使用<code>getUnsafe()</code>获取单例，当然使用这种方法的前提是该方法的调用者必须通过启动类加载器来加载。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>原子类非常多，但是大部分都只是数据类型不同，所以我仅分析了每个类别下的代表类：</p><ol><li>普通原子类：<ul><li><a href="./AtomicInteger-analysis.md">AtomicInteger</a></li><li><a href="./AtomicStampedReference-analysis.md">AtomicStampedReference</a></li></ul></li><li>原子数组：<ul><li><a href="./AtomicIntegerArray-analysis.md">AtomicIntegerArray</a></li></ul></li><li>原子更新对象的updater：<ul><li>AtomicIntegerFiledUpdater</li></ul></li><li>大数原子类<ul><li><a href="./LongAccumulator-analysis.md">LongAccumulator</a></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>atomic class</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从Semaphore中学习共享锁原理</title>
    <link href="/2021-06-03/shared-lock-analysis.html"/>
    <url>/2021-06-03/shared-lock-analysis.html</url>
    
    <content type="html"><![CDATA[<p>共享锁和独占锁的实现差别不是很大，一个最大的区别就是在共享锁中，当一个线程获取锁后，它会尽可能多地唤醒后继线程。</p><p>与独占锁不同的是，对于双链表中的节点，额外指针nextWaiter，指向<code>SHARED</code>节点，用来标志当前节点处于共享模式。而独占锁的nextWatier则指向null。</p><h2 id="1-共享锁的获取"><a href="#1-共享锁的获取" class="headerlink" title="1.共享锁的获取"></a>1.共享锁的获取</h2><p>对于共享锁的获取，自定义同步器肯定会首先调用AQS的模板方法<code>acquireShared</code>，然后会调用自定义的锁获取方法<code>tryAcquireShared</code>。在共享锁模式下，<code>tryAcquireShared</code>的返回值有三种含义：</p><ul><li>返回值小于0表示获取锁失败</li><li>返回等于0表示当前线程获取锁成功，但是不保证后续的获取会成功</li><li>返回值大于0表示当前线程获取成功，并且后续的获取会成功，但是必须检查锁的有效性</li></ul><p>所以当<code>tryAcquireShared</code>返回值小于0时，则调用<code>doAcquireShared</code>将当前线程放入同步队列，准备阻塞，<code>tryAcquireShared</code>代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireShared(arg);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>doAcuqiredShared</code>的主要功能就是将同步队列中的线程挂起或者在线程获取锁后移出同步队列，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);<br>    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>            <span class="hljs-comment">//如果node的前向节点为head，说明轮到node抢锁了</span><br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);<br>                <span class="hljs-comment">//如果tryAcquireShared返回值不小于0，说明可以唤醒node的后继线程来获取共享锁了</span><br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                    <span class="hljs-keyword">if</span> (interrupted)<br>                        selfInterrupt();<br>                    failed = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果有线程获取共享锁成功，则会调用<code>setHeadAndPropagate</code>唤醒<code>node</code>的后继线程。我们来看看具体的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> propagate)</span> </span>&#123;<br>    Node h = head; <span class="hljs-comment">// Record old head for check below</span><br>    setHead(node);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * Try to signal next queued node if:</span><br><span class="hljs-comment">    *   Propagation was indicated by caller,</span><br><span class="hljs-comment">    *     or was recorded (as h.waitStatus either before</span><br><span class="hljs-comment">    *     or after setHead) by a previous operation</span><br><span class="hljs-comment">    *     (note: this uses sign-check of waitStatus because</span><br><span class="hljs-comment">    *      PROPAGATE status may transition to SIGNAL.)</span><br><span class="hljs-comment">    * and</span><br><span class="hljs-comment">    *   The next node is waiting in shared mode,</span><br><span class="hljs-comment">    *     or we don&#x27;t know, because it appears null</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * The conservatism in both of these checks may cause</span><br><span class="hljs-comment">    * unnecessary wake-ups, but only when there are multiple</span><br><span class="hljs-comment">    * racing acquires/releases, so most need signals now or soon</span><br><span class="hljs-comment">    * anyway.</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||<br>        (h = head) == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;<br>        Node s = node.next;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.isShared())<br>            doReleaseShared();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在<code>setHeadAndPropagate</code>中首先会重新设置头节点<code>head</code>，因为当前线程已经获取了锁，所以不需要保证线程安全。随后要经过一系列检查才会调用<code>doReleaseShared</code>执行真正的唤醒后继线程的操作。我们来看看这一系列的检查包括什么：</p><ol><li>propagate &gt; 0</li><li>h == null 或者 (h = head) == null</li><li>h.waitStatus &lt; 0</li></ol><p>其中，第一个条件很正常，当<code>propagate</code>的返回值大于0时，说明后继线程如果被唤醒，那么它们有概率获得锁。但是第二个条件我实在是无法理解，在进入<code>setHeadAndPropagate</code>函数之前，一定会调用<code>addWaiter</code>初始化同步队列，所以h不可能为空，这里为什么需要进行多余的判空操作？对于最后一个条件，<code>h.waitStatus&lt;0</code>说明存在后继线程被挂起的情况。</p><p>假设检查通过，会执行<code>doReleaseShared</code>用来唤醒后继线程。这个方法可以说是共享锁的核心，而且它也会在线程释放共享锁时调用，总共会在两个位置被调用。为什么需要这么做？对于释放锁后调用此方法是可以理解的，不然同步队列的线程怎么获取锁呢？但是当线程获取锁后，还调用此方法，是因为<strong>共享锁</strong>希望能够被尽可能多的线程持有。当一个线程获取成功后，它有责任让更多的后继来尝试。<code>doReleaseShared</code>会被调用两次的原因解释清楚了，具体的分析请见共享锁的释放一章。</p><h2 id="2-共享锁的释放"><a href="#2-共享锁的释放" class="headerlink" title="2.共享锁的释放"></a>2.共享锁的释放</h2><p>首先当共享锁释放时，会调用AQS的<code>releaseShared</code>方法。在<code>releaseShared</code>中会首先调用用户自定义的释放锁方法<code>tryReleaseShared</code>，<code>releaseShared</code>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-comment">//调用用户自定义的释放锁方法</span><br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果锁释放成功，则会调用<code>doReleaseShared</code>唤醒当前节点的后继线程：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * Ensure that a release propagates, even if there are other</span><br><span class="hljs-comment">    * in-progress acquires/releases.  This proceeds in the usual</span><br><span class="hljs-comment">    * way of trying to unparkSuccessor of head if it needs</span><br><span class="hljs-comment">    * signal. But if it does not, status is set to PROPAGATE to</span><br><span class="hljs-comment">    * ensure that upon release, propagation continues.</span><br><span class="hljs-comment">    * Additionally, we must loop in case a new node is added</span><br><span class="hljs-comment">    * while we are doing this. Also, unlike other uses of</span><br><span class="hljs-comment">    * unparkSuccessor, we need to know if CAS to reset status</span><br><span class="hljs-comment">    * fails, if so rechecking.</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Node h = head;<br><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-keyword">int</span> ws = h.waitStatus;<br>            <span class="hljs-comment">//与独占锁类似，只有头节点的waitStatus == -1，说明后继线程才会被挂起</span><br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                        !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>doReleaseShared</code>这个函数用来唤醒尽可能多的处于同步队列的后继线程，为什么要这么做呢？因为这是共享锁，当一个线程获取锁成功后，不必等到当前线程释放后才让后继线程来抢锁，可以让后继线程和当前线程共同使用锁嘛。那么这个唤醒动作什么时候终止呢？答案是：直到没有线程成功锁为止。这个操作如何实现？就是通过下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (;;) &#123;<br>    Node h = head;<br><br>    ...<br>    <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个死循环动作的终止条件是：<code>h==head</code>。这个条件说明什么？说明head没有被改变，没被改变就等同于没有新线程获取锁，所以唤醒动作可以终止了。那么具体的唤醒动作是怎么实现的？请见如下代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (;;) &#123;<br>    Node h = head;<br><br>    <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;<br>        <span class="hljs-keyword">int</span> ws = h.waitStatus;<br>        <span class="hljs-comment">//与独占锁类似，只有头节点的waitStatus == -1，说明后继线程才会被挂起</span><br>        <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>            <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>            unparkSuccessor(h);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                    !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>            <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面代码中的四处if条件我们需要好好理解一下。</p><p>对于代码中的<strong>第一个</strong><code>if</code>条件：<code>(h != null &amp;&amp; h != tail)</code>，说明需要同步队列中除head之外，必须还存在一个节点。不然唤醒谁呢？</p><p>对于<strong>第二个</strong><code>if</code>条件：<code>(ws == Node.SIGNAL)</code>，这个条件的含义是只有<code>head.waitStatus == -1</code>，才表示后续节点被挂起。具体的挂起操作见<code>shouldParkAfterFailedAcquire</code>函数。</p><p>对于<strong>第三个</strong><code>if</code>条件：<code>(!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</code>，这里使用CAS执行<code>head.waitStatus=0</code>是为了防止多个线程多次唤醒同一个head之后的后继节点。这里为什么会有多个线程唤醒同一个head的后继节点？这就跟共享模式的唤醒机制有关了。假设现在同步队列如下：</p><p><img src="images/doReleaseShared-p1.drawio.svg" alt="doReleaseShared"></p><p>当节点A调用<code>setHeadAndPropagate</code>重新设置head出队后，随后进入<code>doReleaseShared</code>时，发现同步队列中还有节点，那么当A成功执行<code>compareAndSetWaitStatus(h, Node.SIGNAL, 0)</code>后，执行<code>unparkSuccessor</code>唤醒节点B，此时节点A开始了下一次循环。</p><p>现在假设节点B也成功获取了锁，在<code>setHeadAndPropagate</code>中改变了head，随后也进入了<code>doReleaseShared</code>,此时同步队列状态如下所示：</p><p><img src="images/doReleaseShared-p2.drawio.svg" alt="doReleaseShared"></p><p>此时线程A和线程B操作的可能是同一个head。假设A唤醒B，B成功获得锁，改变了head，A会再次进入<code>doReleaseShared</code>，并且B也会因为成功获得锁首次调用<code>doReleaseShared</code>，那么A和B操作的就是同一个head，而唤醒C只需要做一次，CAS来保证这个“一次”。</p><p>对于<strong>第四个</strong><code>if</code>条件：<code>(ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</code>，这也可能是为了性能的极致优化。首先我们需要知道能够走到这个条件的状态是同步队列中必须有两个节点。如果<code>ws==0</code>为true，则说明此时同步队列中有可能所有的节点都没有挂起，或者原来的尾节点tail成为了新的头节点head。而<code>compareAndSetWaitStatus(h, 0, Node.PROPAGATE)</code>失败则说明头节点head的状态被另外的线程的改变了，谁有资格改head的<code>waitStatus</code>？只有一种情况：那就是后继节点挂起了，才会将前置节点的<code>waitStatus</code>设置为-1。以下图为例：<br><img src="images/doReleaseShared-p3.drawio.svg" alt="doReleaseShared"></p><p>原始队列只有节点C，此时是有机会获得锁的，如图4-1所示。假设节点C出队，则有(<code>head.ws == 0</code>）。在做CAS之前，节点D入队并挂起，如图4-3所示。C之后的节点D明明有机会获得锁的，因为进入<code>doReleaseShared</code>时，队列中也只有一个节点，但是却不小心被刮起了，这个挂起完全没有意义。所以直接使用<code>continue</code>进入下一轮循环唤醒刚刚被挂起的线程。那么为什么不直接调用unparkSuccssor唤醒然后continue呢？</p><h2 id="3-新状态：PROPAGATE"><a href="#3-新状态：PROPAGATE" class="headerlink" title="3. 新状态：PROPAGATE"></a>3. 新状态：PROPAGATE</h2><p>在<code>doReleaseShared</code>第四个<code>if</code>条件中，我们发现了一点新东西，那就是<code>Node.PROPAGATE</code>。这个状态是什么？用来干嘛的？经过<a href="https://www.cnblogs.com/micrari/p/6937995.html">网上的查阅</a>，PROPAGATR是用来修复<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6801020">JDK-6801020</a>。代码改动如下所示：<br><img src="images/diff-AQS.png" alt="diff"></p><p>如果执行了如下代码，那么则有可能导致主线程被挂起：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSemaphore</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Semaphore sem = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            sem.acquireUninterruptibly();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            sem.release();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; i++) &#123;<br>            Thread t1 = <span class="hljs-keyword">new</span> Thread1();<br>            Thread t2 = <span class="hljs-keyword">new</span> Thread1();<br>            Thread t3 = <span class="hljs-keyword">new</span> Thread2();<br>            Thread t4 = <span class="hljs-keyword">new</span> Thread2();<br>            t1.start();<br>            t2.start();<br>            t3.start();<br>            t4.start();<br>            t1.join();<br>            t2.join();<br>            t3.join();<br>            t4.join();<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在t3、t4获得锁，同步队列如下所示：</p><p><img src="images/propagate.drawio.svg" alt="propagate"></p><p>t1时刻: t4释放锁，调用releaseShared，执行unparkSuccssor，唤醒t2。将head的waitStatus从-1设置0，唤醒t2<br>t2时刻：线程t2执行tryAcquireShared返回propagate=0，获取锁，还未执行setHeadAndPropagate<br>t3时刻：线程t3释放锁，执行releaseShared，读取到head.waitStatus =0（因为此时节点A还未出队），不会执行unparkSuccssor，这里的releaseShared是老版本的，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        Node h = head;<br>    <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)&#123; <br>        unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>t4时刻，线程t2继续执行setHeadAndPropagate，老版本setHeadAndPropagate代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> propagate)</span> </span>&#123;<br>    setHead(node);<br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> &amp;&amp; node.waitStatus != <span class="hljs-number">0</span>) &#123;<br>        Node s = node.next;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.isShared())<br>        unparkSuccessor(node);<br>    &#125;   <br>&#125;<br></code></pre></div></td></tr></table></figure><p>此时propogate==0，因为是<code>&amp;&amp;</code>，不会执行unparkSuccssor。当t2在释放锁时，因为head.waitStatus == 0，不会执行unpark，所以线程t1永远不会被唤醒，那么引入的PROPAGATE是如何解决这个问题的呢？还是采用上述相同的执行顺序：</p><p>t1时刻: t4释放锁，调用releaseShared，执行unparkSuccssor，将head的waitStatus从-1设置0，唤醒t2<br>t2时刻：线程t2执行tryAcquireShared返回0，获取锁，还未执行setHeadAndPropagate<br>t3时刻：线程t3释放锁，执行releaseShared，执行doReleaseShared，如果此时能成功<code>compareAndSetWaitStatus(h, 0, Node.PROPAGATE)</code>，说明后继线程还在挂起，此时执行head.waitStatus==PROPOGATE。<br>t4时刻，线程t2继续执行setHeadAndPropagate，新版如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> propagate)</span> </span>&#123;<br>    Node h = head; <span class="hljs-comment">// Record old head for check below</span><br>    setHead(node);<br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||<br>        (h = head) == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;<br>        Node s = node.next;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.isShared())<br>            doReleaseShared();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>虽然propagate==0，但是head.waitStatus ==PROPAGATE &lt;0,能够成功执行doReleaseShared。在doReleaseShared中，因为新的head（也就是t2）的waitStatus = -1，所以能够成功执行unparkSuccssor，唤醒t1。</p><p>那么引入PROPAGATE状态后，在不考虑conditionObject的条件下，AQS中的状态转换图是如何的呢？</p><p><img src="images/state-transition.drawio.svg" alt="status"></p><p><code>PROPAGATE</code>状态只会赋值给头节点head。其他节点没有资格转移到这个状态。但是我并没有找到从<code>PROPAGATE</code>转化到<code>0</code>的代码，与参考文章[2]的理解略有不同。</p><h2 id="4-共享锁的应用"><a href="#4-共享锁的应用" class="headerlink" title="4.共享锁的应用"></a>4.共享锁的应用</h2><p>CountDownLatch和Semaphore都是基于共享锁实现的。对于Semaphore，如果了解共享锁的获取与释放，并没有什么难以理解。而CountDownLatch则有点特殊。CountDownLatch的基本效果是一组线程等待另外一组线程工作完成。使用例子如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountdownLatchExample</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> totalThread = <span class="hljs-number">10</span>;<br>        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(totalThread);<br>        ExecutorService executorService = Executors.newCachedThreadPool();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; totalThread; i++) &#123;<br>            executorService.execute(() -&gt; &#123;<br>                System.out.print(<span class="hljs-string">&quot;run..&quot;</span>);<br>                countDownLatch.countDown();<br>            &#125;);<br>        &#125;<br>        countDownLatch.await();<br>        System.out.println(<span class="hljs-string">&quot;end&quot;</span>);<br>        executorService.shutdown();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于调用<code>CountDownlatch.await()</code>的线程，会将其加入同步队列，直到调用<code>countDownLatch.countDown</code>的次数达到规定次数。这也就是调用<code>tryReleaseShared</code>释放锁的过程。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>    <span class="hljs-comment">// Decrement count; signal when transition to zero</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = getState();<br>        <span class="hljs-comment">//这么判断是害怕有傻缺，设置count==5，但是却有6个线程调用countDown</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">int</span> nextc = c-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>            <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看出，只有在<code>c</code>第一次被设置为0时，才会返回true。返回true后，则会唤醒队列中被挂起的线程。而线程又会调用<code>tryAcquireShared</code>，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>所以说，当CountDownLatch减为0时，同步队列中的等待线程都会被唤醒。达到了一组线程等待另外一组线程的效果。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><p><a href="https://segmentfault.com/a/1190000016447307">逐行分析AQS源码(3)——共享锁的获取与释放</a></p></li><li><p><a href="https://www.cnblogs.com/micrari/p/6937995.html">AbstractQueuedSynchronizer源码解读</a></p></li><li><p><a href="http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/locks/AbstractQueuedSynchronizer.java?r1=1.73&r2=1.74">引入PROPAGATE之后的AQS差异</a></p></li></ol><p>4.<a href="https://jishuin.proginn.com/p/763bfbd33115">面试官问我AQS中的PROPAGATE有什么用？</a></p>]]></content>
    
    
    <categories>
      
      <category>多线程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shared lock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConcurrentHashMap架构解析</title>
    <link href="/2021-06-03/ConcurrentHashMap-analysis-I.html"/>
    <url>/2021-06-03/ConcurrentHashMap-analysis-I.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇主要介绍<code>ConcurrentHashMap</code>的基本架构、插入与删除操作的原理，对于它扩容的逻辑，放在第二部分讲解：<a href="./ConcurrentHashMap-analysis-II.md">ConcurrentHashMap扩容分析</a>。</p><hr><p>本文旨在介绍J.U.C包下的同步集合<code>ConcurrentHashMap</code>。因为Java自带的<code>HashMap</code>是线程不安全的，虽然也提供了线程安全的<code>HashTable</code>，但是后者是对整个哈希表加锁，势必效率不理想。而<code>ConcurrentHashMap</code>细化了锁的粒度，读取、插入、删除操作有可能达到并行的状态。</p><p>在具体讲述它的原理之前，我阅读了它相关的注释，非常长，我这里仅摘出我看的内容中比较重要的部分：</p><blockquote><p>1.More formally, an update operation for a given key bears a happens-before relation with any (non-null) retrieval for that key reporting the updated value</p></blockquote><p>简而言之，<code>ConcurrentHashMap</code>的插入操作 happens before 对于同一key的获取操作</p><blockquote><p>2.Iterators, Spliterators and Enumerations return elements reflecting the state of the hash table at some point at or since the creation of the iterator/enumeration.They do not throw ConcurrentModificationException. However, iterators are designed to be used by only one thread at a time.Bear in mind that the results of aggregate status methods including size, isEmpty, and containsValue are typically useful only when a map is not undergoing concurrent updates in other threads. Otherwise the results of these methods reflect transient states that may be adequate for monitoring or estimation purposes, but not for program control.</p></blockquote><p>对于迭代器、枚举函数之类操作的返回值仅仅是哈希表在某一点的状态，它们不会抛出<code>ConcurrentModificationException</code>。并且迭代器应该只用在一个时刻中在一个线程中使用。并且需要注意，当我们想要获取<code>ConcurrentHashMap</code>的一些状态时，比如大小，获得的结果仅仅是某一个时刻并且没有其他线程改变的结果，只能用来作为一些监视条件，而<strong>不能用来控制程序的流程</strong>。</p><blockquote><p>3.Like Hashtable but unlike HashMap, this class does not allow null to be used as a key or value.</p></blockquote><p><code>ConcurrentHashMap</code>和<code>Hashtable</code>一样，不支持为null的key或者value。</p><blockquote><p>4.ConcurrentHashMaps support a set of sequential and parallel bulk operations that, unlike most Stream methods, are designed to be safely, and often sensibly, applied even with maps that are being concurrently updated by other threads; for example, when computing a snapshot summary of the values in a shared registry. There are three kinds of operation, each with four forms, accepting functions with Keys, Values, Entries, and (Key, Value) arguments and/or return values. Because the elements of a ConcurrentHashMap are not ordered in any particular way, and may be processed in different orders in different parallel executions, the correctness of supplied functions should not depend on any ordering, or on any other objects or values that may transiently change while computation is in progress; and except for forEach actions, should ideally be side-effect-free. Bulk operations on Map.Entry objects do not support method setValue.</p></blockquote><p>其实上面这段注释我认为是<code>ConcurrentHashMap</code>最有特点的一部分。大致是说<code>ConcurrentHashMap</code>可以针对每一个节点开展函数式的批量操作，即使有其他线程在更新map。那么接受函数式操作的方法有三种：</p><ol><li>forEach</li><li>search</li><li>reduce</li></ol><p>上述三个方法的函数式操作可以支持四种类型的节点，包括key的类型、value的类型、Entry的类型或者返回值的类型进行操作。并且函数式的操作不应该依赖元素的顺序，也不应该依赖其他元素或者对象。</p><hr><p>分界线，<code>ConcurrentHashMap</code>的注释真是太长了，暂时就先看到这吧。对于本文来说，主要内容分为三个部分：</p><ol><li><code>ConcurrentHashMap</code>的整体架构</li><li><code>ConcurrentHashMap</code>的基本操作原理，包括插入、删除、获取等操作</li><li><code>ConcurrentHashMap</code>的计数操作</li></ol><h2 id="1-整体架构"><a href="#1-整体架构" class="headerlink" title="1. 整体架构"></a>1. 整体架构</h2><p>对于<code>ConcurrentHashMap</code>，我们可以通过它实现的接口与继承的父类做一个初步的了解，如下所示：</p><p><img src="images/ConcurrentHashMap-arch.png" alt="concurrent-hashmap"></p><p>可以看到，<code>ConcurrentHashMap</code>与<code>HashMap</code>类似，通过继承抽象实现类<code>AbstractMap</code>完成了一个map应该有的大部分通用方法。当然，<code>ConcurrentHashMap</code>也实现了自定义的接口<code>ConcurrentMap</code>来完成一些特有的操作，如下所示：</p><p><img src="images/ConcurrentMap-interface.png" alt="ConcurrentMap-interface"></p><p>可以看到，虽然是特有接口，但是很多方法跟<code>HashMap</code>的方法重名了。那么它到底是如何保证线程安全的？与<code>HashMap</code>到底有什么异同？回答这个问题前，我们应该需要了解一下它的插入与删除操作。</p><h2 id="2-插入操作原理"><a href="#2-插入操作原理" class="headerlink" title="2. 插入操作原理"></a>2. 插入操作原理</h2><p>对于插入的操作，我们应该首先应该知道我们插入的是什么，然后再去梳理具体的插入逻辑。<code>ConcurrentHashMap</code>中的节点类型比较丰富，总计分为五种，详情请见下一小节。</p><h3 id="2-1-节点类型"><a href="#2-1-节点类型" class="headerlink" title="2.1 节点类型"></a>2.1 节点类型</h3><p><code>ConcurrentHashMap</code>的五种节点类型分别是：Node，TreeNode，TreeBin、ForwardingNode、ReservationNode，它们的关系如下所示：</p><p><img src="images/ConcurrentHashMap-node-arch.png" alt="node-type"></p><p>从上图可以看到，虽然节点类型丰富，但是都是继承自<code>Node</code>类，而<code>Node</code>类又实现了<code>Map.Entry</code>接口。其实我们可以对比<code>HashMap</code>中的<code>Node</code>类型，基本逻辑差不多。</p><p><strong>I. Node类型</strong></p><p>对于<code>Node</code>类型，它是整个<code>ConcurrentHashMap</code>中的基础节点，它通过<code>next</code>指针将发生哈希冲突的节点维护到一起，该节点字段如下所示：</p><p><img src="images/node.png" alt="Node"></p><p><strong>II. TreeNode类型</strong></p><p>对于<code>TreeNode</code>类型，其实它跟<code>HashMap</code>类似，是红黑树中的基础节点。只不过它并没有放弃维护单链表的属性，所以对于每一个节点它维护了一个<code>prev</code>指针，方便快速在单链表逻辑中删除对应的节点，字段如下所示：</p><p><img src="images/TreeNode.png" alt="TreeNode"></p><p><strong>III. TreeBin类型</strong></p><p><code>TreeBin</code>节点，是<code>TreeNode</code>的代理节点，提供针对红黑树的转换操作和锁控制，哈希值固定为“-2”。也就是说，如果我们在一个桶中使用红黑树存储产生哈希冲突的元素，与<code>HashMap</code>不同，红黑树的根节点并不直接存储在table中。而是存储的是一个对应的代理节点<code>TreeBin</code>，<code>TreeBin</code>实现了关于红黑树的读写锁。具体字段含义如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeBin</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    TreeNode&lt;K,V&gt; root; <span class="hljs-comment">//红黑树逻辑下的根节点</span><br>    <span class="hljs-keyword">volatile</span> TreeNode&lt;K,V&gt; first;<span class="hljs-comment">//链表逻辑下的头节点</span><br>    <span class="hljs-keyword">volatile</span> Thread waiter; <span class="hljs-comment">// 最近一个设置锁状态的线程（从网上抄的，这个我不确定）</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> lockState;<span class="hljs-comment">//当前读写锁的状态</span><br>    <span class="hljs-comment">// values for lockState</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> WRITER = <span class="hljs-number">1</span>; <span class="hljs-comment">// set while holding write lock，持有写锁时状态为1</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> WAITER = <span class="hljs-number">2</span>; <span class="hljs-comment">// set when waiting for write lock，等待写锁时状态为2</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> READER = <span class="hljs-number">4</span>; <span class="hljs-comment">// increment value for setting read lock，每当一个线程获取到读锁时，就会将锁状态加4</span><br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>III. ForwardingNode</strong></p><p>扩容时的标记节点。具体原理在扩容时再分析，哈希值固定为“-1”。</p><p><strong>IV. ReservationNode</strong></p><p>保留结点，ConcurrentHashMap中的一些特殊方法会专门用到该类结点，哈希值固定为“-3”。</p><h3 id="2-2-具体的插入逻辑"><a href="#2-2-具体的插入逻辑" class="headerlink" title="2.2 具体的插入逻辑"></a>2.2 具体的插入逻辑</h3><p><code>ConcurrentHashMap</code>插入操作大体逻辑上与<code>HashMap</code>的插入并没有什么太大的区别，只不过前者在Java1.8及以后会使用<code>synchronized</code>对哈希表中的某一个桶加锁，从而实现局部加锁的效果，加锁的位置我在代码中已经明显注释为<strong>lock</strong>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span> || value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-keyword">int</span> hash = spread(key.hashCode());<br>    <span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-keyword">int</span> n, i, fh;<br>        <span class="hljs-comment">//采用懒加载模式，如果table为空，那么则会初始化table</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            tab = initTable();<br>        <span class="hljs-comment">//走到这表示table不为空，查找当前key对应的桶索引</span><br><br>        <span class="hljs-comment">//如果对应的桶为空，表示当前是一个插入操作</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//如果cas插入失败，表示当前桶此刻已经有元素了，需要走后面的逻辑重新插入</span><br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-keyword">null</span>,<br>                            <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>)))<br>                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span><br>        &#125;<br>        <span class="hljs-comment">//发现ForwardingNode结点，说明此时table正在扩容，则尝试协助数据迁移</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-keyword">else</span> &#123;<br>            V oldVal = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-comment">/****************************************************************************</span><br><span class="hljs-comment">            *                                 lock                                       *</span><br><span class="hljs-comment">            *对桶中的第一个节点f进行加锁，这样就保证了在不操作同一个桶的情况下，可以实现读写并发*</span><br><span class="hljs-comment">            *****************************************************************************/</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    <span class="hljs-comment">//判断当前桶的存储模式是链表还是红黑树</span><br>                    <span class="hljs-comment">//因为红黑树的代理节点TreeBin的哈希值固定为-1</span><br>                    <span class="hljs-comment">//所以如果桶中的第一个节点哈希值&gt;=0，说明当前存储模式为链表</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        binCount = <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                            K ek;<br>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                ((ek = e.key) == key ||<br>                                    (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                oldVal = e.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    e.val = value;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            Node&lt;K,V&gt; pred = e;<br>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-keyword">null</span>) &#123;<br>                                pred.next = <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key,<br>                                                            value, <span class="hljs-keyword">null</span>);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">//hash&lt;0，判断桶中第一个元素是否为TreeBin，有可能正在发生扩容</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        Node&lt;K,V&gt; p;<br>                        binCount = <span class="hljs-number">2</span>;<br>                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                        value)) != <span class="hljs-keyword">null</span>) &#123;<br>                            oldVal = p.val;<br>                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                p.val = value;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//当链表过长时，会尝试进行树化，这个hashmap几乎是一样的</span><br>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                    treeifyBin(tab, i);<br>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-keyword">null</span>)<br>                    <span class="hljs-keyword">return</span> oldVal;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    addCount(<span class="hljs-number">1L</span>, binCount);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其实除了操作每一个桶的时候会加同步锁，其他与<code>HashMap</code>插入键值对的流程几乎一致。但是更新<code>ConcurrentHashMap</code>容量的逻辑就完全不同。</p><p><code>ConcurrentHashMap</code>统计大小的逻辑类似于原子类<code>LongAdder</code>自增方法<code>longAccumulate(long,LongBinaryOperator,boolean)</code>的分段计数原理。所谓的分段计数就是说，如果在更新map容量时候发生了冲突，那么<code>ConcurrentHashMap</code>提供了一个<code>baseCount</code>属性，然后分配一个数组<code>CounterCell[]</code>，用来保存多个线程各自新增的增量（所谓的增量就是当前线程往map中添加了几个元素）。那么最后整个map的大小就等于<code>baseCount</code>加上每个线程专属的增量。</p><p>那么<strong>为什么</strong>要这么做？答案很明显：提高并发效率。思考一个场景：<br>当多个线程插入操作很频繁，因为只有在更新map大小之后才表示插入完成。如果直接对<code>size</code>属性加锁，那么冲突的概率的是比较大的。上面的数组思路就是将<code>size</code>的值分散到数组中各线程对应的槽位，那么当需要获得<code>size</code>时，只需要将每个槽位求和获得总增量，再与基数<code>baseCount</code>相加就获得了真正的容量。将属性<code>size</code>这样一个热点数据分散，降低冲突的概率，能够更快的完成插入操作。</p><p>当然，<code>ConcurrentHashMap</code>仅仅会在万不得已发生冲突的情况下，才会采用分散热点数据的逻辑。不冲突时直接将增量加到基数上即可。<code>addCount(long,in)</code>。下面是<code>ConcurrentHashMap</code>扩容时的具体逻辑：</p><figure class="highlight java"><figcaption><span>"addCount"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">调用该方法尝试进行扩容时，首先会计算当前map的最新容量，接着才会尝试进行扩容</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCount</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, <span class="hljs-keyword">int</span> check)</span> </span>&#123;<br>    CounterCell[] as; <span class="hljs-keyword">long</span> b, s;<br>    <span class="hljs-comment">//如果CounterCell为null，表示计数过程没有发生过冲突，那么直接累加到原始容量就行了</span><br>    <span class="hljs-keyword">if</span> ((as = counterCells) != <span class="hljs-keyword">null</span> ||<br>        <span class="hljs-comment">//如果counterCells为空，那么直接尝试CAS更新容量</span><br>        <span class="hljs-comment">//下面的cas参数分别为：[对象地址]，[字段偏移]，[期望旧值]，[更新值]</span><br>        !U.compareAndSwapLong(<span class="hljs-keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;<br><br>        <span class="hljs-comment">//如果cas失败，说明更新容量时发生了冲突，那么则采用类似于分段计算的逻辑</span><br>        CounterCell a; <span class="hljs-keyword">long</span> v; <span class="hljs-keyword">int</span> m;<br>        <span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>            <span class="hljs-comment">//如果CounterCells不为空，那么就类似于HashMap，使用(hash&amp;(n-1))计算当前线程的槽索引</span><br>            <span class="hljs-comment">//最后获得对应的cellValue</span><br>            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="hljs-keyword">null</span> ||<br>            <span class="hljs-comment">//如果计算槽索引成功，那么就尝试使用CAS更新对应的cellValue，否则表示CounterCell对象还未构造</span><br>            <span class="hljs-comment">//如果更新成功，那么就会将各个CounterCell的值加起来，最后的结果就是整个map的大小</span><br>            <span class="hljs-comment">//如果更新失败，那么就会执行fullAddCount</span><br>            !(uncontended =<br>                U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;<br>            <br>            fullAddCount(x, uncontended);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (check &lt;= <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//计算一下插入后的最新大小</span><br>        s = sumCount();<br>    &#125;<br>    <span class="hljs-comment">//下半部分用来处理扩容的逻辑，可以暂时无视</span><br>    <span class="hljs-keyword">if</span> (check &gt;= <span class="hljs-number">0</span>) &#123;<br>        Node&lt;K,V&gt;[] tab, nt; <span class="hljs-keyword">int</span> n, sc;<br>        <span class="hljs-comment">//如果当前table的大小已经超过了扩容阈值</span><br>        <span class="hljs-keyword">while</span> (s &gt;= (<span class="hljs-keyword">long</span>)(sc = sizeCtl) &amp;&amp; <br>        (tab = table) != <span class="hljs-keyword">null</span> &amp;&amp;<br>        <span class="hljs-comment">//并且当前table的大小还未超过最大值</span><br>        <span class="hljs-comment">//那么就会走一个扩容的逻辑</span><br>        (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;<br>            <span class="hljs-keyword">int</span> rs = resizeStamp(n);<br>            <span class="hljs-keyword">if</span> (sc &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="hljs-number">1</span> ||<br>                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="hljs-keyword">null</span> ||<br>                    transferIndex &lt;= <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>))<br>                    transfer(tab, nt);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc,<br>                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))<br>                transfer(tab, <span class="hljs-keyword">null</span>);<br>            s = sumCount();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>根据上面的代码我梳理了一下<code>addCount()</code>的逻辑，如下所示：<br><img src="./images/addCount-workflow.drawio.svg" alt="addCount-workflow"></p><p><code>addCount(long,int)</code>的逻辑可以划分为三部分：</p><ol><li>如果<code>CounterCell</code>数组为空，那么会尝试直接更新基数<code>baseCount</code></li><li>如果<code>CounterCell</code>数组不为空，那么会尝试直接更新对应的<code>CounterCell</code>对象</li><li>最坏情况下调用<code>fullAddCount</code>重新构造<code>CounterCell</code>对象</li></ol><p><code>fullAddCount(long,boolean)</code>的逻辑还是比较复杂的，它会负责<code>CounterCell</code>数组的初始化以及当前线程对应<code>CounterCell</code>的更新，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">这个函数作用就是在当前线程对应的槽位更新cell对象，但是并不负责计算map最后的大小</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">有很多场景能用到这个函数，包括：</span><br><span class="hljs-comment">1. CounterCell数组未初始化</span><br><span class="hljs-comment">2. 对应槽位的CounterCell未初始化</span><br><span class="hljs-comment">3. CounterCell初始化，但是修改value时CAS失败</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">其中属性cellBusy是专门为该函数准备的自旋锁，在扩容或者构造新cell时使用</span><br><span class="hljs-comment">wasCounttended表示进入这个函数原因是是否未更新对应CounterCell对象失败，true为不是因为失败</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fullAddCount</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, <span class="hljs-keyword">boolean</span> wasUncontended)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-comment">//如果当前线程的hash值还为准备好，那么强制初始化</span><br>    <span class="hljs-keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="hljs-number">0</span>) &#123;<br>        ThreadLocalRandom.localInit();      <span class="hljs-comment">// force initialization</span><br>        h = ThreadLocalRandom.getProbe();<br>        wasUncontended = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">boolean</span> collide = <span class="hljs-keyword">false</span>;                <span class="hljs-comment">// True if last slot nonempty</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        CounterCell[] as; CounterCell a; <span class="hljs-keyword">int</span> n; <span class="hljs-keyword">long</span> v;<br>        <span class="hljs-comment">//case1:如果CounterCell数组已经初始化好了</span><br>        <span class="hljs-keyword">if</span> ((as = counterCells) != <span class="hljs-keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//对应槽位的CounterCell对象没有初始化，或者正在扩容，那么尝试构造新的Cell</span><br>            <span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">//如果当前没有线程持有互斥锁</span><br>                <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// Try to attach new Cell</span><br>                    <span class="hljs-comment">//先构造好一个cell对象</span><br>                    CounterCell r = <span class="hljs-keyword">new</span> CounterCell(x); <span class="hljs-comment">// Optimistic create</span><br>                    <span class="hljs-comment">//尝试获取自旋锁cellsBusy</span><br>                    <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp;<br>                        U.compareAndSwapInt(<span class="hljs-keyword">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                        <span class="hljs-keyword">boolean</span> created = <span class="hljs-keyword">false</span>;<br>                        <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">// Recheck under lock</span><br>                            CounterCell[] rs; <span class="hljs-keyword">int</span> m, j;<br>                            <span class="hljs-comment">//再次检查cell数组是否为空</span><br>                            <span class="hljs-keyword">if</span> ((rs = counterCells) != <span class="hljs-keyword">null</span> &amp;&amp;<br>                                (m = rs.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                                rs[j = (m - <span class="hljs-number">1</span>) &amp; h] == <span class="hljs-keyword">null</span>) &#123;<br>                                <span class="hljs-comment">//在cell数组的对应槽位上赋值我们先构造好的cell对象</span><br>                                rs[j] = r;<br>                                <span class="hljs-comment">//cell对象创建成功，那么可以退出循环了</span><br>                                created = <span class="hljs-keyword">true</span>;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            <span class="hljs-comment">//释放自旋锁</span><br>                            cellsBusy = <span class="hljs-number">0</span>;<br>                        &#125;<br>                        <span class="hljs-comment">//如果创建cell对象成功，那么则退出循环</span><br>                        <span class="hljs-keyword">if</span> (created)<br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-comment">//对应的槽位已经不为空了</span><br>                        <span class="hljs-keyword">continue</span>;           <span class="hljs-comment">// Slot is now non-empty</span><br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">//设置扩容标志</span><br>                collide = <span class="hljs-keyword">false</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//走到这说明对应槽位的cell对象已经构造好了</span><br>            <span class="hljs-comment">//那么就判断进入这个函数的原因是不是因为更新对应cell的时候发生冲突</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wasUncontended)       <span class="hljs-comment">// CAS already known to fail</span><br>                <span class="hljs-comment">//如果是因为更新时cas发生冲突，那么就尝试进行一次rehash更新线程的hash值，并且只会更新一次</span><br>                wasUncontended = <span class="hljs-keyword">true</span>;      <span class="hljs-comment">// Continue after rehash</span><br><br>            <span class="hljs-comment">//在rehash之后尝试进行cas操作</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//如果cell数组扩容了，或者大小已经超过了核心处理器数量，那么对于当前线程来说不会再扩容了</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (counterCells != as || n &gt;= NCPU)<br>                <span class="hljs-comment">//设置扩容标志，设为false只会走下面的else-if，不可能到达后面的扩容逻辑</span><br>                collide = <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// At max size or stale</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide)<br>                collide = <span class="hljs-keyword">true</span>;<br>            <br>            <span class="hljs-comment">//尝试加锁扩容</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp;<br>                        U.compareAndSwapInt(<span class="hljs-keyword">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//执行CounterCells数组扩容操作</span><br>                    <span class="hljs-keyword">if</span> (counterCells == as) &#123;<span class="hljs-comment">// Expand table unless stale</span><br>                        CounterCell[] rs = <span class="hljs-keyword">new</span> CounterCell[n &lt;&lt; <span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>                            rs[i] = as[i];<br>                        counterCells = rs;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    cellsBusy = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-comment">//设置扩容标志</span><br>                collide = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">continue</span>;                   <span class="hljs-comment">// Retry with expanded table</span><br>            &#125;<br><br>            <span class="hljs-comment">//重新计算当先线程的hash值</span><br>            h = ThreadLocalRandom.advanceProbe(h);<br>        &#125;<br>        <span class="hljs-comment">//case2:CounterCell数组没有被加锁，并且没有初始化</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; counterCells == as &amp;&amp;<br>                    U.compareAndSwapInt(<span class="hljs-keyword">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">boolean</span> init = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">//那么则尝试进行初始化</span><br>            <span class="hljs-keyword">try</span> &#123;                           <span class="hljs-comment">// Initialize table</span><br>                <span class="hljs-comment">//再次判断cell数组没有被初始化</span><br>                <span class="hljs-keyword">if</span> (counterCells == as) &#123;<br>                    <span class="hljs-comment">//构造一个长度为2的cell数组，因为至少有两个线程竞争更改容量，才会进入这个函数</span><br>                    CounterCell[] rs = <span class="hljs-keyword">new</span> CounterCell[<span class="hljs-number">2</span>];<br>                    <span class="hljs-comment">//在当前线程的槽位上构造cell对象</span><br>                    rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> CounterCell(x);<br>                    counterCells = rs;<br>                    init = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">//释放自旋锁</span><br>                cellsBusy = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-comment">//如果成功初始化，说明cell对象也构造好了，那么则退出循环</span><br>            <span class="hljs-keyword">if</span> (init)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//case3:CounterCell数组正在初始化，因为获取自旋锁CELLBUSY失败，则尝试直接在原来的baseCount上累加</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapLong(<span class="hljs-keyword">this</span>, BASECOUNT, v = baseCount, v + x))<br>            <span class="hljs-keyword">break</span>;                          <span class="hljs-comment">// Fall back on using base</span><br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>整个<code>fullAddCount()</code>的逻辑可以划分为三个case（详情见注释）：</p><ol><li>case1：如果<code>CounterCell</code>数组已经初始化好了，那么直接尝试在当前线程对应槽位更新<code>CounterCell</code>对象</li><li>case2：<code>CounterCell</code>数组没有初始化，也没有加锁，那么会构建一个长度为2的<code>CounterCell</code>数组，因为至少存在两个同时更新的线程才会发生冲突</li><li>case3：<code>CounterCell</code>正在进行初始化或扩容，那么则直接尝试更新<code>baseCount</code></li></ol><p>其中我认为<code>case1</code>的情况稍微复杂点，我这里展示一下它的流程图：</p><p><img src="./images/fullAddCount.drawio.svg" alt="fullAddCount"></p><p>流程图可能有疏漏，后续再精进吧。</p><h3 id="2-3-计数更新逻辑"><a href="#2-3-计数更新逻辑" class="headerlink" title="2.3 计数更新逻辑"></a>2.3 计数更新逻辑</h3><p>上面说了那么多如何更新基数<code>baseCount</code>与<code>CounterCell</code>数组，那么<code>ConcurrentHashMap</code>到底是如何利用这两个属性计算当前table的大小呢？答案就在<code>size()</code>函数中，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> n = sumCount();<br>    <span class="hljs-keyword">return</span> ((n &lt; <span class="hljs-number">0L</span>) ? <span class="hljs-number">0</span> :<br>            (n &gt; (<span class="hljs-keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :<br>            (<span class="hljs-keyword">int</span>)n);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sumCount</span><span class="hljs-params">()</span> </span>&#123;<br>    CounterCell[] as = counterCells; CounterCell a;<br>    <span class="hljs-keyword">long</span> sum = baseCount;<br>    <span class="hljs-keyword">if</span> (as != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-keyword">null</span>)<br>                sum += a.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>size()</code>方法的逻辑很简单，调用<code>sumCount()</code>方法。而<code>sumCount()</code>的逻辑就是将<code>counterCells</code>数组中的每个值累加到<code>baseCount</code>上，最后的结果就是<code>ConcurrentHashMap</code>在某一时刻的值，因为<code>size()</code>方法并不是线程安全的，有可能我们正在计数的时候，其他线程正在更改<code>counterCells</code>数组。</p><h3 id="2-4-扩容逻辑"><a href="#2-4-扩容逻辑" class="headerlink" title="2.4 扩容逻辑"></a>2.4 扩容逻辑</h3><p>扩容实际上是靠<code>addCount()</code>的后半部分来完成的，如果在<code>addCount</code>中，当前线程发现table的大小已经超过了扩容阈值，才会走一个迁移数据的逻辑，这里和<code>tryPresize()</code>的中调用<code>transfer</code>迁移逻辑完全一样，我在<a href="./ConcurrentHashMap-analysis-II.md">ConcurrentHashMap扩容分析</a>中已经详细解释了，这里不在赘述。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCount</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, <span class="hljs-keyword">int</span> check)</span></span>&#123;<br>    ...<br>    <span class="hljs-comment">//下半部分用来处理扩容的逻辑，可以暂时无视</span><br>    <span class="hljs-keyword">if</span> (check &gt;= <span class="hljs-number">0</span>) &#123;<br>        Node&lt;K,V&gt;[] tab, nt; <span class="hljs-keyword">int</span> n, sc;<br>        <span class="hljs-comment">//如果当前table的大小已经超过了扩容阈值</span><br>        <span class="hljs-keyword">while</span> (s &gt;= (<span class="hljs-keyword">long</span>)(sc = sizeCtl) &amp;&amp; <br>        (tab = table) != <span class="hljs-keyword">null</span> &amp;&amp;<br>        <span class="hljs-comment">//并且当前table的大小还未超过最大值</span><br>        <span class="hljs-comment">//那么就会走一个扩容的逻辑</span><br>        (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;<br>            <span class="hljs-keyword">int</span> rs = resizeStamp(n);<br>            <span class="hljs-keyword">if</span> (sc &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="hljs-number">1</span> ||<br>                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="hljs-keyword">null</span> ||<br>                    transferIndex &lt;= <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>))<br>                    transfer(tab, nt);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc,<br>                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))<br>                transfer(tab, <span class="hljs-keyword">null</span>);<br>            s = sumCount();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-删除操作原理"><a href="#3-删除操作原理" class="headerlink" title="3. 删除操作原理"></a>3. 删除操作原理</h2><p>删除操作就比较简单了，核心函数是<code>replaceNode(object,V,Object)</code>，该函数实现了两种功能：</p><ol><li>更新旧值</li><li>删除键值对</li></ol><p>那么具体采用哪种操作取决于第三个参数<code>cv</code>，当不为null时则表示当前操作是更新旧值操作。具体逻辑如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> replaceNode(key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Implementation for the four public remove/replace methods:</span><br><span class="hljs-comment">* Replaces node value with v, conditional upon match of cv if</span><br><span class="hljs-comment">* non-null.  If resulting value is null, delete.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/*该函数实现了替换旧值或者删除节点的操作</span><br><span class="hljs-comment">如果cv不为空，则表示当前是替换旧值的操作</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">replaceNode</span><span class="hljs-params">(Object key, V value, Object cv)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> hash = spread(key.hashCode());<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-keyword">int</span> n, i, fh;<br>        <span class="hljs-comment">//计算当前key对应的桶索引</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span> ||<br>            (f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//如果当前table正在扩容，那么尝试协助</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-keyword">else</span> &#123;<br>            V oldVal = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">boolean</span> validated = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">//与插入类似，先对当前key所在的桶加锁</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    <span class="hljs-comment">//如果当前桶采用链表存储</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        ...<br>                    &#125;<br>                    <span class="hljs-comment">//如果当前桶采用红黑树存储</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        ...<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (validated) &#123;<br>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>)<br>                        <span class="hljs-comment">//如果是删除操作，那么需要更新大小</span><br>                        addCount(-<span class="hljs-number">1L</span>, -<span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">return</span> oldVal;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>实在没什么好说的，只不过在插入的时候，类似的，如果发现当前处理的桶正在扩容，那么就会调用<code>helpTransfer()</code>作为协助者进行数据迁移。并且在删除后会调用<code>addCount</code>更新大小。</p><h2 id="4-疑问"><a href="#4-疑问" class="headerlink" title="4. 疑问"></a>4. 疑问</h2><ol><li>为什么在Java1.8之后，<code>ConcurrentHashMap</code>采用<code>synchronized</code>而放弃了分段锁？</li></ol><p>通过  JDK 的源码和官方文档看来， 他们认为的弃用分段锁的原因由以下几点：</p><ul><li>加入多个分段锁浪费内存空间。</li><li>生产环境中， map 在放入时竞争同一个锁的概率非常小，分段锁反而会造成更新等操作的长时间等待。</li><li>为了提高 GC 的效率</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://segmentfault.com/a/1190000016096542">Java多线程进阶（二三）—— J.U.C之collections框架：ConcurrentHashMap(1) 原理</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>concurrent collections</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConcurrentHashMap扩容分析</title>
    <link href="/2021-06-03/ConcurrentHashMap-analysis-II.html"/>
    <url>/2021-06-03/ConcurrentHashMap-analysis-II.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇继承于<a href="./ConcurrentHashMap-analysis-I.md">ConcurrentHashMap架构解析</a>，在了解了<code>ConcurrentHashMap</code>的整体架构与插入删除逻辑后，还有一个知识点：<strong>扩容逻辑</strong>需要学习，我认为这是<code>ConcurrentHashMap</code>核心中的核心。</p><p>废话不多说，对于<code>ConcurrentHashMap</code>来说，扩容可以整体分为两个部分：</p><ol><li>将属性table扩展为原来的两倍</li><li>将旧table中数据迁移到新table</li></ol><p>那么本文就按照这两个小点逐个击破JDK8下的<code>ConcurrentHashMap</code>。</p><h2 id="1-预备知识"><a href="#1-预备知识" class="headerlink" title="1. 预备知识"></a>1. 预备知识</h2><p>在真正学习扩容逻辑前，我们有必要了解<code>ConcurrentHashMap</code>中的两个重点字段：<code>sizeCtl</code>与<code>transferIndex</code>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Table initialization and resizing control.  When negative, the</span><br><span class="hljs-comment">* table is being initialized or resized: -1 for initialization,</span><br><span class="hljs-comment">* else -(1 + the number of active resizing threads).  Otherwise,</span><br><span class="hljs-comment">* when table is null, holds the initial table size to use upon</span><br><span class="hljs-comment">* creation, or 0 for default. After initialization, holds the</span><br><span class="hljs-comment">* next element count value upon which to resize the table.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">-1表示当前正在初始化table，在初始化完毕后，sizeCtl维护的是扩容阈值</span><br><span class="hljs-comment">为其他负数时，值的含义是：-(1+正在协作数据转移的线程数量)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> sizeCtl;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The next table index (plus one) to split while resizing.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> transferIndex;<br></code></pre></div></td></tr></table></figure><p><strong>sizeCtl</strong>的注释基本上解释了这个字段的含义：</p><ol><li>“-1”表示当前table正在初始化</li><li>“其他负数”的含义为-(1+当前正在协助扩容的线程数量)</li><li>当table为空，为初始值“0”或者用户自定义的容量</li><li>当table不为空，“其他正数”的含义为扩容阈值</li></ol><p>其中第二点需要我们注意，当<code>sizeCtl</code>为负数时，32位bit被一分为2：</p><ol><li>高16位是一个基于当前线程生成的特征码，用于标记线程是否正在协助扩容</li><li>低16位表示（1+当前正在协助扩容的线程数量）</li></ol><p>可能这里说的太抽象，后面了解具体的构造逻辑应该就不是问题了。</p><p>至于<strong>transferIndex</strong>则表示的是一个线程负责的迁移范围右边界的下一个索引。</p><h2 id="2-table扩展逻辑"><a href="#2-table扩展逻辑" class="headerlink" title="2. table扩展逻辑"></a>2. table扩展逻辑</h2><p>能进行<code>table</code>扩展的地方有很多，我目前仅了解到两处：</p><ol><li>在<code>putVal(K,V,boolean)</code>中，如果table未初始化，那么则会调用<code>initTable()</code>扩展<code>table</code></li><li>在链表过长调用<code>treeifyBin()</code>尝试树化时，如果<code>table</code>的容量小于64，那么仅仅会通过<code>tryPreSize(int)</code>完成<code>table</code>扩展以及数据迁移</li><li>在调用<code>putAll()</code>时，首先会调用<code>tryPresize()</code>尝试扩展table</li></ol><p>基本上会扩展<code>table</code>的场景就上面三种，那么我们依次来了解下它们具体的逻辑。</p><h3 id="2-1-table的初始化"><a href="#2-1-table的初始化" class="headerlink" title="2.1 table的初始化"></a>2.1 table的初始化</h3><p><code>table</code>初始化的逻辑还是比较简单的，在关键点我都写了注释：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-keyword">int</span> sc;<br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-keyword">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//如果状态码sizeCtl小于0，表示有其他线程正在扩展扩展，那么我们需要做的只有等待</span><br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br>            Thread.yield(); <span class="hljs-comment">// lost initialization race; just spin</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">//sc不为0，表示用户自定义了容量</span><br>                    <span class="hljs-keyword">int</span> n = (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br>                    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node&lt;?,?&gt;[n];<br>                    table = tab = nt;<br>                    <span class="hljs-comment">//设置sc=factor*capacity，也就是扩容阈值</span><br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-comment">//只初始化一次</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-2-table的预扩展"><a href="#2-2-table的预扩展" class="headerlink" title="2.2 table的预扩展"></a>2.2 table的预扩展</h3><p>所谓的预扩展，也就是方法<code>tryPresize(int)</code>，它作为关键先生，除了初始化table时不使用它，后续所有的扩展逻辑都需要通过<code>tryPresize()</code>扩展table（因为当table不为空，需要进行数据迁移，<code>initTable()</code>干不了这事），并在方法内部调用数据迁移方法<code>transfer()</code>。</p><p>那么所谓的“预”是指什么？我认为是指线程有资格尝试扩容，但不一定完成扩容。因为在一次扩容的过程中，可能有多个线程都想要完成相同的任务，比如从16扩展到32。那么肯定得防止多次扩容，只能允许第一个调用该方法的线程完成扩容的逻辑，后续的线程没资格扩展table，它们只能作为协助者帮助数据迁移。</p><p>了解了<code>tryPresize</code>的使用场景，我们看看它具体的实现逻辑：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Tries to presize table to accommodate the given number of elements.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> size number of elements (doesn&#x27;t need to be perfectly accurate)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryPresize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>    <span class="hljs-comment">//c表示table的新容量</span><br>    <span class="hljs-keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="hljs-number">1</span>)) ? MAXIMUM_CAPACITY :<br>        tableSizeFor(size + (size &gt;&gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> sc;<br>    <span class="hljs-comment">//如果控制码sizeCtl为非负数，说明当前线程没有在初始化或者扩容</span><br>    <span class="hljs-keyword">while</span> ((sc = sizeCtl) &gt;= <span class="hljs-number">0</span>) &#123;<br>        Node&lt;K,V&gt;[] tab = table; <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-comment">//case1：table还未初始化或者长度为0</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>) &#123;<br>            n = (sc &gt; c) ? sc : c;<br>            <span class="hljs-comment">//将sizeCtl设置为-1，表示正在初始化table</span><br>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-comment">//将旧table扩容原来的两倍</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (table == tab) &#123;<br>                        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node&lt;?,?&gt;[n];<br>                        table = nt;<br>                        sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">//设置新的状态码，也就是新的扩容阈值</span><br>                    sizeCtl = sc;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        case2：有可能传入的参数size过小，甚至比原始table的扩容阈值都小，这种情况是有可能发生的：</span><br><span class="hljs-comment">        在putAll()中，首先会将table扩展为传入map的两倍大小，那么有可能原来table就不为空，</span><br><span class="hljs-comment">        并且远大于传入map大小的两倍，那么此时根本就不需要扩展以及数据迁移，直接返回即可</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//case3：table不为空，并且已经扩容完毕，为数据迁移做准备工作</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tab == table) &#123;<br>            <span class="hljs-comment">//为当前线程生成唯一的扩容标识码，n是旧table的长度</span><br>            <span class="hljs-keyword">int</span> rs = resizeStamp(n);<br>            <span class="hljs-comment">/*****************************</span><br><span class="hljs-comment">            *           Question1        *</span><br><span class="hljs-comment">            *****************************/</span><br>            <span class="hljs-keyword">if</span> (sc &lt; <span class="hljs-number">0</span>) &#123;<br>                Node&lt;K,V&gt;[] nt;<br>                <span class="hljs-comment">//如果当前线程无法协作数据转移，则退出</span><br>                <span class="hljs-keyword">if</span> (<br>                    (sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs ||<br>                    sc == rs + <span class="hljs-number">1</span> || sc == rs + MAX_RESIZERS ||<br>                    (nt = nextTable) == <span class="hljs-keyword">null</span> ||<br>                    transferIndex &lt;= <span class="hljs-number">0</span><br>                    )<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">//当前线程可能会作为协作线程帮助进行数据迁移</span><br>                <span class="hljs-comment">//尝试使用cas操作负责把状态码sc中的协作线程数+1</span><br>                <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>))<br>                    transfer(tab, nt);<br>            &#125;<br>            <span class="hljs-comment">//本线程作为第一个作为数据迁移的线程，</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc,<br>                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))<br>                transfer(tab, <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>可以看到，<code>tryPresize(int)</code>中的<code>while</code>执行条件，只有当前table没有扩容或者初始化时才会执行后续操作，这也就防止多个线程执行相同的扩容操作。那么进入<code>while</code>后，会分为3个小场景：</p><ol><li>当table没有被初始化时，说明用户应该调用的是<code>putAll()</code>，那么则尝试将状态码<code>sizeCtl</code>设置为-1并初始化table</li><li>当table不为空时，如果新容量小于旧的扩容阈值，或者已经超过了最大容量，那么根本就不需要扩容，直接返回即可</li><li>当table没有被扩容，那么当前线程则尝试作为第一个进行数据迁移的线程，调用<code>transfer()</code></li></ol><p>上面比较难理解的是第三个场景，我这里详细解释一下。首先会通过调用<code>resizeStamp</code>为本轮扩容操作生成唯一的标识，它的逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//线程标识符生成逻辑</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">resizeStamp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="hljs-number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在生成标识符的过程中：首先会将数字<code>1</code>右移15位（RESIZE_STAMP_BITS值为16），将标识符的第16位（从右往左）设置为1，然后跟当前table长度的前导0个数进行或操作。那么根据这个逻辑，在同一轮扩容操作中，假设有n个线程在协助扩容，扩容完成前旧table的前导0个数必然是相等的，那么为这n个线程生成的标识符也必然相等。</p><p>下面是生成标识符后的代码逻辑，分为两个部分：</p><ol><li>当前table正在进行数据迁移，那么当前线程只能作为协助者去帮助</li><li>当前table没有在数据迁移，那么当前线程作为数据迁移的发起者 </li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//case3逻辑</span><br>...<br><span class="hljs-keyword">if</span> (sc &lt; <span class="hljs-number">0</span>) &#123;<br>    Node&lt;K,V&gt;[] nt;<br>    <span class="hljs-comment">//如果当前线程无法协作数据转移，则退出</span><br>    <span class="hljs-keyword">if</span> (<br>        (sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs ||<br>        sc == rs + <span class="hljs-number">1</span> || sc == rs + MAX_RESIZERS ||<br>        (nt = nextTable) == <span class="hljs-keyword">null</span> ||<br>        transferIndex &lt;= <span class="hljs-number">0</span><br>        )<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-comment">//当前线程可能会作为协作线程帮助进行数据迁移</span><br>    <span class="hljs-comment">//尝试使用cas操作负责把状态码sc中的协作线程数+1</span><br>    <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>))<br>        transfer(tab, nt);<br>&#125;<br><span class="hljs-comment">//本线程作为第一个作为数据迁移的线程，</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc,<br>                                (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))<br>    transfer(tab, <span class="hljs-keyword">null</span>);<br></code></pre></div></td></tr></table></figure><p>可以看到，如果当前线程想要作为协助者，必须要求局部变量<code>sc</code>小于0，那么“Question1”处的<code>if</code>语句什么时候会被执行？能进入<code>while</code>循环，那么局部变量<code>sc</code>（不存在竞争性）不是必定大于等于0？怎么可能小于0？</p><p>对于这个问题，我找了很久很久，终于在网上找到了答案，“Question1”是个bug：<a href="https://bugs.openjdk.java.net/browse/JDK-8215409">JDK-8215409</a>，在JDK11以后，就不存在这个问题了。例如JDK14，对应的<code>tryPresize()</code>如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryPresize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="hljs-number">1</span>)) ? MAXIMUM_CAPACITY :<br>        tableSizeFor(size + (size &gt;&gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> sc;<br>    <span class="hljs-keyword">while</span> ((sc = sizeCtl) &gt;= <span class="hljs-number">0</span>) &#123;<br>        Node&lt;K,V&gt;[] tab = table; <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>) &#123;<br>            ...<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">/**********************</span><br><span class="hljs-comment">        * question1对应的代码  *</span><br><span class="hljs-comment">        **********************/</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tab == table) &#123;<br>            <span class="hljs-keyword">int</span> rs = resizeStamp(n);<br>            <span class="hljs-keyword">if</span> (U.compareAndSetInt(<span class="hljs-keyword">this</span>, SIZECTL, sc,<br>                                    (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))<br>                transfer(tab, <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，JDK8中的if语句完全被删除了。ok，虽然bug的问题解决了，但是又产生了一个新的问题，JDK8中的<code>if</code>是用来使用其他线程帮助数据迁移的，直接删除了帮助的逻辑，这个“帮助”又怎么实现？我仔细查看了插入的逻辑，发现在调用<code>putVal</code>时，有可能会调用<code>helpTransfer()</code>达到“帮助数据迁移”的目的，这个方法我会和迁移逻辑<code>transfer()</code>方法一起分析。</p><hr><p><strong>Extension：</strong><br>对于这个问题，其实我觉的还有一点需要注意：我刚开始用中文英文都没有搜索到这个bug，why？我想原因可能是关键词没有写对，以后找JDK的bug，尽量使用<code>&lt;class name&gt;.&lt;method name&gt;</code>的格式，例如<code>ConcurrentHashMap.tryPresize()</code>。</p><hr><p>那么如果当前线程作为数据迁移的发起者，会尝试CAS<code>U.compareAndSwapInt(this, SIZECTL, sc,(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</code>将状态码<code>sizeCtl</code>设置为负数，这如何理解？</p><p>首先我们从前文知道，线程标识符<code>rs</code>的第16位一定是1，此时再右移16位，那么第16位的1一定会移动至第32位。ok，那么移动完成后<code>rs</code>一定是一个负数，并且第1~16位（从右往左）一定为0。此时再+2（1+1，其中一个1表示当前正在数据迁移的线程数量），就是最终的状态码<code>sizeCtl</code>。这也就达到了<code>sizeCtl</code>的第二种使用场景。</p><p>生成新的状态码后，第一个启动数据迁移的线程会调用<code>transfer()</code>完成真正的数据迁移，该方法的逻辑放在下一章中讲解。</p><h3 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2 小结"></a>2.2 小结</h3><p><code>ConcurrentHashMap</code>扩展table的核心方法是<code>tryPresize(int)</code>,它就是让属于同一轮扩容操作的线程一起完成数据迁移，加快效率。而不是让单个线程把整个table锁住，独自完成。</p><p>但是对于该方法，我也提出一个疑问：如果原始table中没有元素，那么初始化table后，没有数据转移啊，怎么结束<code>while</code>循环？目前我还没有明确的答案，我们在梳理完数据迁移函数<code>transfer()</code>的逻辑后，再来尝试回答这个问题。</p><hr><p>在此贴出答案：其中变量<code>c</code>只会在旧table为空时才会改变，所以只会被初始化一次。而一旦进入<code>transfer()</code>，生成的新table长度是2c，那么新的扩容阈值<code>sizeCtl</code>为<code>2c*0.75=1.5c</code>，所以再次进入while循环时，会进入case2，因为<code>c&lt;=sc</code>，直接退出循环。</p><hr><h2 id="3-数据迁移"><a href="#3-数据迁移" class="headerlink" title="3. 数据迁移"></a>3. 数据迁移</h2><p>数据迁移是扩容操作的核心，主要通过<code>transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</code>完成，如果第二个参数<code>nextTab</code>为空，说明调用该方法的是数据迁移发起者，不为空则说明当前线程是数据迁移协助者。</p><p>能够调用该方法的地方有很多，我罗列一下目前我已知的地方：</p><ol><li>在<code>putVal()</code>中，如果发现table正在进行数据迁移，那么插入线程会调用<code>helpTransfer()</code>帮助数据迁移</li><li>在<code>addCount()</code>中，更新table容量时会=可能会调用<code>transfer()</code>发起数据迁移</li><li>在<code>tryPresize()</code>，会调用<code>transfer()</code>发起数据迁移</li></ol><p>为了能够更快地理解<code>transfer()</code>地逻辑，我们首先需要了解一些前置知识：</p><ol><li>每一个进行数据迁移的线程都会负责一个范围的桶，范围的一般形式为 <strong>[left_bound,right_bound ]<strong>，其中</strong>right_bound-left_bound=stride</strong></li><li><code>stride</code>：表示一个线程需要负责转移多少连续的桶，最小值为16</li><li><code>transferIndex</code>：表示当前线程负责迁移范围的右边界的下一个位置，有<strong>transferIndex=right_bound+1</strong></li><li><code>ForwardingNode</code>：占位符，如果一个桶转移完毕，那么会在旧table中放入一个<code>ForwardingNode</code>作为标记</li><li><code>ConcurrentHashMap</code>是从后往前逐个转移每个桶的数据</li></ol><p>说了这么多，我们来看看<code>transfer()</code>到底长什么样：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 该方法在table扩容后，进行数据迁移的操作</span><br><span class="hljs-comment">* Moves and/or copies the nodes in each bin to new table. See</span><br><span class="hljs-comment">* above for explanation.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = tab.length, stride;<br>    <span class="hljs-keyword">if</span> ((stride = (NCPU &gt; <span class="hljs-number">1</span>) ? (n &gt;&gt;&gt; <span class="hljs-number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)<br>        stride = MIN_TRANSFER_STRIDE; <span class="hljs-comment">// subdivide range</span><br>    <span class="hljs-comment">//数据迁移发起者传入的参数nextTab一定为null，所以能够保证只会生成一个nextTab</span><br>    <span class="hljs-comment">//直接生成一个容量为旧table两倍的新table</span><br>    <span class="hljs-keyword">if</span> (nextTab == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// initiating</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="hljs-number">1</span>];<br>            nextTab = nt;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      <span class="hljs-comment">// try to cope with OOME</span><br>            sizeCtl = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//将nextTab赋值给nextTable</span><br>        nextTable = nextTab;<br>        transferIndex = n;<br>    &#125;<br>    <span class="hljs-keyword">int</span> nextn = nextTab.length;<br>    ForwardingNode&lt;K,V&gt; fwd = <span class="hljs-keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);<br>    <span class="hljs-comment">//advance为true表示当前线程已经把负责范围内的某个桶迁移完毕</span><br>    <span class="hljs-keyword">boolean</span> advance = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">//finishing字段表示整个旧table的数据迁移是否完成</span><br>    <span class="hljs-keyword">boolean</span> finishing = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// to ensure sweep before committing nextTab</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, bound = <span class="hljs-number">0</span>;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-keyword">int</span> fh;<br>        <span class="hljs-comment">//进行具体迁移任务前的预处理工作，主要是计算当前线程需要负责的桶索引</span><br>        <span class="hljs-keyword">while</span> (advance) &#123;<br>            <span class="hljs-comment">//所有协作线程的nextIndex初始值都为(old table).length</span><br>            <span class="hljs-keyword">int</span> nextIndex, nextBound;<br>            <span class="hljs-comment">//i表示当前线程处理的桶索引，如果i&gt;=bound，说明当前负责的范围还没有处理完毕,那么直接跳出循环，处理新桶</span><br>            <span class="hljs-comment">//其中bound表示当前线程负责范围的下界</span><br>            <span class="hljs-keyword">if</span> (--i &gt;= bound || finishing)<br>                advance = <span class="hljs-keyword">false</span>;<br>            <br>            <span class="hljs-comment">//transferIndex&lt;=0，表示整个table已经处理完毕了</span><br>            <span class="hljs-comment">//因为transferIndex表示的是迁移范围的下一个索引</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="hljs-number">0</span>) &#123;<br>                i = -<span class="hljs-number">1</span>;<br>                advance = <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-comment">//当前线程负责迁移的范围：[transferIndex-stride,transferIndex-1]</span><br>            <span class="hljs-comment">//每分配一次范围，将transferIndex从后往前移动stride的距离</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt<br>                        (<span class="hljs-keyword">this</span>, TRANSFERINDEX, nextIndex,<br>                        nextBound = (nextIndex &gt; stride ?<br>                                    nextIndex - stride : <span class="hljs-number">0</span>))) &#123;<br>                <span class="hljs-comment">//bound表示迁移范围的左边界</span><br>                bound = nextBound;<br>                i = nextIndex - <span class="hljs-number">1</span>;<br>                advance = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//case1：</span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;<br>            <span class="hljs-keyword">int</span> sc;<br>            <span class="hljs-comment">//如果扩容结束，那么则将控制码sizeCtl设置为新的扩容阈值：n*factor，并返回</span><br>            <span class="hljs-keyword">if</span> (finishing) &#123;<br>                nextTable = <span class="hljs-keyword">null</span>;<br>                table = nextTab;<br>                sizeCtl = (n &lt;&lt; <span class="hljs-number">1</span>) - (n &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">//将SizeCtl后16位表示的协作线程数量-1</span><br>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-comment">//如果当前线程不是最后一个完成迁移的线程，那么直接退出</span><br>                <span class="hljs-keyword">if</span> ((sc - <span class="hljs-number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)<br>                    <span class="hljs-keyword">return</span>;<br>                <span class="hljs-comment">//当前线程是最后一个完成协作的线程，将完成标志位finishing设为true</span><br>                finishing = advance = <span class="hljs-keyword">true</span>;<br>                i = n; <span class="hljs-comment">// recheck before commit</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//case2：如果当前桶为空，直接尝试使用cas往该桶中放入占位符ForwardingNode</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i)) == <span class="hljs-keyword">null</span>)<br>            advance = casTabAt(tab, i, <span class="hljs-keyword">null</span>, fwd);<br>        <span class="hljs-comment">//case3：如果当前桶的第一个节点是占位符ForwardingNode，那么说明当前桶已经完成了迁移</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            advance = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// already processed</span><br>        <span class="hljs-comment">//case4：</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//对唯一的一个桶上锁，然后开始转移一个桶内的节点，这与HashMap是类似的</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    Node&lt;K,V&gt; ln, hn;<br>                    <span class="hljs-comment">//当前桶的存储结构是链表</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        ...<br>                        setTabAt(nextTab, i, ln);<br>                        setTabAt(nextTab, i + n, hn);<br>                        <span class="hljs-comment">//设置占位符ForwardingNode</span><br>                        setTabAt(tab, i, fwd);<br>                        advance = <span class="hljs-keyword">true</span>;<br>                    &#125;<br>                    <span class="hljs-comment">//如果当前桶的存储结构是红黑树，则采用红黑树的迁移方法</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        ...<br>                        &#125;<br>                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :<br>                            (hc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;<br>                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :<br>                            (lc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;<br>                        setTabAt(nextTab, i, ln);<br>                        setTabAt(nextTab, i + n, hn);<br>                        setTabAt(tab, i, fwd);<br>                        advance = <span class="hljs-keyword">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>transfer()</code>的代码比较长，我们可以把它的逻辑分为如下两个部分：</p><ol><li>计算当前线程负责的迁移范围</li><li>进行具体的迁移操作</li></ol><p>下面我将分别详述这两个部分。</p><h3 id="3-1-迁移范围的计算"><a href="#3-1-迁移范围的计算" class="headerlink" title="3.1 迁移范围的计算"></a>3.1 迁移范围的计算</h3><p>当前线程负责的迁移范围由代码中的<code>while</code>循环负责计算，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">...<br><span class="hljs-keyword">while</span> (advance) &#123;<br>    <span class="hljs-comment">//所有协作线程的nextIndex初始值都为(old table).length</span><br>    <span class="hljs-keyword">int</span> nextIndex, nextBound;<br>    <span class="hljs-comment">//i表示当前线程处理的桶索引，如果i&gt;=bound，说明当前负责的范围还没有处理完毕,那么直接跳出循环，处理新桶</span><br>    <span class="hljs-comment">//其中bound表示当前线程负责范围的下界</span><br><br>    <span class="hljs-comment">/************************</span><br><span class="hljs-comment">    *        case1          *</span><br><span class="hljs-comment">    ************************/</span><br>    <span class="hljs-keyword">if</span> (--i &gt;= bound || finishing)<br>        advance = <span class="hljs-keyword">false</span>;<br>    <br>    <span class="hljs-comment">//transferIndex&lt;=0，表示整个table已经处理完毕了</span><br>    <span class="hljs-comment">//因为transferIndex表示的是迁移范围的下一个索引</span><br><br>    <span class="hljs-comment">/************************</span><br><span class="hljs-comment">    *        case2          *</span><br><span class="hljs-comment">    ************************/</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="hljs-number">0</span>) &#123;<br>        i = -<span class="hljs-number">1</span>;<br>        advance = <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//当前线程负责迁移的范围：[transferIndex-stride,transferIndex-1]</span><br>    <span class="hljs-comment">//每分配一次范围，将transferIndex从后往前移动stride的距离</span><br><br>    <span class="hljs-comment">/************************</span><br><span class="hljs-comment">    *        case3          *</span><br><span class="hljs-comment">    ************************/</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt<br>                (<span class="hljs-keyword">this</span>, TRANSFERINDEX, nextIndex,<br>                nextBound = (nextIndex &gt; stride ?<br>                            nextIndex - stride : <span class="hljs-number">0</span>))) &#123;<br>        <span class="hljs-comment">//bound表示迁移范围的左边界</span><br>        bound = nextBound;<br>        i = nextIndex - <span class="hljs-number">1</span>;<br>        advance = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br>...<br></code></pre></div></td></tr></table></figure><p>我们可以分为三种case来理解<code>while</code>，对于每种case的含义我注释已经写的比较清楚了，不再赘述。我这里模拟一下多线程协作时计算范围的场景（假设有三个线程A、B，旧table的长度为32，步长为16）：</p><ol><li>当第一个线程<code>A</code>进入while循环后，会进入<code>case3</code>，<code>nextIndex</code>默认为32，那么<code>nextBound</code>的结果为（32-16），所以A线程负责的范围为<code>[bound,nextIndex-1]</code> ==<code>[16,32-1]</code>，并且从索引31开始处理</li><li>当线程<code>B</code>进入while循环后，同样会进入<code>case3</code>，<code>nextIndex</code>的值为16，那么<code>nextBound</code>的结果为（16-16），所以B线程负责的范围为<code>[bound,nextIndex-1]</code> ==<code>[0,16-1]</code>，从索引15开始索引</li><li>当A线程处理完毕后，因为<code>case1</code>条件不符合，进入<code>case2</code>将i设为<code>-1</code>，最后完成一些收尾工作；如果旧table足够大的话，会进入<code>case3</code>申请新的迁移区间重复数据迁移的过程</li></ol><p>当整个旧table都迁移完成后，所有迁移线程都会进入<code>case2</code>将索引<code>i</code>设置为<code>-1</code>。</p><h3 id="3-2-迁移操作的四种情况"><a href="#3-2-迁移操作的四种情况" class="headerlink" title="3.2 迁移操作的四种情况"></a>3.2 迁移操作的四种情况</h3><p>在计算完当前线程需要负责的迁移范围后，会分为四种情况：</p><ol><li>当前线程的迁移工作已经结束</li><li>当前处理的桶为空，直接尝试使用cas往该桶中放入占位符ForwardingNode</li><li>当前桶的第一个节点是占位符ForwardingNode，那么说明当前桶已经完成了迁移，开始处理下一个桶</li><li>对当前桶进行迁移工作</li></ol><p>我在下面代码中已经注释了四种case：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">...<br><span class="hljs-comment">//case1：当前线程的迁移工作已经结束</span><br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;<br>    <span class="hljs-keyword">int</span> sc;<br>    <span class="hljs-comment">//如果扩容结束，那么则将控制码sizeCtl设置为新的扩容阈值：n*factor，并返回</span><br>    <span class="hljs-keyword">if</span> (finishing) &#123;<br>        nextTable = <span class="hljs-keyword">null</span>;<br>        table = nextTab;<br>        sizeCtl = (n &lt;&lt; <span class="hljs-number">1</span>) - (n &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//将SizeCtl后16位表示的协作线程数量-1</span><br>    <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-comment">//如果当前线程不是最后一个完成迁移的线程，那么直接退出</span><br>        <span class="hljs-comment">/*****************************</span><br><span class="hljs-comment">        *注意这里的sc和sizeCtl是两个值*</span><br><span class="hljs-comment">        ****************************/</span><br>        <span class="hljs-keyword">if</span> ((sc - <span class="hljs-number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//当前线程是最后一个完成协作的线程，将完成标志位finishing设为true</span><br>        finishing = advance = <span class="hljs-keyword">true</span>;<br>        i = n; <span class="hljs-comment">// recheck before commit</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//case2：如果当前桶为空，直接尝试使用cas往该桶中放入占位符ForwardingNode</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i)) == <span class="hljs-keyword">null</span>)<br>    advance = casTabAt(tab, i, <span class="hljs-keyword">null</span>, fwd);<br><span class="hljs-comment">//case3：如果当前桶的第一个节点是占位符ForwardingNode，那么说明当前桶已经完成了迁移</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>    advance = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// already processed</span><br><span class="hljs-comment">//case4：迁移当前桶的数据</span><br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//对唯一的一个桶上锁，然后开始转移一个桶内的节点，这与HashMap是类似的</span><br>    <span class="hljs-keyword">synchronized</span> (f) &#123;<br>        <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>            Node&lt;K,V&gt; ln, hn;<br>            <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                ...<br>                setTabAt(nextTab, i, ln);<br>                setTabAt(nextTab, i + n, hn);<br>                <span class="hljs-comment">//设置占位符ForwardingNode</span><br>                setTabAt(tab, i, fwd);<br>                advance = <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-comment">//如果当前桶的存储结构是红黑树，则采用红黑树的迁移方法</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                ...<br>                setTabAt(nextTab, i, ln);<br>                setTabAt(nextTab, i + n, hn);<br>                setTabAt(tab, i, fwd);<br>                advance = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>...<br></code></pre></div></td></tr></table></figure><p>我认为<code>case1</code>中的两个if<strong>非常</strong>值得注意：</p><ol><li><p><code>if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1))</code>：这么写的原因是因为当一个线程完成了迁移工作，那么就会将<code>sizeCtl</code>低16位维护的线程数量减1。如果是最后一个协助线程，那么<code>sizeCtl</code>的值为<code>(resizeStamp(old tab.length)&lt;&lt;RESIZE_STAMP_SHIFT)+1</code>，这会作为迁移工作完成的标志，因为最后一个线程会通过下面的if条件并设置标志位<code>finishing</code>。</p></li><li><p><code>if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</code>，这么写的原因是因为迁移工作的发起者会执行<code>sizeCtl=(resizeStamp(old tab.length)&lt;&lt;RESIZE_STAMP_SHIFT)+2</code>，如果该if条件通过，说明当前线程就是最后一个完成迁移的线程，将标志位<code>finishing</code>设为true，并且将索引<code>i</code>设为n，这样下一轮循环依然能进入上面迁移操作的逻辑中，再次进入case1更新<code>sizeCtl</code>、<code>table</code>后并返回</p></li></ol><p>至于其他三种case，我认为并不难理解，基本注释我已写在代码中，这里不再赘述。</p><h3 id="3-3-协助线程的入口"><a href="#3-3-协助线程的入口" class="headerlink" title="3.3 协助线程的入口"></a>3.3 协助线程的入口</h3><p>如果一个线程只能作为协助者的身份来迁移数据，那么它调用<code>tranfser()</code>进行协助的入口点只有<code>helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f)</code>。能够调用<code>helpTransfer()</code>的地方有很多，一般最常见的就是在<code>putVal()</code>中，如果插入桶的第一个节点hash值为<code>MOVED</code>，就会进入<code>helpTransfer()</code>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//putVal()中helpTransfer的入口点</span><br>...<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>        tab = helpTransfer(tab, f);<br></code></pre></div></td></tr></table></figure><p><code>helpTransfer()</code>的返回值是新table，基本的注释我都写在了代码中：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;<br>    Node&lt;K,V&gt;[] nextTab; <span class="hljs-keyword">int</span> sc;<br>    <span class="hljs-comment">//旧table不为空</span><br>    <span class="hljs-keyword">if</span> (tab != <span class="hljs-keyword">null</span> &amp;&amp;<br>    <span class="hljs-comment">//桶中第一个节点为标记节点ForwardingNode</span><br>    (f <span class="hljs-keyword">instanceof</span> ForwardingNode) &amp;&amp;<br>    <span class="hljs-comment">//标记节点ForwardingNode中存储的新table不为空</span><br>        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//计算出本轮扩容的标志码</span><br>        <span class="hljs-keyword">int</span> rs = resizeStamp(tab.length);<br>        <span class="hljs-comment">/*如果标记节点ForwardingNode中存储的新table和ConcurrentHashMap的属性nextTable是同一个table</span><br><span class="hljs-comment">        并且传入的旧table和ConcurrentHashMap的属性table是同一个table才能保证协助线程和发起线程实在操作同一轮扩容操作</span><br><span class="hljs-comment">        因为sizeCtl&lt;0可能是正在进行初始化table操作</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;<br>                (sc = sizeCtl) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-comment">//如果生成的标识符不一样，说明本轮扩容工作已经结束了</span><br>                (sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs ||<br>                <span class="hljs-comment">//表示扩容已经结束，原理在下面详解</span><br>                <span class="hljs-comment">/*******************</span><br><span class="hljs-comment">                *      Question1   *</span><br><span class="hljs-comment">                *******************/</span><br>                sc == rs + <span class="hljs-number">1</span> ||<br>                <span class="hljs-comment">//扩容的线程数达到最大值</span><br>                sc == rs + MAX_RESIZERS ||<br>                <span class="hljs-comment">//转移工作已经结束了</span><br>                transferIndex &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//将协助的线程数+1，并调用transfer进行协助</span><br>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>)) &#123;<br>                transfer(tab, nextTab);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nextTab;<br>    &#125;<br>    <span class="hljs-keyword">return</span> table;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我认为值得注意的是“Question1”处，<code>sc==rs+1</code>为什么表示当前迁移工作已经完成。原因我已在迁移操作四种情况中的case1处解释。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>我认为<code>ConcurrentHashMap</code>的扩容还是比较复杂的，当然我们要抓住核心：只会有一个线程发起数据迁移，而其他线程会作为协作者。并且每个线程会负责一段连续的桶。至于具体的数据迁移跟<code>HashMap</code>是类似的：对于链表，会随机地划分为高低两个链表；对于红黑树，会拆分成两颗子树，最后存入新table对应的位置。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/">ConcurrentHashMap扩容源码介绍</a></p></li><li><p><a href="https://segmentfault.com/a/1190000016124883">Java多线程进阶（二四）—— J.U.C之collections框架：ConcurrentHashMap(2) 扩容</a></p></li><li><p><a href="https://www.javadoop.com/post/hashmap">Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析</a></p></li><li><p><a href="https://programmer.group/concurrent-hashmap-source-detailed-analysis-jdk-1.8.html">Concurrent HashMap Source Detailed Analysis (JDK 1.8)</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>concurrent collections</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOC到底是什么？</title>
    <link href="/2021-06-03/what-is-IOC.html"/>
    <url>/2021-06-03/what-is-IOC.html</url>
    
    <content type="html"><![CDATA[<p>这篇博文：<a href="https://www.cnblogs.com/DebugLZQ/archive/2013/06/05/3107957.html">浅谈IOC–说清楚IOC是什么</a>讲的不错，我在此就是做一些摘抄。</p><hr><h2 id="1-IOC是什么？"><a href="#1-IOC是什么？" class="headerlink" title="1. IOC是什么？"></a>1. IOC是什么？</h2><p>IOC，Inversion of Control，译为控制反转。</p><p>1996年，Michael Mattson在其论文:<a href="https://www.researchgate.net/publication/2238535_Object-Oriented_Frameworks">Object-Oriented FrameworksA survey of methodological issues</a>中，首先提出了IOC这个概念，IOC是一个方法论。</p><p>简单来说，IOC的概念仅适用于面向对象的框架，而不面向于库函数。如果使用了框架，那么不再是程序员控制程序的所有流程，而是框架控制我们书写的程序，我们写的程序仅仅是为了适应框架。</p><p>对于面向对象的框架，IOC用于把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。</p><p><strong>IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。</strong></p><h2 id="2-控制了什么？"><a href="#2-控制了什么？" class="headerlink" title="2. 控制了什么？"></a>2. 控制了什么？</h2><p><img src="https://images0.cnblogs.com/blog/281227/201305/30130748-488045b61d354b019a088b9cb7fc2d73.png" alt="origin"></p><p>软件系统在没有引入IOC容器之前，如上图所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，<strong>自己必须主动</strong>去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</p><p><img src="https://images0.cnblogs.com/blog/281227/201305/30131727-a8268fe6370049028078e6b8a1cbc88f.png" alt="IOC"><br>软件系统在引入IOC容器之后，这种情形就完全改变了，如上图所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。</p><p>通过前后的对比，我们不难看出来：<strong>对象A获得依赖对象B的过程,由主动行为变为了被动行为</strong>，控制权颠倒过来了，这就是“控制反转”这个名称的由来。<strong>所谓的控制就是依赖资源的控制权</strong>。</p><h2 id="3-反转了什么？"><a href="#3-反转了什么？" class="headerlink" title="3. 反转了什么？"></a>3. 反转了什么？</h2><p>2004年，Martin Fowler探讨了同一个问题，既然IOC是控制反转，那么到底是“哪些方面的控制被反转了呢？”，经过详细地分析和论证后，他得出了答案：<strong>“获得依赖对象的过程被反转了”</strong>。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。于是，他给“控制反转”取了一个更合适的名字叫做“依赖注入（Dependency Injection）”。他的这个答案，实际上给出了实现IOC的方法：注入。所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p><p>所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。</p><h2 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4. 代码示例"></a>4. 代码示例</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> UserDao u;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserServiceImpl</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//UserServiceImpl的依赖对象是通过其自己生成的，耦合度较高</span><br>        <span class="hljs-comment">//如果现在想用Oracle的实现类，那么就需要手动更改下面的代码</span><br>        u=<span class="hljs-keyword">new</span> MySQLImpl();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">()</span></span>&#123;<br>        u.use();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面代码中的<code>UserServiceImpl</code>和其依赖的资源<code>UserDao</code>是一个强耦合的现象，<strong>我们需要知道具体调用的是哪个实现类，构造方法的参数是什么</strong>，如果想要换成另外的实现类，复杂程度会随着应用的复杂程度而增加。所以为了降低对象之间的耦合度，可以采取以下注入的方式的降低耦合度：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> UserDao u;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserServiceImpl</span><span class="hljs-params">(UserDao u)</span></span>&#123;<br>        <span class="hljs-comment">//通过注入的方式将UserServiceImpl的依赖添加进来</span><br>        <span class="hljs-keyword">this</span>.u=u;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">()</span></span>&#123;<br>        u.use();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>所以上面实现了一次控制反转，在<code>UserServiceImpl</code>中我们并<strong>不需要知道UserDao具体的实现类是什么，如何生成的，我们只管使用</strong>。依赖资源的生成不再由主动使用方控制，而是由第三方控制，被动地接收第三方提供的资源。这里的第三方在Spring中就是IOC容器。</p><h2 id="5-使用IOC容器有什么好处？"><a href="#5-使用IOC容器有什么好处？" class="headerlink" title="5. 使用IOC容器有什么好处？"></a>5. 使用IOC容器有什么好处？</h2><p>如果我们手动地实现控制反转，那么我们必须手动地写很多new，并且需要了解各个对象的构造函数，例如对于上面的<code>UserServiceImpl</code>，使用的流程一般如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    ...main()&#123;<br>        UserDao u=<span class="hljs-keyword">new</span> MySQLImpl();<br>        UserServiceImpl i=<span class="hljs-keyword">new</span> UserServiceImpl(u);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>如上所示，还是显示的使用了new，当依赖对象一旦多了起来，new的数量就会急剧增加，并且还要了解各个依赖对象的构造方法。所以IOC容器的好处就是：</p><ol><li>因为采用了依赖注入，在初始化的过程中就不可避免的会写大量的new。这里IoC容器就解决了这个问题。这个容器可以自动对你的代码进行初始化，你只需要维护一个Configuration（可以是xml可以是一段代码）</li><li>我们在创建实例的时候不需要了解其中依赖资源的细节</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://labs.madisoft.it/about-inversion-of-control/">About inversion of control</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021-06-03/tomcat.html"/>
    <url>/2021-06-03/tomcat.html</url>
    
    <content type="html"><![CDATA[<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>面试官您好，我叫高宇航，目前是武汉大学国家网络安全学院的硕士二年级研究生，本科也就读于武汉大学网络安全学院。</p><p>在个人技术方面：<br>我对Java的基础比较熟悉，包括Java语言本身以及一些jvm的相关原理，在安全方面，我对二进制安全比较了解，能够熟练阅读调试汇编，使用常见的恶意代码分析工具，比如ollydbg、IDA，对于web安全，我了解一些基本的攻击漏洞，例如xss和CSRF</p><p>在项目经验方面，主要分为两部分：</p><p>第一部分是因为我想深入了解一下web服务器到底是如何工作的，所以我自己完成了一个具备servlet容器功能的web服务器，对于一个servlet容器的核心功能都进行了实现，包括servlet的完整生命周期、重定向与内部转发、cookie与session，调用用户servlet处理的http的请求</p><p>第二部分是参与了实验室的一个大课题，跟另外一个组员完成了一些APT组织恶意样本分析，我主要负责DarkHotel、GreenSpot，并对一些通用的木马功能函数（包括字符串加解密、程序自启动、手机信息这三个类别）进行了代码重构与复用，并编译成静态库供病毒开发使用，最后为整个项目开发了一个恶意文件上下载的原型系统</p><h2 id="1-tomcat"><a href="#1-tomcat" class="headerlink" title="1.tomcat"></a>1.tomcat</h2><h3 id="为什么要参考tomcat？"><a href="#为什么要参考tomcat？" class="headerlink" title="为什么要参考tomcat？"></a>为什么要参考tomcat？</h3><h3 id="为什么要实现一个servlet的容器？"><a href="#为什么要实现一个servlet的容器？" class="headerlink" title="为什么要实现一个servlet的容器？"></a>为什么要实现一个servlet的容器？</h3><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>web服务器实现了servlet的完整声明周期，同时包含用于处理http请求的核心功能，包括cookie与session、http的重定向与内部跳转，自定义类加载器、过滤器，支持多端口多应用部署。</p><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>servlet容器总共由六个组件构成，分别是：server、service、connector、engine、host、context这6个核心组件</p><ol><li><p>Server元素在最顶层，代表整个Tomcat容器，因此它必须是server.xml中唯一一个最外层的元素。一个Server元素中可以有一个或多个Service元素。</p></li><li><p><strong>Service的作用是把Connector和Engine组装在一起对外提供服务。</strong>一个Service可以包含多个Connector，但是只能包含一个Engine；</p></li><li><p><strong>Connector的主要功能是接收连接请求</strong>，创建Request和Response对象用于和请求端交换数据；然后分配线程让Engine来处理这个请求，并把产生的Request和Response对象传给Engine。</p></li><li><p>Engine组件在Service组件中<strong>有且只有一个</strong>；Engine是Service组件中的请求处理组件。Engine组件从一个或多个Connector中接收请求并处理，并将完成的响应返回给Connector，最终传递给客户端。</p></li><li><p>虚拟主机Host是Engine的子容器。Engine组件中可以内嵌1个或多个Host组件，每个Host组件代表Engine中的一个虚拟主机。Host组件至少有一个，<strong>且其中一个的name必须与Engine组件的defaultHost属性相匹配</strong>。<strong>Host虚拟主机的作用是运行多个Web应用</strong>（一个Context代表一个Web应用），并负责安装、展开、启动和结束每个Web应用。</p></li><li><p><strong>Context元素代表在特定虚拟主机上运行的一个Web应用</strong>。在后文中，提到Context、应用或Web应用，它们指代的都是Web应用。每个Web应用基于WAR文件，或WAR文件解压后对应的目录（这里称为应用目录）。</p></li></ol><h3 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h3><p>核心类包括：</p><ol><li>Context类，为当前web应用提供上下文</li><li>request类，必须实现HttpServletRequest接口，因为这样才能够传递给用户的servlet进行处理</li><li>response类，实现了HttpServletResponse接口</li></ol><p>功能类包括：</p><ol><li>ServletContext，用于负责当前web应用所有servlet的上下文</li><li>RequestDispatcher，负责内部转发</li><li>ServletConfig，负责servlet的参数初始化</li><li>HttpSession，用于解决http无状态的问题</li><li>Filter，用于拦截用户请求</li></ol><p>难点主要是系统的初始化工作：</p><h3 id="系统启动时的初始化工作"><a href="#系统启动时的初始化工作" class="headerlink" title="系统启动时的初始化工作"></a>系统启动时的初始化工作</h3><p>根据servlet容器的配置文件<code>server.xml</code>初始化容器的各个组件，</p><p>初始化需要的注意点：</p><ol><li><p>这里采用的是由外到内的初始化各个组件：</p><ul><li>service启动各个connector，这里采用的方法是将connector包装成一个线程，一直监听目标端口</li><li>其中Engine要负责维护一个defaultHost，用来处理没有找到合适host的请求</li><li>host需要扫描默认目录下（也就是webapps）的所有war包以及文件夹，为每一个应用初始化context</li><li>其中context的初始化是核心，通过加载当前web应用的web.xml文件（与tomcat类似，为web应用设置了一个默认的web.xml相对路径（context.xml），一般就是/WEB-INF/web.xml，在配置context，都会配置web应用的虚拟路径和绝对路径映射，只需要将web应用的绝对路径和xml的相对路径拼接起来即可）要负责检查servlet配置（主要是检查url的映射是否重复）、初始化过滤器、初始化所有servlet的初始参数、<strong>初始化当前应用的webappClassLoader</strong>、servletContext以及监听器listener</li></ul></li><li><p>各个组件必须不能添加到AppClassLoader的classpath中，因为这些组件是需要通过CommonClassLoader来加载的，所以这里的解决办法与tomcat类似，写了个脚本，将这些组件打包成一个jar包，然后让commonCLassLoader负责加载容器的所有jar包，包括自己的和引用的，具体实现是将lib下的所有包都加入CommonClassLoader的classpath路径下。仅让AppClassLoader负责加载启动类和CommonClassLoader</p></li></ol><h3 id="启动后基本的工作流程"><a href="#启动后基本的工作流程" class="headerlink" title="启动后基本的工作流程"></a>启动后基本的工作流程</h3><p>对于tomcat，一个可以配置多个service，一个service可以配置多个host，一个host可以配置多个context。那么容器定位一个context的流程是：</p><ol><li>先通过端口号和协议确定目标service，这样engine也确定了，端口号和协议在connector中配置</li><li>再通过host域确定目标主机</li><li>最后根据contextpath唯一地确定一个context，也就是一个web应用</li></ol><p>那么我对应的具体流程就是：</p><ol><li>Connector一直监听指定的端口，当socket接受请求后，Connector负责为本次请求分配线程，线程的任务包括：</li></ol><ul><li>为本次请求构造request与response对象</li><li>将这两个对象交由HttpProcessor（代理engine）处理，engine的操作包括：<ul><li>为当前请求准备session、准备过滤器，准备能够处理当前请求的servlet</li><li>调用过滤链，最后执行目标servlet</li><li>最后根据状态响应码调用对应的处理response对象方法</li></ul></li></ul><p>构造request对象是处理请求的重要一个步骤，包括：</p><ul><li>读取socket，解析uri、解析请求类型、解析请求参数</li><li>解析应用上下文context（这里直接通过engine的defaultHost获取当前应用名对应的context），通过当前host维护的contextMap匹配uri</li><li>解析http头部的信息，例如content-type、压缩类型等等</li><li>解析cookie</li></ul><h3 id="servlet的声明周期"><a href="#servlet的声明周期" class="headerlink" title="servlet的声明周期"></a>servlet的声明周期</h3><p>servlet的完整声明周期包括：初始化单例servlet，servlet提供服务，销毁servlet<br>首先每个web应用的context池会维护一个servlet池，servlet默认采用懒加载的模式，在使用时不存在对应的servlet对象时，才会利用反射使用初始化参数<code>ServletConfig</code>生成对应的实例（初始化）。如果web应用目录下有对应的文件发生修改，那么host会重新加载当前context。在卸载WebappClassLoader时会销毁所有对应的Servlet。</p><p>单例Servlet是逻辑上的，仅仅依靠servlet池实现</p><h3 id="cookie与session"><a href="#cookie与session" class="headerlink" title="cookie与session"></a>cookie与session</h3><p>对于cookie，我实现的方法是，对于一个response对象，其维护了一个cookie列表，当用户的servlet想添加cookie时，只需往response对象的list中添加即可，最后在生成响应报文时，只需要将cookie添加到响应头中，<br>一个cookie占一行，对于每一个cookie的格式是：Set-Cookie: name=value;Expires=;Path=;</p><p>对于session，engine，首先会查找当前request对象中的cookie有没有对应的session name，我这里维护了一个全局sessionMap，如果map中存在，那么将session提取出来，并重新设置为session服务的cookie过期时间。</p><p>对于sessionMap，我提供了一个守护线程负责清除map中过期的session。逻辑很简单，就是判断最后一次访问的时间与当前时间的间隔。对于sessionMap过期的时长，可以在配置文件中设置</p><h3 id="解析http"><a href="#解析http" class="headerlink" title="解析http"></a>解析http</h3><p>仅实现了简单的http请求，首先请求包的布局是：[请求方法类型] [请求路径uri] [http协议版本]，然后接下来每一行都是请求头的一些参数信息，直到出现空白行，空白行之后就是请求体</p><p>而http响应包与请求包类似，第一行是：[http协议版本] [状态码] [对状态码的描述]，接下来每一行都是请求头的信息，直到出现空白行，之后就是响应体</p><p>主要解析的就是请求方法类型、uri以及请求参数。对于get，会从url中提出请求参数、应用名称、获得uri后，engine会查找对应的servlet进行处理。这里的查找我提供了<strong>三类单例servlet</strong>负责提供用户访问的servlet对象并调用。三类分别是：</p><ul><li>处理普通的servlet</li><li>处理jsp对应的servlet</li><li>处理静态资源</li></ul><h2 id="重定向与内部跳转"><a href="#重定向与内部跳转" class="headerlink" title="重定向与内部跳转"></a>重定向与内部跳转</h2><p>如果用户调用了sendRedirect设置重定向路径时，engine会设置状态响应码为302，最后在传输response对象时，会检查它的状态码，如果为302，会向客户端发送302的http数据包</p><p>跳转传参我实现的方法是，在request对象中维护了一个attributeMap，我们只需要将属性添加这个map，然后将request对象在不同的servlet进行传递即可。</p><p>内部跳转就是使用request生成一个RequestDispatcher对象，并在该对象中设置跳转路径，然后调用dispatcher对象forward进行内部跳转，具体的处理方法就是首先需要重新设置request对象的uri，然后直接转发给engine组件来处理请求，engine会根据uri匹配对应的servlet</p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>对于一个请求的过滤器，我们需要维护一个filterChain用来存储当前uri匹配的所有filter，依次执行chain中的所有过滤器，最后filterchain会执行我们的目标servlet</p><h2 id="编译Servlet"><a href="#编译Servlet" class="headerlink" title="编译Servlet"></a>编译Servlet</h2><p>编译servlet也比较麻烦，这也是个难点，<strong>后续值得关注</strong></p><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>CommonClassLoader、WebappClassLoader、JspClassLoader，这里将commonCLassLoader设置为线程上下文类加载器，这样每当为web应用生成classloader时，就可以将commonclassLoader设为它的逻辑父类。</p><p>对于这些自定义类加载器，一种比较简单的实现方法就是继承URLClassLoader，</p><h2 id="动静态部署"><a href="#动静态部署" class="headerlink" title="动静态部署"></a>动静态部署</h2><p>监控默认目录，如果有新的war包存在，那么将加载任务分派给host</p><h2 id="可以改进的地方"><a href="#可以改进的地方" class="headerlink" title="可以改进的地方"></a>可以改进的地方</h2><ol><li>接受用户处理的流程可以改进，因为采用的是线程池的模式</li></ol><p>首先socket的read是阻塞函数，write是阻塞函数</p><p>线程池的execute会抛出异常，但会直接终止线程<br>而submit不会抛出异常</p><p>先扫描生成ContextMap</p><p>字符串排列</p><h2 id="哪些功能没有实现？"><a href="#哪些功能没有实现？" class="headerlink" title="哪些功能没有实现？"></a>哪些功能没有实现？</h2><p>tomcat的用户权限认证没有实现，集群设置没有实现，servlet的wrapper没有实现，直接调用的servlet</p><h2 id="如何理解测开？"><a href="#如何理解测开？" class="headerlink" title="如何理解测开？"></a>如何理解测开？</h2><p>测开其实可以分为两个部分：测试和开发</p><p>对于测试的话：就是常规意义上的功能测试，首先第一步就是需求分析阶段，了解需要测试什么；第二部是设计测试用例，这一步的目的是达到怎么测；第三步是进行具体测试，这一步是找到具体的bug；最后一步是总结修复</p><p>对于开发的话，我认为主要是完成自动化测试与测试工具的开发</p><h2 id="tomcat有哪些IO模型？"><a href="#tomcat有哪些IO模型？" class="headerlink" title="tomcat有哪些IO模型？"></a>tomcat有哪些IO模型？</h2><p>Tomcat支持三种接收请求的处理方式：BIO、NIO、APR 。</p><p>BIO<br>阻塞式I/O操作即使用的是传统 I/O操作，Tomcat7以下版本默认情况下是以BIO模式运行的，由于每个请求都要创建一个线程来处理，线程开销较大，不能处理高并发的场景，在三种模式中性能也最低。</p><p>NIO<br>NIO是Java 1.4 及后续版本提供的一种新的I/O操作方式，是一个基于缓冲区、并能提供非阻塞I/O操作的Java API，它拥有比传统I/O操作(BIO)更好的并发运行性能。tomcat 8版本及以上默认就是在NIO模式下允许。</p><p>APR<br>APR(Apache Portable Runtime/Apache可移植运行时)，是Apache HTTP服务器的支持库。你可以简单地理解为，Tomcat将以JNI的形式调用Apache HTTP服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地提高Tomcat对静态文件的处理性能。 Tomcat apr也是在Tomcat上运行高并发应用的首选模式。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>AQS使用的CLH原型</title>
    <link href="/2021-06-03/CLH.html"/>
    <url>/2021-06-03/CLH.html</url>
    
    <content type="html"><![CDATA[<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="1-内存架构"><a href="#1-内存架构" class="headerlink" title="#1. 内存架构"></a>#1. 内存架构</h3><p>比较常见的内存架构有两种：SMP (Symmetric MultiProcessing) 与 NUMA (Non-uniform memory access)。</p><p>对称多处理是一种包括软硬件的多核计算机架构，会有两个或以上的相同的核心共享一块主存，这些核心在操作系统中地位相同，可以访问所有 I/O 设备。它的优点是内存等一些组件在核心之间是共享的，一致性可以保证，但也正因为内存一致性和共享对象在扩展性上就受到限制了 。</p><h3 id="2-自旋锁与互斥锁"><a href="#2-自旋锁与互斥锁" class="headerlink" title="#2. 自旋锁与互斥锁"></a>#2. 自旋锁与互斥锁</h3><p>互斥锁就是我们常用的<code>synchronized</code>，当产生竞争时，未抢到锁的线程会被阻塞，并且是非公平的，适合临界区长的，因为线程的切换代价不可忽略。而自旋锁在产生竞争时，不会阻塞线程，只会进行忙等待（就是使用死循环无限等待，也就是所谓的自旋），适合临界区较短的，因为自旋时间太长就会一直占用CPU。</p><h3 id="3-队列锁"><a href="#3-队列锁" class="headerlink" title="#3. 队列锁"></a>#3. 队列锁</h3><p>队列锁是一种自旋锁，可以分为公平与非公平的。在公平队列锁中，比较常用有CLH队列锁和MCS队列锁。这二者的区别如下：</p><ul><li>CLH基于隐式的链表，而MCS基于显示的链表</li><li>CLH是在前趋结点的locked域上自旋等待，而MSC是在自己的结点的lock域上自旋等待。正因为如此，它解决了CLH在NUMA系统架构中获取locked域状态内存过远的问题（locked域可以理解为当前节点需要观察的地方，当前节点能不能获得锁就看这个locked域）。</li><li>CLH实现比MCS简单</li></ul><h2 id="CLH队列锁"><a href="#CLH队列锁" class="headerlink" title="CLH队列锁"></a>CLH队列锁</h2><p>CLH队列锁是一种公平锁，能够严格按照FIFO分配锁的使用权，其队列基于链表的思想实现。CLH队列由三种基本元素组成：</p><ul><li>请求锁的线程(process)</li><li>请求状态(request)：包括PENDING和GRANTED两种状态，由请求锁的线程维护</li><li>锁(lock)：初始化为GRANTED状态，维护tail指针，指向最后一个请求锁的线程的请求状态</li></ul><p>每个请求锁的线程还需要维护一个watch域，watch域用来观察前趋节点的锁使用状态。如下所示：</p><p><img src="images/clh-1.png" alt="clh-1"></p><p>如果此时P1请求锁，那么lock的tail指针将指向P1的请求状态，但是p1能不能获得锁得看R0，如下所示：</p><p><img src="images/clh-2.png" alt="clh-2"></p><p>如果此时，P1在使用锁的时候，P2和P3按顺序请求锁，那么P2和P3就要依次进入请求队列，如下所示：</p><p><img src="images/clh-3.png" alt="clh-3"></p><p>每一个线程的watch域都指向前一个线程的请求状态，只有前趋线程释放锁了，当前线程才能获取使用权，这也就保证FIFO，公平的获取锁。</p><p>那么请求状态和watch域是如何保存在各自的线程中的呢？在Java中，可以使用ThreadLocal保存属于每个线程的私有变量，非常巧妙。具体实现分为三个部分：request、lock和CLH。</p><hr><p><strong>A. request的实现部分：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//两个状态</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">State</span> </span>&#123;<br>    PENDING,<br><br>    GRANTED<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Request</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> State state;    <br>    <br>    Request(State state)&#123;<br>        <span class="hljs-keyword">this</span>.state=state;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><hr><p><strong>B. lock实现部分：</strong><br>lock只需要维护一个tail指针，指向最后一个请求状态。但是tail指针的交换必须是原子的，否则在多线程环境下不能保证每个线程的请求都能顺利进入队列。所以tail的类型为<code>AtomicReference&lt;Request&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> AtomicReference&lt;Request&gt; tail;<br>    Lock()&#123;<br>        tail=<span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-keyword">new</span> Request(State.GRANTED,<span class="hljs-keyword">null</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AtomicReference&lt;Request&gt; <span class="hljs-title">getTail</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> tail;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTail</span><span class="hljs-params">(AtomicReference&lt;Request&gt; tail)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.tail = tail;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><hr><p><strong>C. CLH实现部分：</strong></p><p>CLH提供了加锁<code>lock</code>与解锁<code>unlock</code>的接口。并且内部维护了锁lock、请求状态Request和观察域watch。lock由全体线程共享，而Request和watch使用ThreadLocal保存，不会造成数据污染。达到了为每个线程维护一个请求状态和观察域的要求。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CLH</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Lock lock;<br>    <span class="hljs-keyword">private</span> ThreadLocal&lt;Request&gt; myReq;<br>    <span class="hljs-keyword">private</span> ThreadLocal&lt;Request&gt; watch;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CLH</span><span class="hljs-params">()</span></span>&#123;<br>        lock=<span class="hljs-keyword">new</span> Lock();<br>        <span class="hljs-comment">//withInitial的作用就是重写ThreadLocal的初始化函数，在没set就get时自动初始化</span><br>        myReq=ThreadLocal.withInitial(()-&gt;(<span class="hljs-keyword">new</span> Request(State.PENDING,<span class="hljs-keyword">null</span>)));<br>        watch=<span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//设置当前线程请求状态</span><br>        myReq.get().setState(State.PENDING);<br>        <span class="hljs-comment">//入队操作</span><br>        Request preTail=lock.getTail().getAndSet(myReq.get());<br>        <span class="hljs-comment">//设置watch域</span><br>        watch.set(preTail);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>&#123;<br>        myReq.get().setState(State.GRANTED);<br>        <span class="hljs-comment">//这一步有必要吗？防止内存泄露？不是很懂</span><br>        myReq.remove();<br>        <br>        <span class="hljs-comment">/**********************************/</span><br>        <span class="hljs-comment">//将当前线程的Request对象设为watch对象</span><br>        <span class="hljs-comment">//因为后面有可能当前线程可能会再次请求锁，这样不会浪费资源重新设置为Request对象</span><br>        myReq.set(watch.get());<br>        <span class="hljs-comment">/********************************/</span><br><br>        watch.remove();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><hr><p>在CLH的解锁代码中，我们需要注意一个非常致命的点，就是线程P1在释放锁，其请求状态Request的设置。为什么要把请求状态域设置为前一个线程的请求状态R0呢？</p><p>因为如果不进行更改，可能会造成死锁的出现。想象如下一个场景：</p><p>P1在释放锁后，其请求状态为R1。这个R1被后续线程P2观察着。如果在P2获得锁之前，P1再次请求锁。这就造成P1观察着线程P2的请求状态R2，而P2又在观察着P1的请求状态R1,死锁出现。示意图如下：</p><p><img src="images/clh-4.png" alt="clh-4"></p><p>那么为什么要设置成R0呢？完全可以新生成一个请求状态啊，但是没必要啊，原来有就接着用呗。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://blog.csdn.net/firebolt100/article/details/82662102">透彻理解CLH 队列锁原理及其Java实现</a></p></li><li><p><a href="https://pan.baidu.com/s/1JJYhBEOQS6KlJO7dw3TTHw">Building FIFO and Priority-Queuing Spin Locks from Atomic Swap</a>，提取码: 8ks9</p></li><li><p><a href="https://www.cnblogs.com/sanzao/p/10567529.html">并发系列（3）之 CLH、MCS 队列锁简介</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>多线程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>synchronized</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring MVC原理</title>
    <link href="/2021-06-03/what-is-spring-mvc.html"/>
    <url>/2021-06-03/what-is-spring-mvc.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-MVC是什么？"><a href="#1-MVC是什么？" class="headerlink" title="1. MVC是什么？"></a>1. MVC是什么？</h2><p>MVC是一种设计规范，并不是一种设计模式。该规范将一个web分割成3部分来处理：请求首先经过控制器Controller；经过业务处理得到数据模型Model；最后通过model渲染视图View并响应给客户端。</p><p>我们完全利用Servlet自己实现MVC规范，如下图所示：<br><img src="images/servlet-mvc.png" alt="servlet-mvc"></p><p>基本流程为：</p><ol><li>用户发请求</li><li>Servlet（作为Controller）接收请求数据，解析数据模型model，并调用对应的业务逻辑方法</li><li>业务处理完毕，返回更新后的model给Controller</li><li>Controller将model转向到JSP，由JSP来渲染页面</li><li>响应给前端更新后的页面</li></ol><p>当然，上述模型存在的严重缺陷<a href="#refer-anchor-1"><sup>[1]</sup></a>，包括：</p><ol><li><p>控制器出现的问题：随着web应用的复杂，<strong>控制器的添加</strong>一般需要将将映射配置在web文件中，可能不同的页面就要对应于一个Controller，难于维护；请求参数到模型的<strong>封装麻烦</strong>，需要根据具体的参数选择不同的业务逻辑；<strong>视图的选择</strong>严重依赖于Servlet API，因为最后获得数据数据后，最后会调用getDispatcherServlet将请求内部转发到tomcat内置的JspServlet进行处理，局限于JSP视图技术</p></li><li><p>此处数据模型使用JavaBean，可能造成JavaBean组件类很庞大，一般现在项目都是采用三层架构（Service、DAO、Entity）而不采用JavaBean</p></li><li><p>视图层出现的问题：被绑定在JSP，很难更换视图，比如Velocity、FreeMarker；比如我要支持Excel、PDF视图等等,同样严重依赖Servlet API。</p></li></ol><h2 id="2-SpringMVC解决了什么问题？"><a href="#2-SpringMVC解决了什么问题？" class="headerlink" title="2. SpringMVC解决了什么问题？"></a>2. SpringMVC解决了什么问题？</h2><p>SpringMVC基于Servlet容器，主要解决的是Web层的编码问题以及视图层的显示问题。</p><ol><li><p>在WebMVC中，根据请求路径配置Controller是一件很难维护的事情，SpringMVC相当于提供了一个Controller分发器，能够自动地根据不同的请求路径选择不同的Controller。并且能够自动将请求参数参数封装成数据模型提供给业务层处理。</p></li><li><p>视图的渲染并不由开发者实际控制，仅需要给SpringMVC提供视图的名字，具体的视图渲染交给SpringMVC提供的渲染器或者我们自己的渲染器解决，方便了视图技术的切换，不再严重依赖Servlet API。</p></li></ol><p>在SpringMVC中，<code>DispatcherServlet</code>的角色就相当于Controller分发器，官方名称<strong>前端控制器</strong>，其工作流程图如下所示：<br><img src="images/springmvc-workflow.png" alt="DispatcherServlet-workflow"></p><p>从图中可以看出<code>DispatcherServlet</code>、<code>HandlerMapping</code>、<code>HandlerAdapter</code>、<code>ViewResolver</code>是维持SpringMVC正常工作的核心组件。</p><p>按道理来说，使用HandlerMapping就足够了，为什么还要个适配器？经网上查阅，这是由于Spring的handler多样化，采用了适配器模式，具体原因仍待研究。<code>DispatcherServlet</code>工作流程如下：</p><ol><li><p>HTTP请求：客户端向应用程序发起Http请求，tomcat将请求转到DispatchServlet(Spring提供的前端控制器 ) ，所有的请求通过DispatchServlet进行分发</p></li><li><p>寻找处理器： 在DiispatchServlet在将请求分发给Controller之前， 通过HandlerMapping，根据请求url查找Handler。HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。</p></li><li><p>HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler，也就是Controller。将请求提交给Controller，Controller需要为并发用户处理，需要Controller实现Controller接口，必须保证是线程安全的</p></li><li><p>调用业务处理服务：Controller会调用 业务处理 Service， 并返回ModelAndView，给到前端控制器，ModelAndView包含应用程序所需要的数据信息（Model）以及视图讯息（View）</p></li><li><p>得到处理信息：DispatchServlet得到ModelAndView对象，会调用Viewresolver视图解析器。也就是找到ModelAndView所对应的视图，对Model数据进行渲染</p></li></ol><hr><p><strong>注意：</strong> 实际的视图渲染工作是通过<strong>具体的渲染器</strong>完成的，而不是SpringMVC完成的，SpringMVC只负责找到视图并将渲染请求发送到渲染器。</p><p>例如在渲染jsp时，SpringMVC实际上是将数据model封装到Response对象，然后进行内部转发，随后tomcat调用内部Servlet来处理渲染工作。</p><hr><h2 id="3-SpringMVC基本使用"><a href="#3-SpringMVC基本使用" class="headerlink" title="3. SpringMVC基本使用"></a>3. SpringMVC基本使用</h2><p>基于tomcat使用SpringMVC时，首先我们需要配置前端控制器<code>DispatcherServlet</code>，然后配置<code>DispatcherServlet</code>的三大件：handler映射器，handler适配器，视图解析器。最原始的方式就是使用Spring配置文件来硬编码这三项的配置。</p><p>第一步在web应用的<code>web.xml</code>文件配置<code>DispatcherServlet</code>,就像配置Servlet那样：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注册DispatcherServlet--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <br>            <span class="hljs-comment">&lt;!--配置SpringMVC使用的配置文件</span><br><span class="hljs-comment">            默认配置文件名称:[servlet name]-servlet.xml--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--设置servlet的启动级别--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--将任意uri交给DispatcherServlet来处理--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.html<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>其中<code>DispatcherServlet</code>的<code>url pattern</code>配置会存在一点小问题，这个后面来讲。然后在SpringMVC需要使用的配置文件中配置三大件：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--配置HandlerMapping--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--配置HandlerAdapter--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--视图解析器，DispatcherServlet将HandlerAdapter返回的ModelAndView传递给viewResolver</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    viewResolver做了3件事：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    1. 提取MV对象中的数据</span><br><span class="hljs-comment">    2. 根据规定的前缀与后缀 拼接视图的名字并找到对应的视图，例如视图的名字是hello，最后拼接的是/WEB-INF/jsp/hello.jsp</span><br><span class="hljs-comment">    3. 使用数据对视图进行渲染</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    最后DispatcherServlet根据视图的名字返回渲染好的视图</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-comment">&lt;!--配置视图解析器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--前缀--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--后缀--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;/index&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.g.HelloController&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ol start="4"><li><h2 id="DispatcherServlet的url-pattern为什么要配置为"><a href="#DispatcherServlet的url-pattern为什么要配置为" class="headerlink" title="DispatcherServlet的url-pattern为什么要配置为/?"></a><code>DispatcherServlet</code>的url-pattern为什么要配置为<code>/</code>?</h2></li></ol><p>在配置<code>DispatcherServlet</code>时，建议将<code>url-pattern</code>配置成<code>/</code>而不是<code>*/</code>。这跟tomcat路径映射的优先级有关。在tomcat中，路径匹配分成四个模式<a href="#refer-anchor-2"><sup>[2]</sup></a>：</p><ol><li>以<code>/*</code>开头的前缀匹配</li><li>以<code>*.</code>开头的后缀匹配</li><li><code>/</code>表示默认匹配</li><li>其他情况，表示精确匹配</li></ol><p>这四种模式是有优先级的，我们从上到下以优先级的高低进行说明：</p><ol><li><p>规则1：精确匹配，</p></li><li><p>规则2：前缀匹配，也就是url-pattern是<code>/*</code></p></li><li><p>规则3：扩展名匹配，也是就url-pattern是<code>*.</code></p></li><li><p>规则4：使用资源文件来处理servlet，</p></li></ol><p>…</p><ol start="7"><li>规则7：使用默认的servlet，也就是url-pattern为<code>/</code></li></ol><p>也就是说，如果把<code>DispatcherServlet</code>的<code>url-pattern</code>配置为或者<code>/</code>或者<code>/*</code>，所有的请求都会由<code>DispatcherServlet</code>处理，那么为什么建立采用<code>/</code>？我对此进行了进行了调研与简单的实验。</p><p>实验准备：</p><p>Controller代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Controller</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();<br>        mv.addObject(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;hello mvc&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;run in controller&quot;</span>);<br>        mv.setViewName(<span class="hljs-string">&quot;index&quot;</span>);<br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>视图解析器的配置文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--前缀--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--后缀--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;/index&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.g.HelloController&quot;</span> /&gt;</span><br></code></pre></div></td></tr></table></figure><p>DispatcherServlet的路径映射配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--将任意uri交给DispatcherServlet来处理--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>根据解析器后缀与路径映射的组合产生了四种情况：</p><ol><li>把路径映射设置为<code>/</code>，解析器后缀为<code>.jsp</code>时，能够处理请求</li><li>把路径映射设置为<code>/</code>，解析器后缀为<code>.html</code>时，无法处理请求，错误原因：<code>noHandlerFound No mapping for GET /WEB-INF/jsp/index.html</code></li><li>把路径映射设置为<code>/*</code>，解析器后缀为<code>.jsp</code>时，无法处理请求，错误原因：<code>noHandlerFound No mapping for GET /WEB-INF/jsp/index.jsp</code></li><li>把路径映射设置为<code>/*</code>，解析器后缀为<code>.html</code>时，无法处理请求，错误原因：<code>noHandlerFound No mapping for GET /WEB-INF/jsp/index.html</code></li></ol><p>对于这四种情况，目前已知Controller都能够成功打印<code>run in controller</code>，说明<code>DispatcherServlet</code>能够成功分发请求，那么为什么只有第一种情况能够正确响应？</p><p>我怀疑是视图解析的过程出现了问题，<a href="#refer-anchor-3">参考文章.[3]</a>也验证了我的猜想，但是文章只告诉了我DispatcherServlet会循环处理请求,并没有说它为什么会循环处理。我产生了一个猜想：既然能够循环处理，那岂不是又经过了一次tomcat处理路径映射？</p><p>带着这个问题，我去研究了<code>DispatcherServlet</code>的视图解析过程，尝试寻找解析过程的转发请求流程，根据<a href="#refer-anchor-4">参考文章.[4]</a>，渲染的调用链如下：</p><blockquote><p>doService()—&gt;doDispatch()—&gt;processDispatchResult()—&gt;render()</p></blockquote><p><code>processDispatcherResult</code>主要处理异常、请求状态及触发请求完成事件,最后把视图的渲染工作交给了render()。针对JSP提供的InternalResourceViewResolver与InternalResourceView。</p><p>render首先需要借助InternalResourceViewResolver通过view的名称解析并获得view对象，</p><p><img src="images/view-render-1.png" alt="render-1"></p><p>然后调用view对象的render方法进行渲染，如下图所示：</p><p><img src="images/view-render-2.png" alt="render-2"></p><p>这里的render具体实现在<code>AbstractView</code>，如下所示：<br><img src="images/view-render-3.png" alt="render-3"></p><p>该方法最后又会调用<code>renderMergedOutputModel</code>，具体实现在<code>InternalResourcecView</code>，代码如下所示：<br><img src="images/view-render-4.png" alt="render-4"></p><p>下面是进行重复请求的重点，首先将数据model存入request，通过RequestDispatcher调用forward或者include方法，如下所示：<br><img src="images/view-render-5.png" alt="render-5"></p><p>了解了渲染流程之后，根据<a href="#refer-anchor-3">参考文章.[3]</a>可知，tomcat的配置文件<code>conf/web.xml</code>配置了一个内部处理jsp的servlet，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- The mappings for the JSP servlet --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>jsp<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.jspx<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>jsp<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.apache.jasper.servlet.JspServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>fork<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>xpoweredBy<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>所以我们配置的视图后缀为<code>.jsp</code>时，url的名称为<code>/WEB-INF/jsp/index.jsp</code>，SpringMVC进行forward之后，tomcat又会进行一次url-pattern匹配，寻找具体的渲染器来渲染视图</p><ol><li>如果DispatcherServlet的pattern为<code>/</code>，内部jsp servlet的url-pattern<code>*.jsp</code>比<code>/</code>优先级高，这个请求会交给内部jsp的servlet来处理，不会导致DispatcherServlet循环处理</li><li>如果DispatcherServlet的pattern为<code>/*</code>，内部servlet的url-pattern<code>*.jsp</code>比<code>/*</code>优先级低，这个请求会交给DispatcherServlet处理，而我们又没有配置该url的Controller进行处理，所以报错 no handler mapping</li></ol><p>当视图后置配置为<code>.html</code>时，解析后的url全称为<code>/WEB-INF/jsp/index.html</code>，SpringMVC进行forward之后，tomcat又会进行一次url-pattern匹配：</p><ol><li>如果DispatcherServlet的pattern为<code>/</code>，内部jsp servlet的url-pattern无法匹配该url，所以最后还是交给DispatcherServlet处理，而我们又配置该url的Controller进行处理，所以报错 no handler mapping</li><li>如果DispatcherServlet的pattern为<code>/*</code>，这个请求会直接交给DispatcherServlet处理，而我们又配置该url的Controller进行处理，所以报错 no handler mapping</li></ol><p>那么我们难道只能把视图后缀配置为jsp吗？当然不是的，解决办法就是使用就是名为<code>default</code>的servlet，它的作用和jsp的大概一样，大家知道它是拿来配置静态资源的，却很少了解它怎么来的。这个Servlet也是存在与<code>conf/web.xml</code>，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>debug<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>listings<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <br><span class="hljs-comment">&lt;!-- The mapping for the default servlet --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>注意它的url-pattern为 **/**。，如果我们在自己的<code>web.xml</code>中配置<code>default</code>servlet，就会覆盖tomcat中的<code>default</code>，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.html<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>这样当我们的url为<code>/WEB-INF/jsp/index.html</code>时：</p><ol><li>如果<code>DispatcherServlet</code>的url-pattern为<code>/</code>时，<code>*.html</code>的优先级比<code>/</code>高，tomcat就会把请求匹配到<code>default</code> servlet而不是<code>DispatcherServlet</code><br>如果<code>DispatcherServlet</code>的url-pattern为<code>/*</code>时，<code>/*</code>的优先级比<code>*.html</code>高，tomcat就会把请求匹配到<code>DispatcherServlet</code> servlet而不是<code>default</code>，而我们又没有配置该url的Controller进行处理，所以报错 no handler mapping</li></ol><p>这里又有一个问题出现了，为什么tomcat配置文件的<code>conf/web.xml</code>的<code>jsp</code>servlet在我们不配置的情况下能够默认生效，而<code>default</code>servlet却需要我们手动配置呢？答案是因为<code>default</code>servlet的url-pattern为<code>/</code>，我们配置的<code>DispatcherServet</code>的url-pattern也为<code>/</code>，这里我猜测是因为配置的<code>/</code>覆盖的了<code>default</code>servlet的<code>/</code>。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>对于tomcat配置文件<code>conf/web.xml</code>中的servlet，是供<strong>所有</strong>已经部署的webapp使用的，如果我们在自己的配置文件中覆盖了tomcat的同名servlet或者同名url-pattern，则以我们自己编写的<code>web.xml</code>为准。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><div id="refer-anchor-1"></div><ol><li><p><a href="https://blog.csdn.net/u012881904/article/details/51291387">webMVC模型存在的问题</a></p></li><li><p><a href="https://www.cnblogs.com/fangjian0423/p/servletcontainer-tomcat-urlpattern.html">Servlet容器Tomcat中web.xml中url-pattern的配置详解[附带源码分析]</a></p></li><li><p><a href="https://ddnd.cn/2018/12/24/springmvc-view-webxml/">我是如何一步步解决问题 让Spring MVC返回HTML类型的视图</a></p></li><li><p><a href="https://www.cnblogs.com/wdpnodecodes/p/7820295.html">SpringMVC DispatcherServlet——-视图渲染过程</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring MVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReentrantLock源码解析</title>
    <link href="/2021-06-03/ReentrantLock-analysis.html"/>
    <url>/2021-06-03/ReentrantLock-analysis.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-预备知识"><a href="#1-预备知识" class="headerlink" title="1. 预备知识"></a>1. 预备知识</h2><p><code>ReentrantLock</code>是基于<code>AbstractQueueSynchronizer</code>的可重入锁。分为公平和非公平模式。它的内部类<code>Sync</code>继承了<code>AbstractQueueSynchronizer</code>，具体的资源获取与释放由<code>Sync</code>来实现，基本结构如下图所示：</p><p><img src="images/ReentrankLock.png" alt="reentrantLock"></p><p>其中<code>NonfairSync</code>实现了非公平锁的逻辑，<code>FairSync</code>实现了公平锁的逻辑。</p><h2 id="2-ReentrantLock的加锁流程"><a href="#2-ReentrantLock的加锁流程" class="headerlink" title="2. ReentrantLock的加锁流程"></a>2. ReentrantLock的加锁流程</h2><p>这里以非公平模式为例，当调用<code>ReentrantLock.lock()</code>时，根据多态最终会调用<code>NonfairSync.lock()</code>。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">7316153563782823691L</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * Performs lock.  Try immediate barge, backing up to normal</span><br><span class="hljs-comment">        * acquire on failure.</span><br><span class="hljs-comment">        */</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//这一步体现了非公平，有可能队列里的第一个线程唤醒了，但是没抢到锁，被这个新来的抢到了</span><br>        <span class="hljs-comment">//也就是说不管同步队列里到底有没有内容，先加个塞</span><br><br>        <span class="hljs-comment">//这里设置锁的状态需要为CAS操作</span><br>        <span class="hljs-comment">//因为如果此时有两个线程都先后读取了State=0，threadA和threadB都能够将state设置为1，违背了锁的互斥性</span><br>        <br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>            setExclusiveOwnerThread(Thread.currentThread());<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">//加塞失败，乖乖的走后面的正常流程</span><br>            acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果当前线程加塞失败，会调用<code>AbstractQueueSynchronizer</code>的<code>acquire()</code>方法,代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-comment">//因为多态，所以会调用ReentrantLock的tryAcquire</span><br>    <span class="hljs-comment">//这个tryAcquire是不会操作同步队列的</span><br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        <span class="hljs-comment">//tryAcquire失败后，会调用addWaiter</span><br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>acquire</code>首先会调用<code>tryAcquire</code>再次加塞，根据多态，最终会调用<code>NonFairSync.tryAcquire</code>，而<code>tryAcquire</code>又会调用<code>Sync.nonfairTryAcquire</code>，<code>Sync.nonfairTryAcquire</code>实现了可重入的逻辑，并且给了线程最后加塞抢锁的机会，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//Sync中的nonfairTryAcquire</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>    <span class="hljs-keyword">int</span> c = getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//再次加塞,如果成功，后面的线程就再也不能成功获取锁了</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//是否是锁重入</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-keyword">int</span> nextc = c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        <span class="hljs-comment">//不许要保证原子性</span><br>        <span class="hljs-comment">//因为这是锁重入，在一个线程内，获取锁、释放锁都是串行的，</span><br>        <span class="hljs-comment">//不会出现在获取c之后，c又再次被当前线程改变，导致nextc的值不正确，</span><br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//返回false表示获取锁失败了，可以准备加入同步队列了</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果<code>tryAcquire</code>中的加塞操作失败了，说明当前线程应该进入同步队列了，不然占着CPU又抢不到锁，不是浪费么。那么当前线程是如何入队的呢？请见下文。</p><h3 id="2-1-线程的入队操作"><a href="#2-1-线程的入队操作" class="headerlink" title="2.1 线程的入队操作"></a>2.1 线程的入队操作</h3><p>独占锁的同步队列是一个双链表，对于双链表中的节点，会使用一个额外指针指向nextWaiter指向<code>Node.EXCLUSIVE</code>（也就是null）标志当前节点是独占节点。</p><p>在入队时，当前线程首先通过<code>addWaiter</code>进入同步队列,然后又调用了<code>accquireQueued</code>。这其中存在许多问题：</p><ol><li><code>addWaiter</code>是怎么实现的？</li><li><code>accquireQueued</code>是干嘛的？</li><li><code>selfInterrupt</code>是干嘛的？</li></ol><h4 id="2-1-1-addWaiter是怎么实现的？"><a href="#2-1-1-addWaiter是怎么实现的？" class="headerlink" title="2.1.1 addWaiter是怎么实现的？"></a>2.1.1 <code>addWaiter</code>是怎么实现的？</h4><p>对于这个问题，我们先来看看<code>addWaiter()</code>的源码：</p><figure class="highlight java"><figcaption><span>"addWaiter"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//返回当前线程的node节点</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;<br>    Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>    Node pred = tail;<br>    <span class="hljs-comment">//如果此时同步队列还未创建（tail和head都为空），那么就会直接调用enq</span><br>    <span class="hljs-comment">//否则尝试直接入队</span><br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//node节点是线程私有的，所以下面一句无需保证原子性</span><br>        node.prev = pred;<br><br>        <span class="hljs-comment">/**************************************</span><br><span class="hljs-comment">        * problem1                   </span><br><span class="hljs-comment">        **************************************/</span><br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//一旦进入到enq函数，node的prev指针会被重新设置</span><br>    <span class="hljs-comment">//有可能发生code1处的代码执行了，node的前向节点pred失效了</span><br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-comment">//enq只负责将当前node加入队列，并返回tail</span><br><span class="hljs-comment">//并且enq会重新设置当前线程的prev指针</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Node t = tail;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))<br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node.prev = t;<br>            <span class="hljs-comment">//volatile写禁止重排序</span><br>            <span class="hljs-comment">//enq中使用CAS的原因和addWaiter一样。</span><br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在阅读上面的代码中，我产生一个问题：在<code>addWaiter</code>中problem1处，设置tail指针时为什么需要使用CAS呢？经过我的分析，我认为原因如下图所示：<br><img src="images/addWaiter-p1.drawio.svg" alt="addWaiter-cas"></p><p>可以发现，如果设置tail不是原子操作,最后同步队列中threadA的node就会丢失，因为下一个节点只会接在tail节点的后面。并且pred的next有可能发生混乱，比如tail=nodeB，但是pred.next=nodeA。</p><p>试想如下一个场景：threadA只设置了tail，还没设置pred.next时间片就用完了。threadB设置了tail和pred.next后，threadA再设置pred.next。结果如下所示：</p><p><img src="images/addWaiter-p2.drawio.svg" alt="addWaiter-p2"></p><p>那么为什么使用了CAS就会避免上图中的情况发生呢？因为<code>nodeA</code>如果CAS失败，后续会进入<code>enq</code>重新设置当前<code>node</code>的<code>prev</code>指针。而CAS成功的<code>nodeB</code>能够继续保留先前设置的<code>prev</code>指针。</p><p>从上面的代码我们得出结论：<strong>一旦一个节点成功的设置了tail指针，那么这个节点就算成功进入同步同列。</strong></p><h4 id="2-2-1-accquireQueued是干嘛的？"><a href="#2-2-1-accquireQueued是干嘛的？" class="headerlink" title="2.2.1 accquireQueued是干嘛的？"></a>2.2.1 <code>accquireQueued</code>是干嘛的？</h4><p>在线程进入同步队列后，它可能会执行的操作包括：线程获取锁并出队，或者线程抢不到锁并挂起，<code>accquireQueued()</code>就是用来实现这两个操作的。</p><p>下面我们具体来分析一下代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//调用该方法之前，节点肯定被放入队列了</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">//node是当前节点，p是node的前一个节点</span><br>            <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>            <span class="hljs-comment">//这里p是head的情况下还需要抢锁是因为不公平性，有可能别的线程没入队直接抢</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                <span class="hljs-comment">//设置头节点是时会将node节点的prev设置为null</span><br>                setHead(node);<br>                <span class="hljs-comment">//前一个获得锁的node</span><br>                p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">//线程在每次进入挂起之前，都会重新安排当前节点的前向节点</span><br>            <span class="hljs-comment">//如果前向节点cancel了的话，则需要重新找爹</span><br>            <span class="hljs-comment">//只有前向节点pred的waitStatus为-1时，当前线程才会挂起</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                <span class="hljs-comment">//如果发生中断，则需要将interrupted设置为true，以便后续能够及时补一个中断操作</span><br>                interrupted = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//如果没有获取到锁，并且取消了请求，那么就要执行取消操作</span><br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过阅读上面的代码我们可以发现：如果<code>node</code>（当前处理的节点）的前向节点<code>pred</code>==<code>head</code>时，那么说明node前面没有人了，可以抢锁了。没人了还跟谁抢？当然是跟那些第一次来不遵守规则的人抢了。</p><p>如果成功抢到锁，则在<strong>逻辑</strong>上退出当前队列，并返回中断情况。</p><p>没抢到的话，就需要准备找爹（一个合适的前置节点）然后挂起了，但是被挂起之前需要做一些准备工作。准备工作包括：调用<code>shouldParkAfterFailedAcquire</code>为当前线程的包装节点<code>node</code>找到一个合适的前置节点<code>pred</code>用来唤醒<code>node</code>，<strong>只有<code>node</code>的前向节点<code>pred</code>的waitStatus为-1时，才会被挂起来。</strong> 分析一下具体的准备工作是如何完成的：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;<br>    <span class="hljs-comment">//如果前向节点的waitStatus为-1，说明可以将当前线程park了</span><br>    <span class="hljs-comment">//否则如果前向节点的waitStatus为0,则在将前向节点状态设为-1后，先不park当前线程，再给一次获取锁的机会</span><br>    <span class="hljs-keyword">int</span> ws = pred.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * This node has already set status asking a release</span><br><span class="hljs-comment">        * to signal it, so it can safely park.</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * Predecessor was cancelled. Skip over predecessors and</span><br><span class="hljs-comment">        * indicate retry.</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">//直系前向节点不可靠，继续在前面的节点中找个好爹</span><br>        <span class="hljs-comment">//这一步能够将前面取消取消的节点移出队列，因为重新设置了当前节点node的prev指针</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        pred.next = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="hljs-comment">        * need a signal, but don&#x27;t park yet.  Caller will need to</span><br><span class="hljs-comment">        * retry to make sure it cannot acquire before parking.</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">/***********************************************</span><br><span class="hljs-comment">        * 为什么设置状态要使用CAS操作？什么情况下会发生竞争？谁会修改pred的status？是pred自己吗？</span><br><span class="hljs-comment">        * pred的status需要靠后继节点来设置，如果它执行cancel操作后，status&gt;0，但是如果还是执行pred.status=-1，cancel的状态丢失了</span><br><span class="hljs-comment">        * 所以由于pred.ws==Node.SGNAL，pred可能会被唤醒获取锁，但是pred却不会执行获取锁的代码了，所以pred后面的节点即使唤醒永远无法跳过pred</span><br><span class="hljs-comment">        * 所以需要使用CAS操作，避免cancel状态被覆盖</span><br><span class="hljs-comment">        ***********************************************/</span><br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>        <span class="hljs-comment">/***********************************************</span><br><span class="hljs-comment">        * 使用CAS后，如果pred.waitStatus==Node.SIGNAL，那么node的直系前向节点pred状态为-1，能够保证node在不取消的前提下，任何情况都能够被唤醒</span><br><span class="hljs-comment">        * 如果CAS失败，那么就会再走一轮判断ws的代码，如果pred执行cancel，在CAS之后的第一次调用shouldParkAfterFailedAcquire中，</span><br><span class="hljs-comment">        * node就能够跳过pred，找到一个waitStatus==-1的前向节点</span><br><span class="hljs-comment">        ***********************************************/</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对<code>shouldParkAfterFailedAcquire</code>的基本流程总结如下：</p><ol><li>如果node的前向节点pred的<code>waitStatus == -1</code>，说明爹已经找好了，安心地睡觉了，到时候有人会叫。</li><li>如果node的前向节点pred的<code>waitStatus &gt; 0</code>，说明前面的人不可靠，需要从pred开始向前遍历，找一个可靠的爹</li><li>如果node的前向节点pred的<code>waitStatus &lt;= 0</code>,如果能成功设置pred.waitStatus==-1,说明爹已经找好了，否则返回false，等待下次进入该函数找爹</li></ol><p><code>shouldParkAfterFailedAcquire</code><strong>只有在确保前一个节点状态为-1时，才会返回true挂起当前线程</strong>。否则返回false，需要一直继续找个好爹。因为如果当前节点的前向节点<code>pred</code>执行了取消动作，就是靠<code>pred.waitStatus</code>是否为<code>-1</code>判断<code>pred</code>后面是否有线程挂起。这也就是为什么线程在挂起时必须保证<code>pred-waitStauts == -1</code>。</p><p>上面描述了一个节点从入队到挂起等待的全过程。但是如果有的节点不想等了呢？能直接退出同步队列吗？当前，这个操作由<code>acquireQueued.cancelAcquire</code>完成。但是这个方法是如何被调用的？<code>acquireQueued</code>中完全没有抛出异常的代码。其实真正能够抛出异常的地方就是由用户重写的方法<code>tryAcquire</code>,用户是可能在这个方法中抛出异常的,抛出后，会执行<code>cancelAcquire</code>，并且抛出的异常会层层上传到调用<code>ReentrantLock.lock()</code>的地方，此时用户可以处理自己抛出的异常。抛出的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            ...<br>            <span class="hljs-comment">//可能抛出异常的地方</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>            ...<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//如果没有获取到锁，并且取消了请求，那么就要执行取消操作</span><br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在了解了什么时候调用<code>cancelAcquire</code>，我们需要看看这个cancel操作到底是如何实现的，其实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//cancel的节点一直存在,直到后面的节点在挂起前，执行了shouldParkAfterFailedAcquire，设置prev后，cancel的节点就会不可达了</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancelAcquire</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-comment">//该函数只会操作node的next指针，因为</span><br>    <span class="hljs-comment">// Ignore if node doesn&#x27;t exist</span><br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span>;<br><br>    node.thread = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// Skip cancelled predecessors</span><br>    Node pred = node.prev;<br>    <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>)<br>        node.prev = pred = pred.prev;<br><br>    <span class="hljs-comment">// predNext is the apparent node to unsplice. CASes below will</span><br>    <span class="hljs-comment">// fail if not, in which case, we lost race vs another cancel</span><br>    <span class="hljs-comment">// or signal, so no further action is necessary.</span><br>    Node predNext = pred.next;<br><br>    <span class="hljs-comment">// Can use unconditional write instead of CAS here.</span><br>    <span class="hljs-comment">// After this atomic step, other Nodes can skip past us.</span><br>    <span class="hljs-comment">// Before, we are free of interference from other threads.</span><br>    node.waitStatus = Node.CANCELLED;<br><br>    <span class="hljs-comment">// If we are the tail, remove ourselves.</span><br><br>    <span class="hljs-comment">/*********************************************</span><br><span class="hljs-comment">        为什么使用CAS设置tail指针？</span><br><span class="hljs-comment">    *********************************************/</span><br>    <span class="hljs-comment">//因为有可能在设置tail的时候，有新节点nodeC入队，tail=nodeC，如果此时执行tail=pred，那么nodeC会丢失</span><br>    <span class="hljs-comment">//或者pred也取消了，tail被设置为pred的前向节点，如果此时执行tail=pred，那么tail就会指向已经取消的pred</span><br>    <span class="hljs-comment">// 所以需要使用CAS操作</span><br>    <span class="hljs-keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;<br><br>        <span class="hljs-comment">/**********************************************</span><br><span class="hljs-comment">        *               problem1 begin                *</span><br><span class="hljs-comment">        **********************************************/</span><br>        compareAndSetNext(pred, predNext, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">/**********************************************</span><br><span class="hljs-comment">        *               problem1 begin                *</span><br><span class="hljs-comment">        **********************************************/</span><br>    <br>    &#125;<br>    <span class="hljs-comment">// 如果node为tail，但是更新tail失败，也会走else流程</span><br>    <span class="hljs-comment">// 因为更新失败，表示有新节点入队或者pred节点也cancel了</span><br>    <span class="hljs-comment">// 新节点入队，自然需要看node的前向节点pred是否能够 </span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/***********************************************</span><br><span class="hljs-comment">        *  如果cancel的是中间节点，那么一定要保证node前面有一个直系节点的status为-1，或者能够被设置为-1，</span><br><span class="hljs-comment">        *  否则就需要手动唤醒node之后的节点</span><br><span class="hljs-comment">        ***********************************************/</span><br>        <span class="hljs-comment">// If successor needs signal, try to set pred&#x27;s next-link</span><br>        <span class="hljs-comment">// so it will get one. Otherwise wake it up to propagate.</span><br>        <span class="hljs-keyword">int</span> ws;<br><br><br>        <span class="hljs-comment">/**********************************************</span><br><span class="hljs-comment">        *               problem2 begin                *</span><br><span class="hljs-comment">        **********************************************/</span><br>        <span class="hljs-keyword">if</span> (pred != head &amp;&amp;<br>            ((ws = pred.waitStatus) == Node.SIGNAL ||<br>                <br>                <span class="hljs-comment">// ws&gt;0说明pred已经cancel了或者</span><br>                <span class="hljs-comment">// cas失败说明，pred可能被cancel了</span><br>                (ws &lt;= <span class="hljs-number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;<br>            pred.thread != <span class="hljs-keyword">null</span>) <br>            <br>        <span class="hljs-comment">/**********************************************</span><br><span class="hljs-comment">        *                problem2 end                 *</span><br><span class="hljs-comment">        **********************************************/</span><br>        &#123;<br>            Node next = node.next;<br>            <span class="hljs-keyword">if</span> (next != <span class="hljs-keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="hljs-number">0</span>)<br><br>            <span class="hljs-comment">/**********************************************</span><br><span class="hljs-comment">            *               problem3 begin                *</span><br><span class="hljs-comment">            **********************************************/</span><br>                compareAndSetNext(pred, predNext, next);<br>            <span class="hljs-comment">/**********************************************</span><br><span class="hljs-comment">            *                problem3 end                 *</span><br><span class="hljs-comment">            **********************************************/</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            unparkSuccessor(node);<br>        &#125;<br><br>        node.next = node; <span class="hljs-comment">// help GC</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>阅读源码发现，<code>cancelAcquire</code>将取消节点<code>node</code>的位置分为三种情况：</p><ol><li><code>node</code>为尾节点<code>tail</code></li><li><code>node</code>为头节点<code>head</code>的后继节点</li><li><code>node</code>在中间，既不为<code>tail</code>，也不为<code>head</code></li></ol><p>对于三种情况的取消操作，只有后两种情形会执行唤醒后继节点的操作。why？这里先不做解释，具体请看<code>Q2</code>的问题答疑。对于我存在三个疑问，具体位置我已在代码中进行了标注。但是在解决疑问之前，我们需要知道一个基本事实：</p><blockquote><p>如果一个节点已经cancel了，那么这个节点表示的线程即使唤醒了，也不会执行获取锁的操作。因为当前执行的代码早就有可能执行到别的地方，而不是停留在获取锁的地方。</p></blockquote><p>了解了基本事实后，我讲讲我对每个问题的理解。</p><hr><p><strong>Question 1：既然代码中problem1处，的CAS成功与否并不重要，那么为什么要使用CAS？</strong></p><hr><p>我认为使用CAS的原因有两点：</p><ol><li>不覆盖其他线程的操作结果</li><li>加快查找下一个唤醒的目标线程</li></ol><p>假设现在有线程A要取消获取锁，在执行完<code>compareAndSetTail(node, pred)</code>后，就切换到了线程B，此时同步队列状态如下图所示:</p><p><img src="images/cancelAcquire-p5.drawio.svg" alt="cancelAcquire-p5"></p><p>随后线程B进入同步队列，或者线程C也恰巧进入同步队列，此时同步队列状态如下所示：</p><p><img src="images/cancelAcquire-p6.drawio.svg" alt="cancelAcquire-p6"></p><p>然后切换到线程A执行<code>compareAndSetNext(pred, predNext, null);</code>，正常情况下这里肯定失败，不会产生错误的后果。<strong>但是如果这里没有使用CAS</strong>，那么就仍会执行<code>nodeA_pred.next=null</code>，结果如下所示：</p><p><img src="images/cancelAcquire-p7.drawio.svg" alt="cancelAcquire-p7"></p><p>当nodeA_pred释放锁后，它需要唤醒下一个节点，<code>nodeA_pred.next=null</code>。所以就需要从尾部<code>tail</code>开始向前遍历同步队列。当队列很长时，这种遍历是耗时的，但是这种情况可以通过CAS避免，达到了快速找到下一个唤醒线程的目标。</p><hr><p><strong>Question 2：为什么代码中problem2处要设置如此的判断条件？</strong></p><hr><p>试想当我们取消一个节点获取锁时，有必要唤醒（通过<code>unparkSuccessor</code>完成，在第3节中分析）当前被取消节点的后继节点，因为后继节点的唤醒是由当前被取消的节点负责的，但是并不是所有的情况都需要唤醒的。假设我们当前取消的节点为<code>node</code>，其前向节点为<code>pred</code>：</p><ol><li><p>当<code>node</code>为尾节点tail时，并且在当前线程更新<code>tail</code>前，没有新节点入队，那么就不用执行唤醒操作（如果在当前线程更新<code>tail</code>后，有新节点A入队，那么A在挂起前会找到一个可靠的前向节点B，A的唤醒由B管理，而不是由<code>node</code>管理）。否则执行2或者3。</p></li><li><p>当<code>pred</code>为头节点<code>head</code>时，必须唤醒<code>node</code>的后继节点。这个逻辑很容易理解。假设当前<code>pred</code>释放锁了，它会唤醒<code>node</code>，而<code>node</code>此时已经取消了，代码早就跑飞了，唤醒了<code>node</code>有什么用？<code>node</code>不抢锁了，自然不会唤醒<code>node</code>的后继节点。</p></li><li><p>当<code>node</code>为非尾节点时，并且<code>node</code>的前一个节点状态不为-1并且不能更新为-1时，那么就必须手动唤醒<code>node</code>之后的第一个有效节点。这是因为<code>pred</code>必须为一个有效节点，否则即使设置了<code>pred.next</code>，<code>node</code>的后继节点也可能会永远无法被唤醒。可能这个逻辑比较难理解。我试图结合以下几张图说说我的理解。</p></li></ol><p>如果没有第3点的条件限制，也就是说实际的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (pred != head) &#123;<br>    Node next = node.next;<br>    <span class="hljs-keyword">if</span> (next != <span class="hljs-keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="hljs-number">0</span>)<br>        compareAndSetNext(pred, predNext, next);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    unparkSuccessor(node);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么当取消<code>node</code>节点时，刚通过了if条件的检查，切换<code>pred</code>执行取消操作：初始状态如下所示（图中所有的next指针都是在CAS操作成功的情况下决定的，下图同理）：</p><p><img src="images/cancelAcquire-p1.drawio.svg" alt="cancelAcquire-p1"></p><p>因为<code>pred</code>的前向节点状态正常，在<code>pred</code>完成取消操作后，状态如下所示：</p><p><img src="images/cancelAcquire-p2.drawio.svg" alt="cancelAcquire-p2"></p><p>然后，又切换回<code>node</code>，完成剩余设置指针的操作，状态如下所示：</p><p><img src="images/cancelAcquire-p3.drawio.svg" alt="cancelAcquire-p3"></p><p>试想如果在<code>c</code>释放锁后，会唤醒<code>node</code>，<del>但是<code>node</code>代表的线程执行的代码早就不会停留在获取锁的地方了，所以唤醒<code>node</code>同样会造成<code>node</code>之后的节点永远被挂起的状态</del>，但是node的状态不符合要求，所以会从tail指针开始遍历。</p><p>那么为什么有了<code>((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))</code>，就能够避免上述的情况？</p><p><strong>因为了该条件保证前向节点<code>pred</code>的有效性。</strong></p><p>试想，如果<code>node</code>在取消时，发现<code>ws!=Node.SIGNAL</code>或者CAS失败，这就说明<code>pred</code>不可靠了，需要手动唤醒<code>node</code>的后继线程，让这些后继线程在重新挂起前重新找个好爹，所以保证了唤醒链不会中断。</p><p>那么在<code>node</code>取消后，<code>pred</code>再取消为什么不会有问题呢？这就很简单了，原理如下图所示：</p><p><img src="images/cancelAcquire-p4.drawio.svg" alt="cancelAcquire-p4"></p><p><strong>小结：</strong></p><p>对于被取消的节点<code>node</code>，如果在完成取消操作前，<code>node</code>后续有节点，那么必须保证<code>node</code>前面有一个<code>waitstatus == -1</code>的节点用来完成唤醒<code>node</code>之后的线程。</p><hr><p><strong>Question 3：既然代码中problem3处，的CAS成功与否并不重要，那么为什么要使用CAS？</strong></p><hr><p>我的理解是：使用CAS能够加速查找下一个唤醒目标。</p><p>试想如下一种场景：threadA正在取消节点，正准备执行<code>compareAndSetNext(pred, predNext, next);</code>时切换threadB。threadB排在threadA后面。恰巧threadB也在取消节点，并且取消的是尾节点tail，取消<strong>完成</strong>后状态如下所示：</p><p><img src="images/cancelAcquire-p8.drawio.svg" alt="cancelAcquire-p8"></p><p>恰巧此时有新节点入队，入队完成后，又切换到threadA执行<code>compareAndSetNext(pred, predNext, next);</code>。如果这不是CAS操作，那么threadA会继续执行<code>nodeA_pred.next=next(nodeB)</code>。执行完成后，同步队列如下所示：</p><p><img src="images/cancelAcquire-p9.drawio.svg" alt="cancelAcquire-p9"></p><p>那么在<code>nodeA_pred</code>释放锁后，唤醒的线程是<code>nodeB</code>，但是<code>nodeB</code>已经取消了，必须从尾部开始向前遍历，直到找到一个可用的节点。</p><p><strong>小结</strong><br>如果被取消节点<code>node</code>的前向节点<code>pred</code>的next指针设置失败时，就说明<code>node</code>的直系后继节点<code>next</code>可能已经失效了，<strong>因为<code>pred</code>的next指针只会被<code>node</code>的后继节点更改。</strong> 自然不能执行<code>pred.next=node.next</code>（这个操作由CAS来保证）。</p><h4 id="2-1-3-selfInterrupt是干嘛的？"><a href="#2-1-3-selfInterrupt是干嘛的？" class="headerlink" title="2.1.3 selfInterrupt是干嘛的？"></a>2.1.3 <code>selfInterrupt</code>是干嘛的？</h4><p>简单点来说，<code>selfInterrupt</code>是用来补偿中断的。为何要补偿？因为<code>ReentrantLock</code>在获取锁时，即使产生了中断，也不会退出获取锁的流程。那么中断在哪里产生？<br>见下面代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>    LockSupport.park(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在线程被挂起后，要么被<code>unpark</code>唤醒，要么被中断唤醒。唤醒之后会调用<code>Thread.interrupted</code>返回当前中断状态（用来判断当前线程被唤醒的原因是什么）。如果是由于中断唤醒的，那么<code>interrupted</code>会被设置为true，具体实现在<code>acquireQueued</code>中：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                ...<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//如果没有获取到锁，并且取消了请求，那么就要执行取消操作</span><br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在<code>acquireQueued</code>正常返回后，会返回<code>interrupted</code>，如果该变量为<code>true</code>，则会调用<code>selfInterrupt</code>手动实现一个中断，补偿在获取锁过程中产生的未响应中断。</p><h2 id="3-ReentrantLock的释放操作"><a href="#3-ReentrantLock的释放操作" class="headerlink" title="3. ReentrantLock的释放操作"></a>3. ReentrantLock的释放操作</h2><p>锁的释放还是需要借助AQS框架实现，首先会调用<code>AbstractQueuedSynchronizer.release</code>,代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-comment">// 上边自定义的tryRelease如果返回true，说明该锁没有被任何线程持有</span><br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-comment">// 获取头结点</span><br>        Node h = head;<br>        <span class="hljs-comment">// 头结点不为空并且头结点的waitStatus不是初始化节点情况，解除线程挂起状态</span><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当锁没有被线程持有时，就可以唤醒头节点head之后的节点了。但是唤醒的判断条件为什么是h != null &amp;&amp; h.waitStatus != 0？原因有两点：</p><ol><li>h == null 说明head还没初始化。初始情况下，head == null，第一个节点入队，Head会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现head == null 的情况。</li><li>h != null &amp;&amp; waitStatus == 0 表明后继节点对应的线程仍在运行中，不需要唤醒。因为只有当前节点的waitStatus== -1，后继线程才会挂起。h != null &amp;&amp; waitStatus &lt; 0 表明后继节点可能被阻塞了，需要唤醒。</li></ol><p>那么释放锁唤醒线程的操作由<code>unparkSuccessor</code>完成：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取当前结点waitStatus</span><br>    <span class="hljs-keyword">int</span> ws = node.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">/***********************************</span><br><span class="hljs-comment">        * 这个if操作完全是给head节点用的，</span><br><span class="hljs-comment">        * 使用CAS我认为是为了防止有的线程多一次获取锁的机会，避免覆盖别的线程操作结果</span><br><span class="hljs-comment">        /**********************************/</span><br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 获取当前节点的下一个节点</span><br>    Node s = node.next;<br>    <span class="hljs-comment">// 如果下个节点是null或者下个节点被cancelled，就找到队列最开始的非cancelled的节点</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        s = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 就从尾部节点开始找，到队首，找到队列第一个waitStatus&lt;0的节点。</span><br>        <span class="hljs-keyword">for</span> (Node t = tail; t != <span class="hljs-keyword">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>    &#125;<br>    <span class="hljs-comment">// 如果当前节点的下个节点不为空，而且状态&lt;=0，就把下个节点unpark</span><br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)<br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>为什么要从后往前找第一个非Cancelled的节点呢？答案在addWaiter方法中：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;<br>    Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>    Node pred = tail;<br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;<br>        node.prev = pred;<br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们从这里可以看到，节点入队并不是原子操作，也就是说，node.prev = pred; compareAndSetTail(pred, node) 这两个地方可以看作Tail入队的原子操作，但是此时pred.next = node;还没执行，如果这个时候执行了unparkSuccessor方法，就没办法从前往后找了，所以需要从后往前找。还有一点原因，在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的Node。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p><code>ReentrantLock</code>是独占锁的经典实现。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://zhuanlan.zhihu.com/p/122186071">AQS源码详细解读</a></p></li><li><p><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html#:~:text=AQS%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E6%98%AF%EF%BC%8C%E5%A6%82%E6%9E%9C,%E7%BA%BF%E7%A8%8B%E5%8A%A0%E5%85%A5%E5%88%B0%E9%98%9F%E5%88%97%E4%B8%AD%E3%80%82">从ReentrantLock的实现看AQS的原理及应用</a></p></li><li><p><a href="https://www.tianxiaobo.com/2018/05/01/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/#421-%E8%8E%B7%E5%8F%96%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81">AbstractQueuedSynchronizer 原理分析 - 独占/共享模式</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>多线程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ReentrantLock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Condition队列</title>
    <link href="/2021-06-03/condition-analysis.html"/>
    <url>/2021-06-03/condition-analysis.html</url>
    
    <content type="html"><![CDATA[<p><code>Condition</code>接口的功能用来实现类似于<code>synchronized</code>的await()/signal()通知机制。但是比<code>synchronized</code>的通知机制更丰富、更灵活。我们知道，<code>synchronized</code>锁内部维护了一个<code>waitList</code>保存调用了<code>wait()</code>主动释放锁的线程。AQS的<code>waitList</code>功能就是通过<code>Condition</code>内部维护的<code>Condition queue</code>实现的。</p><p>与AQS的同步队列相似，<code>Condition queue</code>也是由<code>Node</code>类型的节点组成的。但是这里并没有使用<code>Node</code>的prev、next指针组成双向队列，而是通过一组额外的指针<code>firstWaiter</code>和<code>lastWaiter</code>维护了一个<strong>单向队列</strong>。<code>condition queue</code>的组成元素如下图所示：</p><p><img src="images/condition-queue.png" alt="condition queue"></p><p>我们发现还有两个没见过的元素：<code>REINTERRUPT</code>和<code>THROW_IE</code>。这两个元素与线程wait之后发生的中断有关，这放到后面再解释。了解了基本情况，那么我们就来看看AQS的wait/notify机制是如何实现的。</p><h2 id="wait机制"><a href="#wait机制" class="headerlink" title="wait机制"></a>wait机制</h2><p>在AQS中，主动挂起是通过<code>await()</code>方法实现的，与<code>synchronized</code>类似，调用<code>await()</code>的线程必须是获得锁的线程。那万一有人故意在没有获得锁的时候调用呢？这种情况如何处理？暂时不清楚。<code>await()</code>方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">//当线程发生中断时，直接抛出异常</span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>    <span class="hljs-comment">// 将当前线程加入condition queue</span><br>    Node node = addConditionWaiter();<br>    <span class="hljs-comment">// 释放当前线程持有的锁</span><br>    <span class="hljs-keyword">int</span> savedState = fullyRelease(node);<br>    <span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 如果当前线程仍然在condition queue中，那么就主动park，直到被唤醒</span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        LockSupport.park(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 处理park期间发生中断的情况</span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// clean up if cancelled</span><br>        unlinkCancelledWaiters();<br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>        reportInterruptAfterWait(interruptMode);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>线程调用<code>await()</code>之后，首先会将当前线程加入<code>condition queue</code>，然后完全释放当前线程持有的锁，最后挂起当前线程直到当前线程被中断或者被<code>signal</code>唤醒。我们先来分析线程从调用<code>await()</code>到被挂起这一阶段所发生的事情。处理park期间发生中断的代码我们在第四部分进行分析。</p><p>调用<code>await</code>后，要做的操作就是将当前线程的包装节点node加入<code>condition queue</code>。加入操作不需要保证线程安全，因为能够调用<code>await()</code>的线程，在正确的情况下都已经获得了锁，具体的实现代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 将当前线程加入队列</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addConditionWaiter</span><span class="hljs-params">()</span> </span>&#123;<br>    Node t = lastWaiter;<br>    <span class="hljs-comment">// If lastWaiter is cancelled, clean out.</span><br>    <span class="hljs-comment">//如果condition queue不为空，并且最后一个节点不在condition queue中</span><br>    <span class="hljs-comment">// 那么就剔除队列中的所有取消节点</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;<br>        unlinkCancelledWaiters();<br>        t = lastWaiter;<br>    &#125;<br>    Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);<br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>)<br>        firstWaiter = node;<br>    <span class="hljs-keyword">else</span><br>        t.nextWaiter = node;<br>    lastWaiter = node;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-comment">// 剔除所有的非等待节点</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlinkCancelledWaiters</span><span class="hljs-params">()</span> </span>&#123;<br>    Node t = firstWaiter;<br>    <span class="hljs-comment">//trail始终指向队列中最后一个有效节点</span><br>    Node trail = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">while</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>        Node next = t.nextWaiter;<br>        <span class="hljs-comment">//如果当前节点仍不为Node.CONDITION状态</span><br>        <span class="hljs-keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;<br>            t.nextWaiter = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-comment">//如果仍没有找到一个有效节点</span><br>            <span class="hljs-keyword">if</span> (trail == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-comment">// 那么就假设next是有效节点</span><br>                firstWaiter = next;<br>            <span class="hljs-comment">// 如果已经找到了有效节点，那么就跳过当前节点</span><br>            <span class="hljs-keyword">else</span><br>                trail.nextWaiter = next;<br>            <br>            <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>)<br>                lastWaiter = trail;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            trail = t;<br>        t = next;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>节点入队的逻辑比较简单，如果条件队列的最后一个节点失效了，那么就会一次性剔除队列中所有的失效节点。<strong>那么这里就出现了一个问题：<code>condition queue</code>中的节点的waitStatus什么时候会被修改成非<code>Node.CONDITION</code>？</strong> 有人说是超时、中断会被更改，没找到啊？此问题仍待解决。</p><p>当前线程找到最后一个有效节点入队后，就会释放所有持有的锁。这里为什么要指<strong>所有</strong>？因为有可能发生锁重入的情况。这也就是释放锁为什么叫<code>fullyRelease</code>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//释放目前持有的锁，包括可重入</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fullyRelease</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">int</span> savedState = getState();<br>        <span class="hljs-comment">//调用AQS框架的释放方法，最终又会调用用户自定的tryRelease</span><br>        <span class="hljs-keyword">if</span> (release(savedState)) &#123;<br>            failed = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">return</span> savedState;<br>        &#125;<br>        <span class="hljs-comment">//释放锁失败，则说明当前线程根本就没有持有锁 </span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            node.waitStatus = Node.CANCELLED;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在前面我们曾说到，调用<code>await()</code>的线程必须持有锁，但是有可能有人故意在没有持有锁的线程中调用<code>await()</code>。在<code>await()</code>中并没有对这一特殊情况进行处理，其实AQS是把这个检查交给用户自己去定义了。例如在<code>reentrantLock</code>自定义的<code>tryRelease</code>中，如果当前线程没有持有锁，则释放失败。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> c = getState() - releases;<br>    <span class="hljs-comment">//当前线程并没有持有锁，直接抛出异常</span><br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>    <span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-keyword">true</span>;<br>        setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>    &#125;<br>    setState(c);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果释放锁时抛出异常，那么会将当前已经进入<code>condition queue</code>的节点的waitStatus设为Node.CANCELLED（原来这也是在条件队列中生成取消节点的一种方法）。释放锁之后需要做的就是主动挂起当前线程，直到被中断或者被<code>signal</code>。从下面的代码中我们发现，如果当前线程被唤醒之后仍在条件队列中，那么继续会被主动挂起。？？？将被挂起的线程移除条件队列难道不是通过<code>await()</code>实现的？是谁？我们想想，正常情况下，是谁把挂起的线程唤醒的？是<code>signal</code>或者发生的中断。那么有没有可能就是这二者偷偷做的呢？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ...<br>    <span class="hljs-comment">//被唤醒之后，如果当前节点不在同步队列中，那么继续park</span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        LockSupport.park(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="signal机制"><a href="#signal机制" class="headerlink" title="signal机制"></a>signal机制</h2><p>当某个条件满足时，线程可以通过调用<code>signal()</code>方法唤醒<code>condition queue</code>中的某个线程或者使用<code>signalALL()</code>方法唤醒<code>condition queue</code>中的所有线程。注意，调用<code>await()</code>的线程和调用<code>signal()</code>的线程不是同一个哦。<code>signal()</code>和<code>signalALL()</code>的具体实现差不多。我先详细一下已下<code>singal()</code>吧。具体代码如下所示：</p><figure class="highlight java"><figcaption><span>"signal"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 如果当前锁没有被调用signal的线程独占</span><br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>    Node first = firstWaiter;<br>    <span class="hljs-comment">// 如果首节点不为空，则调用doSignal唤醒线程</span><br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>)<br>        doSignal(first);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSignal</span><span class="hljs-params">(Node first)</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-keyword">null</span>)<br>            lastWaiter = <span class="hljs-keyword">null</span>;<br>        first.nextWaiter = <span class="hljs-keyword">null</span>;<br>    &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;<br>                (first = firstWaiter) != <span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>signal()</code>函数首先会检查当前调用<code>signal()</code>函数的线程是否独占锁。如果是，那么则调用<code>doSingal</code>唤醒条件队列中第一个节点。而在<code>doSignal</code>中，又会循环调用<code>transferForSignal()</code>。这个方法的名字很有意思，transform，transform什么？我们进入具体的方法瞅瞅。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">transferForSignal</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * If cannot change waitStatus, the node has been cancelled.</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * Splice onto queue and try to set waitStatus of predecessor to</span><br><span class="hljs-comment">    * indicate that thread is (probably) waiting. If cancelled or</span><br><span class="hljs-comment">    * attempt to set waitStatus fails, wake up to resync (in which</span><br><span class="hljs-comment">    * case the waitStatus can be transiently and harmlessly wrong).</span><br><span class="hljs-comment">    */</span><br>    Node p = enq(node);<br>    <span class="hljs-keyword">int</span> ws = p.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))<br>        LockSupport.unpark(node.thread);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>transferForSignal</code>首先尝试使用CAS将node的<code>waitStatus</code>从Node.CONDITION更改为0。如果更改失败，则说明当前node已经被cancel了。那么为什么不可能是被中断了呢？node被中断后，waitStatus会被更改为0，这个CAS也会失败啊。这个CAS失败好像没有关系，应该会继续<code>transforForSignal</code>条件队列中的下一个节点。所以最坏的局面就是条件队列中的线程全部被唤醒了。</p><p><code>transferForSignal</code>如果第一步的CAS成功，则会通过调用<code>enq</code>把当前节点node加入同步队列，如果当前node的前向节点<code>p</code>不是一个一个可靠的爹，说明当前node的唤醒操作不能依赖<code>p</code>，需要手动调用<code>unpark</code>唤醒当前node表示的线程。</p><p>如果<code>transferForSignal</code>返回true，则说明成功<code>signal</code>一个线程，可以停止<code>doSignal</code>的循环操作了。这样就成功执行了<code>signal</code>操作。那么<code>signalAll</code>是什么样的操作呢？是将条件队列中的节点依次加入同步队列吗？来瞅瞅。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signalAll</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>    Node first = firstWaiter;<br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>)<br>        doSignalAll(first);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSignalAll</span><span class="hljs-params">(Node first)</span> </span>&#123;<br>    lastWaiter = firstWaiter = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        Node next = first.nextWaiter;<br>        first.nextWaiter = <span class="hljs-keyword">null</span>;<br>        transferForSignal(first);<br>        first = next;<br>    &#125; <span class="hljs-keyword">while</span> (first != <span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>signalAll</code>内部会调用与<code>doSignal</code>类似的函数<code>doSignalAll</code>。<code>doSignalAll</code>的流程与<code>doSignal</code>高度类似。其内部也是循环调用<code>transferForSignal</code>将条件队列中节点依次加入同步队列。只不过<code>doSingalAll</code>的循环操作终止条件不再是<code>transferForSignal</code>操作是否成功，而是遍历完条件队列中的所有节点后才会终止循环操作。</p><h2 id="signal机制与中断的交互"><a href="#signal机制与中断的交互" class="headerlink" title="signal机制与中断的交互"></a>signal机制与中断的交互</h2><p>通过了解<code>signal</code>机制，我们知道，一旦调用<code>signal</code>，一般情况下则会将条件队列的首节点加入条件队列争锁。但是如果线程在等待资源期间收到了中断请求怎么办？对于这个问题，我们需要拆分成两个小问题：</p><ol><li>中断是谁处理的？</li><li>发生中断的情况会有哪几种？</li></ol><p>对于第一个问题，我们首先想想线程是如何进入条件队列等待资源的？是通过调用<code>await</code>完成。那么在等待期间收到中断请求的处理是不是也应该由<code>await</code>完成？我们来看看<code>await</code>的我们未分析的后半部分：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ...<br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        <span class="hljs-comment">//调用park函数后当前线程被主动挂起</span><br>        LockSupport.park(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 处理park期间发生中断的情况</span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// clean up if cancelled</span><br>        unlinkCancelledWaiters();<br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>        reportInterruptAfterWait(interruptMode);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在<code>await</code>中调用<code>park</code>后，如果被唤醒，则会执行<code>checkInterruptWhileWaiting</code>判断是否结束循环，如果能够成功跳出循环，则会通过三个<code>if</code>处理具体的情况，到底是怎么处理的我们后文再看。我们再来看看第二个问题：可能出现的情况也就两种：</p><ul><li>中断发生时，线程还没有被<code>signal</code></li><li>中断发生时，线程已经被别的线程<code>signal</code>了</li></ul><p>那么中断和<code>signal</code>到底谁先发生是怎么判断的呢？这肯定是<code>checkInterruptWhileWaiting</code>处理的：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">checkInterruptWhileWaiting</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-comment">//清除中断位</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted() ?<br>        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :<br>        <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>checkInterruptWhileWaiting</code>的内容很简单，如果没有发生中断，则返回0。否则继续调用<code>transferAfterCancelledWait</code>判断：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">transferAfterCancelledWait</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-comment">//如果是中断先发生，那么CAS会成功，否则就表示当前node已经被signal了</span><br>    <span class="hljs-keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>)) &#123;<br>        enq(node);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * If we lost out to a signal(), then we can&#x27;t proceed</span><br><span class="hljs-comment">    * until it finishes its enq().  Cancelling during an</span><br><span class="hljs-comment">    * incomplete transfer is both rare and transient, so just</span><br><span class="hljs-comment">    * spin.</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// 如果是signal先发生，为什么一定要保证节点加入了同步队列？</span><br>    <span class="hljs-comment">// 因为如果直接返回false，后续会执行acquireQueued抢锁</span><br>    <span class="hljs-comment">// node都未加入同步队列怎么抢？必然会发生奇怪的不可预期的事情</span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node))<br>        Thread.yield();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 判断node是否已经处于同步队列</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOnSyncQueue</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-comment">//条件队列中的node是不会设置prev与next指针的</span><br><br>    <span class="hljs-keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (node.next != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// If has successor, it must be on queue</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * node.prev can be non-null, but not yet on queue because</span><br><span class="hljs-comment">    * the CAS to place it on queue can fail. So we have to</span><br><span class="hljs-comment">    * traverse from tail to make sure it actually made it.  It</span><br><span class="hljs-comment">    * will always be near the tail in calls to this method, and</span><br><span class="hljs-comment">    * unless the CAS failed (which is unlikely), it will be</span><br><span class="hljs-comment">    * there, so we hardly ever traverse much.</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> findNodeFromTail(node);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果中断先于<code>signal</code>发生，那么则会调用<code>enq</code>将当前node加入同步队列并返回<code>true</code>。否则自旋直到当前节点成功加入同步队列，随后返回<code>false</code>。这里我存在一个问题：如果<code>signal</code>先于中断发生，那么为什么一定要保证当前node加入了同步队列呢？</p><p>可以看出，<code>transferAfterCancelledWait</code>就是判断中断和<code>signal</code>到底谁先发生的关键函数。如果中断先发生，则返回true，否则返回false。在返回之后，我们再次回到<code>checkInterruptWhileWaiting</code>。如果中断发生，那么则返回<code>THROW_IE</code>，否则返回<code>REINTERRUPT</code>。这两个是什么意思？通过下面的注释，我们了解到，<code>THROW_IE</code>表示在<code>wait</code>退出后，需要抛出一个中断异常，否则只是重新设置中断位。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/** Mode meaning to reinterrupt on exit from wait */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> REINTERRUPT =  <span class="hljs-number">1</span>;<br><span class="hljs-comment">/** Mode meaning to throw InterruptedException on exit from wait */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> THROW_IE    = -<span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure><p>我们的视角再次回到<code>await</code>，在判断中断与<code>signal</code>谁先发生后，则会跳出循环（如果中断和<code>signal</code>都没有发生，那么则会继续调用park挂起自己）。在跳出循环后，会执行三个<code>if</code>条件，基本流程我都以注释的形式写在了代码中，还是比较容易理解的。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    ...<br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        <span class="hljs-comment">//调用park函数后当前线程被主动挂起</span><br>        LockSupport.park(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 处理park期间发生中断的情况</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 需要获得锁savedState次，因为需要与调用await之前线程持有锁的状态一致</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * acquireQueueed返回true表示在抢锁过程中发生了中断了，</span><br><span class="hljs-comment">    * 如果没有后半部分的判断条件，那么原来可能interruptMode=THROW_IE,THROW_IE在await结束后</span><br><span class="hljs-comment">    * 需要抛出中断异常，但是因为在抢锁的过程中又发生了中断，没有后半部分的条件</span><br><span class="hljs-comment">    * interruptMode被覆盖为REINTERRUPT这样仅仅只会重新设置中断位，丢失了原本需要抛出的中断异常</span><br><span class="hljs-comment">    */</span><br>    interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 在node被移出条件队列后，需要设置node的nextWaiter指针</span><br><span class="hljs-comment">    * 在中断先发生的情况下，node只是被加入了同步队列，而没有设置nextWaiter指针</span><br><span class="hljs-comment">    * 但是signal先发生的情况下，node的nextWaiter已经被修改了，所以使用if判断</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// clean up if cancelled</span><br>        unlinkCancelledWaiters();<br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>    <span class="hljs-comment">// node被移出条件队列后，要根据interruptMode的值来决定是抛出异常还是重新设置中断标志位</span><br>        reportInterruptAfterWait(interruptMode);<br>&#125;<br><br><span class="hljs-comment">// 根据interruptMode的值来决定是抛出异常还是设置中断标志位</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reportInterruptAfterWait</span><span class="hljs-params">(<span class="hljs-keyword">int</span> interruptMode)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// 直接抛出中断异常</span><br>    <span class="hljs-keyword">if</span> (interruptMode == THROW_IE)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>    <span class="hljs-comment">//重新设置中断位</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interruptMode == REINTERRUPT)<br>        selfInterrupt();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我认为需要再对条件语句<code>if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</code>做一下说明，一旦一个线程被唤醒：</p><ol><li>如果中断先于<code>signal</code>发生，那么不管在抢锁的过程中有没有发生中断，因为if的后半部分的条件无法通过，最后的结果就是抛出中断。if的后半个条件就是为了处理此类情况，避免了中断被覆盖</li><li>如果<code>signal</code>先于中断发生，如果抢锁的过程中发生了中断，那么无论后半部分的条件是否通过，都不会影响最后设置中断位的结果</li></ol><p>无论是因为中断还是<code>signal</code>谁先发生，唤醒后都会转移到同步队列抢锁，<strong>抢到锁才会考虑后续是否需要补一个中断异常。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>条件队列还是比较简单的，最复杂的地方就是<code>signal</code>与中断如果都发生了，那么情况就比较棘手。条件队列仅通过额外的<code>nextWaiter</code>指针维护一个单向队列，如果线程的资源要求达到满足，那么就会将节点从条件队列移步至同步队列抢锁。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://segmentfault.com/a/1190000016462281">逐行分析AQS源码(4)——Condition接口实现</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>多线程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>condition queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql中的索引</title>
    <link href="/2021-06-03/index-of-mysql.html"/>
    <url>/2021-06-03/index-of-mysql.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>索引是使用MySQL是一个很重要的知识点,正确的使用索引能够极大地提高MySQL的运行效率。那么关于索引,我产生了如下问题:</p><ul><li>索引是什么</li><li>有哪些索引</li><li>索引的原理是什么</li><li>如何正确地使用索引</li></ul><p>下面我将一一对问题进行解答。</p><h2 id="1-索引是什么"><a href="#1-索引是什么" class="headerlink" title="1.索引是什么"></a>1.索引是什么</h2><p>索引是一种专门用于数据库的结构,其目的也非常明显,就是用来优化数据库的执行效率。首先我们来看看官方是如何描述索引的用处:</p><blockquote><p>Indexes are used to find rows with specific column values quickly.</p></blockquote><p>简单来说,索引就是用来加速我们查找特定的行。不同类型的索引具体实现的原理不同,当然适用场景也不同。</p><h2 id="2-索引分类"><a href="#2-索引分类" class="headerlink" title="2. 索引分类"></a>2. 索引分类</h2><p>根据不同的角度,索引的分类也不同。下面将从实现索引的数据结构、索引的物理存储结构、逻辑结构三个方面对索引进行分类。</p><h3 id="2-1-数据结构角度"><a href="#2-1-数据结构角度" class="headerlink" title="2.1 数据结构角度"></a>2.1 数据结构角度</h3><p><strong>(1). B树索引</strong><br>    在B树中,一个节点可以有多组key-value,如<a href="https://zsr.github.io/images/B-%E6%A0%91.jpg">下图所示</a>:<br><img src="https://zsr.github.io/images/B-%E6%A0%91.jpg" alt="B-tree">那么如果使用B树实现索引,每个节点中存在多组key-value,每组key-value中：key就是索引值,value就是对应的具体一行。所以使用B树索引时,查找某一特定行的效率是不定的,因为不一定每一次查找都查到了叶子节点。当然<strong>B树的中序遍历是有序的</strong>。</p><p><strong>(2). B+树索引</strong><br>B+树是B树的改进，B+树中每个节点不再存储多个key-value组合，而是只存储多组key，对应的data全部存储在最底层的叶子节点,并且叶子节点中的key都是有序的。如<a href="https://zsr.github.io/images/B+%E6%A0%91.jpg">下图所示</a>:<img src="https://zsr.github.io/images/B+%E6%A0%91.jpg" alt="B+ tree"><br>同时每层的节点又组成了一个双向链表,方便横向遍历。当然,<strong>B+树横向遍历和中序遍历也都是有序的</strong>。</p><p><strong>(3). hash索引</strong><br>hash索引与HashMap类似,key为每个索引值对应的hash值,而对应的value就是索引值对应的data。</p><h4 id="2-1-1-hash索引的适用场景"><a href="#2-1-1-hash索引的适用场景" class="headerlink" title="2.1.1 hash索引的适用场景"></a>2.1.1 hash索引的适用场景</h4><p>因为hash索引只是对单个key做hash，并且各个hash之间是无序的，所以hash索引比较适用精确查询，在进行范围查询、排序查询时效率非常差，并且当数据大量重复时，会发生大量的哈希冲突。当然只有<strong>memory存储引擎显示地支持hash索引</strong>,并且hash索引也没有进行持久化保存。</p><h4 id="2-1-2-MySQL为什么要适用B-树实现索引"><a href="#2-1-2-MySQL为什么要适用B-树实现索引" class="headerlink" title="2.1.2 MySQL为什么要适用B+树实现索引"></a>2.1.2 MySQL为什么要适用B+树实现索引</h4><p>在回答这个问题之前,还需要回答一个问题,为什么不用平衡二叉树、红黑树等查找效率高的结构来实现索引?</p><p><strong>为什么不采用AVL树或者RB树？</strong></p><p>在一般情况下，索引文件是非常大的，所以不可能一次性把表中所有记录加载进内存。所以使用基本都会产生IO操作。又因为IO操作代价较高,cpu一般会按照<strong>局部性原理</strong>按<strong>页</strong>读取。然而因为RB树是逻辑上有序，物理存储上可能相隔很远，逻辑上相邻的节点物理上根本不在同一页。所以如果使用AVL树或红黑树，查询节点时产生的IO操作必然非常多。尽管查询复杂度为logN，仍旧是非常不划算的。</p><p><strong>为什么不采用B树？</strong></p><p>为了解决AVL树IO操作代价高昂的原理，科学家们提出了B树，将相邻的值保存在同一个节点中(应该是在物理存储上的相邻)。这样就能顺利地利用上局部性原理。并且由于一个节点中储存了多个值，树的高度必然会比RB树、AVL树的高度低。</p><p>虽然B树在查询上的性能不如它们，但是由于规避了大量的IO操作，带来的收益已经远远超过了AVL树微不足道的查询性能。</p><p>但是使用B树做索引仍然存在一个问题,B+树就是为了解决这个问题。</p><p><strong>为什么采用B+树？</strong></p><p>虽然B树规避了大量的IO操作，但是由于B树不能满足对数据库做范围查询、扫库等操作的性能要求，提出了B+树。</p><p>因为B+树的节点不再储存data，只存储key。这样B+树的一个节点中可以B树的一个节点存储更多的key，所以B+树的高度会比B+树还低。并且B+树会将所有的叶子节点串联起来做成一个双向链表。因为叶子节点存储的是表中真正的数据。所以范围查询只需要找到目标范围的起点与终点，随后遍历双向链表就可以很方便的完成范围查找操作。扫库操作同理。</p><hr><p>Extension:为什么需要限制表中每一行的大小？</p><p>MySQL将每个节点的大小设置为一个页的整数倍，(即B+树的一个节点)只能存储一条数据，因为如果一行的数据大小超过了系统一页的一半，可以想象完成扫库操作的代价是巨大的。所以最好一条数据的大小不要超过一个<strong>innodb_page_size</strong>的一半。</p><p>在大于5.7.6的版本中，innodb_page_size的大小<strong>默认为16KB</strong>。可以选择的大小包括4KB、8KB、16KB、32KB、64KB。</p><hr><h4 id="2-1-3-B树索引和B-树索引有什么区别"><a href="#2-1-3-B树索引和B-树索引有什么区别" class="headerlink" title="2.1.3 B树索引和B+树索引有什么区别"></a>2.1.3 B树索引和B+树索引有什么区别</h4><p>基本上就有三点不同：</p><ul><li>B+树的IO操作代价较低</li><li>B+树查询效率更稳定，因为每次查询都必然会查找到叶节点</li><li>B+树能够更方便地完成扫库操作</li></ul><h4 id="2-1-4-innodb和myiasm的索引有什么不同"><a href="#2-1-4-innodb和myiasm的索引有什么不同" class="headerlink" title="2.1.4 innodb和myiasm的索引有什么不同"></a>2.1.4 innodb和myiasm的索引有什么不同</h4><p>虽有这二者都采用B+树作为索引的底层数据结构，但是innodb的叶子节点中，存储的是表中一行具体的数据；而myiasm的叶子节点中存储的是表中一行数据的地址(当然一个节点中会存储多组值)。</p><h3 id="2-2-物理存储角度"><a href="#2-2-物理存储角度" class="headerlink" title="2.2 物理存储角度"></a>2.2 物理存储角度</h3><p><strong>(1) 聚簇索引</strong></p><p>所谓的聚簇索引其实非常简单,索引的基本组成包括一组key-value。如果key是表中的主键，那么基于该主键构建的索引就是聚簇索引。</p><p>因为聚簇索引的value就是表中某一行正真的数据。所以使用聚簇索引查找某一行的过程如<a href="https://cloud.tencent.com/developer/article/1543335">下图所示</a>：<br><img src="images/Clustered-index.jpeg" alt="Clustered index"></p><p>就跟正常使用AVL树一样，如果我们想要查询id&gt;=18 &amp;&amp; id&lt;40的数据，</p><p>（一）：那么我们首先加载页1，发现id=18的数据存于页3，那么将页3加载至内存。<br>（二）：发现id=18的数据存于页8，那么将页8加载至内存<br>（三）：从页8开始依次加载页8、页9、页10、页11的数据至内存</p><p>至此完成了一次范围查询。</p><p><strong>(2) 非聚簇索引</strong></p><p>与聚簇索引相反，如果使用非主键的列作为索引的key，那么基于该列构建的索引就是非聚簇索引。</p><p>使用非聚簇索引进行查询时<strong>可能</strong>会产生<strong>回表</strong>操作。因为每组key-value中的value不再对应于具体的某一行，而是对应该表的主键。查找到对应的主键后，再使用主键在表中进行查找。</p><h3 id="2-3-逻辑角度"><a href="#2-3-逻辑角度" class="headerlink" title="2.3 逻辑角度"></a>2.3 逻辑角度</h3><ol><li><p>唯一索引(UNIQUE)：所谓的唯一索引，就是列值必须唯一，但是允许NULL值</p></li><li><p>主键索引(PRIMARY KEY)：一种特殊的<strong>唯一索引</strong>，要求索引列值唯一，并且不允许NULL值</p></li><li><p>单列索引(INDEX)：普通的选取某一列作为索引，没有任何限制</p></li><li><p>复合索引(multiple-column index)：选取多列作为索引，遵循最左匹配原则</p></li><li><p>全文索引(FULLTEXT)：一般不使用，用于对全文进行搜索，可与基于B树实现的索引共同使用</p></li></ol><h2 id="3-索引的使用技巧"><a href="#3-索引的使用技巧" class="headerlink" title="3. 索引的使用技巧"></a>3. 索引的使用技巧</h2><p>所谓的最左前缀原则与复合索引的建立息息相关，单列索引比较简单，就是以选定的列作为key来建立索引。那么复合索引选取哪列作为key呢？</p><p>答案是建立符合索引时<strong>排在第一位的列</strong>，这里以复合索引(A、B、C)为例，建立B树索引时就是将<code>A</code>作为key。那么这里又会产生新的问题，那么复合索引中的<code>B</code>和<code>C</code>有什么用？以<a href="https://houbb.github.io/2019/01/02/combine-index">下图为例</a>:<br><img src="http://www.2cto.com/uploadfile/Collfiles/20180217/20180217145611191.png" alt="multiple-column index"></p><p>图片中以(年龄、姓、名)三列建立复合索引，在叶子节点中，当年龄相同时，行按照姓排序，当姓再次相同时，按照名排序。当然我对于原作者这样的理解并没有完全认同，因为我还没找到具体的出处，但是这样理解我认为能够很好地解释最左前缀原则。</p><p>是时候介绍最左前缀原则了，如果建立的复合索引是(A,B,C)。那么在查询时只使用<code>B</code>、<code>C</code>作为条件，那么是无法使用这个复合索引的，因为索引是根据<code>A</code>建立的，都不以<code>A</code>作为条件，怎么使用到这颗B树？同理，查询时只要先查询<code>A</code>，那么就能使用这个复合索引，只是完全使用索引还是部分使用索引的区别。</p><p>最重要的一点，复合索引非叶子节点都是以第一列为key来决定树分支的走向，后面的索引列只会在叶子节点用到，<strong>如果上面这样图片正确</strong>的话。</p><hr><p>update：2021-03-11 15:26:05</p><p>上面的配图果然是错误的，对于复合索引，一个索引节点会包含所有的索引列，例如复合索引（A，B，C）。只有当A相等时才会比较B，B相等时比较C。所以如果直接跳过A，是无法直接使用这个索引的。再偷一张图:<img src="https://user-gold-cdn.xitu.io/2020/2/27/170867eb79a354d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="复合"></p><p>可以看出只有第一行相等时，第二行才保持有序，第二行相等时，第三行才保持有序。</p><p>所以对于一个复合索引来说，一个索引节点是包含复合索引的所有列，而不是单单仅包含复合索引的第一个列。<a href="https://juejin.cn/post/6844904073955639304">参考</a></p><hr><h3 id="3-1-复合索引使用技巧"><a href="#3-1-复合索引使用技巧" class="headerlink" title="3.1 复合索引使用技巧"></a>3.1 复合索引使用技巧</h3><p>有了上面复合索引的理论基础，在使用索引我们还需要使用以下四点：</p><ul><li>精准匹配时<br>在所有的索引列都是精准匹配时，虽然MySQL可以帮我们调整where语句中的条件顺序，以帮助我们能够使用索引，但是建议还是按照复合索引中列的顺序书写where语句中的条件</li><li>匹配某列的前缀字符串时<br>如果条件语句中<code>%</code><strong>不出现</strong>在待匹配字符串的<strong>开头</strong>，那么还是能够使用索引，当然还是要遵循最左前缀原则</li><li>范围查询时<br>范围查询后的列无法使用索引，同时索引只能用于一个范围列</li></ul><p><strong>并且当复合索引有一列为NULL时，该复合索引无效</strong></p><h3 id="3-2-建立索引的基本原则"><a href="#3-2-建立索引的基本原则" class="headerlink" title="3.2 建立索引的基本原则"></a>3.2 建立索引的基本原则</h3><ol><li>索引的字段越短越好</li><li>应该为查询频繁而不是更改频繁的列建立索引</li><li>数据类型越简单越好，尽量避免NULL值，因为为null建立优化比较困难</li><li>尽量选择区分度较高的列作为索引，公式为count(distinct col)/count(*)</li><li>尽量扩展索引，而不是新建索引</li><li>尽量使用自增字段，因为自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂、而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。<br>而如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片</li></ol><h3 id="3-3-索引的缺点"><a href="#3-3-索引的缺点" class="headerlink" title="3.3 索引的缺点"></a>3.3 索引的缺点</h3><ol><li>维护索引需要成本</li><li>记录索引需要空间代价</li></ol><h3 id="3-4-使用索引的地方"><a href="#3-4-使用索引的地方" class="headerlink" title="3.4 使用索引的地方"></a>3.4 使用索引的地方</h3><ol><li>where查询时的条件，使用or时必须两端的字段都具备索引</li><li>order by排序</li><li>join时on的字段</li></ol><h3 id="3-5-索引失效的场景"><a href="#3-5-索引失效的场景" class="headerlink" title="3.5 索引失效的场景"></a>3.5 索引失效的场景</h3><ol><li>查询条件含有函数或表达式时无法使用索引</li><li>where查询时的条件，使用or时只有一个字段具有索引</li><li>where查询条件使用NOT、!=或者&lt;&gt;，只会产生全表扫描</li><li>使用like时，%在最开头，因为索引不知道怎么匹配，这个最容易理解</li></ol><h3 id="3-6-建立索引三种方式"><a href="#3-6-建立索引三种方式" class="headerlink" title="3.6 建立索引三种方式"></a>3.6 建立索引三种方式</h3><ol><li>使用<code>create index</code>创建索引，但是这种方法只能创建普通索引或者唯一索引，不能创建主键索引</li></ol><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> [index]<span class="hljs-operator">|</span>[<span class="hljs-keyword">unique</span> index] <span class="hljs-operator">&lt;</span>index name<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">on</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">table</span> name<span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">column</span> list)<br></code></pre></div></td></tr></table></figure><ol start="2"><li>使用<code>alter table</code>创建索引，这种方式能够创建普通、主键、唯一三种索引。</li></ol><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">#创建主键索引时只能有一个列，或者是联合主键<br>#同理创建<span class="hljs-keyword">UNIQUE</span>时也必须保证所选的列值唯一<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> [<span class="hljs-keyword">table</span> name] <span class="hljs-keyword">add</span> [index] <span class="hljs-operator">|</span>[<span class="hljs-keyword">unique</span> index] <span class="hljs-operator">|</span>[<span class="hljs-keyword">primary</span> key] <span class="hljs-operator">&lt;</span>index name<span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">column</span> list);<br></code></pre></div></td></tr></table></figure><ol start="3"><li>在创建表的时候创建，例如：</li></ol><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user_index2 (<br>id <span class="hljs-type">INT</span> auto_increment <span class="hljs-keyword">PRIMARY</span> KEY,<br>first_name <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">16</span>),<br>last_name <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">16</span>),<br>id_card <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">18</span>),<br>information text,<br>KEY name (first_name, last_name),<br>FULLTEXT KEY (information),<br><span class="hljs-keyword">UNIQUE</span> KEY (id_card)<br>);<br><br></code></pre></div></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1.<a href="https://zhuanlan.zhihu.com/p/79987871">为什么要对一行的大小进行限制</a></p><p>2.<a href="https://www.cnblogs.com/aspirant/p/9214485.html">innodb为什么要采用B+树作为索引的底层数据结构</a></p><p>3.<a href="https://zsr.github.io/2016/08/18/B+%E6%A0%91%E7%B4%A2%E5%BC%95/">B+树索引</a></p><p>4.<a href="https://houbb.github.io/2019/01/02/combine-index">复合索引的基本原理</a></p><p>5.<a href="https://juejin.im/post/6844904162094759949">索引的常见问题</a></p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于centos7安装MySQL</title>
    <link href="/2021-06-03/the-installation-of-mysql-on-linux.html"/>
    <url>/2021-06-03/the-installation-of-mysql-on-linux.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>安装的环境为centos7。并且要在</p><h2 id="Docker下安装MySQL"><a href="#Docker下安装MySQL" class="headerlink" title="Docker下安装MySQL"></a>Docker下安装MySQL</h2><h2 id="centos下安装MySQL"><a href="#centos下安装MySQL" class="headerlink" title="centos下安装MySQL"></a>centos下安装MySQL</h2>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021-06-03/hello-world.html"/>
    <url>/2021-06-03/hello-world.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo server<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo generate<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
