

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="cras">
  <meta name="keywords" content="">
  
  <title>synchronized关键字 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="synchronized关键字">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-06-02 14:53" pubdate>
        2021年6月2日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      149
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">synchronized关键字</h1>
            
            <div class="markdown-body">
              <h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>Java提供的同步机制有许多，<code>synchronized</code>是其中最经常使用、最万能的机制之一。<br>为了学习<code>synchronized</code>的实现原理，进而了解到<code>monior object</code>模式。在java中<code>synchronized</code>辅助实现了该模式。</p>
<h1 id="1-monitor机制的起源与定义"><a href="#1-monitor机制的起源与定义" class="headerlink" title="1. monitor机制的起源与定义"></a>1. monitor机制的起源与定义</h1><p>在早期，编写并发程序时使用的同步原语是信号量semaphore与互斥量mutex。程序员需要手动操作信号量的数值与线程的唤醒与挂起，想想这也是一个十分麻烦的工作。所以提出了更高层次的同步机制<code>monitor</code>封装了信号量的操作。但是值得注意的是<code>monitor</code>并未在操作系统层面实现，而是在软件层次完成了这一机制。</p>
<p>下面描述了<code>monitor</code>机制之所以会出现的一个应用场景（摘自<a target="_blank" rel="noopener" href="https://developer.ibm.com/zh/articles/j-lo-synchronized/">探索Java同步机制</a>）：</p>
<blockquote>
<p>我们在开发并发的应用时，经常需要设计这样的对象，该对象的方法会在多线程的环境下被调用，而这些方法的执行都会改变该对象本身的状态。为了防止竞争条件 (race condition，等同于死锁) 的出现，对于这类对象的设计，需要考虑解决以下问题：<br>1.在任一时间内，只有唯一的公共的成员方法，被唯一的线程所执行。<br>2.对于<strong>对象的调用者</strong>来说，如果总是需要在调用方法之前进行拿锁，而在调用方法之后进行放锁，这将会使并发应用编程变得更加困难。合理的设计是，该对象本身确保任何针对它的方法请求的会同步并且透明的进行，而<strong>不需要调用者的介入</strong>。<br>3.如果一个对象的方法执行过程中，由于某些条件不能满足而阻塞，应该允许其它的客户端线程的方法调用可以访问该对象。</p>
</blockquote>
<p>我们使用 Monitor Object 设计模式来解决这类问题：<strong>将被客户线程并发访问的对象定义为一个 monitor 对象</strong>。客户线程仅仅通过 monitor 对象的同步方法才能使用 monitor 对象定义的服务。为了防止陷入死锁，在任一时刻只能有一个同步方法被执行。每一个monitor对象包含一个 monitor锁，被同步方法用于串行访问对象的行为和状态。此外，同步方法可以根据一个或多个与monitor对象相关的monitor conditions 来决定在何种情况下挂起或恢复他们的执行。</p>
<p>根据上述定义，monitor object模式分为四个组成部分：</p>
<ul>
<li><strong>监视者对象 (Monitor Object):</strong> 负责定义公共的接口方法，这些公共的接口方法会在多线程的环境下被调用执行。</li>
<li><strong>同步方法：</strong> 这些方法是<strong>监视者对象</strong>所定义。为了防止死锁，无论是否同时有多个线程并发调用同步方法，还是监视者对象含有多个同步方法，在任一时间内只有监视者对象的一个同步方法能够被执行（所谓的同步方法也就是我们经常说的临界区）</li>
<li><strong>监视锁 (Monitor Lock):</strong> 每一个监视者对象都会拥有一把监视锁。</li>
<li><strong>监视条件 (Monitor Condition):</strong> 同步方法使用监视锁和监视条件来决定方法是否需要阻塞或重新执行。这里的监视条件可以来自程序本身也可来自monitor object内部。</li>
</ul>
<p>这四个部分完成了两个动作：</p>
<ol>
<li>线程互斥的进入同步方法</li>
<li>完成线程的一些调度动作，例如线程的挂起与唤醒</li>
</ol>
<h1 id="2-Java中的monitor-object模式"><a href="#2-Java中的monitor-object模式" class="headerlink" title="2. Java中的monitor object模式"></a>2. Java中的monitor object模式</h1><p>按照定义，Java下基于<code>synchronized</code>的<code>monitor object</code>模式也应该由四个部分组成,包括监视者对象、监视锁、监视条件、同步方法（临界区）。那么首先来看看我们一般使用<code>synchronized</code>来实现同步的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">demo</span></span>&#123;<br>    Object lock=<span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(lock)&#123;<br>            ...<br>        &#125;<br>        ...<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在我看到的大部分资料中，都认为上述代码中的<code>lock</code>对象是监视者对象，监视条件上面没有展示出来，<code>synchronized</code>后跟的代码块就是同步方法。但是这个同步方法并不是在<code>lock</code>所在的类<code>Object</code>中定义的啊，这如何解释？</p>
<blockquote>
<p>我的理解是这里的“定义”并不是诸如在类<code>A</code>中定义一个方法<code>test</code>之类的定义，而是规定了某些代码作为同步方法，例如规定字母<code>A</code>代表学校，字母<code>B</code>代表公司之类的将两个事物联系到一起的定义，就像在上面代码中规定了<code>&#123;&#125;</code>中的代码作为<code>lock</code>的同步方法</p>
</blockquote>
<p>那么监视锁呢？上面完全没有锁的痕迹。原因是基于<code>monitor object</code>模式的<code>synchronized</code>，监视锁是由监视对象自带的，也被称为<code>intrinsic lock</code>。这个锁在java中是由<code>objectmonitor</code>实现的。</p>
<p>那么监视者对象、监视锁和线程这三者如何产生联系的呢？这就跟Java中对象的内存布局有关了。在jvm中，任何一个对象都会持有一个对象头用来存储一些对象的信息,下图中是一个对象的内存布局，由对象头、对象数据和填充数据组成。</p>
<p><img src="images/object_header.png" srcset="/img/loading.gif" lazyload alt="object memory layout"></p>
<p>其中对象头由<code>markword</code>和<code>klass pointer</code>组成，如果当前对象是数组，那么在<code>klass pointer</code>后面还会追加数组的长度。</p>
<p><code>klass point</code>指针指向它的类元数据，用于判断当前对象属于哪个类(Points to another object (a metaobject) which describes the layout and behavior of the original object.)，<code>markword</code>在32位和64位的机器上略有不同，32bit长的<code>markword</code>布局如下所示（图片出自<a target="_blank" rel="noopener" href="https://deecyn.com/java-synchronized-and-lock.html">Synchronized与锁</a>）：</p>
<p><img src="images/32-MarkWord.png" srcset="/img/loading.gif" lazyload alt="32-markword"></p>
<p>因为空间有限，所以这32bit是复用的，在不同状态下存储的信息是不同的。对于Java1.6之前的<code>synchronized</code>对应于图中的重量级锁状态（其他三种锁状态在Java1.6后出现），该状态下<code>markword</code>存储了指向了重量级锁的指针，这个重量级锁就是<code>monitor object</code>模式中的监视锁。这个重量级锁是在JVM中通过<code>ObjectMonitor</code>类实现的，<strong>而该类本质上又是基于系统的mutex创建的</strong>。其部分代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectMonitor</span> </span>&#123;<br>...<br>  <span class="hljs-comment">//省略一些代码</span><br>  <span class="hljs-function">bool      <span class="hljs-title">try_enter</span> <span class="hljs-params">(TRAPS)</span> </span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span>      <span class="hljs-title">enter</span><span class="hljs-params">(TRAPS)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span>      <span class="hljs-title">exit</span><span class="hljs-params">(bool not_suspended, TRAPS)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span>      <span class="hljs-title">wait</span><span class="hljs-params">(jlong millis, bool interruptable, TRAPS)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span>      <span class="hljs-title">notify</span><span class="hljs-params">(TRAPS)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span>      <span class="hljs-title">notifyAll</span><span class="hljs-params">(TRAPS)</span></span>;<br>  ...<br><br>  <span class="hljs-comment">// WARNING: this must be the very first word of ObjectMonitor</span><br>  <span class="hljs-comment">// This means this class can&#x27;t use any virtual member functions.</span><br><br>  <span class="hljs-keyword">volatile</span> markOop   _header;       <span class="hljs-comment">// displaced object header word - mark</span><br>  <span class="hljs-keyword">void</span>*     <span class="hljs-keyword">volatile</span> _object;       <span class="hljs-comment">// backward object pointer - strong root</span><br><br>  <span class="hljs-comment">// All the following fields must be machine word aligned</span><br>  <span class="hljs-comment">// The VM assumes write ordering wrt these fields, which can be</span><br>  <span class="hljs-comment">// read from other threads.</span><br><br> <span class="hljs-keyword">protected</span>:                         <span class="hljs-comment">// protected for jvmtiRawMonitor</span><br>  <span class="hljs-keyword">void</span> *  <span class="hljs-keyword">volatile</span> _owner;          <span class="hljs-comment">// pointer to owning thread OR BasicLock</span><br>...<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">int</span> OwnerIsThread ;               <span class="hljs-comment">// _owner is (Thread *) vs SP/BasicLock</span><br>...<br> <span class="hljs-keyword">protected</span>:<br>  ObjectWaiter * <span class="hljs-keyword">volatile</span> _EntryList ;     <span class="hljs-comment">// Threads blocked on entry or reentry.</span><br><br> <span class="hljs-keyword">protected</span>:<br>  ObjectWaiter * <span class="hljs-keyword">volatile</span> _WaitSet; <span class="hljs-comment">// LL of threads wait()ing on the monitor</span><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> _WaitSetLock;        <span class="hljs-comment">// protects Wait Queue - simple spinlock</span><br>  <span class="hljs-comment">//省略一些代码</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>_header</code>存储了指向属于<code>monitor object</code>的<code>object header</code>的指针，也就是指向对象头的指针</li>
<li><code>_object</code>存储了指向<code>monitor object</code>的指针</li>
<li><code>_owner</code>存储了指向获得监视锁的线程</li>
<li><code>_EntryList</code>存储了访问同一临界区但是被阻塞的线程集合</li>
<li><code>_WaitList</code>存储了调用<code>wait()</code>方法主动释放锁的线程集合</li>
</ul>
<p>并且<code>ObjectMonitor</code>实现了<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>等方法。</p>
<p>那么监视对象、监视锁、线程的关系是：监视对象内存存储了监视锁，而监视锁中又存储了获得当前锁的线程。并且由于每个对象都会有对象头，而对象头中自带监视锁，所以Java中任何一个对象都可以用作监视对象，所以<code>wait()</code>、<code>notify()</code>等方法在顶级父类<code>Object</code>中实现。</p>
<h1 id="3-Java1-6后的synchronized"><a href="#3-Java1-6后的synchronized" class="headerlink" title="3. Java1.6后的synchronized"></a>3. Java1.6后的synchronized</h1><p>因为Java的线程模型采用的是1:1模型，一个Java线程映射到系统的一个线程，所以Java线程的切换、阻塞、唤醒都需要在内核模式中完成，频繁地切换用户模式与内核模式代价非常高（所以<code>synchronzied</code>被称为重锁）。那么如果同步区非常短，执行同步区的时间比切换内核模式的时间还短，程序的效率就比较低了。所以在Java1.6之后，<code>synchronzied</code>进行了大量优化。对于<code>synchronized</code>，不会再一开始就使用<code>objectMonitor</code>完成同步。而是根据线程对锁的竞争程度不断升级获取锁的难度。</p>
<p>升级后的<code>synchronized</code>分为四个阶段：无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁。这四个状态通过<code>markword</code>中的两位标记来区分，再次搬出32位下的<code>markword</code>结构图：</p>
<p><img src="images/32-MarkWord.png" srcset="/img/loading.gif" lazyload alt="32-markword"></p>
<p>可以看到，偏向锁和无锁状态的锁标志位都是<code>01</code>，他们是通过1bit的标志位来区分。</p>
<p>同时JVM会使用<code>Lock Record</code>在线程中保存锁的一些信息，其组成如下所示：<br><img src="images/lock-record.png" srcset="/img/loading.gif" lazyload alt="lock record"></p>
<p>其中：</p>
<ul>
<li><code>displaced hdr(displaced markword)</code>:一般用来保存<code>monitor object</code>对象头中的<code>markword</code>信息副本</li>
<li><code>owner</code>：指向<code>monitor object</code>的指针。</li>
</ul>
<p>在三种锁状态中，都会使用<code>Lock Record</code>。但是在偏向锁状态中并不会使用<code>Lock Record</code>的<code>displaced markword</code>。</p>
<h2 id="3-1-偏向锁"><a href="#3-1-偏向锁" class="headerlink" title="3.1 偏向锁"></a>3.1 偏向锁</h2><p>偏向锁，将锁的归属权偏向给第一个获得该锁的线程。说人话，就是如果有一个线程threadA第一次成功获得了偏向锁lock，那么lock默认认为以后能够成功获得锁的线程都会是线程A。</p>
<blockquote>
<p>注意：“偏向第一个获得该锁的线程”并不是指在偏向锁的生命周期内只会有一个线程获得锁。<br>比如在最开始，threadA获得了偏向锁lock，此时lock偏向threadA。使用完毕后，threadB请求lock。虽然lock发现此时请求的线程不是threadA，但是由于此时没有发生竞争，所以lock重新设置其偏向的线程为threadB。<strong>而不是说从头到尾lock都只偏向threadA。</strong></p>
</blockquote>
<p> 偏向锁的使用场景是同步区只被同一个线程访问。那么在使用偏向锁时<del>只会在第一次申请时</del>，使用CAS将<code>markword</code>中的线程ID（默认为0，表示匿名偏向状态）替换为当前获得锁的线程ID（当然如果不停地出现新线程成功获取锁的情况，那么每次新线程都会使用CAS替换ThreadID。但是并不是简单的替换而已，JVM同时也会在当前线程的<code>Lock Record</code>列表中插入一个<code>Lock Record</code>结构。</p>
<h3 id="3-1-1-偏向锁的获取流程"><a href="#3-1-1-偏向锁的获取流程" class="headerlink" title="3.1.1 偏向锁的获取流程"></a>3.1.1 偏向锁的获取流程</h3><p>下图中是偏向锁的工作流程：</p>
<p><img src="images/biased-lock.jpg" srcset="/img/loading.gif" lazyload alt="biased-lock"></p>
<p>偏向锁的<strong>开启</strong>需要锁对象头开启以及klass属性头开启才算，单方面无法进入重偏向。其中有几点需要注意，在一个线程每次成功获取偏向锁时，<strong>会在当前线程的<code>Lock Record</code>队列中插入一个<code>Lock Record(LR)</code></strong>,并且设置新插入LR中的owner指向当前监视器对象（monitor object），具体的实现代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//代码分析摘自：Synchronized 源码分析（http://itliusir.com/2019/11-Synchronized/）</span><br><span class="hljs-comment">//源码地址：http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1816</span><br><br>CASE(_monitorenter): &#123;<br>  oop lockee = STACK_OBJECT(-<span class="hljs-number">1</span>);<br>  CHECK_NULL(lockee);<br>  <span class="hljs-comment">// 寻找空闲的锁记录(Lock Record) 空间</span><br>  BasicObjectLock* limit = istate-&gt;monitor_base();<br>  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();<br>  BasicObjectLock* entry = NULL;<br>  <span class="hljs-keyword">while</span> (most_recent != limit ) &#123;<br>  <span class="hljs-keyword">if</span> (most_recent-&gt;obj() == NULL) entry = most_recent;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (most_recent-&gt;obj() == lockee) <span class="hljs-keyword">break</span>;<br>  most_recent++;<br>  &#125;<br>  <span class="hljs-comment">// 存在空闲的Lock Record</span><br>  <span class="hljs-keyword">if</span> (entry != NULL) &#123;<br>    <span class="hljs-comment">/***********************************/</span><br>    <span class="hljs-comment">// 设置Lock Record 的 obj指针(owner)指向锁对象(monitor object)</span><br>    <span class="hljs-comment">//无论是轻量锁还是偏向锁都会设置这个指针</span><br>    <span class="hljs-comment">//这句代码完成了线程每次获取锁时向LR集合中插入新LR的动作</span><br>    entry-&gt;set_obj(lockee);<br>    <span class="hljs-comment">/***********************************/</span><br><br>    <span class="hljs-keyword">int</span> success = <span class="hljs-keyword">false</span>;<br>    uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;<br>    markOop mark = lockee-&gt;mark();<br>    intptr_t hash = (intptr_t) markOopDesc::no_hash;<br><br>    <span class="hljs-comment">/*****************************************************/</span><br>    <span class="hljs-comment">// 如果锁对象的对象头标志是偏向模式,即判断锁标志为101</span><br><br>    <span class="hljs-keyword">if</span> (mark-&gt;has_bias_pattern()) &#123;<br>      uintptr_t thread_ident;<br>      uintptr_t anticipated_bias_locking_value;<br>      thread_ident = (uintptr_t)istate-&gt;thread();<br>      <span class="hljs-comment">// 通过或运算计算anticipated_bias_locking_value</span><br>      anticipated_bias_locking_value =<br>      <span class="hljs-comment">// 将线程id与prototype_header(epoch、分代年龄、偏向模式、锁标志)部分相或</span><br>      (((uintptr_t)lockee-&gt;klass()-&gt;prototype_header() | thread_ident) <br>      <span class="hljs-comment">// 与锁对象的markword异或，相等为0</span><br>          ^ (uintptr_t)mark) <br>      <span class="hljs-comment">// 将上面结果中的分代年龄忽略掉</span><br>      &amp;~((uintptr_t) markOopDesc::age_mask_in_place);<br>      <span class="hljs-comment">// ① 为0代表偏向线程是当前线程 且 对象头的epoch与class的epoch相等，什么也不做</span><br>      <span class="hljs-keyword">if</span>  (anticipated_bias_locking_value == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (PrintBiasedLockingStatistics) &#123;<br>          (* BiasedLocking::biased_lock_entry_count_addr())++;<br>        &#125;<br>        success = <span class="hljs-keyword">true</span>;<br>      &#125;<br>      <span class="hljs-comment">// ② 代表class的prototype_header或对象的mark word中偏向模式是关闭的</span><br>      <span class="hljs-comment">//又因为能走到这已经通过了mark-&gt;has_bias_pattern()判断</span><br>      <span class="hljs-comment">//即对象的mark word中偏向模式是开启的，那也就是说class的prototype_header不是偏向模式。</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// try revoke bias</span><br>        markOop header = lockee-&gt;klass()-&gt;prototype_header();<br>        <span class="hljs-keyword">if</span> (hash != markOopDesc::no_hash) &#123;<br>            header = header-&gt;copy_set_hash(hash);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), mark) == mark) &#123;<br>          <span class="hljs-keyword">if</span> (PrintBiasedLockingStatistics)<br>            (*BiasedLocking::revoked_lock_entry_count_addr())++;<br>        &#125;<br>      &#125;<br><br>        <span class="hljs-comment">/*****************************************************/</span><br>        <span class="hljs-comment">// ③ 锁对象头的 epoch 与 class 的 epoch 不相等，尝试重偏向</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((anticipated_bias_locking_value &amp; epoch_mask_in_place) !=<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// try rebias</span><br>        markOop new_header = (markOop) ( (intptr_t) lockee-&gt;klass()-&gt;prototype_header() | thread_ident);<br>        <span class="hljs-keyword">if</span> (hash != markOopDesc::no_hash) &#123;<br>          new_header = new_header-&gt;copy_set_hash(hash);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Atomic::cmpxchg_ptr((<span class="hljs-keyword">void</span>*)new_header, lockee-&gt;mark_addr(), mark) == mark) &#123;<br>          <span class="hljs-keyword">if</span> (PrintBiasedLockingStatistics)<br>          (* BiasedLocking::rebiased_lock_entry_count_addr())++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 有竞争重偏向失败，调用 monitorenter 锁升级</span><br>          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);<br>        &#125;<br>        success = <span class="hljs-keyword">true</span>;<br>      &#125;<br><br>      <span class="hljs-comment">/*****************************************************/</span><br>      <span class="hljs-comment">// ④ 未偏向任何线程或者偏向的不是当前线程，尝试重新偏向</span><br>      <span class="hljs-keyword">else</span> &#123;<br>        markOop header = (markOop) ((uintptr_t) mark &amp; ((uintptr_t)markOopDesc::biased_lock_mask_in_place |<br>                                                        (uintptr_t)markOopDesc::age_mask_in_place |<br>                                                        epoch_mask_in_place));<br>        <span class="hljs-keyword">if</span> (hash != markOopDesc::no_hash) &#123;<br>            header = header-&gt;copy_set_hash(hash);<br>        &#125;<br>        markOop new_header = (markOop) ((uintptr_t) header | thread_ident);<br>        <span class="hljs-comment">// debugging hint</span><br>        DEBUG_ONLY(entry-&gt;lock()-&gt;set_displaced_header((markOop) (uintptr_t) <span class="hljs-number">0xdeaddead</span>);)<br>        <span class="hljs-comment">// CAS 尝试修改</span><br>        <span class="hljs-keyword">if</span> (Atomic::cmpxchg_ptr((<span class="hljs-keyword">void</span>*)new_header, lockee-&gt;mark_addr(), header) == header) &#123;<br>            <span class="hljs-keyword">if</span> (PrintBiasedLockingStatistics)<br>            (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;<br>        &#125;<br>        <span class="hljs-comment">// 有竞争偏向失败，调用 monitorenter 锁升级</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);<br>        &#125;<br>        success = <span class="hljs-keyword">true</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*****************************************************/</span><br>    <span class="hljs-comment">//能走到这说明当前没有开启偏向模式，而不可能出现偏向的不是当前线程的情况</span><br>    <span class="hljs-comment">//那么就走轻量锁的逻辑</span><br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>      <span class="hljs-comment">// 轻量级锁逻辑 start</span><br>      <span class="hljs-comment">// 构造无锁状态 Mark Word 的 copy(Displaced Mark Word)</span><br><br>      <span class="hljs-comment">/**************************************************/</span><br>      <span class="hljs-comment">//如果是第一次获取轻量锁，那么mark()-&gt;set_unlocked()</span><br>      <span class="hljs-comment">//lockee中的markword期望值最后两位必是01（无锁或偏向锁），所以一定会CAS成功</span><br>      markOop displaced = lockee-&gt;mark()-&gt;set_unlocked();<br>      <span class="hljs-comment">/*************************************************/</span><br>      <br>      <span class="hljs-comment">// 将锁记录空间(Lock Record)指向Displaced Mark Word</span><br>      entry-&gt;lock()-&gt;set_displaced_header(displaced);<br>      <span class="hljs-comment">// 是否禁用偏向锁和轻量级锁</span><br>      bool call_vm = UseHeavyMonitors;<br>      <span class="hljs-keyword">if</span> (call_vm || Atomic::cmpxchg_ptr(entry, lockee-&gt;mark_addr(), displaced) != displaced) &#123;<br>        <span class="hljs-comment">// 判断是不是锁重入，是的话把Displaced Mark Word设置为null来表示重入</span><br>        <span class="hljs-comment">// 置null的原因是因为要记录重入次数，但是mark word大小有限，所以每次重入都在栈帧中新增一个Displaced Mark Word为null的记录</span><br>        <span class="hljs-keyword">if</span> (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced-&gt;clear_lock_bits())) &#123;<br>          entry-&gt;lock()-&gt;set_displaced_header(NULL);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 若禁用则锁升级</span><br>          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);<br>        &#125;<br>      &#125;<br>    &#125;<br>    UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br>  &#125; <br>  <span class="hljs-keyword">else</span> &#123;<br>    istate-&gt;set_msg(more_monitors);<br>    UPDATE_PC_AND_RETURN(<span class="hljs-number">0</span>); <span class="hljs-comment">// Re-execute</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>对偏向锁的获取流程总结如下：</strong></p>
<ol>
<li><p>如果当前线程有空闲的LockRecord（LR），那么设置当前使用的LR的<code>owner</code>指针指向当前<code>monitor object</code>（也就相当于添加了一个新的LR到当前线程中）</p>
</li>
<li><p>检查monitor object是否处于可偏向状态（在开启偏向锁后，markword中的锁标志默认为可偏向状态，如果存储的线程ID为0，则称其为匿名可偏向状态）</p>
</li>
<li><p>如果处于可偏向状态，检查偏向锁偏向的线程是否为当前线程，如果是，那么则执行（6），否则执行（4）</p>
</li>
<li><p>如果偏向模式被关闭，那么执行（8）</p>
</li>
<li><p>对偏向锁设置重偏向，如果成功，那么则执行（7），否则产生竞争，执行（8）</p>
</li>
<li><p>对偏向锁第一次设置偏向线程，如果成功，那么则执行（7），否则产生竞争，执行（8）</p>
</li>
<li><p>执行临界区代码</p>
</li>
<li><p>进行一系列判断，决定是否能够保留偏向锁，或者升级为轻量级锁</p>
</li>
</ol>
<h3 id="3-1-2-偏向锁的撤销流程"><a href="#3-1-2-偏向锁的撤销流程" class="headerlink" title="3.1.2 偏向锁的撤销流程"></a>3.1.2 偏向锁的撤销流程</h3><p>对于偏向锁获取流程中第（8）步的判断，其执行的检查十分复杂，调用链如下：</p>
<p>InterpreterRuntime::monitorenter –&gt; ObjectSynchronizer::fast_enter –&gt; BiasedLocking::revoke_and_rebias –&gt; (safepoint调用)BiasedLocking::revoke_bias</p>
<p>我们着重分析<code>revoke_and_rebias</code>与<code>revoke_bias</code></p>
<p><code>revoke_bias</code>的部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//源码链接:http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/runtime/biasedLocking.cpp#l146</span><br><span class="hljs-keyword">static</span> BiasedLocking::<span class="hljs-function">Condition <span class="hljs-title">revoke_bias</span><span class="hljs-params">(oop obj, bool allow_rebias, bool is_bulk, JavaThread* requesting_thread)</span> </span>&#123;<br>  markOop mark = obj-&gt;mark();<br>  <span class="hljs-comment">// 如果对象不是偏向锁，直接返回 NOT_BIASED</span><br>  <span class="hljs-keyword">if</span> (!mark-&gt;has_bias_pattern()) &#123;<br>    ...<br>    <span class="hljs-keyword">return</span> BiasedLocking::NOT_BIASED;<br>  &#125;<br><br>  uint age = mark-&gt;age();<br>  <span class="hljs-comment">// 构建两个 mark word，一个是匿名偏向模式（101），一个是无锁模式（001）</span><br>  markOop   biased_prototype = markOopDesc::biased_locking_prototype()-&gt;set_age(age);<br>  markOop unbiased_prototype = markOopDesc::prototype()-&gt;set_age(age);<br><br>  ...<br><br>  JavaThread* biased_thread = mark-&gt;biased_locker();<br>  <span class="hljs-keyword">if</span> (biased_thread == NULL) &#123;<br>     <span class="hljs-comment">// 匿名偏向。当调用锁对象原始的 hashcode() 方法会走到这个逻辑</span><br>     <span class="hljs-comment">// 如果不允许重偏向，则将对象的 mark word 设置为无锁模式</span><br>    <span class="hljs-keyword">if</span> (!allow_rebias) &#123;<br>      obj-&gt;set_mark(unbiased_prototype);<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">return</span> BiasedLocking::BIAS_REVOKED;<br>  &#125;<br><br>  <span class="hljs-comment">// 判断偏向线程是否还存活</span><br>  bool thread_is_alive = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-comment">// 如果当前线程就是偏向线程 </span><br>  <span class="hljs-keyword">if</span> (requesting_thread == biased_thread) &#123;<br>    thread_is_alive = <span class="hljs-keyword">true</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-comment">// 遍历当前 jvm 的所有线程，如果能找到，则说明偏向的线程还存活</span><br>    <span class="hljs-keyword">for</span> (JavaThread* cur_thread = Threads::first(); cur_thread != NULL; cur_thread = cur_thread-&gt;next()) &#123;<br>      <span class="hljs-keyword">if</span> (cur_thread == biased_thread) &#123;<br>        thread_is_alive = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 如果偏向的线程已经不存活了</span><br>  <span class="hljs-keyword">if</span> (!thread_is_alive) &#123;<br>    <span class="hljs-comment">// 如果允许重偏向，则将对象 mark word 设置为匿名偏向状态，否则设置为无锁状态</span><br>    <span class="hljs-keyword">if</span> (allow_rebias) &#123;<br>      obj-&gt;set_mark(biased_prototype);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      obj-&gt;set_mark(unbiased_prototype);<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">return</span> BiasedLocking::BIAS_REVOKED;<br>  &#125;<br><br>  <span class="hljs-comment">// 线程还存活则遍历线程栈中所有的 lock record</span><br>  GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(biased_thread);<br>  BasicLock* highest_lock = NULL;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cached_monitor_info-&gt;length(); i++) &#123;<br>    MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);<br>    <span class="hljs-comment">// 如果能找到对应的 lock record，说明偏向所有者正在持有锁</span><br>    <span class="hljs-keyword">if</span> (mon_info-&gt;owner() == obj) &#123;<br>      ...<br>      <span class="hljs-comment">// 升级为轻量级锁，修改栈中所有关联该锁的 lock record</span><br>      <span class="hljs-comment">// 先处理所有锁重入的情况，轻量级锁的 displaced mark word 为 NULL，表示锁重入</span><br>      markOop mark = markOopDesc::encode((BasicLock*) NULL);<br>      highest_lock = mon_info-&gt;lock();<br>      highest_lock-&gt;set_displaced_header(mark);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      ...<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (highest_lock != NULL) &#123; <br>    <span class="hljs-comment">// highest_lock 如果非空，则它是最早关联该锁的 lock record</span><br>    <span class="hljs-comment">// 这个 lock record 是线程彻底退出该锁的最后一个 lock record</span><br>  <br>    <span class="hljs-comment">//关闭偏向模式，这样后面的线程再次抢锁时直接走轻量锁流程</span><br>    highest_lock-&gt;set_displaced_header(unbiased_prototype);<br>    <span class="hljs-comment">//设置锁对象的markword指向displaced header</span><br>    obj-&gt;release_set_mark(markOopDesc::encode(highest_lock));<br>    ...<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 走到这里说明偏向所有者没有正在持有锁</span><br>    ...<br>    <span class="hljs-keyword">if</span> (allow_rebias) &#123;<br>       <span class="hljs-comment">// 设置为匿名偏向状态</span><br>      obj-&gt;set_mark(biased_prototype);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 将 mark word 设置为无锁状态</span><br>      obj-&gt;set_mark(unbiased_prototype);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> BiasedLocking::BIAS_REVOKED;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码中只有一点需要注意：在判断线程是否处于同步状态时，遍历的<code>Lock Record</code>正是线程在获取锁时添加到线程中的只有<code>owner</code>指针的<code>Lock Record</code>。</p>
<ol>
<li><p>所以当偏向锁产生锁的竞争时，JVM会首先JVM中所有存活的线程中是否存在偏向锁偏向的线程。如果存在，执行（2），否则执行（4）</p>
</li>
<li><p>判断偏向锁偏向的线程当前是否处于同步区，这通过遍历目标线程的<code>Lock Record</code>集合实现（为什么能这么做呢？这跟偏向锁的释放有关，见后文）。如果处于同步区，则执行（3），否则执行（4）</p>
</li>
<li><p>将最先关联到线程的<code>Lock Record</code>结构中的<code>Displace markword</code>设置为无锁模式，然后将monitor object对象头的markdown设置为指向<code>Displace markword</code>的指针（处于safepoint，所有线程终止）。至此，完成轻量锁的升级。注意，此时轻量锁的归属权仍然属于原来获得偏向锁的线程</p>
</li>
<li><p>如果开启可重偏向，那么则将monitor object对象的markword设置为匿名偏向模式，否则执行（5）</p>
</li>
<li><p>将将monitor object对象头的markword设置为无锁模式</p>
</li>
</ol>
<h3 id="3-1-3-偏向锁的释放流程"><a href="#3-1-3-偏向锁的释放流程" class="headerlink" title="3.1.3 偏向锁的释放流程"></a>3.1.3 偏向锁的释放流程</h3><p>偏向锁的释放流程比较简单，只是简单地把添加到线程<code>LockRecord</code>列表中的<code>Lock Record</code>删除，当然这里仅是逻辑删除，将<code>Lock Record</code>的owner指针设为null即可。实现源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//代码来自：http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1923</span><br>CASE(_monitorexit): &#123;<br>  oop lockee = STACK_OBJECT(-<span class="hljs-number">1</span>);<br>  CHECK_NULL(lockee);<br>  <span class="hljs-comment">// derefing&#x27;s lockee ought to provoke implicit null check</span><br>  <span class="hljs-comment">// find our monitor slot</span><br>  BasicObjectLock* limit = istate-&gt;monitor_base();<br>  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();<br>  <span class="hljs-comment">// 从低往高遍历栈的Lock Record</span><br>  <span class="hljs-keyword">while</span> (most_recent != limit ) &#123;<br>    <span class="hljs-comment">// 如果Lock Record关联的是该锁对象</span><br>    <span class="hljs-keyword">if</span> ((most_recent)-&gt;obj() == lockee) &#123;<br>      BasicLock* lock = most_recent-&gt;lock();<br>      markOop header = lock-&gt;displaced_header();<br>      <span class="hljs-comment">// 释放Lock Record</span><br>      most_recent-&gt;set_obj(NULL);<br>      <span class="hljs-comment">// 如果是偏向模式，仅仅释放Lock Record就好了。否则要走轻量级锁or重量级锁的释放流程</span><br>      <span class="hljs-keyword">if</span> (!lockee-&gt;mark()-&gt;has_bias_pattern()) &#123;<br>        bool call_vm = UseHeavyMonitors;<br>        <span class="hljs-comment">// header!=NULL说明不是重入，则需要将Displaced Mark Word CAS到对象头的Mark Word</span><br>        <span class="hljs-keyword">if</span> (header != NULL || call_vm) &#123;<br>          <span class="hljs-keyword">if</span> (call_vm || Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), lock) != lock) &#123;<br>            <span class="hljs-comment">// CAS失败或者是重量级锁则会走到这里，先将obj还原，然后调用monitorexit方法</span><br>            most_recent-&gt;set_obj(lockee);<br>            CALL_VM(InterpreterRuntime::monitorexit(THREAD, most_recent), handle_exception);<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">//执行下一条命令</span><br>      UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//处理下一条Lock Record</span><br>    most_recent++;<br>  &#125;<br>  <span class="hljs-comment">// Need to throw illegal monitor state exception</span><br>  CALL_VM(InterpreterRuntime::throw_illegal_monitor_state_exception(THREAD), handle_exception);<br>  ShouldNotReachHere();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于偏向锁，代码从低往高的遍历<code>Lock Record</code>，因为加进去的时候就是按照从高往低加入的。它将当前遍历的<code>Lock Record</code>中的owner指针都置为null，表示当前线程释放了偏向锁。这也就是为什么在偏向锁撤销的过程中，通过查看线程中的<code>Lock Record</code>的owner指针是否指向monitor object就能判断当前持有偏向锁的线程是否处于同步区。因为如果不处于同步区，线程肯定会释放将owner置为null偏向锁。</p>
<h3 id="3-1-4-批量重偏向与撤销"><a href="#3-1-4-批量重偏向与撤销" class="headerlink" title="3.1.4 批量重偏向与撤销"></a>3.1.4 批量重偏向与撤销</h3><p>批量重偏向是指对于大量来自同一个类的锁对象，如果频繁的对这个类的锁对象进行重偏向操作（<strong>在偏向锁模式下抢锁失败才会对重偏向次数计数</strong>），撤销偏向锁的代价也是不能被忽略的。所以如果对一个类的偏向锁撤销次数达到二十次。那么后续使用这种锁的线程都会直接重偏向到目标线程，略去了恢复到匿名偏向状态的过程，这叫<strong>批量重偏向</strong>。</p>
<p>如果在批量重偏向的基础上，还在对这个这个类的锁对象进行重偏向或者升级锁的操作，重偏向达到40次（20+20）。那么以后这个类生成的锁对象就再也不会有作为偏向锁的机会，直接关闭偏向选项（这叫<strong>批量撤销</strong>，后续新生成的锁对象再不也能作为偏向锁），也就是说批量重偏向只有一次机会。但是如果总的重偏向次数在20次到40次之间，那么经过一段时间，该类的重偏向计数会归为0。之后重复上述的操作。</p>
<p>那么上述两个操作是如何实现的呢？其实它们是基于Class对象和锁对象头中<code>markword</code>字段中的<code>epoch</code>属性。</p>
<p>批量重偏向操作开启后，对类C的epcho值加1，以后这个类新生成的对象的mark字段里就是这个epoch值了，同时还要对当前已经获得偏向锁的对象的epoch值加1(通过遍历所有线程中的<code>Lock Record</code>字段中的<code>displace markword</code>并+1)。那么以后有线程再竞争类C的锁对象时，如果有锁对象.epoch!=Class.epoch。说明该锁对象的epoch字段没有更改，也就是说在对epoch+1时，该锁对象没有被使用。竞争这种锁时直接使用CAS替换threadID进行重偏向，，不走撤销这一步。</p>
<blockquote>
<p>所以我个人认为，批量重偏向只适用于那些没有被统一修改epoch字段的锁对象</p>
</blockquote>
<p>具体的函数调用链为：InterpreterRuntime::monitorenter –&gt; ObjectSynchronizer::fast_enter –&gt; BiasedLocking::revoke_and_rebias –&gt;update_heuristics。下面代码片段是对批量偏向和批量撤销前的阈值判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> HeuristicsResult <span class="hljs-title">update_heuristics</span><span class="hljs-params">(oop o, bool allow_rebias)</span> </span>&#123;<br>  markOop mark = o-&gt;mark();<br>  <span class="hljs-comment">// 如果不是偏向模式直接返回</span><br>  <span class="hljs-keyword">if</span> (!mark-&gt;has_bias_pattern()) &#123;<br>    <span class="hljs-keyword">return</span> HR_NOT_BIASED;<br>  &#125;<br> <br>  <span class="hljs-comment">// 获取锁对象的类元数据</span><br>  Klass* k = o-&gt;klass();<br>  <span class="hljs-comment">// 当前时间</span><br>  jlong cur_time = os::javaTimeMillis();<br>  <span class="hljs-comment">// 该类上一次批量重偏向的时间</span><br>  jlong last_bulk_revocation_time = k-&gt;last_biased_lock_bulk_revocation_time();<br>  <span class="hljs-comment">// 该类单个偏向撤销的计数</span><br>  <span class="hljs-keyword">int</span> revocation_count = k-&gt;biased_lock_revocation_count();<br><br>  <span class="hljs-comment">// 按默认参数来说：</span><br>  <span class="hljs-comment">// 如果撤销计数大于等于 20，且小于 40，</span><br>  <span class="hljs-comment">// 且距上次批量撤销的时间大于等于 25 秒，就会重置计数。</span><br>  <span class="hljs-keyword">if</span> ((revocation_count &gt;= BiasedLockingBulkRebiasThreshold) &amp;&amp;<br>      (revocation_count &lt;  BiasedLockingBulkRevokeThreshold) &amp;&amp;<br>      (last_bulk_revocation_time != <span class="hljs-number">0</span>) &amp;&amp;<br>      (cur_time - last_bulk_revocation_time &gt;= BiasedLockingDecayTime)) &#123;<br>    <span class="hljs-comment">// This is the first revocation we&#x27;ve seen in a while of an</span><br>    <span class="hljs-comment">// object of this type since the last time we performed a bulk</span><br>    <span class="hljs-comment">// rebiasing operation. The application is allocating objects in</span><br>    <span class="hljs-comment">// bulk which are biased toward a thread and then handing them</span><br>    <span class="hljs-comment">// off to another thread. We can cope with this allocation</span><br>    <span class="hljs-comment">// pattern via the bulk rebiasing mechanism so we reset the</span><br>    <span class="hljs-comment">// klass&#x27;s revocation count rather than allow it to increase</span><br>    <span class="hljs-comment">// monotonically. If we see the need to perform another bulk</span><br>    <span class="hljs-comment">// rebias operation later, we will, and if subsequently we see</span><br>    <span class="hljs-comment">// many more revocation operations in a short period of time we</span><br>    <span class="hljs-comment">// will completely disable biasing for this type.</span><br>    k-&gt;set_biased_lock_revocation_count(<span class="hljs-number">0</span>);<br>    revocation_count = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (revocation_count &lt;= BiasedLockingBulkRevokeThreshold) &#123;<br>    <span class="hljs-comment">// 自增计数</span><br>    revocation_count = k-&gt;atomic_incr_biased_lock_revocation_count();<br>  &#125;<br>  <span class="hljs-comment">// 此时，如果达到批量撤销阈值，则进行批量撤销。</span><br>  <span class="hljs-keyword">if</span> (revocation_count == BiasedLockingBulkRevokeThreshold) &#123;<br>    <span class="hljs-keyword">return</span> HR_BULK_REVOKE;<br>  &#125;<br>  <span class="hljs-comment">// 此时，如果达到批量重偏向阈值，则进行批量重偏向。</span><br>  <span class="hljs-keyword">if</span> (revocation_count == BiasedLockingBulkRebiasThreshold) &#123;<br>    <span class="hljs-keyword">return</span> HR_BULK_REBIAS;<br>  &#125;<br>  <span class="hljs-comment">// 否则，仅进行单个对象的撤销偏向</span><br>  <span class="hljs-keyword">return</span> HR_SINGLE_REVOKE;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="3-2-轻量锁"><a href="#3-2-轻量锁" class="headerlink" title="3.2 轻量锁"></a>3.2 轻量锁</h2><p>轻量锁是代价比偏向锁稍高的轻量级的锁。那么轻量锁和偏向锁的区别在哪呢？我认为有以下两点：</p>
<ol>
<li><p>偏向锁只需要在第一次请求锁使用CAS设置ThreadID，而轻量锁需要在每次请求锁时都使用CAS修改markword</p>
</li>
<li><p>偏向锁只适用于一个线程进入临界区，轻量锁适用于多个线程交替地进入临界区（交替是指不会发生争夺锁的冲突）</p>
</li>
</ol>
<h3 id="3-2-1-轻量锁的申请流程"><a href="#3-2-1-轻量锁的申请流程" class="headerlink" title="3.2.1 轻量锁的申请流程"></a>3.2.1 轻量锁的申请流程</h3><p>轻量锁的获取流程比较简单，假设现在有线程A，监视锁lock。</p>
<p>JVM会在线程A的<code>Lock Record</code>列表中添加一个<code>Lock Record</code>结构。并将其<code>displaced hdr</code>设置为<code>markword</code>无锁状态时的内容。同时JVM会将lock对象的<code>markword</code>修改为指向刚添加的<code>Lock Record</code>的指针。</p>
<p><strong>并且并且并且，lock的<code>markword</code>最后两位为<code>00</code>，表示轻量锁状态。</strong> 结构如下所示：</p>
<p><img src="images/light-lock.png" srcset="/img/loading.gif" lazyload alt="light-lock"></p>
<p>在具体的JVM中，轻量锁的来源有两处：</p>
<ol>
<li>通过偏向锁升级而来</li>
<li>关闭偏向模式</li>
</ol>
<p>这二者的实现方式和偏向锁的获取都在同一个源文件中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//代码分析摘自：Synchronized 源码分析（http://itliusir.com/2019/11-Synchronized/）</span><br><span class="hljs-comment">//源码地址：http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1816</span><br><br>CASE(_monitorenter): &#123;<br>  oop lockee = STACK_OBJECT(-<span class="hljs-number">1</span>);<br>  CHECK_NULL(lockee);<br>  <span class="hljs-comment">// 寻找空闲的锁记录(Lock Record) 空间</span><br>  BasicObjectLock* limit = istate-&gt;monitor_base();<br>  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();<br>  BasicObjectLock* entry = NULL;<br>  <span class="hljs-keyword">while</span> (most_recent != limit ) &#123;<br>    <span class="hljs-keyword">if</span> (most_recent-&gt;obj() == NULL) entry = most_recent;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (most_recent-&gt;obj() == lockee) <span class="hljs-keyword">break</span>;<br>    most_recent++;<br>  &#125;<br>  <span class="hljs-comment">// 存在空闲的Lock Record</span><br>  <span class="hljs-keyword">if</span> (entry != NULL) &#123;<br>    <span class="hljs-comment">/***********************************/</span><br>    <span class="hljs-comment">// 设置Lock Record 的 obj指针(owner)指向锁对象(monitor object)</span><br>    <span class="hljs-comment">//这句代码完成了线程每次获取锁时向LR集合中插入新LR的动作</span><br>    entry-&gt;set_obj(lockee);<br>    <span class="hljs-comment">/***********************************/</span><br><br>    <span class="hljs-keyword">int</span> success = <span class="hljs-keyword">false</span>;<br>    uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;<br>    markOop mark = lockee-&gt;mark();<br>    intptr_t hash = (intptr_t) markOopDesc::no_hash;<br><br>    <span class="hljs-comment">/*****************************************************/</span><br>    <span class="hljs-comment">// 如果锁对象的对象头标志是偏向模式(1 01)</span><br>    <span class="hljs-keyword">if</span> (mark-&gt;has_bias_pattern()) &#123;<br>      uintptr_t thread_ident;<br>      uintptr_t anticipated_bias_locking_value;<br>      thread_ident = (uintptr_t)istate-&gt;thread();<br>      <span class="hljs-comment">// 通过位运算计算anticipated_bias_locking_value</span><br>      anticipated_bias_locking_value =<br>        <span class="hljs-comment">// 将线程id与prototype_header(epoch、分代年龄、偏向模式、锁标志)部分相或</span><br>        (((uintptr_t)lockee-&gt;klass()-&gt;prototype_header() | thread_ident) <br>        <span class="hljs-comment">// 与锁对象的markword异或，相等为0</span><br>         ^ (uintptr_t)mark) <br>        <span class="hljs-comment">// 将上面结果中的分代年龄忽略掉</span><br>        &amp;~((uintptr_t) markOopDesc::age_mask_in_place);<br>        <span class="hljs-comment">// ① 为0代表偏向线程是当前线程 且 对象头的epoch与class的epoch相等，什么也不做</span><br>        ...<br>      <span class="hljs-comment">// ② 偏向模式关闭，则尝试撤销(0 01)</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// try revoke bias</span><br>        markOop header = lockee-&gt;klass()-&gt;prototype_header();<br>        <span class="hljs-keyword">if</span> (hash != markOopDesc::no_hash) &#123;<br>          header = header-&gt;copy_set_hash(hash);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), mark) == mark) &#123;<br>          <span class="hljs-keyword">if</span> (PrintBiasedLockingStatistics)<br>            (*BiasedLocking::revoked_lock_entry_count_addr())++;<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-comment">/*****************************************************/</span><br>      <span class="hljs-comment">// ③ 锁对象头的 epoch 与 class 的 epoch 不相等，尝试重偏向</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((anticipated_bias_locking_value &amp; epoch_mask_in_place) !=<span class="hljs-number">0</span>) &#123;<br>        ...<br>        <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 有竞争重偏向失败，调用 monitorenter 锁升级</span><br>          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);<br>        &#125;<br>        success = <span class="hljs-keyword">true</span>;<br>      &#125;<br><br>      <span class="hljs-comment">/*****************************************************/</span><br>      <span class="hljs-comment">// ④ 未偏向任何线程，尝试偏向</span><br>      <span class="hljs-keyword">else</span> &#123;<br>        markOop header = (markOop) ((uintptr_t) mark &amp; ((uintptr_t)markOopDesc::biased_lock_mask_in_place |<br>                                                        (uintptr_t)markOopDesc::age_mask_in_place |<br>                                                        epoch_mask_in_place));<br>        ...<br>        <span class="hljs-comment">// 有竞争偏向失败，调用 monitorenter 锁升级</span><br>        <span class="hljs-keyword">else</span> &#123;<br>          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);<br>        &#125;<br>        success = <span class="hljs-keyword">true</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*****************************************************/</span><br>    <span class="hljs-comment">// 走到这里说明没有开启偏向锁等原因</span><br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>      <span class="hljs-comment">// 轻量级锁逻辑 start</span><br>      <span class="hljs-comment">// 构造无锁状态 Mark Word 的 copy(Displaced Mark Word)</span><br>      <span class="hljs-comment">// 注意displaced markword是无锁状态!无锁状态!无锁状态！</span><br>      markOop displaced = lockee-&gt;mark()-&gt;set_unlocked();<br>      <span class="hljs-comment">// 将锁记录空间(Lock Record)的Displaced Mark Word设为无锁状态markword</span><br>      entry-&gt;lock()-&gt;set_displaced_header(displaced);<br>      <span class="hljs-comment">// 是否禁用偏向锁和轻量级锁</span><br>      bool call_vm = UseHeavyMonitors;<br>      <span class="hljs-comment">// exchange ,addr,compare</span><br>      <span class="hljs-comment">//return compare value</span><br>      <span class="hljs-keyword">if</span> (call_vm || Atomic::cmpxchg_ptr(entry, lockee-&gt;mark_addr(), displaced) != displaced) &#123;<br>        <span class="hljs-comment">// 判断是不是锁重入，是的话把Displaced Mark Word设置为null来表示重入</span><br>        <span class="hljs-comment">// 置null的原因是因为要记录重入次数，但是mark word大小有限，所以每次重入都在栈帧中新增一个Displaced Mark Word为null的记录</span><br>        <span class="hljs-keyword">if</span> (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced-&gt;clear_lock_bits())) &#123;<br>          entry-&gt;lock()-&gt;set_displaced_header(NULL);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 若禁用则锁升级</span><br>          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);<br>        &#125;<br>      &#125;<br>    &#125;<br>    UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    istate-&gt;set_msg(more_monitors);<br>    UPDATE_PC_AND_RETURN(<span class="hljs-number">0</span>); <span class="hljs-comment">// Re-execute</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>通过上面的源码我们能够知道：</p>
<p>如果没有开启偏向模式，JVM会初次构造轻量级锁，也就是执行<code>if (!success)&#123;...&#125;</code>后的内容第一次申请轻量锁，如果此时的请求是重入，那么则会在当前线程的<code>Lock Record</code>列表中插入一个新的<code>Lock Record</code>，其中<code>displaced hdr</code>指向null，这么做的原因是因为要记录重入次数。如果此时还发生锁竞争，那么则会调用<code>CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception)</code>升级成重量锁。</p>
<p>如果偏向锁偏向失败，会调用<code>CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception)</code>决定要不要升级成轻量锁。这部分的代码在偏向锁的撤销中都有提及过。</p>
<hr>
<p><strong>存在的问题：</strong></p>
<p><strong>Q1：在代码中，到底在什么时候将lock对象的<code>markword</code>最后两位设置为<code>00</code>？</strong></p>
<p>我阅读了很久的源码，都没有发现设置的地方，网上有人说是通过<a target="_blank" rel="noopener" href="https://github.com/farmerjohngit/myblog/issues/14">字节填充对齐来解决的</a>。然而我不是很懂。</p>
<p>也就是说：执行<code>Atomic::cmpxchg_ptr(entry, lockee-&gt;mark_addr(), displaced)</code>时，entry是一个四字节的指针，由于对齐操作，entry的第31~32bit一定为<code>00</code>，如果CAS成功，那么锁对象头的<code>markword</code>就指向了栈中的<code>Lock Record</code>。</p>
<p><strong>Q2：在轻量锁状态时，CAS算法如何保证锁互斥的获取？</strong></p>
<p>首先，我们看看核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//code1</span><br>markOop displaced = lockee-&gt;mark()-&gt;set_unlocked();<br><span class="hljs-comment">//</span><br>entry-&gt;lock()-&gt;set_displaced_header(displaced);<br><span class="hljs-comment">// 是否禁用偏向锁和轻量级锁</span><br>bool call_vm = UseHeavyMonitors;<br><span class="hljs-comment">//code2</span><br><span class="hljs-keyword">if</span> (call_vm || Atomic::cmpxchg_ptr(entry, lockee-&gt;mark_addr(), displaced) != displaced) &#123;...&#125;<br></code></pre></td></tr></table></figure>

<p>CAS算法需要预期的值和目标修改值。预期值就是上述代码中的<code>displaced</code>。而这个<code>displaced</code>是如何构造出来的呢？见如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> </span>&#123; <br>    locked_value             = <span class="hljs-number">0</span>,<br>    unlocked_value           = <span class="hljs-number">1</span>,<br>    monitor_value            = <span class="hljs-number">2</span>,<br>    marked_value             = <span class="hljs-number">3</span>,<br>    biased_lock_pattern      = <span class="hljs-number">5</span><br>&#125;;<br><span class="hljs-function">markOop <span class="hljs-title">set_unlocked</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> markOop(value() | unlocked_value);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>lock</code>就是当前的锁对象，调用<code>set_unlocked()</code>后，会将当前对象头的<code>markword</code>(上述代码中的<code>value()</code>)与<code>unlocked_value</code>进行<strong>或</strong>操作。这样就能构造出一个无锁状态的<code>markword</code>（也就是最后两位为<code>01</code>）。所以CAS算法的旧预期值displaced<strong>肯定</strong>是一个无锁状态的<code>markword</code>，这跟锁对象的锁状态没有关系。</p>
<p>假设现在有threadA，<strong>第一次</strong>请求轻量锁时，锁对象头的<code>markword</code>第31~32位一定是<code>01</code>（因为如果走到这个CAS，锁对象头的markword一定是无锁状态）。<code>lockee-&gt;mark()</code>(CAS的真实值)与<code>displaced</code>(CAS的预期值)1~30位bit一定是相同的，因为<code>displaced</code>只改变了<code>lockee-&gt;mark()</code>的第32位bit。所以CAS算法的预期值和实际值符合，threadA成功获取锁。</p>
<p>在threadA执行同步区的过程中，如果有threadB请求轻量锁，因为<code>lockee-&gt;mark()</code>最后两位一定为<code>00</code>(详情见Q1)，但是我们构建的预期值<code>displaced</code>最后两位一定为<code>01</code>。所以CAS算法调用失败，保证了轻量锁的互斥获取。</p>
<hr>
<h3 id="3-2-2-轻量锁的释放流程"><a href="#3-2-2-轻量锁的释放流程" class="headerlink" title="3.2.2 轻量锁的释放流程"></a>3.2.2 轻量锁的释放流程</h3><p>轻量锁的释放只需要使用CAS算法将请求锁时，添加的<code>Lock Record</code>的<code>displaced markword</code>复制到锁对象头的<code>markword</code>即可，复制完成后，锁对象目前的状态是<code>001</code>，无锁状态。如果失败，则说明有锁竞争，会调用重锁的退出方法<code>monitorexit</code>。</p>
<p>轻量锁的释放代码和偏向锁的释放代码糅合在一起，详情见如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">CASE(_monitorexit): &#123;<br>  oop lockee = STACK_OBJECT(-<span class="hljs-number">1</span>);<br>  CHECK_NULL(lockee);<br>  <span class="hljs-comment">// derefing&#x27;s lockee ought to provoke implicit null check</span><br>  <span class="hljs-comment">// find our monitor slot</span><br>  BasicObjectLock* limit = istate-&gt;monitor_base();<br>  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();<br>  <span class="hljs-comment">// 从低往高遍历栈的Lock Record</span><br>  <span class="hljs-keyword">while</span> (most_recent != limit ) &#123;<br>    <span class="hljs-comment">// 如果Lock Record关联的是该锁对象</span><br>    <span class="hljs-keyword">if</span> ((most_recent)-&gt;obj() == lockee) &#123;<br>      BasicLock* lock = most_recent-&gt;lock();<br>      markOop header = lock-&gt;displaced_header();<br>      <span class="hljs-comment">// 释放Lock Record</span><br>      most_recent-&gt;set_obj(NULL);<br>      <span class="hljs-comment">// 如果是偏向模式，仅仅释放Lock Record就好了。否则要走轻量级锁or重量级锁的释放流程</span><br>      <span class="hljs-keyword">if</span> (!lockee-&gt;mark()-&gt;has_bias_pattern()) &#123;<br>        bool call_vm = UseHeavyMonitors;<br>        <span class="hljs-comment">// header!=NULL说明不是重入，则需要将Displaced Mark Word CAS到对象头的Mark Word</span><br>        <span class="hljs-keyword">if</span> (header != NULL || call_vm) &#123;<br>          <span class="hljs-keyword">if</span> (call_vm || Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), lock) != lock) &#123;<br>            <span class="hljs-comment">// CAS失败或者是重量级锁则会走到这里，先将obj还原，然后调用monitorexit方法</span><br>            most_recent-&gt;set_obj(lockee);<br>            CALL_VM(InterpreterRuntime::monitorexit(THREAD, most_recent), handle_exception);<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">//执行下一条命令</span><br>      UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//处理下一条Lock Record</span><br>    most_recent++;<br>  &#125;<br>  <span class="hljs-comment">// Need to throw illegal monitor state exception</span><br>  CALL_VM(InterpreterRuntime::throw_illegal_monitor_state_exception(THREAD), handle_exception);<br>  ShouldNotReachHere();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-3-重量锁"><a href="#3-3-重量锁" class="headerlink" title="3.3 重量锁"></a>3.3 重量锁</h2><p>重量级锁就是使用<code>objectmonitor</code>（使用操作系统的mutex）完成同步的工具。</p>
<h3 id="3-3-1-重量锁的获取流程"><a href="#3-3-1-重量锁的获取流程" class="headerlink" title="3.3.1 重量锁的获取流程"></a>3.3.1 重量锁的获取流程</h3><p>获取重量锁的地方有两个：</p>
<ol>
<li>如果在<code>fast_enter</code>中偏向锁升级轻量级锁失败，那么会调用<code>slow_enter</code></li>
<li>在不开启偏向模式的情况下，直接调用<code>slow_enter</code>。在<code>slow_enter</code>中先尝试是否能够使用轻量级锁，如果失败，则直接调用<code>inflate</code>方法直接膨胀为重量级锁</li>
</ol>
<p>我们知道，重锁是需要一个<code>objectmonitor</code>维护互斥锁的。这个对象就是<code>inflate</code>中构建的。<code>inflate</code>主要流程如下：</p>
<ol>
<li>如果锁已经达到重量级状态，则直接返回</li>
<li>如果是轻量级锁状态，那么则需要膨胀，包括设置一些record</li>
<li>如果锁是膨胀中状态，那么则通过<strong>自旋</strong>操作完成忙等待</li>
<li>如果是无锁状态，那么则需要进行膨胀</li>
</ol>
<p>锁膨胀完成后，那么各个线程则尝试通过调用<code>enter</code>方法获取锁进入临界区，分析如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> ATTR ObjectMonitor::enter(TRAPS) &#123;<br>   <br>  Thread * <span class="hljs-keyword">const</span> Self = THREAD ;<br>  <span class="hljs-keyword">void</span> * cur ;<br>  <span class="hljs-comment">// owner为null代表无锁状态，如果能CAS设置成功，则当前线程直接获得锁</span><br>  cur = Atomic::cmpxchg_ptr (Self, &amp;_owner, NULL) ;<br>  <span class="hljs-keyword">if</span> (cur == NULL) &#123;<br>     ...<br>     <span class="hljs-keyword">return</span> ;<br>  &#125;<br>  <span class="hljs-comment">// 如果是重入的情况</span><br>  <span class="hljs-keyword">if</span> (cur == Self) &#123;<br>     <span class="hljs-comment">// TODO-<span class="hljs-doctag">FIXME:</span> check for integer overflow!  BUGID 6557169.</span><br>     _recursions ++ ;<br>     <span class="hljs-keyword">return</span> ;<br>  &#125;<br>  <span class="hljs-comment">// 当前线程是之前持有轻量级锁的线程。由轻量级锁膨胀且第一次调用enter方法，那cur是指向Lock Record的指针</span><br>  <span class="hljs-keyword">if</span> (Self-&gt;is_lock_owned ((address)cur)) &#123;<br>    <span class="hljs-keyword">assert</span> (_recursions == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;internal state error&quot;</span>);<br>    <span class="hljs-comment">// 重入计数重置为1</span><br>    _recursions = <span class="hljs-number">1</span> ;<br>    <span class="hljs-comment">// 设置owner字段为当前线程（之前owner是指向Lock Record的指针）</span><br>    _owner = Self ;<br>    OwnerIsThread = <span class="hljs-number">1</span> ;<br>    <span class="hljs-keyword">return</span> ;<br>  &#125;<br><br>  ...<br><br>  <span class="hljs-comment">// 在调用系统的同步操作之前，先尝试自旋获得锁</span><br>  <span class="hljs-keyword">if</span> (Knob_SpinEarly &amp;&amp; TrySpin (Self) &gt; <span class="hljs-number">0</span>) &#123;<br>     ...<br>     <span class="hljs-comment">//自旋的过程中获得了锁，则直接返回</span><br>     Self-&gt;_Stalled = <span class="hljs-number">0</span> ;<br>     <span class="hljs-keyword">return</span> ;<br>  &#125;<br><br>  ...<br><br>  &#123; <br>    ...<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      jt-&gt;set_suspend_equivalent();<br>      <span class="hljs-comment">// 在该方法中调用系统同步操作</span><br>      EnterI (THREAD) ;<br>      ...<br>    &#125;<br>    Self-&gt;set_current_pending_monitor(NULL);<br>    <br>  &#125;<br><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<code>enter()</code>中，只能完成三种获取锁的动作，包括无锁状态获取锁（即锁没有被占有）、通过轻量级锁升级来获取锁、重入锁这三种情况。超出这三种情况，需要调用<code>enterI()</code>完成系统同步的操作。当然在调用系统同步操作之前，会尝试自旋获取锁。</p>
<p>在前面说过，监视锁<code>objectmonitor</code>维护了两个队列<code>_EntryList</code>、<code>_WaitList</code>用来保存被阻塞等待锁的线程和主动调用<code>wait()</code>等待锁的线程。其实在源码中， <code>objectmonitor</code> 还维护了一个队列<code>_cxq</code>,用来给<code>_EntryList</code>提供被阻塞的线程。这三者的关系如下图所示：</p>
<p><img src="images/synchronized.png" srcset="/img/loading.gif" lazyload alt="syn"></p>
<p>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到cxq队列的队首，然后调用park函数挂起当前线程。在linux系统上，park函数底层调用的是gclib库的pthread_cond_wait。</p>
<p>当线程释放锁时，会从cxq或EntryList中挑选一个线程唤醒，被选中的线程叫做Heir presumptive即假定继承人（即图中的ready thread），假定继承人被唤醒后会尝试获得锁，但synchronized是非公平的，所以假定继承人不一定能获得锁（这也是它叫”假定”继承人的原因）。</p>
<p>如果线程获得锁后调用Object.wait方法，则会将线程加入到WaitSet中，当被Object#notify唤醒后，会将线程从WaitSet移动到cxq或EntryList中去。需要注意的是，<strong>当调用一个锁对象的wait或notify方法时，如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁。</strong> 源码分析如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> ATTR ObjectMonitor::EnterI (TRAPS) &#123;<br>    Thread * Self = THREAD ;<br>    ...<br>    <span class="hljs-comment">// 尝试获得锁</span><br>    <span class="hljs-keyword">if</span> (TryLock (Self) &gt; <span class="hljs-number">0</span>) &#123;<br>        ...<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    DeferredInitialize () ;<br> <br>	<span class="hljs-comment">// 自旋</span><br>    <span class="hljs-keyword">if</span> (TrySpin (Self) &gt; <span class="hljs-number">0</span>) &#123;<br>        ...<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <br>    ...<br><br>    <span class="hljs-comment">// 将线程封装成node节点中</span><br>    <span class="hljs-function">ObjectWaiter <span class="hljs-title">node</span><span class="hljs-params">(Self)</span> </span>;<br>    Self-&gt;_ParkEvent-&gt;reset() ;<br>    node._prev   = (ObjectWaiter *) <span class="hljs-number">0xBAD</span> ;<br>    node.TState  = ObjectWaiter::TS_CXQ ;<br><br>    <span class="hljs-comment">// 将node节点插入到_cxq队列的头部，cxq是一个单向链表</span><br>    ObjectWaiter * nxt ;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        node._next = nxt = _cxq ;<br>        <span class="hljs-keyword">if</span> (Atomic::cmpxchg_ptr (&amp;node, &amp;_cxq, nxt) == nxt) <span class="hljs-keyword">break</span> ;<br><br>        <span class="hljs-comment">// CAS失败的话 再尝试获得锁，这样可以降低插入到_cxq队列的频率</span><br>        <span class="hljs-keyword">if</span> (TryLock (Self) &gt; <span class="hljs-number">0</span>) &#123;<br>            ...<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br><br>	<span class="hljs-comment">// SyncFlags默认为0，如果没有其他等待的线程，则将_Responsible设置为自己</span><br>    <span class="hljs-keyword">if</span> ((SyncFlags &amp; <span class="hljs-number">16</span>) == <span class="hljs-number">0</span> &amp;&amp; nxt == NULL &amp;&amp; _EntryList == NULL) &#123;<br>        Atomic::cmpxchg_ptr (Self, &amp;_Responsible, NULL) ;<br>    &#125;<br><br><br>    TEVENT (Inflated enter - Contention) ;<br>    <span class="hljs-keyword">int</span> nWakeups = <span class="hljs-number">0</span> ;<br>    <span class="hljs-keyword">int</span> RecheckInterval = <span class="hljs-number">1</span> ;<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br><br>        <span class="hljs-keyword">if</span> (TryLock (Self) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span> ;<br>        <span class="hljs-keyword">assert</span> (_owner != Self, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br><br>        ...<br><br>        <span class="hljs-comment">// park self</span><br>        <span class="hljs-keyword">if</span> (_Responsible == Self || (SyncFlags &amp; <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-comment">// 当前线程是_Responsible时，调用的是带时间参数的park</span><br>            TEVENT (Inflated enter - park TIMED) ;<br>            Self-&gt;_ParkEvent-&gt;park ((jlong) RecheckInterval) ;<br>            <span class="hljs-comment">// Increase the RecheckInterval, but clamp the value.</span><br>            RecheckInterval *= <span class="hljs-number">8</span> ;<br>            <span class="hljs-keyword">if</span> (RecheckInterval &gt; <span class="hljs-number">1000</span>) RecheckInterval = <span class="hljs-number">1000</span> ;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//否则直接调用park挂起当前线程</span><br>            TEVENT (Inflated enter - park UNTIMED) ;<br>            Self-&gt;_ParkEvent-&gt;park() ;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (TryLock(Self) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span> ;<br><br>        ...<br>        <br>        <span class="hljs-keyword">if</span> ((Knob_SpinAfterFutile &amp; <span class="hljs-number">1</span>) &amp;&amp; TrySpin (Self) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span> ;<br><br>       	...<br>        <span class="hljs-comment">// 在释放锁时，_succ会被设置为EntryList或_cxq中的一个线程</span><br>        <span class="hljs-keyword">if</span> (_succ == Self) _succ = NULL ;<br><br>        <span class="hljs-comment">// Invariant: after clearing _succ a thread *must* retry _owner before parking.</span><br>        OrderAccess::fence() ;<br>    &#125;<br><br>   <span class="hljs-comment">// 走到这里说明已经获得锁了</span><br><br>    <span class="hljs-keyword">assert</span> (_owner == Self      , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>    <span class="hljs-keyword">assert</span> (object() != NULL    , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>  <br>	<span class="hljs-comment">// 将当前线程的node从cxq或EntryList中移除</span><br>    UnlinkAfterAcquire (Self, &amp;node) ;<br>    <span class="hljs-keyword">if</span> (_succ == Self) _succ = NULL ;<br>	<span class="hljs-keyword">if</span> (_Responsible == Self) &#123;<br>        _Responsible = NULL ;<br>        OrderAccess::fence();<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>主要步骤有3步：</p>
<ol>
<li>将当前线程插入到cxq队列的队首</li>
<li>然后park当前线程</li>
<li>当被唤醒后再尝试获得锁</li>
</ol>
<p>这里需要特别说明的是_Responsible和_succ两个字段的作用：</p>
<p>当竞争发生时，选取一个线程作为_Responsible，_Responsible线程调用的是有时间限制的park方法，其目的是防止出现搁浅现象。</p>
<p>_succ线程是在线程释放锁是被设置，其含义是Heir presumptive，也就是我们上面说的假定继承人。</p>
<h3 id="3-3-2-重量锁的释放流程"><a href="#3-3-2-重量锁的释放流程" class="headerlink" title="3.3.2 重量锁的释放流程"></a>3.3.2 重量锁的释放流程</h3><p>重量级锁释放的代码在ObjectMonitor::exit,在释放锁时，JVM需要提供下一个需要准备获取锁的线程（如果有线程需要的话），代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> ATTR ObjectMonitor::exit(bool not_suspended, TRAPS) &#123;<br>   Thread * Self = THREAD ;<br>   <span class="hljs-comment">// 如果_owner不是当前线程</span><br>   <span class="hljs-keyword">if</span> (THREAD != _owner) &#123;<br>     <span class="hljs-comment">// 当前线程是之前持有轻量级锁的线程。由轻量级锁膨胀后还没调用过enter方法，_owner会是指向Lock Record的指针。</span><br>     <span class="hljs-keyword">if</span> (THREAD-&gt;is_lock_owned((address) _owner)) &#123;<br>       <span class="hljs-keyword">assert</span> (_recursions == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>       _owner = THREAD ;<br>       _recursions = <span class="hljs-number">0</span> ;<br>       OwnerIsThread = <span class="hljs-number">1</span> ;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-comment">// 异常情况:当前不是持有锁的线程</span><br>       TEVENT (Exit - Throw IMSX) ;<br>       <span class="hljs-keyword">assert</span>(<span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;Non-balanced monitor enter/exit!&quot;</span>);<br>       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">false</span>) &#123;<br>          THROW(vmSymbols::java_lang_IllegalMonitorStateException());<br>       &#125;<br>       <span class="hljs-keyword">return</span>;<br>     &#125;<br>   &#125;<br>   <span class="hljs-comment">// 重入计数器还不为0，则计数器-1后返回</span><br>   <span class="hljs-keyword">if</span> (_recursions != <span class="hljs-number">0</span>) &#123;<br>     _recursions--;        <span class="hljs-comment">// this is simple recursive enter</span><br>     TEVENT (Inflated exit - recursive) ;<br>     <span class="hljs-keyword">return</span> ;<br>   &#125;<br><br>   <span class="hljs-comment">// _Responsible设置为null</span><br>   <span class="hljs-keyword">if</span> ((SyncFlags &amp; <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>) &#123;<br>      _Responsible = NULL ;<br>   &#125;<br><br>   ...<br><br>   <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-keyword">assert</span> (THREAD == _owner, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br><br>      <span class="hljs-comment">// Knob_ExitPolicy默认为0</span><br>      <span class="hljs-keyword">if</span> (Knob_ExitPolicy == <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-comment">// code 1：先释放锁，这时如果有其他线程进入同步块则能获得锁</span><br>         OrderAccess::release_store_ptr (&amp;_owner, NULL) ;   <span class="hljs-comment">// drop the lock</span><br>         OrderAccess::storeload() ;                         <span class="hljs-comment">// See if we need to wake a successor</span><br>         <span class="hljs-comment">// code 2：如果没有等待的线程或已经有假定继承人</span><br>         <span class="hljs-comment">//有假定继承人表示可能会选择假定继承人作为唤醒对象，以便争夺锁</span><br>         <span class="hljs-keyword">if</span> ((intptr_t(_EntryList)|intptr_t(_cxq)) == <span class="hljs-number">0</span> || _succ != NULL) &#123;<br>            TEVENT (Inflated exit - simple egress) ;<br>            <span class="hljs-keyword">return</span> ;<br>         &#125;<br>         TEVENT (Inflated exit - complex egress) ;<br><br>         <span class="hljs-comment">// code 3：要执行之后的操作需要重新获得锁，即设置_owner为当前线程</span><br>         <span class="hljs-keyword">if</span> (Atomic::cmpxchg_ptr (THREAD, &amp;_owner, NULL) != NULL) &#123;<br>            <span class="hljs-keyword">return</span> ;<br>         &#125;<br>         TEVENT (Exit - Reacquired) ;<br>      &#125; <br>      ...<br><br>      ObjectWaiter * w = NULL ;<br>      <span class="hljs-comment">// code 4：根据QMode的不同会有不同的唤醒策略，默认为0</span><br>      <span class="hljs-keyword">int</span> QMode = Knob_QMode ;<br>      <span class="hljs-keyword">if</span> (QMode == <span class="hljs-number">2</span> &amp;&amp; _cxq != NULL) &#123;<br>          <span class="hljs-comment">// QMode == 2 : cxq中的线程有更高优先级，直接唤醒cxq的队首线程</span><br>          w = _cxq ;<br>          <span class="hljs-keyword">assert</span> (w != NULL, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>          <span class="hljs-keyword">assert</span> (w-&gt;TState == ObjectWaiter::TS_CXQ, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>          ExitEpilog (Self, w) ;<br>          <span class="hljs-keyword">return</span> ;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (QMode == <span class="hljs-number">3</span> &amp;&amp; _cxq != NULL) &#123;<br>          <span class="hljs-comment">// 将cxq中的元素插入到EntryList的末尾</span><br>          w = _cxq ;<br>          <span class="hljs-keyword">for</span> (;;) &#123;<br>             <span class="hljs-keyword">assert</span> (w != NULL, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>             ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL, &amp;_cxq, w) ;<br>             <span class="hljs-keyword">if</span> (u == w) <span class="hljs-keyword">break</span> ;<br>             w = u ;<br>          &#125;<br>          <span class="hljs-keyword">assert</span> (w != NULL              , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br><br>          ObjectWaiter * q = NULL ;<br>          ObjectWaiter * p ;<br>          <span class="hljs-keyword">for</span> (p = w ; p != NULL ; p = p-&gt;_next) &#123;<br>              guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>              p-&gt;TState = ObjectWaiter::TS_ENTER ;<br>              p-&gt;_prev = q ;<br>              q = p ;<br>          &#125;<br><br>          <span class="hljs-comment">// Append the RATs to the EntryList</span><br>          <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> organize EntryList as a CDLL so we can locate the tail in constant-time.</span><br>          ObjectWaiter * Tail ;<br>          <span class="hljs-keyword">for</span> (Tail = _EntryList ; Tail != NULL &amp;&amp; Tail-&gt;_next != NULL ; Tail = Tail-&gt;_next) ;<br>          <span class="hljs-keyword">if</span> (Tail == NULL) &#123;<br>              _EntryList = w ;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              Tail-&gt;_next = w ;<br>              w-&gt;_prev = Tail ;<br>          &#125;<br><br>          <span class="hljs-comment">// Fall thru into code that tries to wake a successor from EntryList</span><br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (QMode == <span class="hljs-number">4</span> &amp;&amp; _cxq != NULL) &#123;<br>          <span class="hljs-comment">// 将cxq插入到EntryList的队首</span><br>          w = _cxq ;<br>          <span class="hljs-keyword">for</span> (;;) &#123;<br>             <span class="hljs-keyword">assert</span> (w != NULL, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>             ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL, &amp;_cxq, w) ;<br>             <span class="hljs-keyword">if</span> (u == w) <span class="hljs-keyword">break</span> ;<br>             w = u ;<br>          &#125;<br>          <span class="hljs-keyword">assert</span> (w != NULL              , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br><br>          ObjectWaiter * q = NULL ;<br>          ObjectWaiter * p ;<br>          <span class="hljs-keyword">for</span> (p = w ; p != NULL ; p = p-&gt;_next) &#123;<br>              guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>              p-&gt;TState = ObjectWaiter::TS_ENTER ;<br>              p-&gt;_prev = q ;<br>              q = p ;<br>          &#125;<br><br>          <span class="hljs-comment">// Prepend the RATs to the EntryList</span><br>          <span class="hljs-keyword">if</span> (_EntryList != NULL) &#123;<br>              q-&gt;_next = _EntryList ;<br>              _EntryList-&gt;_prev = q ;<br>          &#125;<br>          _EntryList = w ;<br><br>          <span class="hljs-comment">// Fall thru into code that tries to wake a successor from EntryList</span><br>      &#125;<br><br>      w = _EntryList  ;<br>      <span class="hljs-keyword">if</span> (w != NULL) &#123;<br>          <span class="hljs-comment">// 如果EntryList不为空，则直接唤醒EntryList的队首元素</span><br>          <span class="hljs-keyword">assert</span> (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>          ExitEpilog (Self, w) ;<br>          <span class="hljs-keyword">return</span> ;<br>      &#125;<br><br>      <span class="hljs-comment">// EntryList为null，则处理cxq中的元素</span><br>      w = _cxq ;<br>      <span class="hljs-keyword">if</span> (w == NULL) <span class="hljs-keyword">continue</span> ;<br><br>      <span class="hljs-comment">// 因为之后要将cxq的元素移动到EntryList，所以这里将cxq字段设置为null</span><br>      <span class="hljs-keyword">for</span> (;;) &#123;<br>          <span class="hljs-keyword">assert</span> (w != NULL, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>          ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL, &amp;_cxq, w) ;<br>          <span class="hljs-keyword">if</span> (u == w) <span class="hljs-keyword">break</span> ;<br>          w = u ;<br>      &#125;<br>      TEVENT (Inflated exit - drain cxq into EntryList) ;<br><br>      <span class="hljs-keyword">assert</span> (w != NULL              , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>      <span class="hljs-keyword">assert</span> (_EntryList  == NULL    , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br><br><br>      <span class="hljs-keyword">if</span> (QMode == <span class="hljs-number">1</span>) &#123;<br>         <span class="hljs-comment">// QMode == 1 : 将cxq中的元素转移到EntryList，并反转顺序</span><br>         ObjectWaiter * s = NULL ;<br>         ObjectWaiter * t = w ;<br>         ObjectWaiter * u = NULL ;<br>         <span class="hljs-keyword">while</span> (t != NULL) &#123;<br>             guarantee (t-&gt;TState == ObjectWaiter::TS_CXQ, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>             t-&gt;TState = ObjectWaiter::TS_ENTER ;<br>             u = t-&gt;_next ;<br>             t-&gt;_prev = u ;<br>             t-&gt;_next = s ;<br>             s = t;<br>             t = u ;<br>         &#125;<br>         _EntryList  = s ;<br>         <span class="hljs-keyword">assert</span> (s != NULL, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">// QMode == 0 or QMode == 2‘</span><br>         <span class="hljs-comment">// 将cxq中的元素转移到EntryList</span><br>         _EntryList = w ;<br>         ObjectWaiter * q = NULL ;<br>         ObjectWaiter * p ;<br>         <span class="hljs-keyword">for</span> (p = w ; p != NULL ; p = p-&gt;_next) &#123;<br>             guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>             p-&gt;TState = ObjectWaiter::TS_ENTER ;<br>             p-&gt;_prev = q ;<br>             q = p ;<br>         &#125;<br>      &#125;<br><br><br>      <span class="hljs-comment">// _succ不为null，说明已经有个继承人了，所以不需要当前线程去唤醒，减少上下文切换的比率</span><br>      <span class="hljs-keyword">if</span> (_succ != NULL) <span class="hljs-keyword">continue</span>;<br><br>      w = _EntryList  ;<br>      <span class="hljs-comment">// 唤醒EntryList第一个元素</span><br>      <span class="hljs-keyword">if</span> (w != NULL) &#123;<br>          guarantee (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>          ExitEpilog (Self, w) ;<br>          <span class="hljs-keyword">return</span> ;<br>      &#125;<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>代码中的<code>QMode</code>表示唤醒下一个线程的策略。</p>
<p>code 1 设置owner为null，即释放锁，这个时刻其他的线程能获取到锁。这里是一个非公平锁的优化；</p>
<p>code 2 如果当前没有等待的线程则直接返回就好了，因为不需要唤醒其他线程。或者如果说succ不为null，代表当前已经有个”醒着的”继承人线程，那当前线程不需要唤醒任何线程；</p>
<p>code 3 当前线程重新获得锁，因为之后要操作cxq和EntryList队列以及唤醒线程；</p>
<p>code 4根据QMode的不同，会执行不同的唤醒策略。</p>
<p>根据QMode的不同，有不同的处理方式：</p>
<p>QMode = 2且cxq非空：取cxq队列队首的ObjectWaiter对象，调用ExitEpilog方法，该方法会唤醒ObjectWaiter对象的线程（即cxq队列首元素），然后立即返回，后面的代码不会执行了；<br>QMode = 3且cxq非空：把cxq队列插入到EntryList的尾部；<br>QMode = 4且cxq非空：把cxq队列插入到EntryList的头部；<br>QMode = 0：暂时什么都不做，继续往下看；</p>
<p>只有QMode=2的时候会提前返回，等于0、3、4的时候都会继续往下执行：</p>
<ol>
<li>如果EntryList的首元素非空，就取出来调用ExitEpilog方法，该方法会唤醒ObjectWaiter对象的线程（EntryList首元素），然后立即返回；</li>
<li>如果EntryList的首元素为空，就将cxq的所有元素放入到EntryList中，然后再从EntryList中取出来队首元素执行ExitEpilog方法，然后立即返回；</li>
</ol>
<h1 id="4-synchronized锁的大体流程"><a href="#4-synchronized锁的大体流程" class="headerlink" title="4. synchronized锁的大体流程"></a>4. synchronized锁的大体流程</h1><p>偏向锁-&gt;轻量锁-&gt;重量锁三者转换的大体逻辑如下图：</p>
<p>图片来自<a target="_blank" rel="noopener" href="https://blog.csdn.net/DBC_121/article/details/105453101">看完这篇恍然大悟，理解Java中的偏向锁，轻量级锁，重量级锁</a></p>
<p><img src="images/lock.png" srcset="/img/loading.gif" lazyload alt="lock"></p>
<p>但是图片中存在错误：轻量级锁发生竞争时没有自旋操作，直接膨胀为重量级锁</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016417017">Java中的Monitor机制</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.ibm.com/zh/articles/j-lo-synchronized/">探索Java同步机制</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://itliusir.com/2019/11-Synchronized/">Synchronized 源码分析</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903726554038280">死磕Synchronized底层实现–偏向锁</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/farmerjohngit/myblog/issues/14">死磕Synchronized底层实现–轻量级锁</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/farmerjohngit/myblog/issues/15">死磕Synchronized底层实现–重量级锁</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/L__ear/article/details/106369509">源码解析-偏向锁撤销流程解读</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/fd780ef7a2e8">Lock Record–锁记录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.mdeditor.tw/pl/2Z1b">偏向锁到底是怎么回事啊啊啊啊</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.weghos.com/openjdk/OpenJDK/src/hotspot/">在线看JDK源码的网站</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/L__ear/article/details/106365869">源码解析-触发批量撤销或批量重偏向的条件</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/302874340">关于synchronized批量重偏向和批量撤销的一个小实验</a></p>
</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">多线程基础</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/synchronized/">synchronized</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021-06-02/ArrayList-source-code-analysis.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ArrayList源码分析</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021-06-02/Executor-interface.html">
                        <span class="hidden-mobile">Exectuor框架解析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
