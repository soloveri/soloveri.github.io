<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>一颗胡杨树</title>
    <link>https://eripe.me/</link>
    
    <image>
      <url>https://eripe.me/img/panda.png</url>
      <title>一颗胡杨树</title>
      <link>https://eripe.me/</link>
    </image>
    
    <atom:link href="https://eripe.me/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>欢迎乘坐八楼的二路公交车</description>
    <pubDate>Thu, 03 Jun 2021 08:09:25 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Docker使用方法(二)-文件系统架构</title>
      <link>https://eripe.me/2021-06-04/Docker-filesys-layout.html</link>
      <guid>https://eripe.me/2021-06-04/Docker-filesys-layout.html</guid>
      <pubDate>Fri, 04 Jun 2021 11:57:44 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一定要将登录用户切换为root才能查看Docker的文件架构！！！</p><h2 id="0x0-基本文件布局"><a href="#0x0-基本文件布局" class="headerlink" title="0x0 基本文件布局"></a>0x0 基本文件布局</h2><p>Docker的文件主要都存储在<code>/var/lib/docker</code>目录下,文件目录如下所示:</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/Docker-filesys-layout.filesys.png" alt="Docker-filesys-layout.filesys"></p><p>其中<code>containers</code>存储的是容器,<code>images</code>存储的是镜像。在深入了解Docker的原理之前,我们需要了解两个基本名词:</p><ul><li>overlayFS</li><li>overlay2</li></ul><h2 id="0x1-overlayFS"><a href="#0x1-overlayFS" class="headerlink" title="0x1 overlayFS"></a>0x1 overlayFS</h2><p>其中overlayFS是一种类似于aufs的文件堆叠系统,但是比aufs更快。本质上来说,overlayFS是属于linux内核驱动的一部分。</p><p>overlayFS依赖于已有的底层文件系统,它并不实际参与硬盘的分区。而是将一些底层文件系统的文件合并,给不同的用户呈现不同的文件,实现了相同文件复用的功能,提高了空间使用率。下面一张图很好的解释了overlayFS的<a href="https://blog.csdn.net/luckyapple1028/article/details/77916194">基本工作原理</a>:</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/overlayFS.jfif" alt="overlayFS"></p><p>overlayFS分为四个部分:</p><ul><li>lower dir:挂载时最多支持500个lower dir</li><li>upper dir</li><li>merge dir</li><li>work dir:用于存放文件系统挂载后产生的临时和简介文件,内容对用户不可见</li></ul><p>其中的lower dir和upper dir来自底层文件系统,可以由用户自行指定。其中merge dir就是overlayFS的挂载点。并且overlayFS有如下特点:</p><ul><li>如果lower和upper中有同名的目录或文件,会在merge中合并为同一个文件夹,并且upper会覆盖掉lower中的文件与目录。</li><li>如果有多个lower存在同名文件,那么使用层次较高的lower dir的同名文件</li><li>lower dir是<strong>只读</strong>的</li><li>upper dir是<strong>可读可写</strong>的</li><li>overlayFS具有copy-up的特性。也就是如果想对lower dir中的文件进行写入,只能将文件拷贝至upper dir,然后再对拷贝后的文件进行写入。</li></ul><h3 id="0x1-1-overlayFS的挂载"><a href="#0x1-1-overlayFS的挂载" class="headerlink" title="0x1-1 overlayFS的挂载"></a>0x1-1 overlayFS的挂载</h3><p>overlayFS的基本用法可以参考<a href="https://wiki.archlinux.org/index.php/Overlay_filesystem">官网</a>。下面是我参照<a href="https://blog.csdn.net/luckyapple1028/article/details/78075358">overlayFS的基本使用</a>做的一个复现。</p><p>首先需要创建lower、upper、work、merge这四类目录,文件树如下所示:</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/Docker-filesys-layout.worktree.png" alt="Docker-filesys-layout.worktree"></p><p>首先对各个dir下的文件写入标记:</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/Docker-filesys-layout.write-content-1.png" alt="Docker-filesys-layout.write-content-1"></p><p>然后对各个foo文件写入标记:</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/Docker-filesys-layout.write-content-2.png" alt="Docker-filesys-layout.write-content-2"></p><p>最后执行挂载命令:</p><blockquote><p>sudo mount -t overlay overlay -o lowerdir=lower1:lower2,upperdir=upper,workdir=work merge</p></blockquote><p>注意<code>workdir</code>和<code>merge</code>之间是没有<code>,</code>的。<code>lowerdir</code>后面的目录是有顺序的,排在前面的lower dir在lower这个层次中的排名就较前,也就是如开头部分的图片所示:</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/overlayFS.jfif" alt="overlayFS"></p><p>挂载后merge目录下的结构如下:</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/Docker-filesys-layout.merge-tree.png" alt="Docker-filesys-layout.merge-tree"></p><p>最后在merge目录中的<code>aa</code>文件来自<code>lower1</code>,<code>bb</code>文件来自<code>upper</code>。<code>foo</code>文件来自<code>lower</code>与<code>upper</code>。如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/Docker-filesys-layout.result.png" alt="Docker-filesys-layout.result"></p><p>可以看到确实将同名的底层文件都隐藏了起来。</p><h3 id="0x1-2-overlayFS的写入操作"><a href="#0x1-2-overlayFS的写入操作" class="headerlink" title="0x1-2 overlayFS的写入操作"></a>0x1-2 overlayFS的写入操作</h3><p>upper dir是一个可读可写层,而lower dir是只读层。所以如果我们想要写入的文件来自upper dir,那就是直接写入,在此就不举例说明了;如果来自lower dir,就会先将文件复制到upper再写入。这就是所谓的copy-up特性。</p><p>下图是在上述文件挂载完成后向来自<code>lower1/dir/</code>的<code>aa</code>写入文件:</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/Docker-filesys-layout.write-to-lower.png" alt="Docker-filesys-layout.write-to-lower"></p><p>可以看到,我们在挂载点向lower层的文件写入内容后,upper层直接复制了了<code>lower1/dir/aa</code>,并直接追加写入的内容。而<code>lower1/dir/aa</code>本身的内容的却没有改变。</p><h3 id="0x1-3-overlayFS的删除操作"><a href="#0x1-3-overlayFS的删除操作" class="headerlink" title="0x1-3 overlayFS的删除操作"></a>0x1-3 overlayFS的删除操作</h3><p>overlayFS中的删除并不是真正的删除,它只是使用了一个障眼法-<strong>whiteout</strong>文件来覆盖同名文件,让用户以为已经把文件删除了。</p><blockquote><p>whiteout文件并非普通文件，而是主次设备号都为0的字符设备（可以通过”mknod <name> c 0 0”命令手动创建）</p></blockquote><blockquote><p>并且whiteout文件在merge层不可见。达到了隐藏文件的目的</p></blockquote><p>删除操作分为三个场景：</p><ul><li>要删除的文件/文件夹没有覆盖,仅来自upper层,那么直接删除就好</li><li>删除的文件/文件来自lower层,upper层中不存在,那么会在merge层和upper中生成同名的<strong>whiteout</strong>文件,用于屏蔽底层文件</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下图所示,其中upper在进行删除操作前为空目录：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/Docker-filesys-layout.delete-from-merge.png" alt="Docker-filesys-layout.delete-from-merge"></p><ul><li>要删除的文件来自lower层,upper中存在覆盖,那么会在merge层和upper层生成同名的<strong>whiteout</strong>文件,用于屏蔽底层文件。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原始文件结构如下:</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/Docker-filesys-layout.worktree.png" alt="Docker-filesys-layout.worktree"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除后的upper目录如下:</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/Docker-filesys-layout.delete-from-upper.png" alt="Docker-filesys-layout.delete-from-upper"></p><p>这也就是docker中,虽然在container layer(upper)中删除了许多东西,但是image layer(lower)还是没有变小的原因。</p><p>这就是所谓的堆叠文件系统。详细介绍请移步:</p><ul><li><a href="https://blog.csdn.net/luckyapple1028/article/details/77916194">overlayFS的基本介绍</a></li><li><a href="https://blog.csdn.net/luckyapple1028/article/details/78075358">overlayFS的基本使用</a></li></ul><h2 id="0x2-overlay2"><a href="#0x2-overlay2" class="headerlink" title="0x2 overlay2"></a>0x2 overlay2</h2><p>docker为overlayFS提供了了两个存储驱动,一个是原始的overlay,另外一个就是现在新版的overlay2。所以docker自然也采用了堆叠的方式存储镜像。</p><p>这里以拉取最新的ubuntu images为例,可以看到,拉取的镜像为4层:</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/Docker-filesys-layout.pull-ubuntu.png" alt="Docker-filesys-layout.pull-ubuntu"></p><p>在overlay2目录下出现了五个目录,其中四个为拉取的镜像,额外的目录为<code>l</code>。它存放的是对应镜像的软符号链接。为什么需要设置软符号链接?</p><blockquote><p>因为虽然在overlayFS中用户指定的lowerdir最多可以支持500层。但是由于mount的挂载选项最多支持1个内存page的输入（默认大小为4KB），所以如果指定的lowerdir数量较多且长度较长，会有溢出而导致挂载失败的风险（目前内核的-o挂载选项不支持超过1个内存页，即4KB大小）。</p></blockquote><p>所以设置软符号链接就是防止挂载失败,并且还能多挂载几个lower dir。每个软符号链接下的都会存在一个<code>diff</code>目录。接来看看看各个image layer中的内容:</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/Docker-filesys-layout.ubuntu-tree.png" alt="Docker-filesys-layout.ubuntu-tree"></p><p>其中每个image layer中的<strong>diff文件夹存放了当前image layer的内容</strong>, link文件的内容是当前层对应的短符号链接,lower文件夹存放了当前层的所有下层<code>lower dir</code>的id。可以看到,id为<code>9045</code>的image layer没有<code>lower</code>,即<code>9045</code>就是最底层的image layer(这会在后面验证)。work目录用于挂载时的工作目录。</p><p>那么这些这些目录是怎么和镜像关联起来的呢？答案是通过元数据进行关联。元数据又分为image元数据和layer数据。</p><h3 id="0x2-1-image元数据"><a href="#0x2-1-image元数据" class="headerlink" title="0x2-1 image元数据"></a>0x2-1 image元数据</h3><p>image元数据存储在<code>/var/lib/docker/image/&lt;storage_driver&gt;/imagedb/content/sha256/</code>目录,文件名称是对应的iamge id,如下所示:</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/Docker-filesys-layout.imagedb.png" alt="Docker-filesys-layout.imagedb"></p><p>该文件以json格式保存了该image的重要信息,其中<code>rootfs</code>值得关注,因为它指定了各个image layer的工作顺序。查看文件内容时可以将其格式化为json:(<code>使用vim :%!python -m json.tool格式化成json</code>),其中<code>rootfs</code>的内容如下:</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/Docker-filesys-layout.rootfs.png" alt="Docker-filesys-layout.rootfs"></p><p>其中的diff_ids是有严格顺序的,从上到下,表示image layer的最底层到最高层id。顺序是反的是因为如果产生了新的image layer直接在最后面追加即可,非常方便。那么image是又如何关联到layer的呢？docker是通过image元数据中的diff_id与一些历史信息计算出chainID关联到layer元数据,layer元数据再关联到对应的image layer。</p><h3 id="0x2-2-layer元数据"><a href="#0x2-2-layer元数据" class="headerlink" title="0x2-2 layer元数据"></a>0x2-2 layer元数据</h3><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/Docker-filesys-layout.layerdb.png" alt="Docker-filesys-layout.layerdb"></p><p>在<code>/var/docker/&lt;storage_driver&gt;/image/layerdb/sha256</code>中,有四个目录,其中每个目录的数字就是每个diff_id对应的chainID。可以看到,只有最底层的<code>ce30</code>能在layerdb中找到对应的chainID,那是因为最底层的diff_id和chainID是相同的。所以除去最底层,剩下的chainID需要计算,这里不做演示。</p><p>每个chainID目录都有三个共同的文件<code>cache-id</code>、<code>diff</code>、<code>size</code>,而有的没有<code>parent</code>。下面一一解析下各个文件的内容。</p><h3 id="cache-id"><a href="#cache-id" class="headerlink" title="cache-id"></a>cache-id</h3><p>刚才说到layerdb保存的毕竟是元数据,那么这些元数据到底是怎么和具体数据链接起来呢?其中的<code>cache-id</code>是关键。</p><p>我们查看<code>ce30</code>的<code>cache-id</code>文件内容:</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/Docker-filesys-layout.cache-id.png" alt="Docker-filesys-layout.cache-id"></p><p>docker随机生成的uuid，内容是保存image layer的目录索引。其中的id为<code>9045</code>就是刚才拉取的<code>ubuntu</code>镜像中的最底层image layer。说明没有<code>lower</code>目录的image layer就是在最底层。</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/Docker-filesys-layout.ubuntu-tree.png" alt="Docker-filesys-layout.ubuntu-tree"></p><h4 id="size"><a href="#size" class="headerlink" title="size"></a>size</h4><p>size文件表示当前chainID对应的image layer的大小。</p><h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><p>保存了当前chainID对应的diff_id。</p><h4 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h4><p>这里的parent保存的是在<code>rootfs</code>中:位置较下的diff_id的上一个diff_id的chainID。</p><p>比如说chainID为<code>2515</code>的image layer。我们首先在diff中查看其对应的diff_id。</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/Docker-filesys-layout.2515-diff.png" alt="Docker-filesys-layout.2515-diff"></p><p>其对应的diff_id为<code>8eeb</code>。再来查看其<code>parent</code>文件:</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/Docker-filesys-layout.2515-parent.png" alt="Docker-filesys-layout.2515-parent"></p><p>而在<code>rootfs</code>中,<code>8eeb</code>的上一个diff_id对应的chainID就是<code>ce30</code>(因为第一个位置的diff_id与chainID相同)。</p><h3 id="0x2-3-overlay2的挂载"><a href="#0x2-3-overlay2的挂载" class="headerlink" title="0x2-3 overlay2的挂载"></a>0x2-3 overlay2的挂载</h3><p>挂载的信息存储在<code>/var/lib/docker/image/layerdb/mounts</code>目录下,每个目录名称就是对应的容器ID,如下图所示:</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/Docker-filesys-layout.mounts.png" alt="Docker-filesys-layout.mounts"></p><p><code>mounts</code>只有一个目录,对应于一个正在运行的容器。每个容器ID目录下存在三个文件。init-id对应当前挂载的容器的init层,mount-id就是对应的容器层(merge目录)。而parent文件还是存储位置在当前layer在<code>rootfs</code>上一个的diff_id的chainID。</p><p>三个文件的内容如下:</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/Docker-filesys-layout.threes.png" alt="Docker-filesys-layout.threes"></p><p>可以看到,<code>parent</code>中的内容为<code>sha256:7515</code>,而该chainID对应的diff_id就是<code>0956</code>。</p><p>最后查看以下<code>/var/lib/docker/overlays/</code>目录:</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/Docker-filesys-layout.final.png" alt="Docker-filesys-layout.final"></p><p>看到多了init层与container层。</p><p>关于init layer的<a href="https://stackoverflow.com/questions/33697774/init-layer-in-docker">作用</a>:</p><blockquote><p>Each containers has two layers, one (called the init layer), which is based on an image layer and a child of that which contains the actual container content. The init layer contains a few files that must always exist in Docker containers (e.g. /.dockerinit). Supported Filesystems</p></blockquote><p>简单来说就是帮我们对容器进行必要的初始化,避免我们自己初始化错误或者根本就忘掉。初始化的目录或文件如下:</p><blockquote><p>The containerID-init layer is the init layer of a container which is based on an image. It add some file into current container,include:<br>    “/dev/pts”:         “dir”,<br>    “/dev/shm”:         “dir”,<br>    “/proc”:            “dir”,<br>    “/sys”:             “dir”,<br>    “/.dockerenv”:      “file”,<br>    “/etc/resolv.conf”: “file”,<br>    “/etc/hosts”:       “file”,<br>    “/etc/hostname”:    “file”,<br>    “/dev/console”:     “file”,<br>    “/etc/mtab”:        “/proc/mounts”,</p></blockquote><p><strong>注意:init layer是一个只读层。</strong></p><p>最后以上述的四层ubuntu image为例,将iamgedb、layerdb、image layer、init layer、contain layer联合到一起。</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/layout.drawio.svg" alt="layout"></p><p>可以看到和挂载命令基本一致:</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/Docker-filesys-layout.docker-mount.png" alt="Docker-filesys-layout.docker-mount"></p><p>其中挂载都是使用的符号链接,upper就是diff目录,work目录与diff目录同级。</p><h3 id="0x2-4-overlay2的删除操作"><a href="#0x2-4-overlay2的删除操作" class="headerlink" title="0x2-4 overlay2的删除操作"></a>0x2-4 overlay2的删除操作</h3><p>删除分为删除image与删除container。</p><ul><li>删除container:首先需要停止想要删除的容器:<code>docker stop [container ID]</code>,然后删除容器:<code>docker rm [container ID]</code></li><li>删除image:在删除image前,一定要删除container,完成上述步骤后,直接<code>docker rmi [image id]</code>即可。</li></ul><h2 id="0x3-小结"><a href="#0x3-小结" class="headerlink" title="0x3 小结"></a>0x3 小结</h2><ol><li><p>docker在每次创建容器时都会自动添加一个init layer对容器进行初始化,添加contain layer面向用户。并且每次默认启动的容器都是不相同的。</p></li><li><p>docker对于每种文件驱动,都会在<code>docker/image</code>下创建同名文件以保存元数据。docker通过imagedb、layerdb、关联到具体的image layer。</p></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://blog.51cto.com/haoyonghui/2457915">docker 存储驱之overlayFS</a></p></li><li><p><a href="https://blog.csdn.net/luckyapple1028/article/details/77916194">深入理解overlayfs（一）：初识</a></p></li><li><p><a href="https://blog.csdn.net/luckyapple1028/article/details/78075358">深入理解overlayfs（二）：使用与原理分析</a></p></li><li><p><a href="https://www.cnblogs.com/sammyliu/p/5877964.html">Docker镜像存储-overlayfs</a></p></li><li><p><a href="https://www.cnblogs.com/sammyliu/p/5877964.html">docker一站式学习</a></p></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/tools/">tools</category>
      
      
      <category domain="https://eripe.me/tags/Docker/">Docker</category>
      
      
      <comments>https://eripe.me/2021-06-04/Docker-filesys-layout.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Dockerfile的基本规则</title>
      <link>https://eripe.me/2021-06-04/Docker-write-dockfile.html</link>
      <guid>https://eripe.me/2021-06-04/Docker-write-dockfile.html</guid>
      <pubDate>Fri, 04 Jun 2021 11:57:44 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在了解了&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在了解了<a href="Docker-filesys-layout.md">docker的基本原理</a>后，是时候了解以下Dockerfile是怎么写的了。首先我们需要了解<code>RUN</code>与<code>CMD</code>命令的区别。</p><ul><li><code>RUN</code>命令：每执行一次，就会在原有镜像的基础上添加一个<code>upper dir</code>保存所作的改变，所以对于一类的命令我们尽量使用一条<code>RUN</code>，否则会创建过多的不必要的<code>upper dir</code></li><li><code>CMD</code>命令：容器是一个进程，<code>CMD</code>命令就像是容器启动时输入的命令参数，所以只能有一条<code>CMD</code></li></ul><h2 id="Dockerfile的栗子"><a href="#Dockerfile的栗子" class="headerlink" title="Dockerfile的栗子"></a>Dockerfile的栗子</h2><p>下面是我基于centos7.8制作的mysql5.7镜像。Dockerfile如下所示：</p><figure class="highlight dockerfile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> centos:<span class="hljs-number">7.8</span>.<span class="hljs-number">2003</span><br><br><span class="hljs-keyword">MAINTAINER</span> sssoloveri@gmail.com<br><span class="hljs-keyword">RUN</span><span class="bash"> (<span class="hljs-built_in">cd</span> /lib/systemd/system/sysinit.target.wants/; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> *; <span class="hljs-keyword">do</span> [ <span class="hljs-variable">$i</span> == \</span><br><span class="bash">systemd-tmpfiles-setup.service ] || rm -f <span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span>); \</span><br><span class="bash">rm -f /lib/systemd/system/multi-user.target.wants/*;\</span><br><span class="bash">rm -f /etc/systemd/system/*.wants/*;\</span><br><span class="bash">rm -f /lib/systemd/system/local-fs.target.wants/*; \</span><br><span class="bash">rm -f /lib/systemd/system/sockets.target.wants/*udev*; \</span><br><span class="bash">rm -f /lib/systemd/system/sockets.target.wants/*initctl*; \</span><br><span class="bash">rm -f /lib/systemd/system/basic.target.wants/*;\</span><br><span class="bash">rm -f /lib/systemd/system/anaconda.target.wants/*;</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;root:123456&quot;</span> | chpasswd \ </span><br>&amp;&amp; groupadd --gid <span class="hljs-number">1000</span> rain \<br>&amp;&amp; useradd --uid <span class="hljs-number">1000</span> --gid rain  --<span class="hljs-keyword">shell</span><span class="bash"> /bin/bash --create-home rain \</span><br><span class="bash">&amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;rain:123456&quot;</span> | chpasswd</span><br><span class="hljs-comment">#USER rain</span><br><span class="hljs-keyword">RUN</span><span class="bash"> rpm -ivh https://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm \</span><br><span class="bash">&amp;&amp; rpm --rebuilddb \ </span><br>&amp;&amp; yum install -y yum-utils net-tools sudo vim \<br>&amp;&amp; rpm -ivh https://dev.mysql.com/get/mysql57-community-release-el7-<span class="hljs-number">11</span>.noarch.rpm \<br>&amp;&amp; yum install -y mysql-community-server \<br>&amp;&amp; yum install -y openssh openssh-server openssh-clients \<br>&amp;&amp; mkdir -p /var/<span class="hljs-keyword">run</span><span class="bash">/sshd \</span><br><span class="bash"><span class="hljs-comment">#&amp;&amp; mkdir -p ~/.ssh \</span></span><br><span class="bash">&amp;&amp; yum install -y supervisor \</span><br><span class="bash">&amp;&amp; rm -rf /etc/supervisord.conf \</span><br><span class="bash">&amp;&amp; mkdir -p /etc/supervisord/conf.d \</span><br><span class="bash">&amp;&amp; mkdir -p /var/<span class="hljs-built_in">log</span>/supervisor/ \</span><br><span class="bash">&amp;&amp; mkdir -p /var/run/supervisor/ \</span><br><span class="bash">&amp;&amp; ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key \</span><br><span class="bash">&amp;&amp; ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key</span><br><span class="hljs-keyword">COPY</span><span class="bash"> authorized_keys /root/.ssh/authorized_keys</span><br><span class="hljs-keyword">COPY</span><span class="bash"> supervisord.conf /etc/supervisord.conf</span><br><span class="hljs-comment">#COPY mysql.conf /etc/supervisord/conf.d/</span><br><span class="hljs-comment">#COPY sshd.conf /etc/supervisord/conf.d/</span><br><span class="hljs-keyword">RUN</span><span class="bash"> yum clean all</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3306</span> <span class="hljs-number">22</span><br><br><span class="hljs-comment"># 挂载数据、配置和日志目录</span><br><span class="hljs-keyword">RUN</span><span class="bash"> rm -rf /etc/my.cnf /var/lib/mysql /var/<span class="hljs-built_in">log</span>/mysqld.log</span><br><span class="hljs-keyword">VOLUME</span><span class="bash"> [<span class="hljs-string">&quot;/var/lib/mysql&quot;</span>, <span class="hljs-string">&quot;/etc/my.cnf&quot;</span>,<span class="hljs-string">&quot;/var/log/mysqld.log&quot;</span>]</span><br><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;/usr/sbin/init&quot;</span>]</span><br></code></pre></div></td></tr></table></figure><p>上面的内容基本上可以分为以下四个步骤：</p><ol><li>选取基础镜像，声明作者</li><li>安装基础软件，这一步骤中不要写太多的<code>RUN</code>，因为这样会让镜像十分臃肿</li><li>拷贝一些必要的文件，设置数据挂载目录，开放网络端口</li><li>声明容器入口命令</li></ol><p>安装基础软件没什么好说的，按照自己的需求声明就好。 <strong>重点是数据卷映射的权限问题</strong>。以上面的Dockerfile为例，我们当前宿主机的用户id为1000。我们容器启动时的命令为：</p><figure class="highlight docker"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs docker">docker <span class="hljs-keyword">run</span><span class="bash"> -d -u 1000:1000 \                       </span><br>--name mysql --hostname mysql --privileged=true \<br>--<span class="hljs-keyword">volume</span><span class="bash"> /usr/<span class="hljs-built_in">local</span>/mysql/data/:/var/lib/mysql \</span><br><span class="bash">--publish 3306:3306  -v /usr/<span class="hljs-built_in">local</span>/mysql/config/my.cnf:/etc/my.cnf -v /usr/<span class="hljs-built_in">local</span>/mysql/<span class="hljs-built_in">log</span>/mysqld.log:/var/<span class="hljs-built_in">log</span>/mysqld.log mysql:latest /usr/sbin/init</span><br><br></code></pre></div></td></tr></table></figure><p>上面我进行了三项文件或目录的映射：</p><ol><li>(宿主机)/usr/local/mysql/data/—–&gt;(容器)/var/lib/mysql</li><li>(宿主机)/usr/local/mysql/config/my.cnf—–&gt;(容器)/etc/my.cnf</li><li>(宿主机)/usr/local/mysql/log/mysqld.log——&gt;(容器)/var/log/mysqld.log</li></ol><p>上述三个宿主机中的文件或目录的拥有者都是uid为1000的用户。那么就会产生四种情况：</p><ol><li>容器中没有uid为1000的用户，并且没有指定容器的启动用户</li><li>容器中没有uid为1000的用户，并且指定了一个容器中不存在的用户作为启动用户</li><li>容器有uid为1000的用户，并且指定了uid为1000的用户作为启动用户</li><li>容器有uid为1000的用户，但是指定了容器中的另一个uid=1111的用户作为启动用户</li></ol><p>面对上面的问题，我们需要树立一个总的前提：容器中被映射的目录或文件的所有权是与宿主机中映射的目录或文件相同的。所以在容器中，目录<code>var/lib.mysql</code>，文件<code>my.cnf</code>、<code>mysqld.log</code>的所有者都是uid=1000的用户。然后就是容器的启动用户是谁的问题。</p><ol><li>如果没有明确指定，那么容器的默认启动用户就是root</li><li>如果指定了一个容器中不存在的用户，那么容器会显示<code>I have no name!</code>，没有username，没有home</li><li>如果指定的是容器中存在的但不是uid=1000的用户，那么就会正常显示用户名，但不能操作文件，因为所有者不同</li><li>如果指定了容器中存在且和宿主机uid相同的用户，那么就能正常操作文件</li></ol><p>所以显而易见，docker是<strong>根据uid而不是username的映射</strong>来完成权限管理的。所以我们在创建镜像时，一般都会创建一个uid与宿主机数据卷所有者相同的用户方便在容器中操作文件。<strong>一定要确保容器执行者的权限和挂载数据卷的所有者相对应。</strong></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://www.cnblogs.com/woshimrf/p/understand-docker-uid.html">docker挂载volume的用户权限问题,理解docker容器的uid</a></li><li><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/workdir">docker的中文手册</a></li><li><a href="http://ghoulich.xninja.org/2018/03/27/how-to-build-and-use-mysql-docker-image/">MySQL的Docker镜像制作详解</a></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/tools/">tools</category>
      
      
      <category domain="https://eripe.me/tags/Docker/">Docker</category>
      
      
      <comments>https://eripe.me/2021-06-04/Docker-write-dockfile.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Docker使用方法(一)-基本安装</title>
      <link>https://eripe.me/2021-06-04/basic-Docker-install.html</link>
      <guid>https://eripe.me/2021-06-04/basic-Docker-install.html</guid>
      <pubDate>Fri, 04 Jun 2021 11:57:44 GMT</pubDate>
      
      <description>&lt;p&gt;docker的基本使用与配置&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>docker的基本使用与配置</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>实验主机:虚拟机ubuntu-18.04 LTS</p></li><li><p>docker版本:19.03</p></li><li><p>能google</p></li></ol><p>因为如果在安装vm的主机上直接安装docker for windows是基本不可能成功的,要么卸载vm,要么在把vm升级到15.5以上,再或者在vm将docker配置为虚拟机使用。所以我选择在虚拟机中安装docker。所以基本架构为:windows-&gt;vm-&gt;docker-&gt;containers,老套娃了。</p><h2 id="基本安装"><a href="#基本安装" class="headerlink" title="基本安装"></a>基本安装</h2><p>在ubuntu中安装我也是直接copy网上的指令就完事了。建议使用DaoCloud的<a href="http://get.daocloud.io/">一键安装脚本</a>就完事了。</p><h2 id="镜像配置"><a href="#镜像配置" class="headerlink" title="镜像配置"></a>镜像配置</h2><p>新版的配置采用json文件的方式,首次使用时需要在<code>/etc/Docker/</code>目录下新建<code>daemon.json</code>。然后填入以下内容:</p><blockquote><p>{<br>  “registry-mirrors”: [“your mirror url”]<br>}<br>中科大的镜像源为<code>https://docker.mirrors.ustc.edu.cn</code>。</p></blockquote><p>镜像源的选择一般有以下三种:</p><ul><li><a href="https://www.daocloud.io/mirror#accelerator-doc">DaoCloud</a></li><li><a href="https://developer.aliyun.com/article/29941">阿里云</a></li><li><a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker">中科大镜像源</a></li></ul><p>最后重启docker:</p><blockquote><p>service docker restart</p></blockquote><p>完事。</p><h2 id="Docker初体验"><a href="#Docker初体验" class="headerlink" title="Docker初体验"></a>Docker初体验</h2><p>使用<code>Docker pull hello-world</code>拉取镜像看看Docker是否能正常工作。</p><p>使用<code>Docker run hello-world</code>运行镜像。</p><p>ps:</p><p>如果你使用DaoCloud的脚本安装Docker,那么运行镜像的话会产生权限问题，如下所示:</p><blockquote><p>docker: Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Post http://%2Fvar%2Frun%2Fdocker.sock/v1.26/containers/create: dial unix /var/run/docker.sock: connect: permission denied.<br>See ‘docker run –help’.</p></blockquote><p>意思就是我们没有权限访问unix socket,从而导致无法与Docker Engine通信。</p><ul><li>临时办法:使用<code>sudo</code>运行</li><li>一劳永逸:<code>sudo usermod -a -G docker $USER</code>,记得重启或者重录当前用户,配置才能生效。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://www.jianshu.com/p/34d3b4568059">Docker的安装</a></p></li><li><p><a href="https://medium.com/@dhananjay4058/solving-docker-permission-denied-while-trying-to-connect-to-the-docker-daemon-socket-2e53cccffbaa">权限问题的解决方法</a></p></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/tools/">tools</category>
      
      
      <category domain="https://eripe.me/tags/Docker/">Docker</category>
      
      
      <comments>https://eripe.me/2021-06-04/basic-Docker-install.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计网热门问题</title>
      <link>https://eripe.me/2021-06-04/top-questions-for-network.html</link>
      <guid>https://eripe.me/2021-06-04/top-questions-for-network.html</guid>
      <pubDate>Fri, 04 Jun 2021 11:57:44 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;本篇不为别的，只为记录面试过程中关于计网的热门问题。&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1-点击一个链接后，发生了什么&quot;&gt;&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>本篇不为别的，只为记录面试过程中关于计网的热门问题。</p><p>[TOC]</p><hr><h2 id="1-点击一个链接后，发生了什么"><a href="#1-点击一个链接后，发生了什么" class="headerlink" title="1. 点击一个链接后，发生了什么"></a>1. 点击一个链接后，发生了什么</h2><p>首先，我们需要有一个总的概念：在点击一个链接后，网卡首先会将http请求使用http协议封装，接着将数据包经由tcp/udp协议封装，最后使用ip协议将数据包在各个网段之间传输直至到达目的地。http协议的封装这里不作详细介绍。tcp连接的建立和ip数据包的转发才是重点。</p><ol><li>tcp连接建立的基础是使用ip协议将数据包转发到目标主机</li><li>使用ip的前提是知道目标主机的ip地址</li><li>而ip地址的获取需要靠dns解析</li></ol><p>所以点击链接后发生的事，主要分为域名解析、ip数据包转发、tcp连接，我们依次分析这三小部分。</p><p><strong>I. 域名解析</strong></p><p>dns解析的流程比较简单，查询步骤如下：</p><ol><li><p>首先查询浏<strong>览器缓存</strong>，如若失败则执行2，否则执行6</p></li><li><p>查询本机<strong>host文件</strong>，如若失败则执行3，则执行6</p></li><li><p>查询<strong>本地dns服务器</strong>（一般是指由用户设置的dns服务器），如果失败，如果采用迭代模式，则执行4；如果采用递归模式，则执行5</p></li><li><p>本地dns服务器采用递归模式的查询流程如下所示：</p></li></ol><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.dns-recursion.png" alt="top-questions-for-network.dns-recursion"></p><ol start="5"><li>本地dns采用迭代模式的查询流程如下所示：</li></ol><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.dns-iteration.png" alt="top-questions-for-network.dns-iteration"></p><ol start="6"><li>返回域名对应的ip地址</li></ol><p>上图中所谓的根服务器的概念与域名的级别有关系，根服务器负责管理13个顶级域名服务器，如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.root.png" alt="top-questions-for-network.root"></p><hr><p>延申问题：</p><p><strong>Q1. 域名解析是通过dns映射完成的，那么这个映射是如何建立？</strong></p><details><summary>展开</summary><p>映射一般需要我们手动建立，建立的类型一般就是两种：A类和CNAME类。</p><ul><li><p>A类可以简单理解为域名到ip地址的直接映射。</p></li><li><p>CNAME类（Canonical Name）就是域名到域名的映射。</p></li></ul><p>CNAME类解析的用处多多，我们可以像使用环境变量一样设置CNAME<a href="#refer-anchor-1"><sup>[1]</sup></a>。例如如果我们在域名<code>test.com</code>下有三个子域名<code>a.test.com</code>、<code>b.test.com</code>、<code>c.test.com</code>。现在我们想把这三个子域名解析到我们的ip<code>10.10.1.11</code>，当然我们可以为每个子域名设置一个A类解析，但是如果更改了ip地址，那么需要更改的地方是非常多的。<br>反之，我们将这三个子域名都是用CNAME解析到域名<code>test.com</code>，那么解析时就把问题转化为<code>test.com</code>的ip地址是多少。当ip地址改变时，只需要更改<code>test.com</code>的A记录</p><p> 主机名 | 记录类型 | 目标 |<br>| :—–| —-: | :—-: |<br>| test.com |A     | 10.10.1.11 |<br>| a.test.com | CNAME | test.com |<br>| b.test.com | CNAME | test.com |<br>| c.test.com | CNAME | test.com |</p><p>那么CNAME这么好用，它有什么缺陷呢？</p><ol><li>CNAME只能解析到另一个域名，不能解析ip</li><li>增加一次解析的负担，一般可以使用cdn加速</li></ol></details><p><strong>Q2. 多个域名绑定到同一ip怎么区分？</strong></p><details><summary>展开</summary><p>如上所述，我们可以将多个子域名绑定到同一ip，一般我们需要根据端口来区分针对不同域名发起的请求。但是为了用户体验，我们希望多个域名都访问80端口，这时一般使用nginx实现反向代理<a href="#refer-anchor-9"><sup>[13]</sup></a>来区分不同域名。nginx为什么能够区分？因为http请求头中都会包含请求的域名。</p><p>或者使用虚拟主机，直接将子域名映射到二级目录就行。</p></details><p><strong>Q3. 上面提到的子域名是什么？</strong></p><details><summary>展开</summary>正如前文所述，域名是有等级的。根据[维基百科](https://en.wikipedia.org/wiki/Domain_name)，一级域名是13个顶级域名。一级域名左侧为二级域名，二级域名左侧为三级域名，以此类推。<p>例如域名<code>lol.qq.com</code>，一级域名为<code>com</code>、二级域名为<code>qq</code>、三级域名为<code>lol</code>。域名所有者可以任意配置所有域名下的子域名<a href="#refer-anchor-2"><sup>[2]</sup></a>。</p><p>但是站在使用者的角度，我们一般称<code>qq.com</code>为一级域名，因为单单使用<code>com</code>什么都不是。</p></details><hr><p><strong>II. ip数据包的转发</strong></p><p>请求到目标域名的ip后，ip数据包首先需要传输到网关，然后再经过层层路由转发至目标主机<a href="#refer-anchor-3"><sup>[3-5]</sup></a>。而ip数据包的转发实际还要依靠链路层，而链路层的转发依靠的是mac地址。所以需要完成ip地址到mac地址之间的映射，这个工作交由arp协议来完成,由上可知<strong>arp工作在链路层</strong>。</p><p><strong>arp的请求是广播，而响应是单播</strong>，因为在一个局域网中，主机A只知道路由器B的ip地址，而不知道路由器B的mac地址是多少，必须发起广播，并且只有路由器B才会响应这个arp请求。那么为什么主机能够知道需要将数据包转发至路由器B呢？这里我们可以将这个路由器B看作<strong>默认网关</strong>，这一般都会自动获取，而网关之后的转发流程就是网关的事了。</p><p>完成ip到mac的映射后，数据包会从主机A转发到路由器B。路由器B解析ip数据包后，发现目的ip为<code>111.222.333.444</code>。那么接下来怎么转发才能到这个地址呢？这就需要以来路由器中的路由表。而路由表的生成有专门的协议来负责，后面将会介绍。查询路由表后，一般都会知道下一跳路由器的ip地址，这时再使用arp协议请求mac地址，重复上面的操作就会层层路由到ip为<code>111.222.333.444</code>的主机了。</p><hr><p>延申问题</p><p><strong>Q1：路由表是如何生成的？</strong></p><details><summary>展开</summary><p>首先我们需要知道根据不同的网络服务商，会组成不同的、各自的超大局域网，一般将超大局域网成为自治系统(autonomous system)。AS内部之间的路由协议称为<strong>内部网关协议</strong>( interior gateway protocol )，而AS之间的路由协议称为<strong>外部网关协议</strong>(Exterior gateway protocol)。</p><p>需要注意的是：参考<a href="https://en.wikipedia.org/wiki/Exterior_gateway_protocol">维基百科</a>，IGP是内部网关协议的总称，并不是一个具体的协议。而EGP既是外部网关协议的总称，而且确实有一种外部网关协议叫做EGP。</p><p>具体来说，IGP主要有两种类型：距离矢量类型和链路状态类型，所谓的距离矢量就是靠源地址与目标地址之间的路由跳数来决定路由路径。而距离矢量类型是指通过路径长度、可靠性、延迟、带宽、负载和通信开销来决定路由路径。距离适量类型的代表路由协议是<strong>路由信息协议RIP</strong>、<strong>内部网络路由协议IGRP</strong>。链路状态类型的代表路由协议有开放式最短路由协议<strong>OSPF</strong>、<strong>IS-IS</strong>。</p><p>EGP运行于AS之间，代表协议主要包括EGP、BGP（EGP的升级版）、EBGP等。</p></details><hr><p><strong>III. 建立tcp连接</strong></p><p>tcp连接的建立需要经过三次握手，如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.tcp-three-handshake.png" alt="top-questions-for-network.tcp-three-handshake"></p><ol><li>客户发送的第一个段是 SYN 段。这个段仅有 SYN 标志被置位，它用于序号同步。<strong>它占用一个序号，不能携带数据</strong>。当数据传输开始时，客户<strong>随机</strong>选择一个数字作为初始序号(ISN)。注意，这个段不包含确认号。它也没有定义窗口大小；窗口大小的定义只有当段包含确认号时才有意义。<br>&nbsp;</li><li>服务器发送第二个段，两个标志位SYN和ACK置位的段，即 SYN  +ACK 段。这个段有两个目的。首先，它是另一方向通信的 SYN 段。服务器使用这个段来<strong>随机</strong>初始化序号，这个序号用来给从服务器发向客户的字节编号。服务器也通过给 ACK 置位并展示下一个序号来确认已经接收到来自客户的SYN，这里的下一个序号是服务器预期从客户接收的序号。因为它包含确认，它也需要定义接收窗口，即 rwnd（供客户参考使用）。因为这个段起到 SYN段的作用，它需要被确认。因此，<strong>它占用一个序号。但SYN + ACK 段不携带数据</strong>。<br>&nbsp;</li><li>客户发送第三个段。这个段仅仅是一个 ACK 段。它使用 ACK 标志和确认序号字段来确认收到了第二个段。<strong>该段可携带或者不携带数据</strong>。注意，如果不携带数据，ACK段没有占用任何序号，但是一些实现允许这第三个段在连接阶段从客户端携带第一块数据，在这种情况下，段消耗的序号与数据字节数相同。</li></ol><p>标志位小结：</p><p>SYN：可以理解为谁需要同步序号，谁就要设置SYN标志位<br>ACK：谁收到了数据包，谁就要设置ACK标志位</p><hr><p>扩展问题：</p><p><strong>Q1: 为什么需要三次握手？</strong></p><details><summary>展开</summary>相信大家都知道，tcp连接的建立需要三次握手，但是想要明白为什么需要三次握手，我们首先就需要知道tcp的连接[<sup>[4]</sup>](#refer-anchor-4)和握手到底是什么意思。<p>根据<a href="https://tools.ietf.org/html/rfc793">RFC 793 - Transmission Control Protocol </a>的规定，tcp的连接定义如下：</p><blockquote><p>The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream. The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.</p></blockquote><p>大致是说，为了防止网络的不确定性可能会导致数据包的缺失和顺序颠倒等问题，需要为每一个数据流初始化和保持确定的状态信息，包括socket、数据包序号、窗口大小。这些状态信息叫做一个连接。</p><p>那么握手到底是啥意思？我认为所谓的握手是指：对于一个<strong>数据包</strong>来说，它经历了一组收发的过程，就叫一次握手。如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/tcp-handshake.drawio.svg" alt="what-is-a-handshake"></p><p>明白了<strong>连接</strong>和<strong>握手</strong>的概念，我们再来讨论握手的次数。因为tcp是双工的，收方和发方都是可以发送信息的，所以就需要为收发两端同步上述的状态信息，而<strong>两次握手都不能完成同步信息(主要是序列号ISN)的任务</strong>。如何理解？</p><p><a href="https://tools.ietf.org/html/rfc793">RFC 793 - Transmission Control Protocol </a>指出使用三次连接原因主要是为了防止重复的连接初始化信息出现，导致连接错乱：</p><blockquote><p>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</p></blockquote><p>试想如下一个场景：<br>因为网络延迟较高，发送方A发出连接请求后，如果这个请求经过了很长时间才到达收方B。那么B无法判断这个请求是正常还是超时的。如果B采用两次握手，贸然建立连接，那么对A发出响应信息后，A是不会作出响应的，因为这个连接已经过时了。那么B建立连接的资源就一直无法释放。这是一个非常严重的问题。</p><p>那么为什么三次握手就能解决这个问题呢？其实我们可以把三次握手退化成四次握手，如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/tcp-four-handshake.drawio.svg" alt="four-handshake"></p><p>经过四次握手后，主机A和主机B都确认对方能够收到数据，就会建立tcp连接。如果此时再出现A发送的连接请求超时到达，B不会建立连接，而是向A发送应答请求，并且试图同步序列号，如果同步失败，连接就不会建立，主机A和B都能很快的释放资源。但是其中数据包2、3是可以一起发送的。四次就退化成三次握手，如下所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.tcp-three-handshake.png" alt="top-questions-for-network.tcp-three-handshake"></p><p>图中三次握手的重点就是<strong>同步序列号</strong>，序列号之所以如此重要，是因为它能够防止以下情况出现：</p><ol><li>数据包丢失、超时到达</li><li>数据包重发</li><li>数据包乱序</li></ol></details><p><strong>Q2: 为什么ISN是随机的？</strong></p><details><summary>展开</summary><p>简单来说，随机ISN防止了一些历史数据包和新数据包的冲突以及ISN欺骗攻击。</p><p><strong>数据包冲突问题</strong><br>如果ISN每次开始都是固定的、静止的起始值。想象如下一个场景：如果初始ISN固定为0，旧连接已经断开，因为网络问题旧数据包1-10仍残存于网络中。如果某时刻复用此旧链接，ISN又从0开始，那么新的数据包1-10和旧的数据包1-10有可能发生冲突。所以解决办法就是动态地随着时间增长生成ISN。但是这样同样存在下面的安全问题。</p><p><strong>ISN欺骗攻击</strong><br>如果ISN是根据当前时间计算，那么服务器生成的ISN有可能被破解，这就有可能发生ISN猜测攻击。下面是一个攻击场景<a href="#refer-anchor-5"><sup>[9]</sup></a>：现在我们有三台主机A、B、C</p><p>HOST A &lt;—-&gt; HOST B<br>^<br>|<br>|<br>HOST C</p><p>在这里，主机A和主机B是受信任的主机。主机A接受来自主机B的连接，因为它是受信任的源。此处的识别参数只是ip地址（示例是rlogin应用程序，网络中的主机受信任并允许执行命令。请参阅rlogin以查看其工作原理）</p><p>现在，HOST C想要欺骗主机B并与A建立连接。步骤如下：</p><ol><li>C（欺骗B）—-&gt;将SYN数据包发送给A，序列号为ISN_C。欺骗手段C发送以IP地址B作为源IP的数据包。</li><li>A用具有自己的序列号的SYN（ISN_A）+ ACK（ISN_C + 1）数据包响应SYN。但这不会达到C。这是因为B是受信任的源，并且A可以直接向B发送数据。A向B发送一个SYN + ACK数据包。但是B对此一无所知，并且可以选择重置连接。在这一阶段，我们必须通过使B充满垃圾数据包来使B保持忙碌，以便它不会响应A</li><li>现在，C知道ISN_C，但不知道ISN_A，因为它没有收到数据包。如果<strong>C可以预测ISN_A</strong>，则可以发送具有确认号ISN_A + 1的第三个ACK数据包。这样，我们与A建立了3种方式的握手。（通过具有可预测的序列号，我们可以建立连接。）</li></ol><p>现在我们可以将命令从C发送到A，它将执行该命令，因为我们正在欺骗可信任的源。这是一个严重的安全问题。同样，我们可以重置连接或将数据注入流中。</p><p>当然，上述攻击方式是有限制的：<br>1.如果C与A＆B在同一个网络中，并且可以嗅探数据包，则只需嗅探数据包就可以轻松看到ISN。随机序列号不会阻止这种情况。如果您与A和B位于不同的网络上，则可以防止受到攻击。</p><p>2.由于存在可信源（rlogin，rsh等）的概念且未进行任何加密，因此可能会发生这种攻击。如果具有任何类型的加密，则这种欺骗将不起作用。</p><p><strong>ISN计算公式</strong><br><a href="https://www.ietf.org/rfc/rfc1948.txt">RFC1948 Defending Against Sequence Number Attacks</a>提出的ISN计算方法如下：</p><blockquote><p>ISN = M + F(localhost, localport, remotehost, remoteport).</p></blockquote><p>其中M是一个4微妙计时器，F是一个秘密的hash算法。这防止了一部分ISN猜测攻击</p></details><p><strong>Q3：SYN泛洪攻击是什么？如何防范？</strong></p><details><summary>展开</summary><p>SYN泛洪攻击时大量tcp连接发送到服务器，但是只进行前两次握手，导致服务器的资源无法释放。</p><p>解决策略： 当服务器接受到 SYN 报文段时，不直接为该 TCP 分配资源，而只是打开一个半开的套接字。接着会使用 SYN 报文段的源Id，目的Id，端口号以及只有服务器自己知道的一个秘密函数生成一个 cookie，并把 cookie 作为序列号响应给客户端。</p><p>如果客户端是正常建立连接，将会返回一个确认字段为 cookie + 1 的报文段。接下来服务器会根据确认报文的源Id，目的Id，端口号以及秘密函数计算出一个结果，如果结果的值 + 1等于确认字段的值，则证明是刚刚请求连接的客户端，这时候才为该 TCP 分配资源</p><p>这样一来就不会为恶意攻击的 SYN 报文段分配资源空间，避免了攻击。</p></details><hr><h2 id="2-https的是什么？原理是什么？"><a href="#2-https的是什么？原理是什么？" class="headerlink" title="2. https的是什么？原理是什么？"></a>2. https的是什么？原理是什么？</h2><p>https全称为Hyper Text Transfer Protocol over Secure Socket Layer，也就是对http数据包使用tls/ssl协议加密。那么https的原理就是tls协议是如何工作的。</p><p>tls协议简单来说就是将http的明文数据包加密后再发送，那么如何同步客户端与服务端的加密套件、密钥呢？这些前提工作都会在tls握手的时候完成，这是我们需要重点理解的。</p><p>对于加密套件，我们都知道对称密钥算法的强度高，难破解。所以我们只需要为客户端和服务端同步一个对称加密算法。但是对称密钥在网络中的同步是十分困难的。所以对称密钥的同步是tls握手的重点，这一操作又称为密钥协商算法。常用的密钥协商算法分为基于RSA和基于DH两种类型。</p><p><strong>I. 基于RSA的密钥协商算法</strong></p><p>基于RSA的协商算法较为简单：客户端首先生成一个随机数，并使用服务端的公钥加密生成密文发送给服务端，服务端利用自己的私钥解密即可获得服务端生成的随机数。</p><p>但是<strong>RSA密钥交换的简单性是它最大的弱点</strong>。用于加密pre master key的服务器公钥，一般会保持多年不变。任何能够接触到对应私钥的人都可以解密第三个随机数，并构建相同的master key，从而危害到会话安全性。只要密钥泄露，就可以解密之前记录的所有流量了。</p><p><strong>基于DH的协商算法</strong></p><p>DH密钥协商基于一个数学难题，这个不详细介绍。我们只需要知道，对于求模公式<code>b = a^x mod p</code>：已知a计算b很容易，但是已知b计算a却很困难<a href="#refer-anchor-6"><sup>[10]</sup></a>，其中参数a、p均公开。</p><p>使用DH协商密钥的流程如下：</p><ol><li><p>服务器决定a、p两个参数，同时服务器首先生成一个随机数Xs，计算Ys=a^Xs mod p，将参数a、p和Ys发送给客户端，Xs保密</p></li><li><p>客户端生成随机数Xc，计算Yc=a^Xc mod p，发送给服务器，Xc保密</p></li><li><p>客户端利用公式Kc = Ys^Xc mod p计算公钥，服务器利用公式Ks = Yc^Xs mod p计算密钥，最终Kc和Ks一定相同，证明见<a href="#refer-anchor-6"><sup>[10]</sup></a>。</p></li></ol><p>现在比较流程的基于DH的协商算法有ECDH（elliptic curve Diffie-Hellman），ECDH仅仅将基于求模的数学难题替换为基于椭圆曲线的数学难题，后者同样会选择合适的参数a和p。</p><p>tls将密钥分为了三个部分：</p><ol><li>客户端生成的随机数</li><li>服务端生成的随机数</li><li>pre master key</li></ol><p>tls最终会基于这三个部分计算最终的master key。其中前两个随机数的协商较为简单，明文传输即可；对于pre master key的协商则会应用上述基于RSA或DH的协商算法。<br><strong>II. tls流程分析</strong></p><p>tls的握手流程如下所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/tls-workflow.drawio.svg" alt="tls-workflow"></p><p>接下来我们根据抓取访问淘宝的数据包来分析上图的各个阶段，我访问的ip地址为<code>140.205.94.189</code>，实际的握手数据包如下所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.taobao-tls.png" alt="top-questions-for-network.taobao-tls"></p><p><strong>A. Client Hello</strong></p><p>该阶段就是客户端向服务器发起tls认证，向客户端发送了第一个随机数，,并声明客户端支持的算法套件。内容如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.client-hello.png" alt="top-questions-for-network.client-hello"></p><p><strong>B. Server hello</strong></p><p>该阶段确定了密钥算法，并向客户端发送了第二个随机数，如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.server-hello.png" alt="top-questions-for-network.server-hello"><br><strong>C. Certificate</strong></p><p>该阶段将服务器的证书发送给客户端验证，如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.certificate.png" alt="top-questions-for-network.certificate"></p><p><strong>D. Server key Exchange</strong></p><p>该阶段服务器会选择好a、p两个参数（这里的协商算法基于ECDH），并计算出Ys发送给客户端，如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.server-key-exchange.png" alt="top-questions-for-network.server-key-exchange"></p><p><strong>E. client key Excnahge</strong></p><p>该阶段客户端将自己的Yc发送给服务端，如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.client-key-exchange.png" alt="top-questions-for-network.client-key-exchange"></p><p><strong>F. Change Chiper Spec</strong></p><p>客户端和服务端都会存在该阶段，这一阶段表示握手需要的信息发送完毕了，下面就可以使用生成的master key加密数据传输了。</p><p><strong>G. New Session Ticket</strong></p><p>该阶段的工作就是服务器传递给客户端一个Session用以维持https连接，不然每次都像上面这么连接是十分浪费资源的，此次传递的session如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.session-ticket.png" alt="top-questions-for-network.session-ticket"></p><p>至此，同步了session后，客户端和服务端的握手流程结束，可以使用协商好的master key进行加密与解密了。</p><hr><p>扩展问题：</p><p><strong>Q1：tls为什么要使用两个随机数？</strong></p><details><summary>展开</summary><p>以下答案摘自<a href="https://coolcao.com/2018/08/06/https/">https运行原理解析笔记</a>：</p><blockquote><p>前两个随机数采用明文传输，存在被拦截的风险，最终对话密钥安全性只和第三个随机数有关，那么前两个随机数有没有必要？<br>“不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来*<em>保证协商出来的密钥的随机性</em>8。</p></blockquote><blockquote><p>对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。</p></blockquote><blockquote><p>pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。”</p></blockquote><p>所以简单来说，采用三个随机数是为了是最终的对话密钥更“随机”。</p></details><p><strong>Q2：tls使用的证书了解吗</strong></p><details><summary>展开</summary><p>证书按照认证等级可以划分为DV、OV、IV、EV，从左到右，安全性依次增强，当然价格也依次增高。</p><p>数字证书的作用就相当于我们的身份证。对于一个网站A来说，它没办法向客户端证明它是A，就好像我们证明自己身份时需要借助身份证一样。所以这时一般需要借助一个权威的机构来做信用背书，这个权威的机构向客户端证明网站A的真实性。我们是可以完全相信这些权威机构的，所以间接的，我们就相信网站A真的是它自己了。这里的权威机构就是CA（Certificate Authority）。</p><p>那么这里存在一个问题，CA证明我们的网站是真的，那么谁来证明这些CA是真的？答案很简单：因为CA是有等级的，会构成一条形如：网站A-&gt;普通CA-&gt;中等CA-&gt;顶级CA的信用链。顶级CA没有理由作假，因为没有必要砸自己的饭碗。所以顶级CA证明自己的方法就是在给自己颁发的证书上自签名，这一类自己给自己证明的证书叫<strong>自签证书</strong>，又称<strong>根证书</strong>。浏览器和操作系统一般都会将可信度的根证书内置，方便认证。</p><p>那么CA机构颁发数字证书的一般流程是怎么样的呢？</p><ol><li>首先向CA机构提供CSR(certificate signing request),CSR大致个人信息和公钥</li><li>CA验证我们提交的信息，主要是验证我们是否对域名有真正的控制权。如果验证通过，则会使用我们提交的CSR和公钥生成对应的CA证书，并使用自己的私钥对CA进行签名</li></ol><p>上述的认证过程肯定是要花钱的，那么是不是我们一定要花钱才能获得数字证书呢？当然不，因为上面曾提到顶级CA会发布自签证书，我们也可以利用开源软件，比如<a href="https://www.gokuweb.com/operation/d95eae05.html">openssl发布自定义自签证书</a>，再用自定义自签证书发布普通的CA证书。哎，那么那些花钱的人是不是傻？有免费的不用？</p><p>天下没有免费的午餐，自签证书虽然不花钱，但是它最大的缺点就是自签证书<strong>非常</strong>容易被伪造。并且浏览器一般无法认证由自定义自签证书签署的CA证书，会出现下面这种情况：</p><p><img src="images/self-signed.png" alt="self-signed"></p><p>这时因为自签根证书没有内置，信用链的顶部没有可信度。当然我们可以把自定义自签证书安装在浏览器中，就不会出现这种问题。当然，这可能会遭受中间人攻击。</p><p>自签名根证书可能被伪造，如果在主机中安装了伪造的根证书，这时中间人使用了伪造的自签名证书，就不会出现错误提示，劫持了正常流量，这样中间人和主机之间使用自签名的伪造证书建立了https链接，而中间人又和目标网站使用网站正规的CA证书建立了https链接，那么流量对于中间人来说，完全是明文的</p></details><p><strong>Q3：https一定安全吗？</strong></p><details><summary>展开</summary><p><strong>只要我们不信任不安全的CA的证书，https就是安全的。</strong></p><p>因为权威CA签署的证书不容易被篡改。如果篡改了证书内容，新的摘要无法使用CA机构的私钥加密。那么当客户端使用CA机构的公钥解密摘要时，明文和客户端自己计算的证书摘要对不上号，导致证书不被信任，拒绝连接。</p><p>当然仍然有办法攻破https，我发现了两个可能成功的办法：</p><p><strong>方法1：DNS欺骗+安装自定义根证书</strong></p><p>但是上面曾说道，我们可以发布自定义自签根证书，我们使用<a href="https://blog.cuiyongjian.com/safe/https-attack/">dns劫持+伪造证书</a>开展中间人攻击，https将不再安全。攻击方法如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/https-hijack.drawio.svg" alt="https-hijack"></p><p>攻击前提是攻击者已经预先在主机中安装了自签名的根证书A，然后基本的攻击场景如下：</p><ol><li>首先主机对目标网站发起https连接，这时通过<strong>dns劫持</strong>将流量定向到攻击者的机器上</li><li>攻击者返回使用自定义根证书A签名的CA证书，这时由于根证书已经预先安装到主机上，浏览器不会发出警告。所以主机与攻击者之间建立了https连接，主机发送的数据对攻击者来说完全是可见的</li><li>攻击者再与真正的目标网站建立https连接，将主机发送给自己的数据完全转发到目标网站，同理网站的响应数据也将由攻击者转发到主机上</li></ol><p>经过上述的步骤，主机似乎与网站建立了安全的https连接，但是数据完全被中间人窃听了。</p><p><strong>方法2：sslStrip</strong></p><p>SSLStrip<a href="#refer-anchor-11"><sup>[15]</sup></a>方法也是中间人攻击一种。攻击前提时用户使用http发起第一次连接，因为用户一般只会写域名，而不会声明特定的协议。</p><p>该方法的核心操作是利用arp欺骗或dns欺骗将主机流量定向到攻击者机器上并建立http连接，而攻击者与目标网站建立真正的https连接。</p><p>那么如何防范上述攻击呢？这要从客户端和服务端两个方面防范：</p><ul><li>服务端：开启HSTS，拒绝http连接等等</li><li>客户端：不要相信不安全的证书、不要使用http连接</li></ul></details><p><strong>Q4：http如何升级为https？</strong></p><details><summary>展开</summary><p>将http升级为https的方法一般以下两种方法：</p><ol><li>302重定向</li><li>服务端开启HSTS(HTTP Strict Transport Security)<a href="#refer-anchor-8"><sup>[12]</sup></a></li></ol><p>重定向的方法很简单，简单让浏览器重定向访问即可，但是非常不安全。因为第一次连接使用http协议的，这有可能被劫持实施SSLStrip。而且即便当前连接是https，页内的连接仍有可能是http的，又给了黑客一次机会。所以这种方法很不安全。</p><p>上面的缺陷可以总结为两点：</p><ul><li>用户书签是http或者手动输入了http</li><li>https连接的页面内可能有http连接</li></ul><p>而HSTS能够在一定程度上解决上面的缺陷。因为开启HSTS后，浏览器内部会将http使用307重定向为https，并且HSTS还能够完全拒绝危险的证书。因为上面曾说过，浏览器虽然会对自签证书发出警告，但是用户可以选择忽略警告，继续访问，如下图所示：</p><p><img src="images/HSTS.png" alt="hsts"></p><p>HSTS则不会显示此选项，用户不能忽略警告。</p><p><strong>HSTS开启的方法</strong></p><p>只需要在http添加以下内容即可：</p><blockquote><p>Strict-Transport-Security: max-age=31536000; includeSubDomains</p></blockquote><p>其中<code>max-age</code>表示HSTS有效的时间。</p><p><strong>HSTS的缺陷</strong></p><p>HSTS虽然厉害，但仍然有缺点：用户首次访问某网站是不受HSTS保护的。这是因为首次访问时，浏览器还未收到HSTS，所以仍有可能通过明文HTTP来访问。解决这个问题的方法有两点<a href="#refer-anchor-10"><sup>[14]</sup></a>：</p><p>一是浏览器预置HSTS域名列表，Google Chrome、Firefox、Internet Explorer和Spartan实现了这一方案。google坚持维护了一个“HSTS preload list”的站点域名和子域名，并通过<a href="https://hstspreload.appspot.com/">https://hstspreload.appspot.com/</a>提交其域名。该域名列表被分发和硬编码到主流的web浏览器。客户端访问此列表中的域名将主动的使用HTTPS，并拒绝使用HTTP访问该站点。</p><p>二是将HSTS信息加入到域名系统记录中。但这需要保证DNS的安全性，也就是需要部署域名系统安全扩展。截至2014年这一方案没有大规模部署。</p></details><hr><h2 id="3-tcp的断开机制？"><a href="#3-tcp的断开机制？" class="headerlink" title="3. tcp的断开机制？"></a>3. tcp的断开机制？</h2><p>tcp的断开有两种情况：理想情况下的三次握手，或者<strong>半关闭</strong>的四次握手。</p><p>因为tcp是双工的，所以当tcp断开来接时，收发两端都需要确定对方收到了自己准备要断开连接的信息。所以与tcp建立连接的三次握手类似，在理想情况下，三次握手就能够保证收发两端收到足够的信息断开连接。过程如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.tcp-remove-three-handshake.png" alt="top-questions-for-network.tcp-remove-three-handshake"></p><p>而所谓的半关闭，是指在一方断开了连接的请款下，另一方仍能够发送剩余的信息。半关闭就需要四次握手才能传递足够的信息,这是因为理想情况下的第二次握手被拆分成了两次。如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.tcp-remove-four-handshake.png" alt="top-questions-for-network.tcp-remove-four-handshake"></p><hr><p>扩展问题</p><p><strong>Q1：TIME_WAIT状态了解吗？</strong></p><p>tcp连接与释放的过程中，会形成11种状态，如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.11-status.png" alt="top-questions-for-network.11-status"></p><p>而<code>TIME_WAIT</code>状态是<strong>断开</strong>连接时<strong>主动方独有</strong>的状态。当主动方进入该状态时，等待2MSL后，才会完全释放当前资源。</p><p>我们以半关闭四次握手的状态转化为例，了解什么时候会进入该状态：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.time-wait-status-in-four.png" alt="top-questions-for-network.time-wait-status-in-four"></p><p>从上图中看出，当主动方发出FIN后，会经历FIN-WAIT-1 –&gt; FIN-WAIT-2 –&gt; TIME-WAIT  –&gt; CLOSED的状态转化。</p><p>而被动方第一次收到主动方的FIN后，会经历CLOSE-WAIT –&gt; LAST-ACK –&gt; CLOSED状态。</p><p><strong>Q2：TIME_WAIT为什么被设置为2MSL？</strong></p><p>有两点原因<a href="#refer-anchor-13"><sup>[17]</sup></a>：</p><ol><li>防止复用旧链接的ip、端口建立新链接时，旧链接的数据包还存活</li><li>保证tcp正确的被关闭，即被动关闭一方收到ACK</li></ol><p>首先MSL（maximum segment lifetime）是segment能够在网络中存活的最长时间。那么为什么2MSL就能保证旧链接的数据包不会存活呢？</p><p>在进入TIME-WAIT状态后，主动方会发送ACK，这个ACK最坏在刚好经过1MSL时，到达了被动收方。而被动收方在ACK到达前一直在重发FIN。如果在0.9999MSL时，被动收方发送了最后一个FIN，它最多在网络中存活1MSL。那么主动收方等待2MSL后，主动方发送的最后一个ACK、被动方发送的最后一个FIN都会在网络中消失。<br>那么旧链接的普通数据包肯定会在最后一个ACK和FIN之前发出，所以普通数据包也肯定会在网络中消失。</p><p>当主动方每次收到FIN,会重设2MSL的等待时间。</p><p>如果Server在长时间收不到ACK，重传FIN的次数达到某一设定值时，会向Client发送RESET报文段，表明“异常终止”，然后完全结束本次TCP连接（它不再操心客户是否收到RESET报文段），避免无限占用资源。（对应上图中的Stop Sending FIN)</p><hr><h2 id="4-tcp是如何保证可靠性的？"><a href="#4-tcp是如何保证可靠性的？" class="headerlink" title="4. tcp是如何保证可靠性的？"></a>4. tcp是如何保证可靠性的？</h2><p>保障可靠性主要有三个方面：流量控制、差错控制（校验和、确认机制、超时机制）、拥塞控制。</p><p>流量控制仅仅是考虑两台机器之间的传输能力，而拥塞控制则考虑了网络传输的能力。</p><h2 id="5-tcp的流量控制？"><a href="#5-tcp的流量控制？" class="headerlink" title="5. tcp的流量控制？"></a>5. tcp的流量控制？</h2><p>流量控制通过滑动窗口来实现，并且发送方的窗口通过接收方来控制。接收方会维护一个名为<code>rwind</code>的滑动窗口。还需更新</p><p>一般有一个要求：<br>新的ackNo+新rwnd&gt;=旧的ackNo+旧rwnd，也就是说滑动窗口的右沿一般不移动</p><hr><p><strong>Q1：糊涂窗口综合症是什么？如何避免？</strong></p><p>糊涂窗口综合症有两种：发方糊涂和收方糊涂。</p><p><strong>发方糊涂</strong>是指发送方每次发送的数据很少，极端情况下有效数据仅有一个字节，而tcp头部达到四十字节，极大降低效率。解决办法是nagle算法：</p><ol><li>nagle算法定义是任意时刻，最多只能有一个未被确认的小段。 所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。流程如下图所示：</li></ol><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.nagle.png" alt="top-questions-for-network.nagle"></p><p><strong>收方糊涂</strong>是指收方处理数据很慢，每次都只能处理一个字节，而发送方一次也只能发送一个字节。处理的方法一般有以下两种：</p><ol><li><p>延迟确认，这表示当一个报文段到达时并不立即发送确认。接收端在确认收到的报文段之前一直等待，直到缓存有足够的空间为止。</p></li><li><p>Clark解决方法，这表示只要有数据到达就发送确认，但宣布的窗口大小为零，直到或者缓存空间已能放入具有最大长度的报文段，或者缓存空间的一半已经空了。</p></li></ol><hr><h2 id="6-tcp的拥塞控制？"><a href="#6-tcp的拥塞控制？" class="headerlink" title="6. tcp的拥塞控制？"></a>6. tcp的拥塞控制？</h2><p>tcp提出了四种拥塞策略：慢启动，拥塞避免，快速重传，快恢复。而实际的拥塞算法可以按照判断拥塞的标准分为基于丢包的拥塞算法和基于网络延迟的拥塞算法<a href="#refer-anchor-14"><sup>[18]</sup></a>：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.base-packet-loss.png" alt="top-questions-for-network.base-packet-loss"><br><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.base-time.png" alt="top-questions-for-network.base-time"></p><p>而上述四种拥塞策略主要应用在传统的基于丢包的拥塞算法上：</p><ul><li>taho：采用慢启动和拥塞避免策略。并且用相同的拥塞策略对待超时和三次ACk</li><li>reno：采用慢启动、拥塞避免、快速恢复策略</li><li>new reno：采用慢启动、拥塞避免、快速恢复策略</li></ul><p>以下内容详细介绍了这四种策略的步骤，以及在三种算法中的应用。引自<a href="https://www.cnblogs.com/fll/archive/2008/06/10/1217013.html">TCP拥塞控制算法</a>：</p><p>最初由V. Jacobson在1988年的论文中提出的TCP的拥塞控制由“慢启动(Slow start)”和“拥塞避免(Congestion avoidance)”组成，后来TCP Reno版本中又针对性的加入了“快速重传(Fast retransmit)”、“快速恢复(Fast Recovery)”算法，再后来在TCP NewReno中又对“快速恢复”算法进行了改进，近些年又出现了选择性应答( selective acknowledgement,SACK)算法。</p><p>TCP的拥塞控制主要原理依赖于一个拥塞窗口(cwnd)来控制，在之前我们还讨论过TCP还有一个对端通告的接收窗口(rwnd)用于流量控制。TCP的拥塞控制算法就是要在这两者之间权衡，选取最好的cwnd值，从而使得网络吞吐量最大化且不产生拥塞，一般来说选择min(cwind,rwind)。</p><p>关于cwnd的单位，在TCP中是以<strong>字节</strong>来做单位的，我们假设TCP每次传输都是按照MSS大小来发送数据的，因此你可以认为cwnd按照数据包个数来做单位也可以理解，所以有时我们说cwnd增加1也就是相当于字节数增加1个MSS大小。</p><p><strong>I. 慢启动</strong></p><p>最初的TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此新建立的连接不能够一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量，以避免上述现象的发生。具体来说，当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加1个MSS大小。这样cwnd的值就随着网络往返时间(Round Trip Time,RTT)呈指数级增长，事实上，慢启动的速度一点也不慢，只是它的起点比较低一点而已。我们可以简单计算下：</p><ol><li><p>开始           —&gt;     cwnd = 1</p></li><li><p>经过1个RTT后   —&gt;     cwnd = 2*1 = 2</p></li><li><p>经过2个RTT后   —&gt;     cwnd = 2*2= 4</p></li><li><p>经过3个RTT后   —&gt;     cwnd = 4*2 = 8</p></li></ol><p>如果带宽为W，那么经过RTT*log2W时间就可以占满带宽。</p><p><strong>II. 拥塞避免</strong></p><p>从慢启动可以看到，cwnd可以很快的增长上来，从而最大程度利用网络带宽资源，但是cwnd不能一直这样无限增长下去，一定需要某个限制。TCP使用了一个叫慢启动门限(ssthresh)的变量，当cwnd超过该值后，慢启动过程结束，进入拥塞避免阶段。对于大多数TCP实现来说，ssthresh的值是65536(同样以字节计算)。<strong>拥塞避免的主要思想是加法增大，也就是cwnd的值不再指数级往上升，开始加法增加</strong>。此时当窗口中所有的报文段都被确认时，cwnd的大小加1，cwnd的值就随着RTT开始线性增加，这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。</p><p>上面讨论的两个机制都是没有检测到拥塞的情况下的行为，那么当发现拥塞了cwnd又该怎样去调整呢？</p><p>首先来看TCP是如何确定网络进入了拥塞状态的，<strong>TCP认为网络拥塞的主要依据是它重传了一个报文段</strong>。上面提到过，TCP对每一个报文段都有一个定时器，称为重传定时器(RTO)，当RTO超时且还没有得到数据确认，那么TCP就会对该报文段进行重传，当发生超时时，那么出现拥塞的可能性就很大，某个报文段可能在网络中某处丢失，并且后续的报文段也没有了消息，在这种情况下，TCP反应比较“强烈”：</p><ol><li><p>把ssthresh降低为cwnd值的一半</p></li><li><p>把cwnd重新设置为1</p></li><li><p>重新进入慢启动过程。</p></li></ol><p>从整体上来讲，TCP拥塞控制窗口变化的原则是AIMD原则，即加法增大、乘法减小。可以看出TCP的该原则可以较好地保证流之间的公平性，因为一旦出现丢包，那么立即减半退避，可以给其他新建的流留有足够的空间，从而保证整个的公平性。</p><p>其实TCP还有一种情况会进行重传：那就是收到3个相同的ACK。TCP在收到乱序到达包时就会立即发送ACK，TCP利用3个相同的ACK来判定数据包的丢失，此时进行<strong>快速重传</strong>，快速重传做的事情有：</p><ol><li><p>把ssthresh设置为cwnd的一半</p></li><li><p>把cwnd再设置为ssthresh的值(具体实现有些为ssthresh+3)</p></li><li><p>重新进入拥塞避免阶段。</p></li></ol><p><strong>III. 快速恢复</strong></p><p>后来的快速恢复算法是在上述的“快速重传”算法后添加的，当收到3个重复ACK时，TCP最后进入的不是拥塞避免阶段，而是快速恢复阶段。快速重传和快速恢复算法一般同时使用。快速恢复的思想是“数据包守恒”原则，即同一个时刻在网络中的数据包数量是恒定的，只有当“老”数据包离开了网络后，才能向网络中发送一个“新”的数据包，如果发送方收到一个重复的ACK，那么根据TCP的ACK机制就表明有一个数据包离开了网络，于是cwnd加1。如果能够严格按照该原则那么网络中很少会发生拥塞，事实上拥塞控制的目的也就在修正违反该原则的地方。</p><p>具体来说快速恢复的流程如下所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.reno.png" alt="top-questions-for-network.reno"></p><ol><li><p>当收到3个重复ACK时，把ssthresh设置为cwnd的一半，把cwnd设置为ssthresh的值加3，然后重传丢失的报文段，加3的原因是因为收到3个重复的ACK，表明有3个“老”的数据包离开了网络。 </p></li><li><p>再收到重复的ACK时，拥塞窗口增加1。</p></li><li><p>当收到新的数据包的ACK时，把cwnd设置为第一步中的ssthresh的值。原因是因为该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。</p></li></ol><p>快速重传算法首次出现在4.3BSD的Tahoe版本，快速恢复首次出现在4.3BSD的Reno版本，也称之为Reno版的TCP拥塞控制算法。</p><p>可以看出Reno的快速重传算法是针对一个包的重传情况的，然而在实际中，一个重传超时可能导致许多的数据包的重传，因此当多个数据包从一个数据窗口中丢失时并且触发快速重传和快速恢复算法时，问题就产生了。因此NewReno出现了，它在Reno快速恢复的基础上稍加了修改，可以恢复一个窗口内多个包丢失的情况。具体来讲就是：Reno在收到一个新的数据的ACK时就退出了快速恢复状态了，而NewReno需要收到该窗口内所有数据包的确认后才会退出快速恢复状态，从而更一步提高吞吐量。</p><p>SACK就是改变TCP的确认机制，最初的TCP只确认当前已连续收到的数据，SACK则把乱序等信息会全部告诉对方，从而减少数据发送方重传的盲目性。比如说序号1，2，3，5，7的数据收到了，那么普通的ACK只会确认序列号4，而SACK会把当前的5，7已经收到的信息在SACK选项里面告知对端，从而提高性能，当使用SACK的时候，NewReno算法可以不使用，因为SACK本身携带的信息就可以使得发送方有足够的信息来知道需要重传哪些包，而不需要重传哪些包。</p><h2 id="7-加不加www有什么区别？"><a href="#7-加不加www有什么区别？" class="headerlink" title="7. 加不加www有什么区别？"></a>7. 加不加www有什么区别？</h2><p>其实是因为早期服务器资源有限，一个服务器往往要承担多项任务，所以在主域名前面加子域名<code>www</code>表示万维网服务<a href="#refer-anchor-12"><sup>[16]</sup></a>，例如<code>www.example.com</code>表示互联网，<code>mail.example.com</code>表示邮件服务。</p><p>而后来资源丰富，仍然加上www仅仅是为了纪念万维网的建立，</p><h2 id="8-http常用的状态码有哪些？"><a href="#8-http常用的状态码有哪些？" class="headerlink" title="8. http常用的状态码有哪些？"></a>8. http常用的状态码有哪些？</h2><ol><li>2xx状态码：操作成功。200 OK</li><li>3xx状态码：重定向。301 永久重定向；302暂时重定向</li><li>4xx状态码：客户端错误。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found；</li><li>5xx状态码：服务端错误。500服务器内部错误；501服务不可用</li></ol><h2 id="9-既然IP层已经分片了，TCP为什么还要分段？"><a href="#9-既然IP层已经分片了，TCP为什么还要分段？" class="headerlink" title="9. 既然IP层已经分片了，TCP为什么还要分段？"></a>9. 既然IP层已经分片了，TCP为什么还要分段？</h2><p>因为ip是没有重传机制的，如果tcp不分段，那么如果ip层丢失了某个报文片，就需要重传整个报文。</p><h2 id="10-GET和POST的区别？"><a href="#10-GET和POST的区别？" class="headerlink" title="10. GET和POST的区别？"></a>10. GET和POST的区别？</h2><ol><li><p>POST与相比GET，A通常在请求主体中具有相关信息。（一个GET不应该有主体，因此除了cookie之外，唯一可以传递信息的地方就是URL。）除了保持URL相对整洁之外，POST还可以让您发送更多的信息（由于URL的长度受到限制，因此在实际操作中用途），并让您几乎可以发送任何类型的数据（例如，文件上传表单不能使用GET-它们必须使用，还要POST加上特殊的内容类型/编码）。</p></li><li><p>除此之外，POST表示请求将更改某些内容，并且不应随意重做。这就是为什么您有时会在单击“后退”按钮时看到浏览器询问您是否要重新提交表单数据的原因。</p></li><li><p>GET另一方面，它应该是幂等的，这意味着您可以做一百万次，并且服务器每次都会做相同的事情（并且基本上显示出相同的结果）</p></li><li><p>最后，在使用AJAX发送GET请求时，一个重要的考虑因素是某些浏览器（尤其是IE）会缓存GET请求的结果。因此，例如，如果您使用相同的GET请求进行轮询，即使您正在查询的数据正在服务器端更新，您也将始终获得相同的结果。缓解此问题的一种方法是，通过附加时间戳使每个请求的URL唯一。</p></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><div id="refer-anchor-1"></div><p>[1] <a href="https://www.pythonthree.com/what-is-cname/">什么是CNAME记录？CNAME记录如何使用</a></p><div id="refer-anchor-1"></div><p>[2] <a href="https://www.zhihu.com/question/29998374">顶级域名 一级域名 二级域名 三级域名什么区别?</a></p><div id="refer-anchor-3"></div><p>[3] <a href="https://blog.csdn.net/lnboxue/article/details/52220928">一步一步学习IP路由流程</a></p><p>[4] <a href="https://cloud.tencent.com/developer/article/1173761">转发表(MAC表)、ARP表、路由表总结</a></p><p>[5] <a href="https://www.cnblogs.com/michael9/p/13345911.html">数据包的通信过程</a></p><p>[6] <a href="https://zhuanlan.zhihu.com/p/21392419">浅谈路由协议</a></p><div id="refer-anchor-4"></div><p>[7] <a href="https://draveness.me/whys-the-design-tcp-three-way-handshake/">为什么 TCP 建立连接需要三次握手</a></p><p>[8] <a href="https://developer.aliyun.com/article/742739">阿里面试官： HTTP、HTTPS、TCP/IP、Socket通信、三次握手四次挥手过程？（附全网最具深度的三次握手、四次挥手讲解）</a></p><div id="refer-anchor-5"></div><p>[9] <a href="https://www.quora.com/Why-in-a-TCP-sequence-is-a-number-taken-as-a-random-number-and-what-is-the-actual-number-at-the-start">Why in a TCP sequence, is a number taken as a random number and what is the actual number at the start?</a></p><div id="refer-anchor-6"></div><p>[10] <a href="http://wsfdl.com/algorithm/2016/02/04/%E7%90%86%E8%A7%A3Diffie-Hellman%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95.html">理解 Deffie-Hellman 密钥交换算法</a></p><div id="refer-anchor-7"></div><p>[11] <a href="https://razeencheng.com/post/ssl-handshake-detail">HTTPS篇之SSL握手过程详解</a></p><div id="refer-anchor-8"></div><p>[12] <a href="https://www.acunetix.com/blog/articles/what-is-hsts-why-use-it/">What Is HSTS and Why Should I Use It?</a></p><div id="refer-anchor-9"></div><p>[13] <a href="https://www.digitalocean.com/community/tutorials/understanding-nginx-http-proxying-load-balancing-buffering-and-caching">Understanding Nginx HTTP Proxying, Load Balancing, Buffering, and Caching</a></p><div id="refer-anchor-10"></div><p>[14] <a href="https://blog.csdn.net/weixin_44316575/article/details/103698819">nginx启用HSTS以支持从http到https不通过服务端而自动跳转</a></p><div id="refer-anchor-11"></div><p>[15] <a href="https://jjayyyyyyy.github.io/2017/04/27/HSTS.html">HSTS学习笔记</a></p><div id="refer-anchor-12"></div><p>[16] <a href="https://www.zhihu.com/question/20064691">为什么有些网址前面没有www？</a></p><div id="refer-anchor-13"></div><p>[17] <a href="https://www.zhihu.com/question/67013338">为什么TCP4次挥手时等待为2MSL？</a></p><div id="refer-anchor-14"></div><p>[18] <a href="https://my.oschina.net/u/3872630/blog/4434563">万字长文|全网最强 TCP/IP 拥塞控制总结…</a></p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/network/">network</category>
      
      
      
      <comments>https://eripe.me/2021-06-04/top-questions-for-network.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java中的类型系统</title>
      <link>https://eripe.me/2021-06-04/type-system-of-java.html</link>
      <guid>https://eripe.me/2021-06-04/type-system-of-java.html</guid>
      <pubDate>Fri, 04 Jun 2021 11:57:44 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>java的类型系统在1.5之后就变的很复杂了。但是又极其重要因为java中的反射基于此。所以想要深入理解反射还需要简单地学习一下java的类型系统。首先我们简要说明一下在逻辑上java的type分类。然后再在实现层次上简要了解一下java到底是如何实现的。</p><p>首先java是一个强类型语言,其任何一个变量、任何一个表达式都有类型。在Java中,总的分为<del>两类</del>三类(还有一个特殊的<code>null type</code>):</p><ul><li>primitive types:原始类型,分类<code>boolean type</code>和<code>numeric type</code>,后者又可以分为<code>integral types</code>和<code>floating-point types</code>。<ul><li>integral types:包括<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>char</code></li><li>floating-point type:包括<code>float</code>和<code>double</code></li></ul></li><li>reference types:包括<code>class types</code>、<code>interface types</code>、<code>array type</code>以及<code>type virables</code></li><li>special type:<code>null type</code></li></ul><blockquote><p>在java中,对象是类的实例或者是动态创建的数组,<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3">参考文献</a></p></blockquote><p>是的,数组也是一个对象。</p><hr><p><strong>Extension：</strong></p><p>这里额外说一下<code>null type</code>,关键字<code>null</code>不是一个类型而是一个特殊的值,可以简答的认为null指向一个特殊的内存区域。我们不能声明一个为<code>null type</code>的引用,也不能将<code>null type</code>声明为类型参数,例如<code>List&lt;null&gt;</code>(<a href="https://stackoverflow.com/questions/26632104/java-kinds-of-type-and-null-reference">参考</a>)。但是<code>null</code>却可以强转为任何类型的引用,转换结果为目标类型的空引用,<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.2">参考</a>。</p><blockquote><p>A value of the null type (the null reference is the only such value) may be assigned to any reference type, resulting in a null reference of that type.</p></blockquote><p>最后,<code>null type</code>不是一个引用类型。</p><hr><h3 id="Reference-Types"><a href="#Reference-Types" class="headerlink" title="Reference Types"></a>Reference Types</h3><p>下面的一段代码使用了四种引用类型(摘自<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3">jse8规范</a>):</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">int</span>[] metrics;<br>    T variables;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Move</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">int</span> deltax, <span class="hljs-keyword">int</span> deltay)</span></span>; &#125;<br></code></pre></div></td></tr></table></figure><p>其中,<code>Point</code>是一个<code>class type</code>(翻译成类类型好难受…),<code>int[]</code>是一个<code>array type</code>,<code>Move</code>是一个<code>interface type</code>,<code>T</code>是一个<code>type variable</code>。前三种都很好理解,最后一个<code>type variable</code>值得一提。</p><p>在jse8规范中,<code>type variable</code>被定义为一个唯一的符号在类、接口、方法、构造函数中作为一个type。所以这个<code>type variable</code>只能在上面四个地方使用。引入<code>type variable</code>的原因是因为在泛型类、泛型接口、泛型构造函数、泛型方法中定义了类型参数。</p><p>所以,很好理解,<code>type variable</code>就是泛型中<code>&lt;T&gt;</code>中的T。注意,<code>type</code></p><p><code>Type</code>接口是java中type信息的顶级接口。主要有五种type,分别是:</p><ul><li><code>raw types</code>:原始类型,使用对应类型的Class对象表示</li><li><code>primitive types</code>:基本类型,使用对应原始类型的Class对象表示</li><li><code>parameterized types</code>:参数类型,基于接口<code>ParameterizedTypes</code>,对应实现类为<code>ParameterizedTypesImpl</code></li><li><code>array types</code>:泛型数组类型,基于接口<code>GenericArrayType</code>,对应实现类为<code>GenericArrayTypeImpl</code></li><li><code>type variables</code>:类型变量,基于接口<code>TypeVariable</code>,对应实现类为<code>TypeVariableImpl</code></li><li><code>WildcardType</code>:通配符类型,基于接口<code>WildcardType</code>,对应实现类为<code>WildcardTypeImpl</code></li></ul><p>其中<code>ParameterizedTypes</code>、<code>GenericArrayType</code>、<code>TypeVariable</code>、<code>WildcardType</code>这四个接口是<code>Type</code>接口的子接口。继承图如下所示:</p><p><img src="images/Type.png" alt="Type继承图"></p><p>可以看到,<code>Class</code>类是<code>Type</code>接口的子类。下面来一一解释一下四种子接口的含义。</p><h2 id="1-ParameterizedType"><a href="#1-ParameterizedType" class="headerlink" title="1. ParameterizedType"></a>1. ParameterizedType</h2><p><code>ParameterizedType</code>翻译过来就是参数化类型,emm。应该就是将类型参数化,这是引入泛型(Generic)的必然结果。例如我们常用的<code>List&lt;Integer&gt;</code>,这一个完整的带<code>&lt;&gt;</code>的类型就叫做参数化类型。下面解释了raw type于parameterized type之间的关系。</p><ul><li>genric type:<code>List&lt;T&gt;</code></li><li>parameterized type:<code>List&lt;Integer&gt;</code></li><li>raw type:<code>List</code></li><li>type parameter:<code>Integer</code></li></ul><p><strong>有如下常用方法</strong>:</p><ul><li><code>Type getRawType()</code>: 返回承载该泛型信息的对象, 如上面那个Map&lt;String, String&gt;承载范型信息的对象是Map</li><li><code>Type[] getActualTypeArguments()</code>: 返回实际泛型类型列表, 如上面那个Map&lt;String, String&gt;实际范型列表中有两个元素, 都是String</li><li><code>Type getOwnerType()</code>: 返回当前成员的属主,例如<code>Map.Entry</code>属于<code>Map</code></li></ul><p>以具体的参数化类型, 如<code>Map&lt;String, String&gt;</code>为例:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestType</span> </span>&#123;<br>    Map&lt;String, String&gt; map;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Field f = TestType.class.getDeclaredField(<span class="hljs-string">&quot;map&quot;</span>);<br>        System.out.println(f.getGenericType());                               <span class="hljs-comment">// java.util.Map&lt;java.lang.String, java.lang.String&gt;</span><br>        System.out.println(f.getGenericType() <span class="hljs-keyword">instanceof</span> ParameterizedType);  <span class="hljs-comment">// true</span><br>        ParameterizedType pType = (ParameterizedType) f.getGenericType();<br>        System.out.println(pType.getRawType());                               <span class="hljs-comment">// interface java.util.Map</span><br>        <span class="hljs-keyword">for</span> (Type type : pType.getActualTypeArguments()) &#123;<br>            System.out.println(type);                                         <span class="hljs-comment">// 打印两遍: class java.lang.String</span><br>        &#125;<br>        System.out.println(pType.getOwnerType());                             <span class="hljs-comment">// null</span><br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="2-TypeVariable"><a href="#2-TypeVariable" class="headerlink" title="2. TypeVariable"></a>2. TypeVariable</h2><p>类型变量, 范型信息在编译时会被转换为一个特定的类型, 而TypeVariable就是用来反映在JVM编译该泛型前的信息.</p><p><strong>常用方法:</strong></p><ul><li><code>Type[] getBounds()</code>: 获取类型变量的上边界, 若未明确声明上边界则默认为Object</li><li><code>D getGenericDeclaration()</code>: 获取声明该类型变量实体,其中<code>D</code>是泛型类型的声明,也就是所在的类全限定名</li><li><code>String getName()</code>: 获取在源码中定义时的名字</li></ul><p>注意:<br>类型变量在定义的时候只能使用extends进行(多)边界限定, 不能用super;为什么边界是一个数组? 因为类型变量可以通过&amp;进行多个上边界限定，因此上边界有多个</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestType</span> &lt;<span class="hljs-title">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span> &amp; <span class="hljs-title">Serializable</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br>    K key;<br>    V value;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获取字段的类型</span><br>        Field fk = TestType.class.getDeclaredField(<span class="hljs-string">&quot;key&quot;</span>);<br>        Field fv = TestType.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>);<br>        Assert.that(fk.getGenericType() <span class="hljs-keyword">instanceof</span> TypeVariable, <span class="hljs-string">&quot;必须为TypeVariable类型&quot;</span>);<br>        Assert.that(fv.getGenericType() <span class="hljs-keyword">instanceof</span> TypeVariable, <span class="hljs-string">&quot;必须为TypeVariable类型&quot;</span>);<br>        TypeVariable keyType = (TypeVariable)fk.getGenericType();<br>        TypeVariable valueType = (TypeVariable)fv.getGenericType();<br>        <span class="hljs-comment">// getName 方法</span><br>        System.out.println(keyType.getName());                 <span class="hljs-comment">// K</span><br>        System.out.println(valueType.getName());               <span class="hljs-comment">// V</span><br>        <span class="hljs-comment">// getGenericDeclaration 方法</span><br>        System.out.println(keyType.getGenericDeclaration());   <span class="hljs-comment">// class com.test.TestType</span><br>        System.out.println(valueType.getGenericDeclaration()); <span class="hljs-comment">// class com.test.TestType</span><br>        <span class="hljs-comment">// getBounds 方法</span><br>        System.out.println(<span class="hljs-string">&quot;K 的上界:&quot;</span>);                        <span class="hljs-comment">// 有两个</span><br>        <span class="hljs-keyword">for</span> (Type type : keyType.getBounds()) &#123;                <span class="hljs-comment">// interface java.lang.Comparable</span><br>            System.out.println(type);                          <span class="hljs-comment">// interface java.io.Serializable</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;V 的上界:&quot;</span>);                        <span class="hljs-comment">// 没明确声明上界的, 默认上界是 Object</span><br>        <span class="hljs-keyword">for</span> (Type type : valueType.getBounds()) &#123;              <span class="hljs-comment">// class java.lang.Object</span><br>            System.out.println(type);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-GenericArrayType"><a href="#3-GenericArrayType" class="headerlink" title="3. GenericArrayType"></a>3. GenericArrayType</h2><p>我们仍然记得,不能创建泛型数组,那么这个<code>GenericArrayType</code>是啥意思?</p><p>虽然不能泛型数组,但是能够创建泛型数组引用啊,<code>T[] nums=null</code>是合法的,见下方代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestType</span> &lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Method method = Test.class.getDeclaredMethods()[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// public void com.test.Test.show(java.util.List[],java.lang.Object[],java.util.List,java.lang.String[],int[])</span><br>        System.out.println(method);<br>        Type[] types = method.getGenericParameterTypes();  <span class="hljs-comment">// 这是 Method 中的方法</span><br>        <span class="hljs-keyword">for</span> (Type type : types) &#123;<br>            System.out.println(type <span class="hljs-keyword">instanceof</span> GenericArrayType);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(List&lt;String&gt;[] pTypeArray, T[] vTypeArray, List&lt;String&gt; list, String[] strings, <span class="hljs-keyword">int</span>[] ints)</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>声明一个泛型数组引用还是没有问题的,运行结果如下:</p><ul><li>第一个参数List<String>[]的组成元素List<String>是ParameterizedType类型, 打印结果为true</li><li>第二个参数T[]的组成元素T是TypeVariable类型, 打印结果为true</li><li>第三个参数List<String>不是数组, 打印结果为false</li><li>第四个参数String[]的组成元素String是普通对象, 没有范型, 打印结果为false</li><li>第五个参数int[] pTypeArray的组成元素int是原生类型, 也没有范型, 打印结果为false</li></ul><p>所以数组元素是<code>ParameterizedType</code>或<code>TypeVariable</code>的数组类型才是<code>GenericArrayType</code>。</p><h2 id="4-WildcardType"><a href="#4-WildcardType" class="headerlink" title="4. WildcardType"></a>4. WildcardType</h2><p>该接口表示通配符泛型, 比如? extends Number 和 ? super Integer 它有如下方法:</p><ul><li>Type[] getUpperBounds(): 获取范型变量的上界</li><li>Type[] getLowerBounds(): 获取范型变量的下界<br>注意:</li></ul><p>现阶段通配符只接受一个上边界或下边界, 返回数组是为了以后的扩展, 实际上现在返回的数组的大小是1</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestType</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;? extends Number&gt; a;  <span class="hljs-comment">// // a没有下界, 取下界会抛出ArrayIndexOutOfBoundsException</span><br>    <span class="hljs-keyword">private</span> List&lt;? <span class="hljs-keyword">super</span> String&gt; b;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Field fieldA = TestType.class.getDeclaredField(<span class="hljs-string">&quot;a&quot;</span>);<br>        Field fieldB = TestType.class.getDeclaredField(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-comment">// 先拿到范型类型</span><br>        Assert.that(fieldA.getGenericType() <span class="hljs-keyword">instanceof</span> ParameterizedType, <span class="hljs-string">&quot;&quot;</span>);<br>        Assert.that(fieldB.getGenericType() <span class="hljs-keyword">instanceof</span> ParameterizedType, <span class="hljs-string">&quot;&quot;</span>);<br>        ParameterizedType pTypeA = (ParameterizedType) fieldA.getGenericType();<br>        ParameterizedType pTypeB = (ParameterizedType) fieldB.getGenericType();<br>        <span class="hljs-comment">// 再从范型里拿到通配符类型</span><br>        Assert.that(pTypeA.getActualTypeArguments()[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> WildcardType, <span class="hljs-string">&quot;&quot;</span>);<br>        Assert.that(pTypeB.getActualTypeArguments()[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> WildcardType, <span class="hljs-string">&quot;&quot;</span>);<br>        WildcardType wTypeA = (WildcardType) pTypeA.getActualTypeArguments()[<span class="hljs-number">0</span>];<br>        WildcardType wTypeB = (WildcardType) pTypeB.getActualTypeArguments()[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 方法测试</span><br>        System.out.println(wTypeA.getUpperBounds()[<span class="hljs-number">0</span>]);   <span class="hljs-comment">// class java.lang.Number</span><br>        System.out.println(wTypeB.getLowerBounds()[<span class="hljs-number">0</span>]);   <span class="hljs-comment">// class java.lang.String</span><br>        <span class="hljs-comment">// 看看通配符类型到底是什么, 打印结果为: ? extends java.lang.Number</span><br>        System.out.println(wTypeA);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>转载自<a href="http://loveshisong.cn/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2016-02-16-Type%E8%AF%A6%E8%A7%A3.html">Java中的Type详解</a>。</p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E5%8F%8D%E5%B0%84/">反射</category>
      
      
      <category domain="https://eripe.me/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">基本概念</category>
      
      <category domain="https://eripe.me/tags/%E7%B1%BB%E5%9E%8B/">类型</category>
      
      
      <comments>https://eripe.me/2021-06-04/type-system-of-java.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>反射初体验</title>
      <link>https://eripe.me/2021-06-04/%E5%8F%8D%E5%B0%84%E5%88%9D%E4%BD%93%E9%AA%8C.html</link>
      <guid>https://eripe.me/2021-06-04/%E5%8F%8D%E5%B0%84%E5%88%9D%E4%BD%93%E9%AA%8C.html</guid>
      <pubDate>Fri, 04 Jun 2021 11:57:44 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h3 id=&quot;0x0-反射是什么&quot;&gt;&lt;a href=&quot;#0x0-反射是什么&quot; class=&quot;headerlink&quot; title=&quot;0x0 反射是什么&quot;&gt;&lt;/a&gt;0x0</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h3 id="0x0-反射是什么"><a href="#0x0-反射是什么" class="headerlink" title="0x0 反射是什么"></a>0x0 反射是什么</h3><p>反射是java中非常重要的一个概念。简而言之，反射就是在程序<strong>运行时</strong>可以<strong>动态</strong>的获取一个类的对象、执行某个类的方法等等。这里采用<a href="https://stackoverflow.com/questions/4453349/what-is-the-class-object-java-lang-class">overflow</a>上的一个回答。</p><blockquote><p>In order to fully understand the class object, let go back in and understand we get the class object in the first place. You see, every .java file you create, when you compile that .java file, the jvm will creates a .class file, this file contains all the information about the class, namely:</p></blockquote><blockquote><p>Fully qualified name of the class<br>Parent of class<br>Method information<br>Variable fields<br>Constructor<br>Modifier information<br>Constant pool<br>The list you see above is what you typically see in a typical class. Now, up to this point, your .java file and .class file exists on your hard-disk, when you actually need to use the class i.e. executing code in main() method, the jvm will use that .class file in your hard drive and load it into one of 5 memory areas in jvm, which is the method area, immediately after loading the .class file into the method area, the jvm will use that information and a Class object that represents that class that exists in the heap memory area.</p></blockquote><blockquote><p>Here is the top level view,<br>.java –compile–&gt; .class –&gt;when you execute your script–&gt; .class loads into method area –jvm creates class object from method area–&gt; a class object is born</p></blockquote><p>With a class object, you are obtain information such as class name, and method names, everything about the class.</p><p>反射机制是通过一个名为Class对象的概念来实现的。在编译每个.java文件后，都会生成一个对应的.class文件。这个.class文件包含了我们所编写的类的所有信息。比如类的全限定名、属性、方法、修饰符等等。然后当我们需要使用所编写的类时（这里记为target），.class文件会被加载至方法区，并且jvm会在堆区创建一个target类对应的Class对象。然后targt类的所有实例都由这个Class对象来产生。</p><p>注意，对于一个类，jvm只会生成一个对应的Class对象。</p><h3 id="0x1-反射有什么用"><a href="#0x1-反射有什么用" class="headerlink" title="0x1 反射有什么用"></a>0x1 反射有什么用</h3><p>反射最主要的作用的我认为就是提高了对未知应用的扩展能力。</p><p>试想一个场景：</p><p>项目的云服务我们最先使用的是阿里云，然后某天不爽想换成腾讯云，然后又换成什么亚马逊，七牛等等，需求不停的在变。如果我们在代码里写死了业务代码，那么每换一次，就要更新一次代码，烦不烦，你说烦不烦。</p><p>那么这是肯定有人想，写个配置文件，到时候我们在代码里判断到底用的是哪个云服务不就完事了？用什么反射，自找麻烦。</p><p>但是想过没有，我们if判断的条件只能是已知的，如果某天市场上杀出一个新的厂商，怎么办？还是得更新业务代码。得重新编译、重新运行。</p><p>所以为了处理这种未知的状况，就不得不使用使用反射了。我们把类名写在配置文件里，然后利用反射加载对应的类，这样以不变应万变。配置文件变化时只需要重新应用就行了，<strong>无需重新编译代码!!!</strong></p><p>当然，这些服务应该还有统一的接口，不然不可能实现一份代码适配多种情况。</p><h3 id="0x2-反射怎么用"><a href="#0x2-反射怎么用" class="headerlink" title="0x2 反射怎么用"></a>0x2 反射怎么用</h3><h4 id="1-获取反射对象"><a href="#1-获取反射对象" class="headerlink" title="1. 获取反射对象"></a>1. 获取反射对象</h4><p>想使用反射，我们必须得首先获得Class对象，获得Class对象的方法有三种：</p><ul><li>使用Class类的静态方法forName，参数为类的全限定名</li><li>直接使用某个类的class属性</li><li>调用某个对象的getClass()方法</li></ul><figure class="highlight java"><figcaption><span>"获取Class对象的三种方式"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//获取class对象的方法有三种</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getClassObject</span><span class="hljs-params">(Employee employee)</span></span>&#123;<br>        <span class="hljs-comment">//第一种通过全限定名获取</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Class c1=Class.forName(<span class="hljs-string">&quot;ReflectionBase.Employee&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">//第二种通过类的class属性获取</span><br>        Class&lt;ReflectionBase.Employee&gt; c2=Employee.class;<br><br>        <span class="hljs-comment">//第三种通过对象的getClass()方法获取</span><br>        Class&lt;? extends ReflectionBase.Employee&gt; c3=employee.getClass();<br>    &#125;<br></code></pre></div></td></tr></table></figure><h4 id="2-通过Class对象创造实例"><a href="#2-通过Class对象创造实例" class="headerlink" title="2. 通过Class对象创造实例"></a>2. 通过Class对象创造实例</h4><p>主要有两种方法：</p><ul><li>调用Class对象的newInstance()方法。</li><li>通过Class对象获取想要的Constructor，然后通过Constructor生成实例</li></ul><figure class="highlight java"><figcaption><span>"通过反射获取类的实例"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//通过newInstance方法</span><br><span class="hljs-keyword">try</span> &#123;<br>    Employee instance = c2.newInstance();<br>&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>    e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//通过获取Constructor来构造实例</span><br><span class="hljs-comment">//其中的参数填充要根据我们想要的构造函数</span><br><span class="hljs-keyword">try</span> &#123;<br>    Constructor&lt;Employee&gt; constructor = c2.getDeclaredConstructor(String.class, <span class="hljs-keyword">int</span>.class, String.class, <span class="hljs-keyword">int</span>.class, String.class, <span class="hljs-keyword">double</span>.class);<br>    <span class="hljs-comment">//取消访问检查</span><br>    constructor.setAccessible(<span class="hljs-keyword">true</span>);<br>    Employee e = constructor.newInstance(<span class="hljs-string">&quot;bob&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;eng&quot;</span>, <span class="hljs-number">200.2</span>);<br>    e.sayHello();<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，第一种方法只能通过默认无参构造方法构造对象，那么如果我们的类米有无参构造函数怎么办？这也许就是它被放弃的理由吧。</p><p>第二种可以获取任意一个构造函数，无论有参无参、私有公共，不过就是参数必须一一对应。</p><h4 id="3-获取修饰符"><a href="#3-获取修饰符" class="headerlink" title="3. 获取修饰符"></a>3. 获取修饰符</h4><p>修饰符的信息封装在<code>Modifier</code>类中，常见的用法通过<code>getModifiers()</code>返回一个用于描述Field、Method和Constructor的修饰符的整形数值，然后再由Modifier的静态方法<code>toString()</code>转为字符串。</p><p>以及一些常用的判断是否为<code>static</code>字段。</p><h4 id="4-获取类的属性"><a href="#4-获取类的属性" class="headerlink" title="4. 获取类的属性"></a>4. 获取类的属性</h4><p>类的属性都由Filed类管理。常用的方法有：</p><ul><li><code>getFields()</code>,获取该类所有的public属性，但不包括父类的属性。</li><li><code>getDeclaredFields()</code>,获取该类的所有属性，包括私有，但同样不包括父类的属性</li></ul><figure class="highlight java"><figcaption><span>"获取类的所有属性"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">parseFields</span><span class="hljs-params">(Class c)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    StringBuilder sb=<span class="hljs-keyword">new</span> StringBuilder();<br>    Field[] fields = c.getFields();<br><br>    <span class="hljs-keyword">for</span> (Field elem : fields) &#123;<br><br>        sb.append(SPLIT);<br>        <span class="hljs-keyword">int</span> modifiers = elem.getModifiers();<br>        <span class="hljs-keyword">if</span> (Modifier.toString(modifiers).length() &gt; <span class="hljs-number">0</span>) &#123;<br>            sb.append(Modifier.toString(modifiers)).append(SPLIT);<br><br>        &#125;<br>        Class&lt;?&gt; type = elem.getType();<br>        <span class="hljs-keyword">if</span> (type != <span class="hljs-keyword">null</span>) &#123;<br>            sb.append(type.getName()).append(SPLIT);<br>        &#125;<br>        sb.append(elem.getName());<br>        sb.append(<span class="hljs-string">&quot;;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br></code></pre></div></td></tr></table></figure><h4 id="5-获取类的构造方法"><a href="#5-获取类的构造方法" class="headerlink" title="5. 获取类的构造方法"></a>5. 获取类的构造方法</h4><p>同样，类的构造方法也会被封装在<code>Constructor</code>类中。<code>getDeclaredConstructors()</code>可以获取该类的所有构造方法。但是不包含<strong>父类的构造方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">parseConstructor</span><span class="hljs-params">(Class c)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    StringBuilder sb=<span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-comment">//获得该类的所有共有构造方法</span><br>    Constructor[] constructors = c.getConstructors();<br>    <span class="hljs-keyword">for</span>(Constructor elem:constructors)&#123;<br>        sb.append(SPLIT);<br>        <span class="hljs-keyword">int</span> modifiers = elem.getModifiers();<br>        <span class="hljs-keyword">if</span>(Modifier.toString(modifiers).length()&gt;<span class="hljs-number">0</span>)&#123;<br>            sb.append(Modifier.toString(modifiers)).append(SPLIT);<br>        &#125;<br>        sb.append(elem.getName()).append(<span class="hljs-string">&quot;(&quot;</span>);<br>        Class[] types = elem.getParameterTypes();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;types.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>)&#123;<br>                sb.append(<span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>            sb.append(types[i].getName());<br>        &#125;<br>        sb.append(<span class="hljs-string">&quot;);\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br></code></pre></div></td></tr></table></figure><h4 id="6-获取类的所有方法"><a href="#6-获取类的所有方法" class="headerlink" title="6. 获取类的所有方法"></a>6. 获取类的所有方法</h4><p>与上面类似，方法被封装在Method类中，同样，<code>getDeclaredMethod()</code>获取的方法<strong>不包括</strong>父类的方法。<code>getMethods()</code>获取公共的、父类或接口的所有方法。</p><figure class="highlight java"><figcaption><span>"获取类的所有方法"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">parseMethods</span><span class="hljs-params">(Class c)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    StringBuilder sb=<span class="hljs-keyword">new</span> StringBuilder();<br>    Method[] methods = c.getDeclaredMethods();<br>    <span class="hljs-keyword">for</span>(Method elem:methods)&#123;<br>        sb.append(SPLIT);<br>        <span class="hljs-keyword">int</span> modifiers = elem.getModifiers();<br>        <span class="hljs-keyword">if</span>(Modifier.toString(modifiers).length()&gt;<span class="hljs-number">0</span>)&#123;<br>            sb.append(Modifier.toString(modifiers)).append(SPLIT);<br>        &#125;<br>        Class&lt;?&gt; returnType = elem.getReturnType();<br>        sb.append(returnType.getName()).append(SPLIT);<br>        sb.append(elem.getName()).append(<span class="hljs-string">&quot;(&quot;</span>);<br>        Class&lt;?&gt;[] parameterTypes = elem.getParameterTypes();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;parameterTypes.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>)&#123;<br>                sb.append(<span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>            sb.append(parameterTypes[i].getName());<br>        &#125;<br>        sb.append(<span class="hljs-string">&quot;);\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>获取了方法，我们如何使用？非常简单，调用Method类的<code>invoke(Object invoke(Object obj, Object... args)</code> 执行方法，第一个参数执行该方法的对象，如果是static修饰的类方法，则传null即可方法。</p><p>通过获取Method对象时，仍然需要通过准确的参数类型才能找到我们想要的method对象。</p><h4 id="7-解析类的基本信息"><a href="#7-解析类的基本信息" class="headerlink" title="7. 解析类的基本信息"></a>7. 解析类的基本信息</h4><p>有了上面的工具我们就可以通过class文件来解析该类的基本信息了，我们构造两个类，Person和Employee类，后者继承前者：</p><figure class="highlight java"><figcaption><span>"Person类"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> String hobby;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String hobby)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.hobby = hobby;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getHobby</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> hobby;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHobby</span><span class="hljs-params">(String hobby)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.hobby = hobby;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><hr><figure class="highlight java"><figcaption><span>"Employee类"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> employeeId;<br>    <span class="hljs-keyword">protected</span> String title;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String hobby, <span class="hljs-keyword">int</span> employeeId, String title, <span class="hljs-keyword">double</span> salary)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name, age, hobby);<br>        <span class="hljs-keyword">this</span>.employeeId = employeeId;<br>        <span class="hljs-keyword">this</span>.title = title;<br>        <span class="hljs-keyword">this</span>.salary = salary;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;Hello, 我是 %s, 今年 %s 岁, 爱好是%s, 我目前的工作是%s, 月入%s元\n&quot;</span>,<br>                name, age, getHobby(), title, salary));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;My name is %s, 工作中勿扰.&quot;</span>, name));<br><br>    &#125;<br></code></pre></div></td></tr></table></figure><p>构造了上述类，我们就可以通过反射获取该类的字段、构造器、方法等等，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseClass</span><span class="hljs-params">(String className)</span></span>&#123;<br><br>    StringBuilder result=<span class="hljs-keyword">new</span> StringBuilder();<br>    Class c= <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        c = Class.forName(className);<br>        <span class="hljs-keyword">int</span> modifiers = c.getModifiers();<br>        <span class="hljs-comment">//打印类的修饰符</span><br>        result.append(Modifier.toString(modifiers));<br>        result.append(SPLIT);<br>        result.append(c.getName()).append(SPLIT);<br>        Class superclass = c.getSuperclass();<br>        <span class="hljs-keyword">if</span>(superclass!=<span class="hljs-keyword">null</span> &amp;&amp; superclass!=Object.class)&#123;<br>            result.append(<span class="hljs-string">&quot;extends&quot;</span>).append(SPLIT).append(superclass.getName());<br>        &#125;<br>        result.append(<span class="hljs-string">&quot;&#123;\n&quot;</span>);<br>        <span class="hljs-comment">//打印属性</span><br>        result.append(parseFields(c));<br>        <span class="hljs-comment">//打印构造函数</span><br>        result.append(parseConstructor(c));<br>        <span class="hljs-comment">//打印成员方法</span><br>        result.append(parseMethods(c));<br><br>        result.append(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>        System.out.println(result.toString());<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>        e.getMessage();<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ReflectionBase.Employee extends ReflectionBase.Person&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> employeeId;<br>    <span class="hljs-keyword">public</span> java.lang.String name;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="8-解析类的数据"><a href="#8-解析类的数据" class="headerlink" title="8. 解析类的数据"></a>8. 解析类的数据</h4><p>上面的解析是解析类的基本结构，那么如何获取一个对象的具体数据呢？与上面类似，我们将对象的类型分为三种，字符串、数组、普通对象。采用递归的方法解析所有字段。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">parseObject</span><span class="hljs-params">(Object obj)</span></span>&#123;<br><br>    <span class="hljs-keyword">if</span>(obj==<span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    StringBuilder sb=<span class="hljs-keyword">new</span> StringBuilder();<br><br>    Class&lt;?&gt; c = obj.getClass();<br>    <span class="hljs-comment">//判断是否为字符串类</span><br>    <span class="hljs-keyword">if</span>(c==String.class)&#123;<br>        <span class="hljs-keyword">return</span> (String)obj;<br>    &#125;<br>    <span class="hljs-comment">//判断对象是否为数组</span><br>    <span class="hljs-keyword">if</span>(c.isArray())&#123;<br>        sb.append(c.getComponentType()).append(<span class="hljs-string">&quot;[]&#123;\n&quot;</span>);<br>        System.out.println(Array.getLength(obj));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;Array.getLength(obj);i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>)&#123;<br>                sb.append(<span class="hljs-string">&quot;,\n&quot;</span>);<br>            &#125;<br>            sb.append(<span class="hljs-string">&quot;\t&quot;</span>);<br>            Object o = Array.get(obj, i);<br>            <span class="hljs-comment">//数组元素类型为8种普通类型，直接打印即可</span><br>            <span class="hljs-keyword">if</span>(c.getComponentType().isPrimitive())&#123;<br>                sb.append(o.toString());<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//数组元素类型为类，递归解析</span><br>                sb.append(parseObject(o));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.append(<span class="hljs-string">&quot;\n&#125;&quot;</span>).toString();<br>    &#125;<br>    <span class="hljs-comment">//既不是数组，也不是字符串，那就是普通对象</span><br>    <span class="hljs-keyword">while</span>(c!=<span class="hljs-keyword">null</span>)&#123;<br>        sb.append(c.getName());<br>        sb.append(<span class="hljs-string">&quot;[&quot;</span>);<br>        Field[] fields = c.getDeclaredFields();<br>        AccessibleObject.setAccessible(fields,<span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;fields.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!Modifier.isStatic(fields[i].getModifiers())) &#123;<br>                <span class="hljs-keyword">if</span> (!sb.toString().endsWith(<span class="hljs-string">&quot;[&quot;</span>)) &#123;<br>                    sb.append(<span class="hljs-string">&quot;,&quot;</span>);<br>                &#125;<br>                sb.append(fields[i].getName()).append(<span class="hljs-string">&quot;=&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//属性为8种普通类型，直接打印即可</span><br>                    <span class="hljs-keyword">if</span> (fields[i].getType().isPrimitive()) &#123;<br>                        sb.append(fields[i].get(obj));<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">//属性为类，继续递归解析</span><br>                        sb.append(parseObject(fields[i].get(obj)));<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        sb.append(<span class="hljs-string">&quot;]&quot;</span>);<br>        c=c.getSuperclass();<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>测试代码为：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        list.add(i*i);<br>    &#125;<br><br>    System.out.println(ReflectionUtil.parseObject(list).toString());<br><br></code></pre></div></td></tr></table></figure><hr><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">java.util.ArrayList[elementData=<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Object</span>[]</span>&#123;<br>    java.lang.Integer[value=<span class="hljs-number">1</span>]java.lang.Number[]java.lang.Object[],<br>    java.lang.Integer[value=<span class="hljs-number">4</span>]java.lang.Number[]java.lang.Object[],<br>    java.lang.Integer[value=<span class="hljs-number">9</span>]java.lang.Number[]java.lang.Object[],<br>    ,<br>    ,<br>    ,<br>    ,<br>    ,<br>    ,<br>&#125;,size=<span class="hljs-number">3</span>]java.util.AbstractList[modCount=<span class="hljs-number">3</span>]java.util.AbstractCollection[]java.lang.Object[]<br></code></pre></div></td></tr></table></figure><p>这里的空白行是为ArrayList的默认容量为10。</p><p>小结：我们通过Filed类的<code>getType()</code>的方法来获取属性的类型，通过Field类的<code>get(Object o)</code>获取该属性的值，参数为我们当前想要查看的对象。</p><h3 id="0x4-反射机制的优缺点"><a href="#0x4-反射机制的优缺点" class="headerlink" title="0x4 反射机制的优缺点"></a>0x4 反射机制的优缺点</h3><p>优点：</p><ul><li>就是灵活，提高了对未知代码的兼容性</li></ul><p>缺点：</p><ul><li>对性能有影响，反射的性能消耗比不使用的要高很多</li><li>而且打破了安全限制，使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</li><li>破坏了封装性</li></ul><p>所以能不用反射，就不用反射。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&mid=2247483785&idx=1&sn=f696c8c49cb7ecce9818247683482a1c&chksm=e9c2ed84deb564925172b2dd78d307d4dc345fa313d3e44f01e84fa22ac5561b37aec5cbd5b4&scene=0#rd">java反射机制详解</a></p></li><li><p><a href="https://laijianfeng.org/2018/12/Java-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/">动态代理详解</a></p></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E5%8F%8D%E5%B0%84/">反射</category>
      
      
      <category domain="https://eripe.me/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">基本概念</category>
      
      
      <comments>https://eripe.me/2021-06-04/%E5%8F%8D%E5%B0%84%E5%88%9D%E4%BD%93%E9%AA%8C.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>通过MySQL驱动的加载学习SPI机制</title>
      <link>https://eripe.me/2021-06-04/SPI-service-mechanism.html</link>
      <guid>https://eripe.me/2021-06-04/SPI-service-mechanism.html</guid>
      <pubDate>Fri, 04 Jun 2021 11:57:44 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言-什么是SPI&quot;&gt;&lt;a href=&quot;#前言-什么是SPI&quot; class=&quot;headerlink&quot; title=&quot;前言 什么是SPI&quot;&gt;&lt;/a&gt;前言</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言-什么是SPI"><a href="#前言-什么是SPI" class="headerlink" title="前言 什么是SPI"></a>前言 什么是SPI</h2><p>SPI机制（Service Provider Interface)简而言之，就是java规定了一组服务的接口，但是没有具体的实现类。那么具体的实现类肯定由不同的厂商实现，那么客户在使用时是仅依赖于接口的。<strong>SPI的具体实现是靠<code>ServiceLoader</code>完成的。</strong><br>在讲解双亲委派模型时，我们知道，SPI接口是通过<code>bootstrap ClassLoader</code>加载至jvm中的。而具体的驱动实现类是通过线程上下文类加载器加载至jvm中的。下面我们就通过加载数据库驱动的例子来了解SPI的实现原理。</p><h2 id="1-获得数据库连接实例的方式"><a href="#1-获得数据库连接实例的方式" class="headerlink" title="1. 获得数据库连接实例的方式"></a>1. 获得数据库连接实例的方式</h2><p>在JDBC4.0之前，还没有引入SPI，一般需要使用<code>Class.forName()</code>注册驱动，所以加载驱动的代码一般是如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Class.forName(<span class="hljs-string">&quot;xxxx&quot;</span>);<br>Connection c=DriverManager.getConnection(<span class="hljs-string">&quot;url&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>在JDBC4.0之后，我们只需要使用<code>DriverManager.getConnection(url)</code>就可以获得连接对象。这是因为在<code>getConnection()</code>内部会自己调用<code>Class.forName()</code>，这里包含了一层嵌套关系。而<code>DriverManager</code>又是由<code>Bootstrap ClassLoader</code>加载的，根据符号解析的规定，<code>DriverManager</code>内部的符号如果需要解析为类或接口，则会调用<code>DriverManager</code>的加载器。但是问题是<code>DriverManager</code>只会加载核心库。根据双亲委派模型，父类的请求无法派给子类，所以这时候就采用了线程上下文类加载器。<strong>而在JDBC4.0之前没有这层嵌套关系。</strong></p><p>下面我们来看看到底是如何获得驱动的。在初次使用<code>DriverManager</code>时，首先会执行静态代码块中<code>loadInitialDrivers()</code>函数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    loadInitialDrivers();<br>    println(<span class="hljs-string">&quot;JDBC DriverManager initialized&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>初始化函数如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadInitialDrivers</span><span class="hljs-params">()</span> </span>&#123;<br>    String drivers;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//查看是否设置了系统属性jdbc.drivers</span><br>        drivers = AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> System.getProperty(<span class="hljs-string">&quot;jdbc.drivers&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        drivers = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//使用ServiceLoader加载驱动</span><br>    AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);<br>            <br>            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">while</span>(driversIterator.hasNext()) &#123;<br>                    driversIterator.next();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;<br>            <span class="hljs-comment">// Do nothing</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;);<br><br>    println(<span class="hljs-string">&quot;DriverManager.initialize: jdbc.drivers = &quot;</span> + drivers);<br><br>    <span class="hljs-keyword">if</span> (drivers == <span class="hljs-keyword">null</span> || drivers.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//如果设置了系统属性jdbc.drivers,</span><br>    <span class="hljs-comment">//那么如果SPI已经成功加载了驱动，下面的代码还是会重复注册驱动</span><br>    String[] driversList = drivers.split(<span class="hljs-string">&quot;:&quot;</span>);<br>    println(<span class="hljs-string">&quot;number of Drivers:&quot;</span> + driversList.length);<br>    <span class="hljs-keyword">for</span> (String aDriver : driversList) &#123;<br>        ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，<code>DriverManager</code>的初始化分分为两个版本：</p><ul><li>设置系统属性<code>jdbc.drivers</code>属性</li><li>使用``ServiceLoader`加载，如果驱动以service provider的形式出现</li></ul><h2 id="2-SPI加载数据库驱动的原理"><a href="#2-SPI加载数据库驱动的原理" class="headerlink" title="2. SPI加载数据库驱动的原理"></a>2. SPI加载数据库驱动的原理</h2><h3 id="2-1-获取ServiceLoader对象"><a href="#2-1-获取ServiceLoader对象" class="headerlink" title="2.1 获取ServiceLoader对象"></a>2.1 获取ServiceLoader对象</h3><p>使用SPI初始化代码时首先使用<code>ServiceLoader</code>的静态方法<code>load</code>加载SPI<code>Driver</code>的class文件。源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-function">ServiceLoader&lt;S&gt; <span class="hljs-title">load</span><span class="hljs-params">(Class&lt;S&gt; service)</span> </span>&#123;<br>    ClassLoader cl = Thread.currentThread().getContextClassLoader();<br>    <span class="hljs-keyword">return</span> ServiceLoader.load(service, cl);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code> ServiceLoader.load(service, cl)</code>又会通过私有构造方法返回<code>ServiceLoader</code>对象，在私有构造方法内部调用了<code>reload()</code>方法，源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reload</span><span class="hljs-params">()</span> </span>&#123;<br>    providers.clear();<br>    lookupIterator = <span class="hljs-keyword">new</span> LazyIterator(service, loader);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先清空<code>providers</code>，这里的<code>providers</code>是一个<code>LinkedHashMap</code>，用来保存已经加载过服务实现类的实例。随后生成了<code>lazyIterator</code>对象，这个懒加载器是<code>ServiceLoader</code>的核心，它完成了查找实现类、加载实现类的动作。</p><p>那么这里的<strong>懒</strong>到底是指什么？我的理解是在程序启动之初，服务实现类并没有被加载至jvm中<strong>直到我们使用时</strong>。所以这里的懒就是在程序启动到我们使用之前的这一段时间内，不需要也没有加载服务实现类，懒就是懒在这个阶段。那非懒应该就是指在程序一启动就会加载所有的服务实现类。</p><h3 id="2-2-使用ServiceLoader对象迭代器遍历实现类容器"><a href="#2-2-使用ServiceLoader对象迭代器遍历实现类容器" class="headerlink" title="2.2 使用ServiceLoader对象迭代器遍历实现类容器"></a>2.2 使用ServiceLoader对象迭代器遍历实现类容器</h3><p>在成功获取ServiceLoader对象<code>loadedDrivers</code>后，会继续获取<code>loadedDrivers</code>的内部迭代器：</p><blockquote><p>Iterator<Driver> driversIterator = loadedDrivers.iterator();</p></blockquote><p>然后<code>DriverManager</code>会使用这个迭代器遍历ServiceLoader内部用来存储服务实现类对象的容器。具体的驱动注册就在遍历容器的时候完成。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-keyword">while</span>(driversIterator.hasNext()) &#123;<br>        driversIterator.next();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们来看看<code>ServiceLoader</code>内部迭代器的<code>hasNext()</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;S&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Iterator&lt;S&gt;() &#123;<br><br>        Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders<br>            = providers.entrySet().iterator();<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (knownProviders.hasNext())<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">return</span> lookupIterator.hasNext();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> S <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (knownProviders.hasNext())<br>                <span class="hljs-keyword">return</span> knownProviders.next().getValue();<br>            <span class="hljs-keyword">return</span> lookupIterator.next();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>hasNext()</code>首先调用内部容器<code>providers</code>自身的迭代器。失败后才会调用懒迭代器类<code>LazyIterator</code>的<code>hasNext()</code>，其具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyIterator</span></span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">S</span>&gt;</span><br><span class="hljs-class"></span>&#123;<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//无论执行if还是else，都会最终执行hasNextService</span><br>        <span class="hljs-keyword">if</span> (acc == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> hasNextService();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            PrivilegedAction&lt;Boolean&gt; action = <span class="hljs-keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;<br>                <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> hasNextService(); &#125;<br>            &#125;;<br>            <span class="hljs-keyword">return</span> AccessController.doPrivileged(action, acc);<br>        &#125;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在调用<code>LazyIteraotr</code>的<code>hasNext()</code>方法后，内部会调用<code>hashNextService()</code>:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNextService</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nextName != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (configs == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <br>            String fullName = PREFIX + service.getName();<br>            <span class="hljs-keyword">if</span> (loader == <span class="hljs-keyword">null</span>)<br>                configs = ClassLoader.getSystemResources(fullName);<br>            <span class="hljs-keyword">else</span><br>                configs = loader.getResources(fullName);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException x) &#123;<br>            fail(service, <span class="hljs-string">&quot;Error locating configuration files&quot;</span>, x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> ((pending == <span class="hljs-keyword">null</span>) || !pending.hasNext()) &#123;<br>        <span class="hljs-keyword">if</span> (!configs.hasMoreElements()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        pending = parse(service, configs.nextElement());<br>    &#125;<br>    nextName = pending.next();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们看到该方法内部有一个常量字符串<code>PREFIX</code>，其值为:</p><blockquote><p>private static final String PREFIX = “META-INF/services/“;</p></blockquote><p>这是因为java规定，所谓为SPI提供实现的厂商必须在jar包提供目录<code>META-INF/services/</code>，目录内的文件存放当前服务实现类的入口类名，文件名文当前服务接口的全限定名。以MySQL为例，其jar包内容如下：</p><p><img src="images/mysql-SPI.PNG" alt="mysql-SPI"></p><p>其中<code>java.sql.Driver</code>就是java数据库服务接口的全限定名，其内容如下：</p><p><img src="images/mysql-content.PNG" alt="mysql-content"></p><p><code>com.mysql.cj.jdbc.Driver</code>就是具体实现类的全限定名。<code>hasNextService</code>的目标就是把具体实现类的全限定名找到。找的方法就是找到文件：<code>META-INF/services/+service.name</code>。其中<code>service</code>的名字是java规定好的。例如加载数据库时的<code>service</code>就对应<code>Driver</code>类。</p><p>在找到具体实现类的名字后，下一步当然是要把它加载进来了。调用<code>ServiceLoader</code>迭代器的<code>next()</code>方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (acc == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> hasNextService();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        PrivilegedAction&lt;Boolean&gt; action = <span class="hljs-keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> hasNextService(); &#125;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> AccessController.doPrivileged(action, acc);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> S <span class="hljs-title">nextService</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!hasNextService())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>    String cn = nextName;<br>    nextName = <span class="hljs-keyword">null</span>;<br>    Class&lt;?&gt; c = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        c = Class.forName(cn, <span class="hljs-keyword">false</span>, loader);<br>    &#125;<br>    ...<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        S p = service.cast(c.newInstance());<br>        providers.put(cn, p);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>具体的加载由<code>Class.forName()</code>完成，注意，其中传入的loader是线程上下文类加载器。在将具体实现类加载进jvm后，会实例化一个实现类对象，即调用<code>c.newInstance()</code>。在实例化的过程完成了驱动的注册。我们来看看mysql实现类的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Driver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NonRegisteringDriver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">sql</span>.<span class="hljs-title">Driver</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Driver</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            DriverManager.registerDriver(<span class="hljs-keyword">new</span> Driver());<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException var1) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Can&#x27;t register driver!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>非常简单，一旦进行实例化，就会执行静态构造代码块，mysql实现的<code>Driver</code>会主动向<code>DriverManger</code>提出注册请求。至此，已经完成了数据库驱动的一次注册过程。</p><h3 id="2-3-获得数据库连接对象"><a href="#2-3-获得数据库连接对象" class="headerlink" title="2.3 获得数据库连接对象"></a>2.3 获得数据库连接对象</h3><p><code>DriverManager</code>会遍历所有已经注册过的驱动，如果能成功连接目标数据库，那么就返回当前连接对象，否则继续遍历剩下的Driver实例直至结束。下面是遍历驱动的核心代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;<br>    <span class="hljs-comment">// If the caller does not have permission to load the driver then</span><br>    <span class="hljs-comment">// skip it.</span><br>    <span class="hljs-keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            println(<span class="hljs-string">&quot;    trying &quot;</span> + aDriver.driver.getClass().getName());<br>            Connection con = aDriver.driver.connect(url, info);<br>            <span class="hljs-keyword">if</span> (con != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// Success!</span><br>                println(<span class="hljs-string">&quot;getConnection returning &quot;</span> + aDriver.driver.getClass().getName());<br>                <span class="hljs-keyword">return</span> (con);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException ex) &#123;<br>            <span class="hljs-keyword">if</span> (reason == <span class="hljs-keyword">null</span>) &#123;<br>                reason = ex;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        println(<span class="hljs-string">&quot;    skipping: &quot;</span> + aDriver.getClass().getName());<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，如果在一次尝试连接中抛出异常，那么就不会尝试后续的数据库驱动，这还是有点小bug的。</p><h3 id="2-4-存在的问题"><a href="#2-4-存在的问题" class="headerlink" title="2.4 存在的问题"></a>2.4 存在的问题</h3><p><strong>A. ServiceLoader的providers有什么用？</strong></p><p>可以看到，在<code>DriverMangaer</code>初次完成注册后，并没有使用过缓存<code>providers</code>。但是这仅仅是<code>DriverManager</code>的问题，并不能说明缓存没有用。如果我们此时再次遍历当前<code>loadedDrivers</code>，那么就不会再次使用<code>Class.forName()</code>加载，而是会通过内部缓存获得具体的实现类对象。</p><p><strong>B. 如果有多个驱动需要注册，那么在成功注册第一个驱动后，<code>knownProviders.hasNext()</code>返回的结果不应该是<code>true</code>吗？</strong></p><p>其实这跟HashMap迭代器的实现有关，在每次调用<code>entrySet().iterator()</code>后，返回的迭代器都是新<code>new</code>出来的，即初始化函数<code>loadInitialDrivers()</code>中的<code>driversIterator</code>永远都是<code>providers</code>为空时生成的迭代器。所以尽管成功了加载了一个驱动，<code>knownProviders.hasNext()</code>的结果依然是<code>false</code>，依旧会调用懒迭代器<code>lookupIterator</code>的<code>hasNext()</code>方法。</p><h2 id="3-传统的驱动加载方式"><a href="#3-传统的驱动加载方式" class="headerlink" title="3. 传统的驱动加载方式"></a>3. 传统的驱动加载方式</h2><p>传统的加载是通过<code>Class.forName()</code>完成的，而该方法会默认初始化目标类，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; forName(String className)<br>            <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    Class&lt;?&gt; caller = Reflection.getCallerClass();<br>    <span class="hljs-keyword">return</span> forName0(className, <span class="hljs-keyword">true</span>, ClassLoader.getClassLoader(caller), caller);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>一旦完成了实现类的初始化，数据库驱动会自己向<code>DriverManager</code>完成注册。SPI仅仅替代我们写了<code>Class.forName</code>这句话。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>SPI的核心<code>ServiceLoader</code>类，而该类的核心又是内部实现的<code>LazyIterator</code>。在实现SPI时，规定实现库的jar包中必须在<code>META-INF/services/</code>目录下存放以目标SPI命名的文件，其中的内容就是厂商具体实现类的全限定名。</p><p>但是SPI仍然是有缺点的：</p><ul><li>对于某一项服务，会加载所有的实现类，但是其中有一些我们并不需要</li><li>会存在并发问题</li></ul>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E7%B1%BB%E5%8A%A0%E8%BD%BD/">类加载</category>
      
      
      <category domain="https://eripe.me/tags/SPI%E6%9C%BA%E5%88%B6/">SPI机制</category>
      
      <category domain="https://eripe.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD/">数据库驱动加载</category>
      
      
      <comments>https://eripe.me/2021-06-04/SPI-service-mechanism.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java的内存布局</title>
      <link>https://eripe.me/2021-06-04/java-memory-layout.html</link>
      <guid>https://eripe.me/2021-06-04/java-memory-layout.html</guid>
      <pubDate>Fri, 04 Jun 2021 11:57:44 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>众所周知,java虚拟机的内存布局和传统的内存布局都差不多,都分为栈、堆啥的。准确的来说，jvm的内存分为以下几个部分:</p><ul><li>程序计数器(就是eip)</li><li>堆</li><li>方法区</li><li>本地方法栈</li><li>虚拟机栈</li></ul><p>其中堆和方法区是所有线程锁共享的,而程序计数器、栈肯定都是线程私有的,因为这与程序的正常运行息息相关。</p><p>上述的五个区域都可能产生内存溢出,有的还可能产生内存泄漏(虽然内存由jvm管理,但是并不能保证内存不会泄露奥)。下面我将一一介绍上述四个区域(不包括程序计数器)产生内存溢出的一般情况,当然大部分内容还是来自&lt;&lt;深入理解JVM&gt;&gt;一书,我在这里仅仅做个概括加上自己一点的感想。</p><h2 id="0x1-虚拟机栈"><a href="#0x1-虚拟机栈" class="headerlink" title="0x1 虚拟机栈"></a>0x1 虚拟机栈</h2><p>虚拟机栈跟传统汇编里的栈感觉差不多,只不过这里用所谓的局部变量槽来保存(Slot)。当然栈就是用来存储局部变量和返回地址的，内容肯定和传统栈一样。当然本地方法栈和虚拟机栈在性质上就是一类东西,<strong>仅仅是用途不同而已</strong>。所以就不单独分开说本地方法栈了。</p><p>Tips:</p><blockquote><p>当进入一个方法时,这个方法需要多少个局部变量槽是确定的,局部变量所需的内存在编译时期分配完成,而具体内存是多少个byte是不确定的,因为局部变量槽的实现方式不在JVM规范中。由虚拟机厂商所决定。</p></blockquote><p>上面这个我也是才注意的,不像传统栈可以不停的push,使用的大小完全无法确定。</p><p>进入正题,虚拟机栈可能会发生两种内存错误:</p><ul><li>StackOverFlow</li><li>OutOfMemeory</li></ul><p>StackOverFlow要么是死递归造成的栈空间不够,要么是局部变量太多。感觉后者不太可能发生,因为需要的局部变量太多儿。所以出现StackOverFlow的第一直觉就是死递归。</p><p>第二种出现于允许栈可扩展的虚拟机中。虚拟机之王HotSpot是不支持虚拟机栈扩展的。但是仍然可能出现OOM,当线程申请栈空间失败时。反之申请成功就永远不会出现OOM。</p><h2 id="0x2-堆"><a href="#0x2-堆" class="headerlink" title="0x2 堆"></a>0x2 堆</h2><p>堆是所有线程共享的内存区域,堆中能出现的内存错误当然是OOM辣。在Java中,几乎所有的对象实例都在堆中分配(具体解释来自深入理解JVM:page45)。</p><p>堆的可以被实现为固定的或者可扩展的。hotSpot中堆属于可扩展的。堆的大小可以通过参数<code>-Xms</code>(初始堆的大小)和<code>-Xmx</code>(堆的最大值)来控制。</p><p>当在堆中无法完成对象的分配时,在堆上就会出现OOM。</p><h3 id="0x2-1-方法区"><a href="#0x2-1-方法区" class="headerlink" title="0x2-1 方法区"></a>0x2-1 方法区</h3><p>方法区跟堆一样也是属于所有线程共享的内存区域。其中主要存储由虚拟机加载的类型信息、常量、静态变量、JIT编译后的缓存数据等等。</p><p>在JDK8以前,HotSopt采用了永久代的方法实现了方法区,从而能够像管理堆一样管理方法区。<strong>但是这是一个陋习</strong>。永久代有上限,这就导致在加载过多类后会出现内存溢出。</p><p>所以在JDK7中,oracle已经将方法区中的常量池、静态变量移出了永久代。在JDK8中,在方法区中彻底废除了永久代,通过在本地内存中实现元空间(与J9类似)保存剩余的信息,大部分都是类型信息。</p><p>虚拟机规范对方法区的要求是非常宽松的,比如方法区可以<strong>不执行内存回收</strong>,当然在方法区执行内存回收也是比较麻烦的。</p><p>当在方法区中无法申请到满足要求的内存时,就会出现OOM错误。</p><h3 id="0x2-2-运行时常量池"><a href="#0x2-2-运行时常量池" class="headerlink" title="0x2-2 运行时常量池"></a>0x2-2 运行时常量池</h3><p>运行时常量池本来是属于方法区的东西(注意oralce在JDK7是把常量池移出了永久代,而不是移出了方法区)。在Class文件中有一项信息为常量表,存储的是编译时期的各种常量与符号引用。这部分内容将在类加载完成后存放至方法区的运行时常量池。</p><p>当然常量池的内容不一定得是编译时的常量，也可以在运行时将新常量加入到池中。所以说运行时常量池与Class文件的常量池相比,前者具有动态性。</p><p>运行时常量池既然是方法区的东西,自然也会受到方法区的限制,当无法申请到足够多的内存时,就会出现OOM。</p><h2 id="0x3-直接内存"><a href="#0x3-直接内存" class="headerlink" title="0x3 直接内存"></a>0x3 直接内存</h2><p>直接内存并不是虚拟机规范中定义的内存区域,但是逐渐变得很重要。</p><p>在JDK1.4中,java引入了NIO。注意IO操作可以是要频繁跟本地堆的内容进行交互的。所以在NIO中：</p><blockquote><p>引入了一种基于管道和缓冲区的IO方式,可以直接使用native函数库分配native堆,然后通过一个存储在java堆中的DirectByteBuffer对象作为native堆的引用来操作native堆</p></blockquote><p>上述这种操作就避免了在java堆中和native中频繁的复制数据。</p><p>native堆的分配大小一般都会忽略,导致各个内存区域的大小总和超过了本机主机内存,从而出现OOM。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://medium.com/platform-engineer/understanding-java-memory-model-1d0863f6d973">Understanding Java Memory Model</a></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/jvm/">jvm</category>
      
      
      <category domain="https://eripe.me/tags/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/">内存布局</category>
      
      
      <comments>https://eripe.me/2021-06-04/java-memory-layout.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>类的加载机制</title>
      <link>https://eripe.me/2021-06-04/class-loading-mechanism.html</link>
      <guid>https://eripe.me/2021-06-04/class-loading-mechanism.html</guid>
      <pubDate>Fri, 04 Jun 2021 11:57:44 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;1-类初始化的时机&quot;&gt;&lt;a href=&quot;#1-类初始化的时机&quot; class=&quot;headerlink&quot; title=&quot;1. 类初始化的时机&quot;&gt;&lt;/a&gt;1.</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="1-类初始化的时机"><a href="#1-类初始化的时机" class="headerlink" title="1. 类初始化的时机"></a>1. 类初始化的时机</h1><p>当复习类加载时机时，我给自己抛出了一个问题：这里的时机只说明了<strong>类</strong>的初始化，那么对于接口呢？接口什么时候会被初始化呢？</p><p>仔细回顾《深入理解Java虚拟机》，才发现，作者给出的是会触发<strong>类型</strong>初始化的六种时机，而不是<strong>类</strong>初始化。这里类型可能是指类或者接口。ok，那么我的问题迎刃而解了。接口初始化的时机同样遵循以下六种场景。</p><hr><p>在Java中，只有主动引用才会触发<del>类</del>类型加载动作。所谓的主动引用指<strong>只</strong>包括以下六种情况（除了下面这六种情况，其余的引用都称为被动引用）：</p><ol><li>遇到new、getstatic、setstatic或者invokestatic这4个字节码指令时，如果<strong>类型</strong>没有进行过初始化，那么需要先触发其初始化阶段。对应的java代码场景为：<ul><li>new一个关键字或者一个实例化对象时</li><li>读取或设置一个<strong>类型</strong>的静态字段时(final修饰、已在编译期把结果放入常量池的除外)</li><li>调用一个<strong>类行</strong>的静态方法时</li></ul></li><li>使用java.lang.reflect包的方法对<strong>类型</strong>进行反射调用的时候，如果类型没进行初始化，需要先触发其初始化。</li><li>当初始化一个<strong>类</strong>时，如果其父类还未进行初始化，会先触发其父类的初始化；当一个接口在初始化时。并不要求其父接口全部完成了初始化。只有真正使用到了父接口时（例如使用接口中定义的常量）才会对父接口进行初始化</li><li>当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的类)，虚拟机会先初始化这个类。</li><li>当使用JDK 1.7等动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li><li>当一个接口定义了JDK8新加入的默认方法时，如果这个接口的实现类发生了初始化，那么接口需要在其之前被初始化</li></ol><p><strong>注意：</strong><br>对于静态字段或者静态方法，只会对定义了这些内容的类执行类加载动作。我们通过下面的代码来理解这句话的真正含义：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">staticTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       subTest.m1();<br>    <span class="hljs-comment">// System.out.println(subTest.a);</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">subTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;load subclass subTest&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;load class Test&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;method m1&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>执行结果为：</p><blockquote><p>load class Test<br>method m1</p></blockquote><p>虽然通过子类名称调用父类的静态方法，但是jvm仍然只会加载真正定义了静态方法<code>m1</code>的类<code>Test</code>。这是一个特殊情况。</p><hr><p>update：2021-01-18 00:27:01</p><p>我又给自己提出了一个问题：当一个类被初始化时，它实现的接口是什么时候被加载的？这种情况不符合上面所述的六种场景啊。</p><p>经过我的思考，我发现我进入了一个误区。上面所述的六种场景只是声明类或接口被初始化的时机，而不是加载的时机。</p><p>初始化一定要求类或者接口被加载，但是反之则不一定，加载了类或接口，不一定需要初始化。所以我猜测，当是一个实现类在解析接口引用时，只是加载了接口，而没有初始化接口。不然类怎么实现验证步骤？</p><h1 id="2-类加载的七个步骤"><a href="#2-类加载的七个步骤" class="headerlink" title="2. 类加载的七个步骤"></a>2. 类加载的七个步骤</h1><p>将类的Class文件加载至jvm中一般会经历七个步骤：加载、验证、准备、解析、初始化、使用、卸载。但是注意：<strong>这七个步骤并不是完全串行的</strong>。有可能在一个步骤的执行中开启另外一个步骤，而不是等待当前步骤执行完毕。</p><p>并且其中的验证、准备、解析合在一起叫做“连接”。这不就是cpp编译过程的符号链接的步骤嘛，搞的这么花里胡哨的。</p><p>并且其中的初始化是指类的初始化，而不是对象的初始化。类的初始化是指：</p><ul><li>静态字段的初始化</li><li>静态代码的执行</li></ul><p>并且类的初始化只会在类加载的时候执行一次。下面我们就来看看这七个步骤。</p><h2 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1 加载"></a>2.1 加载</h2><p>这个加载是指整个类加载过程中的第一个步骤，而且是整个类加载过程中我们可以实实在在用代码控制的部分。该步骤分为三小步：</p><ol><li>通过类的全限定名获取类的二进制字节流</li><li>将二进制字节流表示的静态存储结构转化<strong>方法区</strong>为运行时存储结构</li><li>生成Class对象，作为方法区各种类型数据的访问接口</li></ol><p>其中通过类的权限名获取类的二进制字节流就是我们能够控制的部分，虚拟机规范只规定了我们要获取字节流，而没有规定从哪里获取字节流。可以从Class文件中获取、静态的jar包中获取、网络中获取，或者动态的在内存中生成，也就是所谓的动态代理技术，这完全都可以自定义实现。<strong>并且获取字节流这个动作就是通过我们自定义的类加载器来实现。</strong></p><p>但是有一个特殊情况，就是数组类的加载不是我们可以控制的，但是数组中的元素类却又是我们可以控制的。因为<strong>数组类的并不是由类加载器加载，而是由jvm在内存中直接构造的。</strong></p><hr><p>这里的数组类可以看作数组的wrapper，即数组的包装类，由jvm动态生成，数组类提供了一些数组的属性，并且数组的访问也通过该类实现。</p><blockquote><p>java访问数组的安全性比c++高很大程度是因为该类包装了数组的访问操作。</p></blockquote><hr><h3 id="2-1-1-数组类的加载机制"><a href="#2-1-1-数组类的加载机制" class="headerlink" title="2.1.1 数组类的加载机制"></a>2.1.1 数组类的加载机制</h3><ul><li>如果数组的组件类型(即数组去掉一个维度，例如int[4][3],实际的组件类型为int[3],因为二维数组可以看作元素类型是一维数组的一维数组)。那么就递归的采用类加载过程去加载这个组件类型。是类就用类的加载过程，是数组类就用数组类的加载过程。并且该数组会被标识在加载该组件类型的类加载器的类名称空间上，因为这样才能唯一的确定一个类</li><li>如果数组的组件类型不是引用类型，那么该数组会被标识在启动类加载器的类名称空间上</li><li>数组类的可访问性和它组件类型的可访问性一致，如果组件类型不是引用类型，那么数组类的可访问性默认为public</li></ul><h3 id="2-1-2-生成Class对象"><a href="#2-1-2-生成Class对象" class="headerlink" title="2.1.2 生成Class对象"></a>2.1.2 生成Class对象</h3><p>在获得类文件的二进制的字节流后，会被转化为方法区的动态存储结构，这个结构是怎么样的并没有强制规定。但是在转化完成后，会在<strong>堆区</strong>实例化一个代表当前类的Class对象。作为方法区存储结构中的数据的访问接口。</p><p><strong>加载阶段和连接阶段是交叉进行的。</strong></p><h2 id="2-2-验证"><a href="#2-2-验证" class="headerlink" title="2.2 验证"></a>2.2 验证</h2><p>验证显而易见就是验证获取的二进制字节流是否安全，符合虚拟机规范。<strong>因为Class不一定是通过编译生成的</strong>，也确实可以直接在二进制层面拼接。<strong>那么在生成Class对象前不是应该先完成验证步骤？</strong></p><p>验证主要验证四个部分：</p><ol><li>文件格式的验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ol><h3 id="2-2-1-文件格式验证"><a href="#2-2-1-文件格式验证" class="headerlink" title="2.2.1 文件格式验证"></a>2.2.1 文件格式验证</h3><p>文件格式的验证就是验证我们在加载阶段获取到的二进制字节流是否符合<strong>Class文件格式</strong>的规范，只有完成这一步验证，字节流才会转化为方法区的存储结构，并且后续的三个验证步骤是基于方法区的存储结构，而不会直接操作二进制流了。</p><h3 id="2-2-2-元数据验证"><a href="#2-2-2-元数据验证" class="headerlink" title="2.2.2 元数据验证"></a>2.2.2 元数据验证</h3><p>元数据验证是验证方法区存储的字节码是否《java语言规范》的语法要求。所谓的语义包括是否继承了final修饰的类、是否修改了final修饰的字段等等。即验证是否符合java的语法。</p><h3 id="2-2-3-字节码验证"><a href="#2-2-3-字节码验证" class="headerlink" title="2.2.3 字节码验证"></a>2.2.3 字节码验证</h3><p><strong>字节码验证主要是验证代码的语义正确性。</strong>例如将父类对象赋值给子类引用（语法验证会通过，但可能会产生运行时问题）。如果代码没有通过字节码验证，说明代码肯定有错误，但反之则不一定，即使通过了验证，也不能说代码完全正确，有可能产生间接的语义错误。</p><p>但是计算代码是否有语义错误显而易见是一项庞大的工程，放到代码运行之前验证不太好。所以在JDK6之后，java团队将验证语义的操作大部分都转移到了编译期间。编译器会在编译时为代码属性添加<code>StackMapTable</code>属性，这一属性描述了代码是否有语义错误。在字节码验证阶段jvm只需要验证该属性是否符合规范。当然，这并不能做到十全十美。</p><h3 id="2-2-4-符号引用验证"><a href="#2-2-4-符号引用验证" class="headerlink" title="2.2.4 符号引用验证"></a>2.2.4 符号引用验证</h3><p>符号引用验证的目的是为了保证<strong>解析阶段</strong>正常进行。会进行权限检查</p><h3 id="2-2-5-小结"><a href="#2-2-5-小结" class="headerlink" title="2.2.5 小结"></a>2.2.5 小结</h3><p>验证阶段可有可无，并不是强制的，只要能够保证代码是正确的，那么也可以关闭大部分类的验证措施来加速类的加载。</p><h2 id="2-3-准备"><a href="#2-3-准备" class="headerlink" title="2.3 准备"></a>2.3 准备</h2><p>准备阶段是为类的静态变量(而不是实例变量，实例变量会在对象实例化时分配空间)分配内存空间，以及赋予静态变量默认的初值，这里的初值指的是int的默认为0、boolean的默认为false之类的默认值。例如:</p><blockquote><p>public static int value=123;</p></blockquote><p>在准备阶段，value的值为默认值，即为0。在初始化阶段才会被赋值为123。</p><p><strong>无论代码中有没有对静态变量的赋值的操作，都会对变量进行初始化操作，至于赋值的步骤，会在初始化阶段完成!!!</strong></p><p>注意：准备阶段只为静态变量做准备。</p><h2 id="2-4-解析"><a href="#2-4-解析" class="headerlink" title="2.4 解析"></a>2.4 解析</h2><p>解析肯定就是符号的链接过程咯。准备来说就是将常量池中的符号引用替换为直接引用。例如Class文件中的<code>CONSTANT_Class_info</code>、<code>CONSTANT_Fieldref_info</code>、<code>CONSTANT_Method_info</code>等符号引用，存储形式都是常量。</p><blockquote><p>解析过程是把符号链接到正确的内存地址，符号引用变为直接引用，而不是确定符号，后者是编译期做的事，<del>解析这件事已经属于运行期了</del>。准确来说，解析并不是运行期，因为解析阶段还没有真正的开始执行字节码，我的理解时<strong>执行字节码才叫做真正的运行期</strong>。</p></blockquote><p>在解析阶段解析符号的过程被称为<strong>静态解析</strong>，当然能够被静态解析的符号类型有限：</p><ul><li>类或接口</li><li>字段</li><li>一部分方法</li><li>接口方法</li></ul><p>关于方法的解析比较复杂，后文单独开一章进行讲解。</p><h3 id="2-4-1-类或接口的解析"><a href="#2-4-1-类或接口的解析" class="headerlink" title="2.4.1 类或接口的解析"></a>2.4.1 类或接口的解析</h3><p>类或接口的解析有一个核心规则：</p><p>如果当前代码所处的类为D，如果想要把D中一个从未解析过的符号引用N解析为类或接口C，那么则有：</p><ol><li><p>如果c不是一个数组类型，那么会使用<strong>D的类加载器</strong>加载c，其中会将c的全限定名传递给D的类加载器。如果其中又需要加载其他类，那么重复整个解析程序</p></li><li><p>如果c是一个数组类型，并且数组元素是对象类型，那么会重复第一步，<strong>并且由虚拟机生成该数组</strong></p></li><li><p>如果上面两步没有出现问题，那么会检查符号引用的权限，确认D对C具有访问，否则会抛出异常</p></li></ol><h3 id="2-4-2-字段的解析"><a href="#2-4-2-字段的解析" class="headerlink" title="2.4.2 字段的解析"></a>2.4.2 字段的解析</h3><p>首先我们需要找到字段所属的类或接口C，然后：</p><ol><li><p>如果在c中找到了简单名称和描述符都与目标相符的字段，那么会返回字段的直接引用</p></li><li><p>在c实现的接口中，从下往上查找目标</p></li><li><p>在c继承的父类中，从下往上查找目标</p></li><li><p>如果成功获得了直接引用，还会检查是否对目标字段具有访问权限</p></li></ol><p>如果在c的父类或接口中实现了相同字段，虽然按照规则可以成功找到目标字段，但是编译器为了安全，还是会选择拒绝编译。</p><blockquote><p>字段会在解析阶段完全解析好，因为符号引用在编译时期就确定了</p></blockquote><h3 id="2-4-3-接口方法的解析"><a href="#2-4-3-接口方法的解析" class="headerlink" title="2.4.3 接口方法的解析"></a>2.4.3 接口方法的解析</h3><p>首先在接口方法表中解析出当前方法所属的类或接口c，然后：</p><ol><li><p>如果c是一个类，那么抛出IncompatibleClassChangeError</p></li><li><p>否则在接口c中查看目标方法，如果成功，则返回直接引用</p></li><li><p>否则在c继承的接口中查找目标方法，这一步骤有一点值得注意：会一直向上递归查找，直到对java.lang.Object查找完毕，因为接口方法的查找范围<strong>包括Object类中的方法。</strong></p></li><li><p>对查找的直接引用进行权限检查在JDK9之后，因为JDK9之后引入了模块化系统。</p></li></ol><p>如果在继承的多个父接口中查找到了多个目标方法，虽然虚拟机规范规定随意返回一个即可。</p><h2 id="2-5-初始化"><a href="#2-5-初始化" class="headerlink" title="2.5 初始化"></a>2.5 初始化</h2><p>这里的初始化是指对类进行初始化，并且这一阶段可以通过程序控制。</p><p>初始化阶段就是执行类构造器<code>&lt;cinit&gt;()</code>方法的过程。这一方法通过编译器自动生成，生成规则如下：</p><ol><li><p>收集类中所有类变量的赋值动作和静态代码块的语句按<strong>顺序</strong>而合成，如果没有静态变量<strong>赋值</strong>语句和静态代码块，那么并不会生成<code>&lt;cinit&gt;()</code></p></li><li><p>静态代码块只能访问定义在块之前的静态变量，对于块之后定义的静态变量，静态代码块只能赋值，不能访问</p></li><li><p>虚拟机会保证父类的类构造器<code>&lt;cinit&gt;()</code>一定会在子类的<code>&lt;cinit&gt;()</code>执行之前执行，这与实例构造器<code>&lt;init&gt;()</code>一样，会保证父类的实例构造器先于子类执行，并且JVM保证在多线程环境下<code>&lt;cinit&gt;()</code>只会被执行一次</p></li></ol><p>这里怎么保证呢？就是虽然<code>super</code>是在是在子类构造器中调用的，但是<code>super</code>实际是在调用父类的<code>&lt;init&gt;</code>，而子类的<code>&lt;init&gt;</code>根本还没有开始执行，这样保证了父类的<code>&lt;init&gt;</code>一定会在子类的<code>&lt;init&gt;</code>之前完成，例如在下面的代码中：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FieldHashNoPolymorphic</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> money = <span class="hljs-number">1</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Father</span><span class="hljs-params">()</span> </span>&#123;<br>            ...<br>            showMeTheMoney();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMeTheMoney</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am Father, I have $&quot;</span> + money);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> money = <span class="hljs-number">3</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Son</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">//虽然super在Son的构造方法中，但是实际上Son的&lt;init&gt;还没有开始执行</span><br>            <span class="hljs-keyword">super</span>();<br>            ...<br>            showMeTheMoney();<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMeTheMoney</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am Son, I have $&quot;</span> + <span class="hljs-keyword">this</span>.money);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Father guy = <span class="hljs-keyword">new</span> Son();<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在执行<code>super</code>的时候，<code>Son</code>类的<code>&lt;init&gt;</code>方法还没有开始调用，所以<code>Son</code>类的<code>money</code>字段仍然为0。那么<code>&lt;init&gt;</code>由哪些部分组成呢？与<code>&lt;cinit&gt;</code>类似，也是由三部分组成：</p><ol><li>成员变量显式赋值代码</li><li>非静态代码块中的代码</li><li>构造器中的代码</li></ol><p>其中1、2部分按照出现的顺序排列，3永远排在最后执行。</p><h3 id="2-5-1-接口的初始化"><a href="#2-5-1-接口的初始化" class="headerlink" title="2.5.1 接口的初始化"></a>2.5.1 接口的初始化</h3><p>对于接口来说，并没有强制要求父接口的<code>&lt;cinit&gt;()</code>一定要在子接口<code>&lt;cinit&gt;()</code>之前执行。只有当父接口中定义的变量被使用时，才会执行父接口的<code>&lt;cinit&gt;()</code>方法。并且接口的实现类初始化时也不会执行接口的<code>&lt;cinit&gt;()</code>方法。</p><h1 id="3-类方法的解析"><a href="#3-类方法的解析" class="headerlink" title="3. 类方法的解析"></a>3. 类方法的解析</h1><p>方法的总体来说可以分为两个部分：</p><ul><li>能够在解析阶段完成解析的方法</li><li>只能在运行时完成解析的方法</li></ul><p>那么如何区分它们呢？这与具体的方法调用的字节码指令有关，在java中，有五条字节码与方法调用有关：</p><ul><li>invokestatic:调用静态方法</li><li>invokespecial：用于调用特殊的实例方法，包括实例初始化方法（<init>()方法）、私有方法、父类方法（<strong>最近的一个父类</strong>）</li><li>invokevirtual：用于调用对象的实例方法</li><li>invokeinferface：用于调用接口方法</li><li>invokedynamic：用于运行时动态解析出调用点限定符所引用的方法</li></ul><p>我们可以根据这五条调用方法的指令来判定当前方法能否在类加载过程中的解析阶段完成符号链接。值得注意的是<strong>前四条的方法调用逻辑</strong>是完全固化在虚拟机内的，而最后一条指令的调用指派完全由程序员指定。</p><h2 id="3-1-类加载阶段的方法符号解析"><a href="#3-1-类加载阶段的方法符号解析" class="headerlink" title="3.1 类加载阶段的方法符号解析"></a>3.1 类加载阶段的方法符号解析</h2><p>只要是通过<code>invokestatic</code>、<code>incokespecial</code>调用的或者被<code>final</code>修饰的方法，就能在类加载阶段中的解析步骤时将符号引用转换为目标方法的直接引用。总计分为五种方法：</p><ul><li>静态方法</li><li>对象的构造方法</li><li>私有方法</li><li>父类方法</li><li>被<code>final</code>修饰的方法</li></ul><p>上述五类方法被称为“非虚方法”，调用的方法的符号引用在编译器就已经完全确定，这类方法的调用称为<strong>解析</strong>。其他的所有方法都为“虚方法”，java中默认方法都是虚方法。</p><h2 id="3-2-运行时的方法符号解析"><a href="#3-2-运行时的方法符号解析" class="headerlink" title="3.2 运行时的方法符号解析"></a>3.2 运行时的方法符号解析</h2><p>除了在3.1小节指出的非虚方法外，其余的方法会在第一次调用时进行链接。这类方法的符号解析有一个特殊的名字，称为<strong>分派</strong>。顾名思义，分派肯定是从多个候选者选择一个。我认为这是与解析最大的不同，因为解析调用的候选方法只有一个。</p><p>分派又可分为静态分派和动态分派。</p><h3 id="3-2-1-静态分派"><a href="#3-2-1-静态分派" class="headerlink" title="3.2.1 静态分派"></a>3.2.1 静态分派</h3><p>所谓的静态分派和上述非虚方法的解析并没有太大差别，都是在编译期确定目标方法的符号引用。值得注意的是：在重载环境下，编译器依赖方法参数的静态类型选择合适的版本。这也侧面说明了重载时只有参数不同才算重载。</p><p>这类依赖静态类型来决定目标方法版本的操作称为静态解析，因为候选者有多个！<strong>静态解析的结果由编译器决定而不是虚拟机。</strong></p><h3 id="3-2-2-动态分派"><a href="#3-2-2-动态分派" class="headerlink" title="3.2.2 动态分派"></a>3.2.2 动态分派</h3><p>静态分派是靠编译器实现的，动态分派是靠<code>invokevirtual</code>执行实现的，<code>invokevirtual</code>的执行步骤如下：</p><ol><li>找到操作数栈顶第一个元素指向的对象的实际类型C</li><li>在类C中查找是否存在描述符和简单名称都符合预期目标的方法，如果存在，那么结束查找</li><li>否则在类C的各个父类中进行查找，直到无法找到抛出异常</li></ol><p>这类依赖变量动态类型来决定调用的方法版本称为动态分派。值得注意的是：字段永远不存在多态，只会存在覆盖的概念。查询字段只会在最近的范围内查找。下面的代码很好地解释了动态分派与同名字段覆盖：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FieldHashNoPolymorphic</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> money = <span class="hljs-number">1</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Father</span><span class="hljs-params">()</span> </span>&#123;<br>            money = <span class="hljs-number">2</span>;<br>            System.out.println(<span class="hljs-keyword">this</span>.money+<span class="hljs-string">&quot;---&quot;</span>+<span class="hljs-keyword">this</span>);<br>            showMeTheMoney();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMeTheMoney</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am Father, I have $&quot;</span> + money);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> money = <span class="hljs-number">3</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Son</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//这个this实际上是不能被传递的，这里只是示意</span><br>            System.out.println(<span class="hljs-keyword">this</span>);<br>            money = <span class="hljs-number">4</span>;<br>            showMeTheMoney();<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMeTheMoney</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am Son, I have $&quot;</span> + money);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Father guy = <span class="hljs-keyword">new</span> Son();<br>        <span class="hljs-comment">// 通过静态类型访问到了父类中的money，输出2</span><br>        System.out.println(<span class="hljs-string">&quot;This guy has $&quot;</span> + guy.money);<br>        <span class="hljs-comment">// 将静态类型强转成Son，访问的就是子类中的money，输出4</span><br>        System.out.println(<span class="hljs-string">&quot;This guy has $&quot;</span> + ((Son) guy).money);<br>    &#125;<br>&#125;<br># 输出如下<br><span class="hljs-number">2</span>---jvm.FieldHashNoPolymorphic$Son@6ed3ef1<br>I am Son, I have $<span class="hljs-number">0</span><br>jvm.FieldHashNoPolymorphic$Son@6ed3ef1<br>I am Son, I have $<span class="hljs-number">4</span><br>This guy has $<span class="hljs-number">2</span><br>This guy has $<span class="hljs-number">4</span><br><br></code></pre></div></td></tr></table></figure><p>在第一次执行中，为什么会调用<code>Son</code>类的<code>showTheMoney()</code>?因为在调用方法时，会将方法接收者（也就是caller）的引用传递进去，调用父类构造函数的代码是<code>super(this)</code>，这里的<code>this</code>代表<code>Son</code>类的对象。所以在执行下面代码时：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Father</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.money = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">this</span>.showMeTheMoney();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>虽然这里的<code>this</code>指向的是子类<code>Son</code>对象，但是我们想想，<code>Son</code>对象肯定会包含了父类<code>Father</code>的数据啊，所以这两个<code>this</code>显示地是同一个地址没毛病。</p><p>但是<code>sout(this.money)==2</code>就说明这里使用的<code>money</code>属性是父类的，因为代码执行处离父类<code>Father</code>最近。而显示的<code>I am Son, I have $0</code>就说明此时使用的是子类<code>Son</code>的<code>money</code>属性，因为此时代码执行处处离<code>Son</code>最近。值为0是因为此时子类<code>Son</code>的<code>money</code>属性还没有初始化，因为父类的构造函数还未执行完毕。</p><p>虽然在Son类型的对象中，内存中会存在两个<code>money</code>,但是Son对象只会使用离他最近的一个，也就是自身类中的<code>money</code>属性，子类的属性会隐藏父类的同名属性。</p><h3 id="3-2-3-单分派与多分派"><a href="#3-2-3-单分派与多分派" class="headerlink" title="3.2.3 单分派与多分派"></a>3.2.3 单分派与多分派</h3><p>决定单分派与多分派的标准是使用的宗量数量。宗量分为两大类：方法的接受者（caller）与方法的参数。采用《深入理解java虚拟机》中的例子作为解释：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dispatch</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QQ</span></span>&#123;&#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_360</span></span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hardChoice</span><span class="hljs-params">(QQ arg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;father choose qq&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hardChoice</span><span class="hljs-params">(_360 arg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;father choose 360&quot;</span>);<br>    &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hardChoice</span><span class="hljs-params">(QQ arg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;son choose qq&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hardChoice</span><span class="hljs-params">(_360 arg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;son chooes 360&quot;</span>);<br>    &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Father father = <span class="hljs-keyword">new</span> Father();<br>    Father son = <span class="hljs-keyword">new</span> Son();<br><br>    father.hardChoice(<span class="hljs-keyword">new</span> _360());<span class="hljs-comment">//father choose 360</span><br>    son.hardChoice(<span class="hljs-keyword">new</span> QQ());<span class="hljs-comment">//son choose qq</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于<code>fahter.hardChoice(new _360())</code>,在编译时期编译器确定调用符号时，可以看出候选者非常多（候选者有哪些，需要列出来）。那么在调用<code>father.hardChoice</code>时发现方法的接收者的静态类型这是<code>Father</code>,这就决定了在<code>Father</code>类中选择。那么接着查看调用方法的参数，发现实参的静态类型为<code>360</code>,那么通过方法调用者和函数实参这两个标准在编译器确定了符号调用，这就代表使用了两个宗量。同理编译<code>son.hardChoice(new QQ())</code>时也会使用两个宗量确定符号引用。</p><p>上述确定的两个符号引用会使用<code>invokevirtual</code>调用。那么在运行时,因为已经在编译器确定了方法签名，但是候选者仍然有两个：</p><ul><li>Father::hardChoice(_360 arg)</li><li>Son::hardChoice(_360 arg)</li></ul><p>因为上述的两个函数调用实际会使用<code>invokeVirtual</code>执行，所以在运行时虚拟机会从上述的两个候选者中选择一个。以<code>father.hardChoice(new _360())</code>为例，方法接收者<code>father</code>的实际类型为<code>Son</code>，所以虚拟机会选择<code>Son</code>类中的方法。可以看出在抉择过程中只用了“方法调用者”这一个参考因素。</p><p>所以到目前为止，<strong>java是一个静态多分派、动态单分派的语言</strong>。那么时候才会进入分派的阶段，也就是使用<code>virtualinvoke</code>指定？</p><p>我认为答案是调用非虚方法时，会进入分派阶段。</p><hr><p><strong>Extension: invokevirtual的执行过程</strong></p><ol><li><code>invokevirtual</code>首先会找到操作数栈的栈顶第一个元素所指向的对象的实际类型，记为C；</li><li>在C自身中进行查找符号和描述相符的方法，如果找到，则需要检查权限</li><li>如果在C自身中未找到，那么会按照继承关系<strong>自下而上</strong>在C的父类中进行查找，如果找到则需要进行权限检查</li><li>如果都为找到，则会抛出<code>AbstractMethodError</code>异常</li></ol><hr><h3 id="3-2-4-分派的具体实现"><a href="#3-2-4-分派的具体实现" class="headerlink" title="3.2.4 分派的具体实现"></a>3.2.4 分派的具体实现</h3><p>在每次调用时才去执行分派效率必定低下，所以jvm选择以虚表(virtual method table)的形式实现分派的过程。虚表和cpp中的虚表概念差不多。这个虚表建立在方法区。对于子类来说，如果没有重写父类的方法，那么子类的虚方法表中，没有被重写的方法的指针和父类同一方法的指针指向同一个函数。</p><blockquote><p>虚表会在类加载阶段完成初始化，在完成连接阶段中的初始化过程后，会完成该类的虚表初始化</p></blockquote><h1 id="4-小测试"><a href="#4-小测试" class="headerlink" title="4. 小测试"></a>4. 小测试</h1><p>根据类加载的规则，下面的代码输出到底是多少？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleTon</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingleTon singleTon = <span class="hljs-keyword">new</span> SingleTon();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count1;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count2 = <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingleTon</span><span class="hljs-params">()</span> </span>&#123;<br>        count1++;<br>        count2++;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleTon <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> singleTon;<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SingleTon singleTon = SingleTon.getInstance();<br>        System.out.println(<span class="hljs-string">&quot;count1=&quot;</span> + singleTon.count1);<br>        System.out.println(<span class="hljs-string">&quot;count2=&quot;</span> + singleTon.count2);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>一个经常出现的错误答案是：</p><blockquote><p>count1=1;<br>count2=1;</p></blockquote><p>但是正确的执行结果为：</p><blockquote><p>count1=1;<br>count2=0;</p></blockquote><p>为什么呢？因为类加载过程中准备阶段是在初始化阶段之前的，虽然在上面的代码中有<code>count2=0</code>，但是准备阶段不关心这个。准备阶段完成后：</p><blockquote><p>count1=0;<br>count2=0;</p></blockquote><p>最后在初始化过程中，编译器生成的<code>&lt;cinit&gt;</code>方法是按照代码书写顺序生成的，例如这个例子中生成的是：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">cinit()&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingleTon singleTon = <span class="hljs-keyword">new</span> SingleTon();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count1;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count2 = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>虽然在执行<code>SingleTon</code>的构造方法时，会执行<code>count2=1</code>的操作，但是注意，<code>&lt;cinit&gt;</code>方法还没有执行完成呢。在<code>&lt;cinit&gt;</code>中最后还是会执行<code>count2=0</code>的操作。</p><p>所以最终的答案是：</p><blockquote><p>count1=1;<br>count2=0;</p></blockquote>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/jvm/">jvm</category>
      
      
      <category domain="https://eripe.me/tags/class-loading/">class loading</category>
      
      
      <comments>https://eripe.me/2021-06-04/class-loading-mechanism.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>双亲委派模型</title>
      <link>https://eripe.me/2021-06-04/parents-delegation-model.html</link>
      <guid>https://eripe.me/2021-06-04/parents-delegation-model.html</guid>
      <pubDate>Fri, 04 Jun 2021 11:57:44 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先在了解双亲委派模型前，我们有必要了解它的英文名字：<code>parents delegation model</code>。其实在具体的模型中，并没有所谓的“双亲”，只有一个逻辑意义上的父类，详情见下文。</p><h2 id="1-类加载器"><a href="#1-类加载器" class="headerlink" title="1. 类加载器"></a>1. 类加载器</h2><p>在《深入理解java虚拟机》一书中写道：</p><blockquote><p>java团队有意将类加载阶段中的“通过一个类的全限定名来获取该类的二进制字节流”这个动作放到java虚拟机外部去实现<br>完成这个动作的代码就称为类加载器，以前不理解放到虚拟机外部是什么意思，现在我的理解是我们能够在编写程序时就能够编写目标类的加载过程，这也就是所谓的在虚拟机外部。这样如此，我们自定义的类加载器就能够处理我们自定义的字节码。</p></blockquote><p>值得一提的是：类加载器与类共同确定了该类在虚拟机中是否唯一。也就是说，在虚拟机要比较两个类是否相同，比较的前提是<strong>待比较的两个类是由同一个类加载器加载到虚拟机中的</strong>，才有比较的意义。</p><p>这里的比较包括：<code>instanceof</code>、Class对象的<code>equals()</code>、<code>isAssignableForm()</code>、<code>isInstance()</code>方法。</p><h2 id="2-双亲委派模型"><a href="#2-双亲委派模型" class="headerlink" title="2. 双亲委派模型"></a>2. 双亲委派模型</h2><p>在了解双亲委派模型前，我们需要知道，jvm中有三类自带的类加载器：</p><ul><li><code>bootstrap class loader</code>，启动类加载器</li><li><code>extension class loader</code>，扩展类加载器</li><li><code>Application class laoder</code>，应用程序类加载器</li></ul><p><strong>启动类加载器</strong><br>启动类加载器由cpp编写，在java代码中无法直接引用。该加载器负责加载java的核心库，包括<code>&lt;JAVA_HOME&gt;/lib/</code>下的库，例如rt.jar、tools.jar；或者由<code>-Xbootclasspath</code>指定的，并且存放在lib目录下的符合规则的库，这里的规则是库的名字由jvm指定，不符合名字要求的即使由参数指定，也不会被加载。</p><p>前面说到，该加载器由cpp编写时，所以在编写代码时如果我们需要使用到该加载器，我们可以用null指代启动类加载器，这一规则由java团队约定。</p><p><strong>扩展类加载器</strong><br>扩展类加载器由java编写，负责加载<code>&lt;JAVA_HOME&gt;/lib/ext/</code>目录下的库，或者由环境变量<code>java.extdirs</code>指定目录下的库。</p><p><strong>应用程序加载器</strong><br>应用程序类加载器通用由java编写，在代码中可以直接引用。该加载器是我们接触最多的加载器了，默认情况下，我们编写的class都由其加载至jvm中。它负责加载由<code>classpath</code>参数指定路径下的类库。</p><blockquote><p>应用程序类加载器由<code>sun.misc.Launcher$AppClassLoader</code>实现。并且应用程序类加载器是ClassLoader中的getSystemClassLoader()方法的返回值</p></blockquote><p>这三个加载器的关系如下所示：</p><p><img src="images/jvmclassloader.jpg" alt="jvm class loader"></p><p>可以看到，<code>BootStrap ClassLoader</code>作为顶层的父类，<code>Extension ClassLoader</code>作为<code>BootStrap ClassLoader</code>的子类，而<code>Application ClassLoader</code>又作为<code>Extension ClassLoader</code>的子类。我们可以看到，这里并没有所谓的双亲，只有单亲，而这么翻译可能是因为第一个翻译的人看到的是parents吧。</p><blockquote><p>这里的父类与子类并不是传统意义上的使用extends保持的继承关系，而是通过内部包含来实现逻辑意义上的继承关系</p></blockquote><p><strong>三类加载器的初始化过程</strong></p><p>下图显示了<code>ExtClassLoader</code>、<code>AppClassLoader</code>、<code>ClassLoader</code>三者真正的继承关系。<br><img src="images/Inheritance.png" alt="继承体系"></p><p><code>ExtClassLoader</code>和<code>AppClassLoader</code>处于平级的关系，那么如何实现所谓的双亲委派？这一切都要靠抽象类<code>ClassLoader</code>中的<code>parent</code>字段来实现，如下图所示：</p><p><img src="images/parents-field.png" alt="parent字段"></p><p>每生成一个新的<code>ClassLoader</code>,都会用父类加载器去初始化它。那么这三个加载器是如何初始化的呢？这一切都起源于<code>Launcher</code>类。 <strong>该类由<code>Bootstrap ClassLoader</code>来加载。</strong> 我们来看看它的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Launcher</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Launcher launcher = <span class="hljs-keyword">new</span> Launcher();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String bootClassPath = System.getProperty(<span class="hljs-string">&quot;sun.boot.class.path&quot;</span>);<br>    <span class="hljs-keyword">private</span> ClassLoader loader;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Launcher <span class="hljs-title">getLauncher</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> launcher;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Launcher</span><span class="hljs-params">()</span> </span>&#123;<br>        Launcher.ExtClassLoader var1;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//初始化ExtClassLoader</span><br>            var1 = Launcher.ExtClassLoader.getExtClassLoader();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException var10) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(<span class="hljs-string">&quot;Could not create extension class loader&quot;</span>, var10);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//初始化loader字段，将其设置为AppClassLoader</span><br>            <span class="hljs-keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException var9) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(<span class="hljs-string">&quot;Could not create application class loader&quot;</span>, var9);<br>        &#125;<br>        <span class="hljs-comment">//设置线程上下文加载器，也就是AppClassLoader</span><br>        Thread.currentThread().setContextClassLoader(<span class="hljs-keyword">this</span>.loader);<br>        ...<br>    &#125;<br>    ...<br></code></pre></div></td></tr></table></figure><p>在<code>Bootstrap ClassLoader</code>把<code>Launcher</code>加载进虚拟机后，<code>Launcher</code>会初始化静态字段<code>Launcher</code>，然后会调用构造方法。在构造方法中，我们目前只需关注三个部分：</p><ol><li><p>使用<code>Launcher.ExtClassLoader.getExtClassLoader()</code>生成扩展类加载器<code>ExtClassLoader</code></p></li><li><p>使用<code>Launcher.AppClassLoader.getAppClassLoader(var1)</code>生成应用类加载器<code>App ClassLoader</code>,其中<code>var1</code>就是第一步生成的扩展类加载器，其用来初始化<code>parent</code>字段</p></li><li><p>使用<code>Thread.currentThread().setContextClassLoader(this.loader)</code>初始化线程上下文加载器，其中<code>loader</code>字段就是第二步生成的应用类加载器</p></li></ol><p>此外我们还需要关注以下<code>App ClassLoader</code>的生成方法，因为其与<code>classpath</code>的设置息息相关。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClassLoader <span class="hljs-title">getAppClassLoader</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ClassLoader var0)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//读取系统属性classpath</span><br>    <span class="hljs-comment">//这里读取的是一个整个字符串，因为在windows上由“;”将多个路径拼接成一个string</span><br>    <span class="hljs-comment">//linux平台使用“:”拼接多个路径组成一个string</span><br>    <span class="hljs-keyword">final</span> String var1 = System.getProperty(<span class="hljs-string">&quot;java.class.path&quot;</span>);<br>    <span class="hljs-comment">//将多个路径抽象为File</span><br>    <span class="hljs-keyword">final</span> File[] var2 = var1 == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> File[<span class="hljs-number">0</span>] : Launcher.getClassPath(var1);<br>    <span class="hljs-keyword">return</span> (ClassLoader)AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Launcher.AppClassLoader&gt;() &#123;<br>        <span class="hljs-keyword">public</span> Launcher.<span class="hljs-function">AppClassLoader <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">//将多个路径转化为URL数组</span><br>            URL[] var1x = var1 == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> URL[<span class="hljs-number">0</span>] : Launcher.pathToURLs(var2);<br>            <span class="hljs-comment">//使用URl路径和Ext ClassLoader生成新的AppClassLoader</span><br>            <span class="hljs-comment">//具体的初始化逻辑见下</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Launcher.AppClassLoader(var1x, var0);<br>        &#125;<br>    &#125;);<br>&#125;<br><br>AppClassLoader(URL[] var1, ClassLoader var2) &#123;<br>    <span class="hljs-comment">//调用父类URLClassLoader的构造函数保存多个classpath路径</span><br>    <span class="hljs-keyword">super</span>(var1, var2, Launcher.factory);<br>    <span class="hljs-keyword">this</span>.ucp.initLookupCache(<span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-comment">//父类URLClassLoader的构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">URLClassLoader</span><span class="hljs-params">(URL[] urls, ClassLoader parent,</span></span><br><span class="hljs-params"><span class="hljs-function">                        URLStreamHandlerFactory factory)</span> </span>&#123;<br>    <span class="hljs-comment">//初始化parent字段</span><br>    <span class="hljs-keyword">super</span>(parent);<br>    ...<br>    <span class="hljs-comment">//实际使用ucp字符保存多个classpath路径</span><br>    ucp = <span class="hljs-keyword">new</span> URLClassPath(urls, factory, acc);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>经过上面的源码学习，我们已经非常清楚这三类加载器如何实现<strong>双亲</strong>的逻辑，并且还顺便搞懂了classpath的初始化过程。那么委派是什么呢？下面的加载流程很好地解释了什么是委派：</p><ol><li><p>在传统情况下，一个类的加载会由默认的类加载器加载，而一般情况下<code>Application ClassLoader</code>会作为默认的类加载器。类加载器首先会将请求委派给父类，而不是由自己来加载。</p></li><li><p><code>Application ClassLoader</code>会将加载请求委派给父类<code>Extension ClassLoader</code>,而<code>Extension ClassLoader</code>又会将请求委派给父类<code>BootStrap ClassLoader</code>。</p></li><li><p>如果<code>BootStrap ClassLoader</code>加载失败，那么具体的加载会由<code>Extension ClassLoader</code>完成。如果<code>Extension ClassLoader</code>加载失败，具体的加载会由<code>Extension ClassLoader</code>完成。如果再次不能完成，那么就会抛出异常。</p></li></ol><p>可以看到，加载请求会一级一级向上传递，直到传到根加载器。然后如果不能完成，请求又会一级一级从上到下传递到底部加载器。<strong>那么为什么要这么做呢？</strong></p><p>答案来自《深入理解java虚拟机》：</p><blockquote><p>这样做的一个显而易见的好处是，被加载的类随着它的加载器一起具备了一种优先级的层次关系。</p></blockquote><p>试想加载类<code>Object</code>,这个类肯定最终由<code>bootstrap ClassLoader</code>来加载。如果没有这种委派关系，我们随便写一个同名的类<code>Object</code>,虚拟机无法保证使用加载正确的<code>Object</code>类。那么最基础的核心类都无法保证正确加载，那就出大问题了。</p><p><strong>双亲委派模型的代码实现</strong></p><p>双亲委派的原理简单，代码实现也非常简单，下面的短短几十行代码就完成了操作：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>        <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// First, check if the class has already been loaded</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">long</span> t0 = System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//如果父类不为空，那么就使用父类的加载方法</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//否则使用根加载器加载</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                <span class="hljs-comment">// to find the class.</span><br>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br>                c = findClass(name);<br>                ...<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>系统类加载器的设置</strong></p><p>update：2021-01-18 00:31:03</p><p>复习到这时，我提出了一个问题：系统类加载器的设置和三类加载器之间的关系是怎么样的？是谁调用谁的？</p><p>目前我只能回答这个问题的一半：某个函数会首先调用<code>getSystemClassLoader()</code>，然后调用链如下：<code>getSystemClassLoader()</code>—&gt;<code>initSystemClassLoader</code>—&gt;<code>sun.misc.Launcher.getLauncher()</code></p><hr><p>我曾在上面提到，如果没有意外发生，那么在jvm中，<code>AppClassLoader</code>会被设置为默认的系统类加载器，这也是为什么会在某些场合称其为“系统类加载器”。那么这一设置是什么时候完成的呢？这一切都起源于<code>ClassLoader</code>中的方法<code>getSystemClassLoader</code>。其注释写道：</p><blockquote><p>If the system property “java.system.class.loader” is defined<br>when this method is first invoked then the value of that property is<br>taken to be the name of a class that will be returned as the system<br>class loader.  The class is loaded using the default system class loader<br>and must define a public constructor that takes a single parameter of<br>type ClassLoader which is used as the delegation parent.  An<br>instance is then created using this constructor with the default system<br>class loader as the parameter.  The resulting class loader is defined<br>to be the system class loader.</p></blockquote><p>如果设置为系统属性<code>java.system.class.loader</code>，那么在第一次调用<code>getSystemClassLoader</code>时，会将该系统属性指向的类设置为系统类加载器。值得注意的是，自定义的系统类加载器必须声明一个带有一个参数的公共构造方法，并且唯一参数用来当作委派父类。下面我们来看看这一方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClassLoader <span class="hljs-title">getSystemClassLoader</span><span class="hljs-params">()</span> </span>&#123;<br>    initSystemClassLoader();<br>    <span class="hljs-keyword">if</span> (scl == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    SecurityManager sm = System.getSecurityManager();<br>    <span class="hljs-keyword">if</span> (sm != <span class="hljs-keyword">null</span>) &#123;<br>        checkClassLoaderPermission(scl, Reflection.getCallerClass());<br>    &#125;<br>    <span class="hljs-keyword">return</span> scl;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们看到，该方法内部会调用<code>initSystemClassLoader()</code>，那么这个方法又做了什么事情呢？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initSystemClassLoader</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!sclSet) &#123;<span class="hljs-comment">//如果系统类加载器还没有被设置</span><br>        <span class="hljs-keyword">if</span> (scl != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;recursive invocation&quot;</span>);<br>        sun.misc.Launcher l = sun.misc.Launcher.getLauncher();<br>        <span class="hljs-keyword">if</span> (l != <span class="hljs-keyword">null</span>) &#123;<br>            Throwable oops = <span class="hljs-keyword">null</span>;<br>            scl = l.getClassLoader();<span class="hljs-comment">//获得ApplicationClassLoader</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                scl = AccessController.doPrivileged(<br>                    <span class="hljs-keyword">new</span> SystemClassLoaderAction(scl));<span class="hljs-comment">//设置系统类加载器</span><br>            &#125; <span class="hljs-keyword">catch</span> (PrivilegedActionException pae) &#123;<br>                oops = pae.getCause();<br>                <span class="hljs-keyword">if</span> (oops <span class="hljs-keyword">instanceof</span> InvocationTargetException) &#123;<br>                    oops = oops.getCause();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (oops != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (oops <span class="hljs-keyword">instanceof</span> Error) &#123;<br>                    <span class="hljs-keyword">throw</span> (Error) oops;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// wrap the exception</span><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(oops);<br>                &#125;<br>            &#125;<br>        &#125;<br>        sclSet = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中<code>sclSet</code>是<code>ClassLoader</code>的属性，如果是第一次调用，那么会通过<code>Launcher</code>调用<code>getSystemLoader</code>获取<code>Launcher</code>内部字段<code>loader</code>的值。不知道大家还记不记得，<code>loader</code>字段会被设置为<code>AppClassLoader</code>。此后<code>scl</code>会被设置为<code>AppCLassLoader</code>。</p><p>然后会使用<code>SystemClassLoaderAction</code>读取系统属性<code>java.system.class.loader</code>,完成系统类加载器的设置，我们来看看其源码。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemClassLoaderAction</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">PrivilegedExceptionAction</span>&lt;<span class="hljs-title">ClassLoader</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> ClassLoader parent;<br><br>    SystemClassLoaderAction(ClassLoader parent) &#123;<br>        <span class="hljs-keyword">this</span>.parent = parent;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ClassLoader <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String cls = System.getProperty(<span class="hljs-string">&quot;java.system.class.loader&quot;</span>);<br>        <span class="hljs-keyword">if</span> (cls == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> parent;<br>        &#125;<br>        Constructor&lt;?&gt; ctor = Class.forName(cls, <span class="hljs-keyword">true</span>, parent)<br>            .getDeclaredConstructor(<span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123; ClassLoader.class &#125;);<br>        ClassLoader sys = (ClassLoader) ctor.newInstance(<br>            <span class="hljs-keyword">new</span> Object[] &#123; parent &#125;);<br>        Thread.currentThread().setContextClassLoader(sys);<br>        <span class="hljs-keyword">return</span> sys;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们可以很清楚的看到，如果系统属性<code>java.system.class.loader</code>为空，那么就会返回<code>parent</code>。此前<code>parent</code>已通过构造函数被设置为<code>AppClassLoader</code>。</p><p>否则，加载系统属性指向的类并获取带有一个参数的构造方法。随后创建自定义类加载器的实例<code>sys</code>并返回。</p><p>至此，已经完成了系统类加载器的设置。所以说，默认情况下，所有的类都会使用<code>AppClassLoader</code>来加载。</p><h2 id="3-破坏双亲委派模型"><a href="#3-破坏双亲委派模型" class="headerlink" title="3. 破坏双亲委派模型"></a>3. 破坏双亲委派模型</h2><p>虽然双亲委派模型好，但它也不是万能的。到目前为止，已经出现了三次破坏行为。下面来品一哈。</p><h3 id="3-1-第一次破坏"><a href="#3-1-第一次破坏" class="headerlink" title="3.1 第一次破坏"></a>3.1 第一次破坏</h3><p>第一次破坏是由于JDK1.2之前还没有出现双亲委派模型，但是此时已经有了类加载器的概念。那么此时已经有了许多用户自定义的类加载器。那么为了兼容以前的代码，无法再以技术手段避免<code>loadClass()</code>被子类覆盖的可能性。这里所谓的无法避免是什么呢？我们再次来看看双亲委派的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>        <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// First, check if the class has already been loaded</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">long</span> t0 = System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//如果父类不为空，那么就使用父类的加载方法</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//否则使用根加载器加载</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                <span class="hljs-comment">// to find the class.</span><br>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br>                c = findClass(name);<br>                ...<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果此时用户代码还在覆盖<code>loadClass</code>,但是编写出的代码并没有采用双亲委派，那么就会使双亲委派失效。因为双亲委派就是靠<code>loadClass</code>来实现的。所以尽管不能避免之前的状态，但是以后要尽量避免让用户覆盖<code>loadClass</code>。</p><p>所以在JDK1.2之后，在<code>ClassLoader</code>中引入了一个<code>protected</code>方法<code>findClass()</code>。希望引导用户能够覆盖<code>findClass()</code>编写自定义类加载器。这样既不影响双亲委派，又可以按照用户自己的意愿加载类，就像上面源码中的那样，当父类加载失败，那么就会调用<code>findClass()</code>加载。</p><p>所以重写<code>loadClass</code>会破坏双亲模型，而重写<code>findClass</code>则不会，如果需要在多个类加载器中加载同一个<code>Class</code>，则需要使用前者。</p><h3 id="3-2-第二次破坏"><a href="#3-2-第二次破坏" class="headerlink" title="3.2 第二次破坏"></a>3.2 第二次破坏</h3><p>第二次破坏是因为双亲委派这个机制存在缺陷。首先我们需要明白下面这种机制：</p><blockquote><p>假设我们当前代码所处的类为D，如果此时要把一个从未解析的符号解析成类或接口C。如果C不是数组类型，那么<strong>jvm会使用加载D的类加载器来加载C</strong>。</p></blockquote><p>但是在双亲委派模型中，上层的类加载器是无法指派下层的类加载器来完成加载动作的。一个典型的例子就是JNDI(The Java Naming and Directory Interface)服务。简而言之，JDNI就是java规定一组服务的接口，但是具体的实现由第三方提供，例如数据库的驱动。</p><p>那么这个<strong>破坏</strong>在哪里呢？首先JDNI肯定是由启动类加载器加载至JVM。那么调用具体的实现类时，启动类加载器是不可能将实现类加载进来的，因为这不符合启动类加载器的规定。那么怎么办呢？</p><p>开发人员又设计了一种叫进程上下文类加载器(Thread Context ClassLoader)的东西来完成这个任务。启动类加载器会调用进程上下文类加载器来加载接口的实现类。</p><p>线程上下文类加载器在(默认情况下)由<code>Bootstrap classLoader</code>第一次加载<code>Launcher</code>类时就会被设置为<code>App ClassLoader</code>。当然，我们可以通过<code>setContextClassLoader(ClassLoader cl)</code>和<code>getContextClassLoader()</code>来设置和使用我们自定义的线程上下文类加载器。<strong>在多线程的情况下</strong>，子线程会继承父线程的线程上下文类加载器。</p><h3 id="3-3-第三次破坏"><a href="#3-3-第三次破坏" class="headerlink" title="3.3 第三次破坏"></a>3.3 第三次破坏</h3><p>这次破坏是为了实现java应用的热部署。简单来说就是OSGi机制破坏了双亲委派模型。以下引自《深入理解java虚拟机》：</p><blockquote><p>OSGi实现模块热部署的关键是它自定义的类加载机制的实现，每一个程序模块（OSGi称其为bundle）都有属于自己的类加载器。当需要替换Bundle时，就把Bundle连同类加载器一起替换以实现代码的热替换。</p><p>在OSGi环境下，类加载机制不再是委派双亲的树模型，而是一个<strong>网状</strong>结构。OSGi的类加载顺序中，只有前两个步骤符合双亲委派的原则，即：</p><ol><li>将以java.*开头的类，委派给父类加载器加载</li><li>否则,将委派列表名单内的类，委派给父类加载器加载</li></ol></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文详细介绍了双亲委派模型的类加载机制，解释了什么是“双亲”、什么是“委派”，三个系统自带的类加载器的初始化过程（仅限于JDK1.2-1.8）。以及历史上三次破坏双亲委派模型的事件，引出了SPI。后面我会以数据库加载驱动的案例讲解SPI到底是如何工作的。</p><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>我们在上面的源码中会经常看到<code> AccessController.doPrivileged()</code>这个方法，这又跟java的安全模型相关，谈起来不简单，后面我会专门开一篇来讲解它。</p><p><strong>参考文献</strong></p><p><a href="https://greenhathg.github.io/2019/06/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-Launcher%E7%B1%BB/">https://greenhathg.github.io/2019/06/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-Launcher%E7%B1%BB/</a></p><p><a href="https://juejin.im/post/6844903837472423944">https://juejin.im/post/6844903837472423944</a></p><p><a href="https://segmentfault.com/a/1190000021869536">https://segmentfault.com/a/1190000021869536</a></p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/jvm/">jvm</category>
      
      
      <category domain="https://eripe.me/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/">类加载</category>
      
      
      <comments>https://eripe.me/2021-06-04/parents-delegation-model.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>关于泛型的常见问题</title>
      <link>https://eripe.me/2021-06-04/Frequently-asked-questions-about-generics.html</link>
      <guid>https://eripe.me/2021-06-04/Frequently-asked-questions-about-generics.html</guid>
      <pubDate>Fri, 04 Jun 2021 11:57:44 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里罗列一些关于泛型的常见问题,并给出解答。其中本篇大多数问题来自<a href="http://www.angelikalanger.com/GenericsFAQ/FAQSections/ParameterizedTypes.html">Java Generics FAQs - Generic And Parameterized Types</a>,我这里仅翻译一些我认为比较容易糊涂的问题。</p><p>当然,在解答这些问题时,我们需要牢记一个概念,通配符<code>?</code>表示的是不知道是什么类型,而不是任意类型。</p><ul><li>泛型类型:<code>class test&lt;T&gt;&#123;&#125;</code></li><li>具体参数类型:<code>class test&lt;String&gt; t1=null;</code></li><li>泛型参数类型:<code>test&lt;?&gt; t2=null;</code></li></ul><h2 id="1-使用通配符时经常出现的capture-XXX-of-到底什么意思"><a href="#1-使用通配符时经常出现的capture-XXX-of-到底什么意思" class="headerlink" title="1. 使用通配符时经常出现的capture#XXX of ? 到底什么意思?"></a>1. 使用通配符时经常出现的capture#XXX of ? 到底什么意思?</h2><p>在使用通配符时,我们很有可能会遇到类似<code>capture#337 of ?</code>这样莫名奇妙的错误。其中<code>capture</code>是捕获的意思,捕获的是通配符<code>?</code>,那么<code>#337</code>又代表着什么?这一切都要从捕获转化(Capture Conversion)开始说起。</p><p>让我们思考一个问题,如果我们定义定义一个泛型类C如下(类似于List容器)如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> &lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span>&gt;</span>&#123;<br>    ...<br>    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T)</span></span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">C&lt;?&gt; c</span>=<span class="hljs-keyword">new</span> C&lt;Integer&gt;()<br></code></pre></div></td></tr></table></figure><p>那么通过<code>c</code>调用对象方法时,方法的签名是什么样的?像下面这样?(编译时期泛型还是存在的)</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> &lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span>&gt;</span>&#123;<br>    ...<br>    ? get();<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(?)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这显然是毫无意义的,但是我们知道实例化类时一定会使用一个具体的类型X:&lt; Number( <strong>:&lt;</strong> 表示前者继承于后者),尽管我们不知道这个X到底是什么类型的。这并不重要。那么被具体类型X实例化的类C长下面这样:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&lt;<span class="hljs-title">X</span>&gt;</span>&#123;<span class="hljs-comment">//X:&lt;Number</span><br>    ...<br>    <span class="hljs-function">X <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(X)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用一个具有名字的类型比使用通配符<code>?</code>容易多了。所以编译器也是这么做的。只不过编译器并不会使用<code>X</code>,而是随机使用一个数字,例如<code>#337</code>表示上面这个通配符。所以才会有了这句<code>capture#337 of ?</code>。即编译将遇到这个统配符<code>?</code>分配了一个名字叫做<code>#337</code>。</p><p>当一个<code>value</code>的类型是通配符类型,编译器会使用类型变量替换这个<code>value</code>种存在的通配符<code>?</code>(类型变量中的数字按序增长),这种操作名为<code>capture conversion</code>,通过这个操作,编译器只需要处理带有具体类型的对象。</p><p>对于上面的例子,<code>get()</code>方法返回一个<code>X</code>类型的引用,其中<code>X:&lt;Number</code>,那么我们就可以执行下述操作:</p><blockquote><p>Number n= c.get();//c为类C的实例,get方法返回的是Number类型</p></blockquote><p>但是我们却不能向c中添加元素。</p><blockquote><p>c.add(number)//add方法接受的参数为类型为capture#1 of ?</p></blockquote><p>因为add方法接受的参数类型为x(编译器的名字可能为capture#1 of ?),而容器c中的引用至少都为Number类型,因为容器内的元素类型都有一个限制:<code>? extends Number</code>,所以编译器出于安全,将容器内的引用推断为<code>Number</code>类型肯定是不会错的。<br>那么一个存储<code>Number</code>类型的容器,能接受一个类型为<code>capture#1 of ?</code>的值吗?不知道,因为后者的类型编译器无法推断,所以为了保险起见,直接会产生编译错误。</p><p>只要有表达式产生了<code>wild type</code>的<strong>value</strong>(The compiler applies capture conversion on every expression that yields a value in wild type),<code>capture conversion</code>操作就存在。并且会为每个通配符<code>?</code>分配一个唯一ID。以下面代码为例:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;? extends Number&gt; foo(List&lt;? extends Number&gt; numberList)<br>&#123;<br>#<span class="hljs-number">1</span>  <span class="hljs-keyword">for</span>(Number number : numberList)<br>#<span class="hljs-number">2</span>      <span class="hljs-keyword">assert</span> numberList.contains(number);<br>#<span class="hljs-number">3</span>  numberList = numberList;<br>#<span class="hljs-number">4</span>  <span class="hljs-keyword">return</span> numberList;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面代码有四个地方都存在<code>wild type</code>的变量,我们一个一个来分析。</p><p>对于<code>#1</code>处的<code>numberList</code>,其类型为<code>List &lt;? extends Number&gt;</code>,那么会将这处的<code>numberList</code>转换为<code>List&lt;X1&gt;</code>类型,<code>List&lt;X1&gt;</code>是<code>Iterable&lt;X1&gt;</code>的子类,所以可以使用for循环遍历,number的类型是<code>X1</code>,又因为<code>X1:&lt;Number</code>,所以其可以向上转型为<code>Number</code></p><p>对于<code>#2</code>处的<code>numberList</code>,编译器会将其类型转换为<code>List&lt;X2&gt;</code>类型,其中的<code>contains</code>方法是<code>List&lt;X2&gt;</code>类型下的<code>contains</code>方法,所以该方法接受一个<code>X2</code>类型的参数</p><p>对于<code>#3</code>处的右<code>numberList</code>,编译器会将其类型转换为<code>List&lt;X3&gt;</code>,但是！！！对于左边的<code>numberList</code>,因为其是一个variable,而不是一个value,所以编译器不会对其类型进行转换,还是<code>List&lt;? extends Number&gt;</code>,将<code>List&lt;X3&gt;</code>类型赋值给<code>List&lt;? extends Number&gt;</code>类型是合法的,因为<code>X3:&lt;Number</code>。<br><strong>那么是否可以认为左侧的都是variable,而右侧的是value???</strong> 或者是否可以这样理解:右边的变量<code>numberList</code>把它的value赋值给了左侧的<code>numberList</code>,而这个value是<code>wild type</code>？或者说用的时候实际上使用的实际上是variable的value?</p><p>对于<code>#4</code>处的<code>numberList</code>,编译器同样会转换为<code>List&lt;X4&gt;</code>后返回。</p><p>上面的转换规则非常重要,我们再来看一个难一点的例子。现在有一个map,类型为<code>Map&lt;?,?&gt; map</code>,那么如果进行如下操作是合法的:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(Entry&lt;?,?&gt; entry : map.entrySet())<br></code></pre></div></td></tr></table></figure><p>因为<code>map</code>会被转型为<code>Map&lt;X1,X2&gt;</code>类型,那么返回的entrySet就是<code>Set&lt;Entry&lt;X1,X2&gt;&gt;</code>,因为<code>X1&lt;:?</code>,<code>X2&lt;:?</code>,所以将<code>Entry&lt;X1,X2&gt;</code>类型赋值给<code>Entry&lt;?,?&gt;</code>类型是合理的。但是下面的操作就非法了</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Set&lt;Entry&lt;?,?&gt;&gt; entrySet = map.entrySet(); <span class="hljs-comment">// compile error</span><br></code></pre></div></td></tr></table></figure><p>很简单,错误原因是因为泛型不是协变的,<code>Set&lt;Entry&lt;X1,X2&gt;&gt;</code>不是<code>Set&lt;Entry&lt;?,?&gt;&gt;</code>的子类。比较笨拙的办法是在定义一个<code>wild type</code>,如下所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Set&lt;? extends Entry&lt;?,?&gt;&gt; entrySet=map.entrySet();<br></code></pre></div></td></tr></table></figure><p>其实还有一个比较取巧的办法,通过名为<code>capture helper</code>的操作来解决这个问题。</p><h3 id="1-1-Capture-Helper"><a href="#1-1-Capture-Helper" class="headerlink" title="1.1 Capture Helper"></a>1.1 Capture Helper</h3><p>因为编译器对于<code>wild type</code>的取名都是任意的,并且对我们是不可见的,所以我们在源码中无法引用,以下面的代码为例:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(List&lt;? extends Number&gt; numberList)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// numberList.add( numberList.get(0) ); // compile error,因为左numberList接受的是X2类型,而又numberList接受的是X1类型</span><br><br>    <span class="hljs-comment">//假设下面的代码存在,我们将传进来的numberList转型为List&lt;X&gt;类型,那么该方法所有使用numberList的地方,其类型是List&lt;X&gt;</span><br>    <span class="hljs-comment">//而不是见一个numberList换一个类型</span><br>    List&lt;X&gt; list = numberList;  <span class="hljs-comment">// *imaginary* code</span><br><br>    X number = list.get(<span class="hljs-number">0</span>);     <span class="hljs-comment">// get() returns X</span><br>    list.add(number);           <span class="hljs-comment">// add() accepts X</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>既然人为定义<code>wild type</code>的类型,可行,那么我把类型<code>X</code>定义出来不久好了?如下面代码所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">&lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar2</span><span class="hljs-params">(List&lt;T&gt; list)</span></span><br><span class="hljs-function"></span>&#123;<br>    T number = list.get(<span class="hljs-number">0</span>);<br>    list.add(number);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后我们就可以调用<code>bar(numberList)</code>解决上面每个<code>numberList</code>类型不一样的问题。方法<code>bar2</code>就叫做<code>capture helper</code>。</p><p>那么<code>capture helper</code>的出现有什么意义呢?<br>答案是为了兼容老代码,因为1.5之前的代码没有泛型,如果使用泛型的代码想要接受没有泛型的容器,就得实现<code>capture helper</code>(当然不局限于容器,这里容器比较典型)</p><p><strong>参考文献:</strong></p><ol><li><p><a href="http://bayou.io/draft/Capturing_Wildcards.html#Capture_Everywhere">Capturing Wildcards</a></p></li><li><p><a href="http://bayou.io/draft/Wildcard_Case_Studies.html#Map&lt;?,?&gt;_Entry_Set">Wildcard Case Studies</a></p></li></ol><h2 id="2-lt-extends-E-gt-与-lt-T-extends-E-gt-有什么区别"><a href="#2-lt-extends-E-gt-与-lt-T-extends-E-gt-有什么区别" class="headerlink" title="2. &lt;? extends E&gt;与&lt;T extends E&gt;有什么区别?"></a>2. &lt;? extends E&gt;与&lt;T extends E&gt;有什么区别?</h2><p>这是容易搞混的一点,首先<code>T</code>叫做类型变量(type variable),<code>?</code>叫做通配符(wildcard)。</p><ol><li><p>类型变量不能使用<code>super</code>,即类型变量不能有上界,例如<code>T super E</code>,这样是非法的。至于为什么非法可以看下一个问题。但是通配符<code>?</code>却可以有上界或者下界。</p></li><li><p>类型变量可以有多个限制,例如<code>T extends A &amp; B</code>,但是通配符<strong>至多</strong>有一个界限。</p></li><li><p>通配符不能表示一个类型变量,所以通配符不能用来定义<code>generic type</code> ,类型变量可以用来定义<code>generic type</code></p></li></ol><p><strong>参考文献:</strong></p><ol><li><a href="https://stackoverflow.com/questions/18384897/what-is-difference-between-extends-object-and-e-extends-object">What is difference between &lt;? extends Object&gt; and <E extends Object>?</a></li></ol><h2 id="3-lt-T-super-E-gt-为什么是非法的"><a href="#3-lt-T-super-E-gt-为什么是非法的" class="headerlink" title="3. &lt;T super E&gt;为什么是非法的?"></a>3. &lt;T super E&gt;为什么是非法的?</h2><p>因为Object所有引用类型的父类。<T super E>并不会按照我们的想法工作。例如我们定义了一个容器<code>ArrayList&lt;Integer&gt; list</code>,思考下面的代码是否意义:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//add方法是list的对象方法</span><br><span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">super</span> Integer&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T)</span></span>&#123;<br>    list.add(T);<br>&#125;<br><br>ArrayList&lt;Integer&gt; list=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<span class="hljs-comment">//正常,没有任何问题</span><br>lsit.add(<span class="hljs-string">&quot;aaa&quot;</span>);<span class="hljs-comment">//我们的本意是这句不该通过编译,但是却通过了</span><br></code></pre></div></td></tr></table></figure><p><code>add</code>方法的本意是接受类型是<code>Integer</code>的参数,可以是<code>Object</code>、<code>Number</code>、<code>Integer</code>,不应该接受<code>String</code>类型。</p><p>但是<code>Object</code>也是<code>String</code>的父类。很有可能给<code>add</code>传入的参数静态类型是<code>Object</code>,动态类型是<code>String</code>。虽然放进去是没有问题,但是如果把这个<code>String</code>类型的元素取出来,会出现<code>castException</code>,因为<code>String</code>根本不可能转换为<code>Integer</code>。</p><p><strong>参考文献:</strong></p><ol><li><a href="https://stackoverflow.com/questions/2800369/bounding-generics-with-super-keyword">Bounding generics with ‘super’ keyword</a></li></ol><h2 id="4-为什么定义类型参数时不能使用通配符’-’"><a href="#4-为什么定义类型参数时不能使用通配符’-’" class="headerlink" title="4. 为什么定义类型参数时不能使用通配符’?’?"></a>4. 为什么定义类型参数时不能使用通配符’?’?</h2><p>因为通配符<code>?</code>只是用来定义<code>wild type</code>的一个语法成分,它没有任何语义,<strong>它不能表示任何类型</strong>。想象一下,如果下面的代码是合法的:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>&lt;?&gt;</span>&#123;<br>    ? get(<span class="hljs-keyword">int</span> index)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(? elem)</span></span>&#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在前面曾经说过,由于<code>capture conversion</code>的原因,编译器会把每一个类型是<code>wild type</code>的value中的通配符<code>?</code>赋一个名字,例如像下面这样:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">X1</span>&gt;</span>&#123;<br>    <span class="hljs-function">X2 <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> inedx)</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(X3 elem)</span></span>&#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么我们在实例化List的时候,像<code>List&lt;String&gt;</code>这样?那么<code>get</code>的返回值类型又是什么?这样就违背了我们使用<code>?</code>定义泛型类的初衷。我们的本意是<code>List</code>接受一个不知道是什么类型的类型参数(unkown type),并且想要<code>get</code>的返回值类型也是同一个<code>unknown type</code>。但是这很显然不可能。</p><p><strong>所以通配符<code>?</code>就不能用来定义一个类型变量(type variable),它只能用在类型声明的地方</strong>,例如声明方法的形参类型,声明一个变量。因为 <strong>?不是一个有效的变量名,不是一个有效的标识符</strong>:</p><blockquote><p>You can’t name a generic parameter as ?, because ? is not a valid identifier - a valid name of a variable.<br>You have to give a generic parameter a valid java name so you can refer to it in the implementation.</p></blockquote><p>下面是通配符常用的地方:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;?&gt; list;<span class="hljs-comment">//ok,声明变量类型</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(List&lt;? extends Number&gt; list)</span></span>;<span class="hljs-comment">//ok,声明参数类型</span><br></code></pre></div></td></tr></table></figure><p>那么所谓的定义一个泛型类型是什么?就像下面这样:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">    List MyList&lt;T&gt;&#123;<span class="hljs-comment">//定义了一个泛型类型MyList&lt;T&gt;,T是类型变量</span><br><br>    <span class="hljs-keyword">public</span> &lt;V&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(V num,T test)</span></span>&#123;&#125;<span class="hljs-comment">//定义了一个类型变量V</span><br>    <span class="hljs-keyword">public</span> &lt;?&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//compile error</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>并且统配符<code>?</code>只能用来填充类型变量。所谓的填充是什么意思,比如我们定义了一个方法接受<code>MyList&lt;T&gt;</code>泛型的方法,那么我们就可以用<code>?</code>填充这个T。那么填充在哪?</p><ul><li>声明方法的参数</li><li>声明变量</li></ul><p>如下所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//定义方法时声明参数,使用?填充T</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(MyList&lt;?&gt; myList)</span></span>&#123;&#125;<br><span class="hljs-comment">//或者加个界限</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(MyList&lt;? extends Number&gt; myList)</span></span>&#123;&#125;<br><span class="hljs-comment">//定义了一个MyList&lt;T&gt;的变量,使用?填充T</span><br>MyList&lt;?&gt; myList;<span class="hljs-comment">//</span><br></code></pre></div></td></tr></table></figure><p><strong>参考文献:</strong></p><ol><li><a href="https://stackoverflow.com/questions/24740590/java-generic-wildcard?rq=1">java Generic wildcard “?”</a></li><li><a href="https://blog.csdn.net/harvic880925/article/details/49883589">夯实JAVA基本之一——泛型详解(2)：高级进阶</a></li></ol><h2 id="5-有没有不能使用泛型的地方"><a href="#5-有没有不能使用泛型的地方" class="headerlink" title="5. 有没有不能使用泛型的地方?"></a>5. 有没有不能使用泛型的地方?</h2><p>几乎所有类型都可以拥有类型参数,但除了一下几种类型:</p><ul><li>枚举类型:因为枚举类型不能有类型参数,所以枚举类中的值都是静态类型的,但是又因为<strong>类型参数不能用于任何静态的上下文环境</strong>,所以在枚举类中使用泛型是没有任何意义的</li><li>匿名内部类:它可以继承一个参数化类型的类或者接口,但它本身不能是，因为<strong>匿名内部泛型类没有任何意义</strong>。因为匿名内部类没有名字,所以在声明时就没有地方提供类型参数</li><li>异常类:一个泛型类不能间接或者直接继承自<code>Throwable</code>接口,因为异常处理机制是一种运行时机制,但是在运行时泛型已经被擦出了。所以对于同一个泛型类型但是类型参数不同的两个参数化类型来说,虚拟机并不能区分它们,所以异常泛型类也是无意义的。</li></ul><h2 id="6-能不能强转成参数化类型"><a href="#6-能不能强转成参数化类型" class="headerlink" title="6.能不能强转成参数化类型?"></a>6.能不能强转成参数化类型?</h2><p>可以,但是这种操作是类型不安全的,且会产生”unchecked”的编译警告。</p><p>因为一个变量的类型分为静态类型与动态类型。一个类型转换操作也分为两个部分:</p><ul><li>编译时期的静态类型检查</li><li>运行十七的动态类型检查</li></ul><p>静态时期的类型检查去除了一些显而易见的错误,例如讲<code>String</code>转换成<code>Date</code>。而动态类型检查使用了动态类型进行检查。如果动态类型不是目标类型或者不是目标类型的子类(也就是所谓的向下转型),那么就会产生<code>ClassCastException</code>。</p><p>但是并不是所有类型转换都会动态类型检查。基本类型之间的转换仅会进行静态类型检查。并且向上转型也只会进行静态类型检查,向上转型不写也没关系,因为编译器会帮你做这件事。</p><p><strong>需要动态检查</strong>的类型转换潜在是类型不安全的,尤其是当目标类型为一个参数化类型。在运行时参数化类型的类型信息不在存在,虚拟机不能区分两个是同一个泛型,但是采用不同的类型参数实例化出的参数化类型,所以在这种情况下,本不该通过动态检查的类型转换却通过了,这不是我们希望看到的。例如下面的代码,将<code>Object</code>转换为<code>List&lt;String&gt;</code>,但是却没有抛出<code>ClassCastException</code>.</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br>  List&lt;Date&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Date&gt;();<br>  ...<br>  m2(list);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">(Object arg)</span> </span>&#123;<br>  ...<br>  List&lt;String&gt; list = (List&lt;String&gt;) arg;    <span class="hljs-comment">// unchecked warning</span><br>  ...<br>  m3(list);<br>  ...<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">(List&lt;String&gt; list)</span> </span>&#123;<br>  ...<br>  String s = list.get(<span class="hljs-number">0</span>);      <span class="hljs-comment">// ClassCastException</span><br>  ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意上面抛出异常的位置,不是在我们进行类型转换的位置,而是在我们提取元素的时候。这种没有在正确地方抛出的异常是我们非常不愿意看到的。所以为了引起我们对这种潜在的类型不安全的转换注意,编译器产生了”unchecked”警告在遇到可疑的转换时。</p><p>所以,<strong>编译器在每一处目标类型是参数化类型并且是向下转型的地方,都会产生一个unchecked警告</strong>。</p><h2 id="7-泛型中哪里会出现的”unchecked”警告"><a href="#7-泛型中哪里会出现的”unchecked”警告" class="headerlink" title="7.泛型中哪里会出现的”unchecked”警告?"></a>7.泛型中哪里会出现的”unchecked”警告?</h2><ol><li><p>首先就是上面一个问题所说的:向下转型为参数化类型的地方。</p></li><li><p>如果方法的参数类型没有因为类型擦除而改变,那么调用这个方法就是类型安全的</p></li><li><p>如果字段的类型因为类型擦除而改变,那么对该字段赋值就会产生”unchecked”,但是读取该字段的值却不会产生任何问题</p></li></ol><h2 id="8-unbound-wildcard-parameterized-type和raw-type有什么区别"><a href="#8-unbound-wildcard-parameterized-type和raw-type有什么区别" class="headerlink" title="8. unbound wildcard parameterized type和raw type有什么区别?"></a>8. unbound wildcard parameterized type和raw type有什么区别?</h2><p>其实这二者没有太大区别,二者都可以被视作是任何参数化类型的超级类,并且二者都是<code>reifiable types</code>。所以这两种类型可以作为数组的元素类型(注意是unbound wildcard而不是wildcard)。但是编译器对<code>unbound wildcard parameterized type</code>更严格。对于同样的操作,如果<code>raw type</code>产生了<code>unchecked</code>警告,那么<code>unbound wildcard parameterized type</code>则会产生编译错误。</p><h2 id="9-泛型真的不能使用instance-of吗"><a href="#9-泛型真的不能使用instance-of吗" class="headerlink" title="9. 泛型真的不能使用instance of吗?"></a>9. 泛型真的不能使用instance of吗?</h2><p>大部分都不行,只有无界通配符可以,因为只有<code>reifiable type</code>能够使用<code>instance of</code>,<code>reifiable types</code>包括且只包括:</p><ul><li><p>It refers to a non-generic class or interface type declaration.</p></li><li><p>It is a parameterized type in which all type arguments are <strong>unbounded</strong> wildcards (§4.5.1).</p></li><li><p>It is a raw type (§4.8).</p></li><li><p>It is a primitive type (§4.2).</p></li><li><p>It is an array type (§10.1) whose element type is reifiable.</p></li><li><p>It is a nested type where, for each type T separated by a “.”, T itself is reifiable.</p></li></ul><h2 id="10-能创建数组元素是具体参数化类型的数组吗"><a href="#10-能创建数组元素是具体参数化类型的数组吗" class="headerlink" title="10. 能创建数组元素是具体参数化类型的数组吗?"></a>10. 能创建数组元素是具体参数化类型的数组吗?</h2><p>所谓的具体参数化类型就是类型参数是一个具体的参数,例如<code>String</code>、<code>Integer</code>等等。对于这个问题的答案是不能,因为是类型不安全的。</p><p>因为插入操作会逃过数组的动态类型检查,见如下代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>  Pair&lt;Integer,Integer&gt;[] intPairArr = <span class="hljs-keyword">new</span> Pair&lt;Integer,Integer&gt;[<span class="hljs-number">10</span>] ; <span class="hljs-comment">// error</span><br>  addElements(intPairArr); <br>  Pair&lt;Integer,Integer&gt; pair = intPairArr[<span class="hljs-number">1</span>];<br>  Integer i = pair.getFirst();<br>  pair.setSecond(i);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addElements</span><span class="hljs-params">( Object[] objArr)</span> </span>&#123;<br>  objArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair&lt;Integer,Integer&gt;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>  objArr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Pair&lt;String,String&gt;(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);      <span class="hljs-comment">// should fail with ArrayStoreException,但是因为在运行时泛型已经不存在了</span><br>                                                  <span class="hljs-comment">//  逃过了数组插入时的类型动态检查</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="11-能创建数组元素类型是通配符参数化类型的数组吗"><a href="#11-能创建数组元素类型是通配符参数化类型的数组吗" class="headerlink" title="11. 能创建数组元素类型是通配符参数化类型的数组吗?"></a>11. 能创建数组元素类型是通配符参数化类型的数组吗?</h2><p>无界通配符可以,有界通配符不行。因为有界通配符的插入操作也可以逃过数组插入时的动态类型检查,而无界通配符不会。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//非法操作</span><br>Object[] numPairArr = <span class="hljs-keyword">new</span> Pair&lt;? extends Number,? extends Number&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">// illegal</span><br>numPairArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair&lt;Long,Long&gt;(<span class="hljs-number">0L</span>,<span class="hljs-number">0L</span>);     <span class="hljs-comment">// fine</span><br><span class="hljs-comment">//注意,下面这句逃过了数组的动态类型检查</span><br>numPairArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair&lt;String,String&gt;(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// should fail, but would succeed</span><br><br><span class="hljs-comment">//合法操作</span><br>Object[] pairArr = <span class="hljs-keyword">new</span> Pair&lt;?,?&gt;[<span class="hljs-number">10</span>] ;        <span class="hljs-comment">// fine</span><br>pairArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair &lt;Long,Long&gt;(<span class="hljs-number">0L</span>,<span class="hljs-number">0L</span>);     <span class="hljs-comment">// fine</span><br>pairArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair &lt;String,String&gt;(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// fine </span><br>pairArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> ArrayList &lt;String&gt;();        <span class="hljs-comment">// fails with ArrayStoreException</span><br></code></pre></div></td></tr></table></figure><h2 id="12-能创建数组元素是有界通配符参数化类型的数组引用吗"><a href="#12-能创建数组元素是有界通配符参数化类型的数组引用吗" class="headerlink" title="12. 能创建数组元素是有界通配符参数化类型的数组引用吗?"></a>12. 能创建数组元素是有界通配符参数化类型的数组引用吗?</h2><p>可以,但没必要。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//创建了数组元素类型是有界通配符类型的数组</span><br><br>Pair&lt;? extends Number,? extends Number&gt;[] arr = <span class="hljs-keyword">null</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">Double</span>,<span class="hljs-title">Double</span>&gt; </span>&#123; ... &#125;<br>Pair&lt;? extends Number,? extends Number&gt;[] arr = <span class="hljs-keyword">new</span> Point[<span class="hljs-number">2</span>];<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Point(-<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>);  <span class="hljs-comment">// fine</span><br><span class="hljs-comment">//虽然能通过静态类型检查,但是无法通过数组的动态类型检查</span><br>arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Pair&lt;Number,Number&gt;(-<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>); <span class="hljs-comment">// fine (causes ArrayStoreException)</span><br>arr[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Pair&lt;Integer,Integer&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// fine (causes ArrayStoreException)</span><br></code></pre></div></td></tr></table></figure><h2 id="13-通配符参数化类型不能干嘛"><a href="#13-通配符参数化类型不能干嘛" class="headerlink" title="13.通配符参数化类型不能干嘛?"></a>13.通配符参数化类型不能干嘛?</h2><p>不能做父类。见如下代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span> &lt;?&gt; </span>&#123; <span class="hljs-comment">// error</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">( ??? arg)</span> </span>&#123; ... &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>编译器无法知道<code>comapreTo</code>方法到底接受的是什么类型的参数,很奇怪。而且,如前面所说,因为有<code>capture conversion</code>操作,这样的定义是没有任何意义的。</p><h2 id="15-具体化参数类型不能做什么"><a href="#15-具体化参数类型不能做什么" class="headerlink" title="15. 具体化参数类型不能做什么?"></a>15. 具体化参数类型不能做什么?</h2><p>具体化参数类型(concrete parameterized type)就是使用具体类型实例化泛型类型的类型。那么它不能做:</p><ol><li>使用<code>instance of</code></li><li>不能创建数组</li><li>不能用于异常处理(泛型都不行)</li></ol><h2 id="14-泛型不能做什么"><a href="#14-泛型不能做什么" class="headerlink" title="14. 泛型不能做什么?"></a>14. 泛型不能做什么?</h2><ol><li>不能在静态字段中使用类型参数(type paramemter):<strong>因为type parameter不适用于静态上下文环境</strong>,所以泛型不能适用于静态泛型字段,例如<code>static T member</code>、<code>static List&lt;T&gt; list</code></li><li>不用如此使用：<code>obj instanceof T</code>，因为类型擦除的原因</li></ol><p><strong>参考文献:</strong></p><p>若非特殊标注,问题引自<a href="http://www.angelikalanger.com/GenericsFAQ/FAQSections/ParameterizedTypes.html#FAQ001">Java Generics FAQs - Generic And Parameterized Types</a></p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E5%9F%BA%E7%A1%80/">基础</category>
      
      
      <category domain="https://eripe.me/tags/%E6%B3%9B%E5%9E%8B/">泛型</category>
      
      
      <comments>https://eripe.me/2021-06-04/Frequently-asked-questions-about-generics.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java的泛型</title>
      <link>https://eripe.me/2021-06-04/the-generic-of-java.html</link>
      <guid>https://eripe.me/2021-06-04/the-generic-of-java.html</guid>
      <pubDate>Fri, 04 Jun 2021 11:57:44 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>这篇文章是在研究java的Type体系顺带扯出的概念,泛型的使用要说简单也很简单,要说难也可以说难。本文将由浅入深,带你学习java中的”泛型”。</p></blockquote><h2 id="1-泛型的基本概念"><a href="#1-泛型的基本概念" class="headerlink" title="1. 泛型的基本概念"></a>1. 泛型的基本概念</h2><p>泛型的概念始于java1.5,所以在1.5之前所有使用java的地方都没有泛型的影子,那么为了保持向后兼容,java中的泛型被设计成了伪泛型,仅仅存在于编译时期,在实际生成的字节码文件中是没有泛型的,这一动作叫做泛型的<strong>擦除</strong>。</p><p>泛型的基本格式为:<code>class Perosn&lt;T&gt;</code>,其中定义在<code>&lt;&gt;</code>的变量称为<code>type variable</code>,这一概念是随着泛型而出生的,并且也跟java的Type子系统息息相关。在jse8文档中,声明<code>type variable</code>允许用在四个地方,但是并不限制<code>type variable</code>的使用个数。允许的四个地方分别是:</p><ul><li>泛型类</li><li>泛型接口</li><li>泛型方法</li><li>泛型构造函数</li></ul><p>其中泛型构造函数的使用可以归档在泛型方法一类中。</p><p>注意:</p><blockquote><p>使用泛型构造方法并不要求类是泛型类</p></blockquote><p>更新(2020-08-14 20:18:36):</p><p>还有一些概念,了解后可以更好的帮助我们了解泛型:</p><ul><li>泛型类型(generic type):是一个带着类型参数的类型,即类似于<code>class Person&lt;T&gt;</code></li><li>参数化类型(parameterized type):即使用具体的类型实参去实例化泛型类型的类型,例如使用类型<code>String</code>去实例化泛型类型<code>class Person&lt;T&gt;</code>,所得的参数类型为<code>class Person&lt;String&gt;</code></li></ul><h3 id="1-1-泛型使用的简单示例"><a href="#1-1-泛型使用的简单示例" class="headerlink" title="1.1 泛型使用的简单示例"></a>1.1 泛型使用的简单示例</h3><p><strong>泛型类与泛型接口:</strong></p><p>泛型类和泛型接口的声明比较简单,仅需要在类名或者接口名后面使用<code>&lt;&gt;</code>声明<code>type variable</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//泛型类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T name;<br>    <span class="hljs-keyword">private</span> E age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T name,E id)</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.getClass().getSimpleName());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(T name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(E age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//泛型接口</span><br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">People</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>泛型方法:</strong></p><p>泛型方法又分为普通的泛型方法、静态泛型方法、泛型构造方法。泛型方法的声明麻烦一点,泛型方法需要在权限修饰后面定义所要使用的<code>type variable</code>。</p><p>下面是一组使用泛型方法和泛型类的代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> generic;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> T name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(T name,<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>        <span class="hljs-keyword">this</span>.age=age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(T name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">V</span>&gt;</span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span>&lt;T&gt; V <span class="hljs-title">getInfo</span><span class="hljs-params">(People&lt;T&gt; p1, People&lt;T&gt; p2, V sum)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;p1:&quot;</span>+p1.getName()+<span class="hljs-string">&quot; &quot;</span>+p1.getAge());<br>        System.out.println(<span class="hljs-string">&quot;p2:&quot;</span>+p2.getName()+<span class="hljs-string">&quot; &quot;</span>+p2.getAge());<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        People&lt;String&gt; p1=<span class="hljs-keyword">new</span> People&lt;&gt;(<span class="hljs-string">&quot;Bob&quot;</span>,<span class="hljs-number">23</span>);<br>        People&lt;String&gt; p2=<span class="hljs-keyword">new</span> People&lt;&gt;(<span class="hljs-string">&quot;Lee&quot;</span>,<span class="hljs-number">20</span>);<br>        Test&lt;Integer&gt; t=<span class="hljs-keyword">new</span> Test&lt;&gt;();<br>        Object result= t.&lt;String&gt;getInfo(p1,p2,<span class="hljs-number">23</span>);<br>        <span class="hljs-comment">//Object result=t.getInfo(p1,p2,23);</span><br><br>        System.out.println(<span class="hljs-string">&quot;result is an instance of Integer:&quot;</span>+result <span class="hljs-keyword">instanceof</span> Integer);<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">p1:Bob <span class="hljs-number">23</span><br>p2:Lee <span class="hljs-number">20</span><br>result is an instance of Integer:<span class="hljs-keyword">true</span><br></code></pre></div></td></tr></table></figure><p>其中泛型方法签名为:<code>public&lt;T&gt; V getInfo(People&lt;T&gt; p1, People&lt;T&gt; p2, V sum)</code>,<code>T</code>是这个泛型方法<code>getInfo</code>指定的类型变量,而<code>V</code>则是泛型类指定的类型变量。在调用泛型方法时,可以在<code>.</code>和方法名之间明确指定泛型方法的具体类型,或者让编译器自己推断。</p><p>其实上面这个泛型方法有个明显的缺点,就是返回值的类型也是一个泛型,这就要求调用者必须判断返回值的具体类型,因为接口。那么可能有人会问了,那<code>ArrayList</code>的源码中也有很多返回泛型的例子,他们写的也差劲?例如:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    rangeCheck(index);<br>    <span class="hljs-keyword">return</span> elementData(index);<br>&#125;<br><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-function">E <span class="hljs-title">elementData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (E) elementData[index];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样写是因为库编写者已经确定容器中存储的元素的类型就是<code>E</code>,强制转换成<code>E</code>并不会出错,并且调用者也知道返回的类型到底是什么。而且因为方法的返回值是泛型<code>E</code>,编译器会在调用者部分的字节码中自动插入一段强制转换代码将元素类型转为为<code>E</code>。这是由于类型擦除导致的,这会在<strong>后文</strong>详细解释。</p><p>静态泛型方法与常规的泛型方法唯一区别就是<strong>静态泛型方法中不能使用泛型类的类型变量</strong>,例如在<code>people</code>中声明一个方法:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;M&gt; calc(M year,M mouth)&#123;...&#125;<br></code></pre></div></td></tr></table></figure><p><code>calc</code>中不能使用泛型类<code>People</code>中的类型变量<code>T</code>。</p><p><strong>泛型构造方法:</strong></p><p>最后泛型构造方法又可以分为两种:类本身就是泛型类,类不是泛型类。下面是一个简单的例子:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//所在类不是泛型类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span></span>&#123;<br>    <span class="hljs-keyword">public</span> &lt;T &amp; Comparable&lt;T&gt;&gt; People(T age)&#123;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//所在类是泛型类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中<code>&lt;T &amp; Comparable&lt;T&gt;&gt;</code>的含义是要求<code>T</code>已经实现了Comparable接口。这部分细节可以查看jse8关于<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.4">type variable</a>的详细规范。</p><h2 id="2-泛型通配符"><a href="#2-泛型通配符" class="headerlink" title="2. 泛型通配符"></a>2. 泛型通配符</h2><p>在了解泛型通配符之前,我们需要知道一些基本术语:协变、逆变、不变,这一部分引自<a href="https://zhuanlan.zhihu.com/p/31137677">仔细说说Java中的泛型</a>。</p><p>逆变与协变用来描述类型转换（type transformation）后的继承关系，其定义：如果A、B表示类型，f(X)表示类型转换，≤表示继承关系(比如,A≤B表示A继承于b),那么这里有三个关系</p><blockquote><ol><li>当A≤B时有f(B)≤f(A)成立，那么说f(X)是逆变（contravariant）的</li><li>当A≤B时有f(A)≤f(B)成立，那么说f(X)是协变(covariant)的</li><li>当上两者都不成立的时候，那么说f(X)是不变（invariant)的</li></ol></blockquote><p>在java中,<strong>数组是支持协变的</strong>,例如下面这句代码可以通过编译,但会产生运行时错误:</p><blockquote><p>Number[] test=new Integer[];</p></blockquote><p><code>Integer</code>是<code>Number</code>的子类,同时变成数组,<code>Integer[]</code>还是<code>Number[]</code>的子类。</p><hr><p><strong>Extension One:在java中数组为什么要设计成协变的?</strong></p><p>答案来源于:<a href="https://www.zhihu.com/question/21394322">java中，数组为什么要设计为协变？</a>,我在这里补充一些我的理解。</p><p>在java1.5之前,java是不支持泛型的,因为没时间做。但是又需要泛型的特性,所以就把数组设计成协变的了。例如在比较数组时调用的是<code>Arrays.equals</code>方法,其底层调用的是<code>Object.equals</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object[] a, Object[] a2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a==a2)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> (a==<span class="hljs-keyword">null</span> || a2==<span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">int</span> length = a.length;<br>    <span class="hljs-keyword">if</span> (a2.length != length)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;length; i++) &#123;<br>        Object o1 = a[i];<br>        Object o2 = a2[i];<br>        <span class="hljs-keyword">if</span> (!(o1==<span class="hljs-keyword">null</span> ? o2==<span class="hljs-keyword">null</span> : o1.equals(o2)))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>如果</strong>数组是不支持协变的,那么比较<code>B</code>时得重写<code>equals</code>的代码,比较<code>A</code>时又得重写一份<code>equals</code>的代码,因为<code>A[]</code>不能赋值给<code>Object[]</code>,代码重写非常严重,违背了代码复用的宗旨。所以将数组设计成协变的,使得<code>A[]</code>能够赋值为<code>Object[]</code>,从而调用对象的<code>equals()</code>方法时,由于多态的原因,实际上调用的<code>A</code>的<code>equals</code>方法。实现了代码复用。</p><p>那么数组设计成协变会产生大问题吗?答案是不会,因为数组记得它到底保持的是什么类型,这会在<strong>编译时</strong>严格检查数据类型。而泛型协变有问题也只会在运行时出现，延后了问题出现的时间。违背了java是严格类型确定的编程语言。</p><p>但是<strong>并不支持</strong>泛型数组,因为数组能记得它存储的元素类型的前提是在创建时就严格确定了其存储的元素类型(之所以能记住这是靠虚拟机实现的,Array由虚拟机来实现)。</p><p><strong>Extension Two:java中为什么不支持泛型数组?</strong></p><p>参考自<a href="https://www.zhihu.com/question/20928981/answer/117521433">java为什么不支持泛型数组？</a></p><p>java明确规定了数组的元素类型必须是可靠的.</p><blockquote><p>It is a compile-time error if the component type of the array being initialized is not reifiable</p></blockquote><p>其中<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.7">Reifiable Types</a>包括且只包括:</p><ul><li><p>It refers to a non-generic class or interface type declaration.</p></li><li><p>It is a parameterized type in which all type arguments are <strong>unbounded</strong> wildcards (§4.5.1).</p></li><li><p>It is a raw type (§4.8).</p></li><li><p>It is a primitive type (§4.2).</p></li><li><p>It is an array type (§10.1) whose element type is reifiable.</p></li><li><p>It is a nested type where, for each type T separated by a “.”, T itself is reifiable.</p></li></ul><p>下面是每个<code>Reifiable Type</code>的示例:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">E</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&lt;<span class="hljs-title">X</span>&gt;</span>&#123;&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;&#125;<br><br><span class="hljs-comment">//It refers to a non-generic class or interface type declaration.</span><br><span class="hljs-comment">//是一个分泛型的类或接口的引用</span><br>A ref;<br>E ref;<br><span class="hljs-comment">//It is a parameterized type in which all type arguments are **unbounded** wildcards</span><br><span class="hljs-comment">//是一个参数化类型,但是所有的类型参数都是无界通配符</span><br>B&lt;?&gt; ref;<br><span class="hljs-comment">//raw type</span><br>List ref;<br><span class="hljs-comment">//primitive type</span><br><span class="hljs-keyword">int</span> ref;<br><span class="hljs-comment">//array type,并且元素类型都要求是可靠的</span><br><span class="hljs-keyword">int</span>[] ref;<br><span class="hljs-comment">//嵌套类型,要求类型参数参数都是可靠的</span><br>B&lt;?&gt;.C&lt;?&gt; ref;<br>B&lt;A&gt;.C&lt;A&gt; ref;<br><br></code></pre></div></td></tr></table></figure><p>所以想要数组支持泛型的唯一办法就是:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//本意</span><br>ArrayList&lt;String&gt; ref=<span class="hljs-keyword">new</span> ArrayList&lt;String&gt;[];<span class="hljs-comment">//complie-error</span><br><span class="hljs-comment">//正确写法</span><br>ArrayList&lt;String&gt; ref=(ArrayList&lt;String&gt;[])<span class="hljs-keyword">new</span> ArrayList[];<span class="hljs-comment">//cast</span><br></code></pre></div></td></tr></table></figure><p>注:</p><blockquote><p>上述所有言论基于java1.8,似乎在java10中已经开始支持泛型数组,但并未考证</p></blockquote><hr><p>回到正题,java中的泛型是不变的。如果泛型是协变的,思考如下代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ArrayList&lt;Number&gt; ref=<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><br>ref.add(<span class="hljs-number">2.3f</span>);<span class="hljs-comment">//cast</span><br></code></pre></div></td></tr></table></figure><p>在我们眼里,<code>ref</code>是一个存储<code>Number</code>的容器,那么就可以往里面存储<code>Double</code>、<code>Float</code>、<code>Integer</code>。取元素的时候到底转换成什么类型?程序不知道,程序员也不知道。并且很可能会产生运行时错误。既然这么,干脆就在编译期将这类错误禁止就完事了,但是仍然可以通过一些操作实现协变的逻辑。</p><p>对于泛型不支持逆变,是因为父类的引用赋值给子类就非常危险,所以当然不支持,而且也不可能实现。</p><h3 id="使用协变"><a href="#使用协变" class="headerlink" title="使用协变"></a>使用协变</h3><p>有些时候我们确实需要使用协变这一功能。比如我们有一组类<code>Dog``Cat``Pig</code>,需要对这些类实现一个通用的喂食功能,见如下代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> generic;<br><br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>&#123;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">super</span>.getName()+<span class="hljs-string">&quot; eat shit.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cat</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">super</span>.getName()+<span class="hljs-string">&quot; eat air.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CovariantTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">feed</span><span class="hljs-params">(List&lt;Animal&gt; animalList)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(animalList==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(Animal elem:animalList)&#123;<br>            elem.eat();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;Dog&gt; dogs=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        dogs.add(<span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;peter&quot;</span>));<br>        dogs.add(<span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;tom&quot;</span>));<br><br>        ArrayList&lt;Cat&gt; cats=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        cats.add(<span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;lili&quot;</span>));<br>        cats.add(<span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;candy&quot;</span>));<br>        feed(dogs);<span class="hljs-comment">//complie-error</span><br>        feed(cats);<span class="hljs-comment">//complie-error</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面调用<code>feed</code>的代码是无法通过编译的,因为<code>feed</code>接受的是<code>List&lt;Animal&gt;</code>,而提供的是<code>ArrayList&lt;Dog&gt;</code>,这是因为泛型不支持协变。那么这个需求是确确实实存在的,怎么办?</p><p>这时候通配符<code>?</code>该上场了,泛型的作用是限制泛型的类型,提供类似协变的功能。</p><blockquote><p>通配符?表示我们不知道是什么类型,而不是任意类型!!!</p></blockquote><p>注意这里插一句,带有通配符的类型变量(type variable)叫做<code>wild type</code>(不知道是否官方,但是我看到别人这么叫了,而且这种叫法也不错,我就采用了)。但是通配符<code>?</code>是<strong>没有任何语义</strong>的,它不能代表任何一种类型,仅仅为了定义<code>wild type</code>的一个语法组成部分。所以定义类似<code>ArrayList&lt;?&gt;()</code>的对象就是错的,因为没有任何意义。</p><p>通配符是可以加边界来限制类型变量的类型的,通配符<code>?</code>边界分为以下三种:</p><ul><li>有上界的通配符:例如<code>? super Animal</code>,意思是这个泛型只能是<code>Animal</code>或者<code>Animal</code>的父类</li><li>有下界的通配符:例如<code>? extends Animal</code>,意思是这个泛型只能是<code>Animal</code>或者<code>Animal</code>的子类</li><li>无界的通配符:<code>?</code>,泛型是可以任意类型</li></ul><p>那么为了实现上面的需求,应将<code>feed</code>的签名改正为<code>public static void feed(List&lt;? extends Animal&gt; animalList)</code>,现在编译运行:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">peter eat shit.<br>tom eat shit.<br>lili eat air.<br>candy eat air.<br></code></pre></div></td></tr></table></figure><p>成功实现了我们的需求。</p><h3 id="存下取上原则"><a href="#存下取上原则" class="headerlink" title="存下取上原则"></a>存下取上原则</h3><p>该原则取自<a href="https://www.cnblogs.com/Xieyang-blog/p/9215934.html">Java中泛型区别以及泛型擦除详解</a>。</p><p><strong>A. 上界通配符:</strong><br>但是在使用了泛型通配符的地方,想要对容器增删元素就没有那么简单了。就拿上面的<code>List&lt;? extends Animal&gt; animals</code>做例子。传进来的参数有可能是<code>List&lt;Dog&gt;</code>,也有可能是<code>List&lt;Cat&gt;</code>,假设我们能够向<code>animals</code>中存储新元素,那么当我们取出我们存入的新元素时,它到底是什么类型的?编译器不知道。但是我们读取容器中的内容是没问题的,因为里面的元素至少是一个<code>Animals</code>,使用<code>Animals</code>的引用调用<code>Animals</code>的方法是没有任何问题的。这里就体现了<strong>存下取上</strong>的原则。</p><p>对于上界通配符<code>? extends Animal</code>,泛型的上界是<code>Animal</code>,没有下界,那就是<code>null</code>。所以所谓存下取上就是存储的时候按照泛型下界的类型存储,这里就是<code>null</code>,取出的时候按照泛型上界的类型取出,这里就是<code>Animal</code>。注意有一点原文没有说清楚:</p><blockquote><p>储存的元素类型<strong>至多</strong>是下界类型,取出时的元素类型<strong>至少</strong>是上界类型</p></blockquote><p>下面的图片很好的解释了这个原则:</p><p><img src="images/upper-bound.drawio.svg" alt="upper-bound"></p><p>所以如果容器中,存在有<strong>上界通配符</strong>的泛型:对其写入的元素是很鸡肋的,相当于这个容器是<strong>只读</strong>的。</p><p><strong>B. 下界通配符:</strong></p><p>相应的,上界通配符实现的简单意义上的只写功能。例如<code>List&lt;? super Husky&gt; animals</code>,其中<code>husky</code>是<code>Dog</code>的子类,这里能存入的元素类型至多是<code>Husky</code>类型,没有上界,那么就是<code>Object</code>。</p><p>我们可以在<code>animals</code>中存储任意的<code>animals</code>子类对象(就像<code>List&lt;Dog&gt;</code>中存储的都是<code>Dog</code>类型的引用,但是可以在<code>List</code>中存储任意的<code>Dog</code>子类)。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Husky</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Dog</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Husky</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    List&lt;Dog&gt; list=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    insert(list);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> Dog&gt; set)</span></span>&#123;<br>    <span class="hljs-comment">//成功添加</span><br>    set.add(<span class="hljs-keyword">new</span> Husky(<span class="hljs-string">&quot;husky&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;success&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="images/lower-bound.drawio.svg" alt="lower-bound"></p><p>当然类似的,这里只能读取<code>Object</code>类型的对象,也很鸡肋。</p><p>所以如果容器中存在有下界通配符的泛型,那么该容器在非严格意义上是<strong>只写</strong>的。</p><p>这里的存下取上原则也叫做<code>PECS</code>原则,即<code>producer-extends,consumer super</code>。以容器的视角来说,当容器作为作为生产者,往外提供元素时,就使用<code>extends</code>;当容器作为消费者,需要存储元素时,就使用<code>super</code>。</p><p>在<code>Collections.copy</code>方法中,就是用PESC原则:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//src为生产者,dest为消费者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>注意:<strong>如果</strong>同时有读写的要求呢?</strong></p><blockquote><p>就不需要使用泛型了。</p></blockquote><p><strong>C. 无界通配符:</strong></p><p>对于无界通配符<code>?</code>,它对应的下界为<code>null</code>,对应的上界为<code>Object</code>。</p><h3 id="3-泛型的擦除"><a href="#3-泛型的擦除" class="headerlink" title="3. 泛型的擦除"></a>3. 泛型的擦除</h3><p>在最开始曾说到java的泛型是<strong>伪泛型</strong>,仅仅保持在编译层面。在生成字节码文件时会对泛型擦除,将参数类型(parameterized types)转为原始类型(raw types)。所谓的参数类型就是类似于<code>class Person&lt;T&gt;</code>这种,而将它转换为原始类型就是<code>class Pseron</code>。在这种机制下，java中的多态就比较奇妙了。</p><h4 id="3-1-泛型下的多态"><a href="#3-1-泛型下的多态" class="headerlink" title="3.1 泛型下的多态"></a>3.1 泛型下的多态</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> generic;<br><span class="hljs-comment">//定义泛型类Person</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    T name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(T name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student s=<span class="hljs-keyword">new</span> Student();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Student类继承Person</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>Student</code>类继承了<code>Pseron</code>类,并且指定了父类的类型实参为<code>String</code>。那么父类的定义应该如下所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然而java中的泛型都是假泛型,泛型在编译期被擦除后,因为类型变量<code>T</code>没有上界,所以编译会把T推断为<code>Object</code>类型。所以真正的代码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    Object name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(Object name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>所以按道理,<code>Student</code>类中的<code>String</code>类型也应该变成<code>Object</code>类型,这样一来,不是全乱套了?所以java为了解决这个问题,发明了一种桥方法的机制。</p><p>可以看到,<code>Student</code>类中的<code>getName</code>和<code>setName</code>和<code>Person</code>类中的<code>getName</code>和<code>setName</code>参数类型根本就不一样,所以这根本就不是重载。但是代码又可以编译通过并且实现多态的特性。奇怪的事情发生了。我们看看<code>Studnet</code>编译后的字节码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// access flags 0x1</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span>Ljava/lang/String</span>;<br>   L0<br>    LINENUMBER <span class="hljs-number">22</span> L0<br>    ALOAD <span class="hljs-number">0</span><br>    GETFIELD generic/Student.stuName : Ljava/lang/String;<br>    ARETURN<br>   L1<br>    LOCALVARIABLE <span class="hljs-keyword">this</span> Lgeneric/Student; L0 L1 <span class="hljs-number">0</span><br>    MAXSTACK = <span class="hljs-number">1</span><br>    MAXLOCALS = <span class="hljs-number">1</span><br><br>  <span class="hljs-comment">// access flags 0x1</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">setName</span><span class="hljs-params">(Ljava/lang/String;)</span>V</span><br><span class="hljs-function">   L0</span><br><span class="hljs-function">    LINENUMBER 27 L0</span><br><span class="hljs-function">    ALOAD 0</span><br><span class="hljs-function">    ALOAD 1</span><br><span class="hljs-function">    PUTFIELD generic/Student.stuName : Ljava/lang/String</span>;<br>   L1<br>    LINENUMBER <span class="hljs-number">28</span> L1<br>    RETURN<br>   L2<br>    LOCALVARIABLE <span class="hljs-keyword">this</span> Lgeneric/Student; L0 L2 <span class="hljs-number">0</span><br>    LOCALVARIABLE name Ljava/lang/String; L0 L2 <span class="hljs-number">1</span><br>    MAXSTACK = <span class="hljs-number">2</span><br>    MAXLOCALS = <span class="hljs-number">2</span><br><br>  <span class="hljs-comment">// access flags 0x1041</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> synthetic bridge <span class="hljs-title">setName</span><span class="hljs-params">(Ljava/lang/Object;)</span>V</span><br><span class="hljs-function">   L0</span><br><span class="hljs-function">    LINENUMBER 18 L0</span><br><span class="hljs-function">    ALOAD 0</span><br><span class="hljs-function">    ALOAD 1</span><br><span class="hljs-function">    CHECKCAST java/lang/String</span><br><span class="hljs-function">    INVOKEVIRTUAL generic/Student.<span class="hljs-title">setName</span> <span class="hljs-params">(Ljava/lang/String;)</span>V</span><br><span class="hljs-function">    RETURN</span><br><span class="hljs-function">   L1</span><br><span class="hljs-function">    LOCALVARIABLE <span class="hljs-keyword">this</span> Lgeneric/Student</span>; L0 L1 <span class="hljs-number">0</span><br>    MAXSTACK = <span class="hljs-number">2</span><br>    MAXLOCALS = <span class="hljs-number">2</span><br><br>  <span class="hljs-comment">// access flags 0x1041</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> synthetic bridge <span class="hljs-title">getName</span><span class="hljs-params">()</span>Ljava/lang/Object</span>;<br>   L0<br>    LINENUMBER <span class="hljs-number">18</span> L0<br>    ALOAD <span class="hljs-number">0</span><br>    INVOKEVIRTUAL generic/Student.getName ()Ljava/lang/String;<br>    ARETURN<br>   L1<br>    LOCALVARIABLE <span class="hljs-keyword">this</span> Lgeneric/Student; L0 L1 <span class="hljs-number">0</span><br>    MAXSTACK = <span class="hljs-number">1</span><br>    MAXLOCALS = <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>有两个<code>setName</code>,两个<code>getName</code>可以看到其中有一组<code>setName</code>和<code>getName</code>前面有修饰符<code>synthetic</code>和<code>bridge</code>。<code>synthetic</code>表示这是系统自动生成的,而<code>bridge</code>表示这是一个桥方法。</p><p>所以其实桥方法才真正是<code>override</code>了<code>Person</code>类中的两个方法。而桥方法又去调用了我们自定义的<code>setName</code>与<code>getName</code>完成了多态。</p><h4 id="3-2-泛型下的继承"><a href="#3-2-泛型下的继承" class="headerlink" title="3.2 泛型下的继承"></a>3.2 泛型下的继承</h4><p>普通的继承关系并没有类型的困扰。但是一旦给类上了泛型,那么就有点复杂了。大体分为四种情况:</p><ol><li>子类直接指定了父类的类型参数</li><li>子类继承了父类的类型参数</li><li>父类擦除了类型参数,子类没有擦除</li><li>子类与父类都擦出了类型参数</li></ol><p>下面我们一一解释以下,还是以上面的<code>Person</code>类作为例子:</p><p><strong>子类直接制定了父类的类型参数</strong>:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    E name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(E name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这种情况,父类的类型参数已经被制定了,所以子类中从父类继承而来的东西也是被指定的类型,例如<code>String</code>。如果子类新加了类型参数<code>T</code>,那么这个<code>T</code>和父类没有任何关系。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;<br>    T age;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>子类继承了父类的类型参数</strong>:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>    T age;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(E name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么在子类中从父类继承而来的东西,类型还是<code>E</code>,类型参数<code>T</code>与父类没有任何关系。</p><p><strong>父类进行了泛型擦除而子类没有:</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    T age;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(Object name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这个例子中,由于<code>Person</code>类中的类型参数<code>E</code>没有上限,因为编译器只能把<code>E</code>推断为Object最为安全。如果类型参数<code>E</code>有上限,例如<code>E extends Number</code>,那么编译器就会将<code>E</code>推断为<code>Number</code>。上面代码中的<code>Object</code>就会全部换成<code>Number</code>了。</p><p><strong>子类与父类都进行了泛型擦除:</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>     age;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(E name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>子类与父类都进行了擦除这么说并不准确,因为根本就没有定义子类的类型参数…规则和父类擦除而子类不擦除的规则一样。要看父类的类型参数有没有上限,因为编译器的推断类型是不一样的。</p><p><strong>那么为什么不能父类不擦除,而子类不擦除呢？</strong></p><p>因为继承泛型类时,子类必须对父类中的类型参数进行初始化,当然父类擦除或者由子类指定都可以。所以子类擦除而父类不擦除,父类中的类型参数由谁来初始化?</p><h4 id="3-3-泛型下的类型获取"><a href="#3-3-泛型下的类型获取" class="headerlink" title="3.3 泛型下的类型获取"></a>3.3 泛型下的类型获取</h4><p>上面曾说到，Java中的泛型是伪泛型，在编译时会被擦除为<code>Object</code>类型的，但是为什么又能够在运行时获取的泛型的真实类型呢？</p><p>首先我们需要知道一个逻辑：<strong>泛型擦除并不代表JVM不知道类型信息</strong>。对于泛型类，JVM可以从Class文件中的<code>Signature</code>属性来获取泛型类的<strong>声明</strong>类型，而不是实际类型。假设有代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">action</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    T a;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T a)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.a=a;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    action&lt;Integer&gt; test=<span class="hljs-keyword">new</span> action&lt;&gt;();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在运行时我们可以获取引用<code>test</code>中的泛型类型，而不能获得<code>test.a</code>的泛型类。因为<code>test.a</code>在运行时会被泛化为<code>object</code>类型，无法通过class文件获取类型。但是对于<code>test</code>来说，因为在编译的时候编译器会将<code>test</code>泛型的声明类型作为<code>Signature</code>属性保存在<code>action</code>类的class文件中，所以我们可以通过<code>action.class</code>获取它的泛型声明类型。</p><p><strong>参考文献</strong></p><ol><li><a href="https://www.itzhai.com/articles/exploring-the-nature-of-java-generics.html">深入探索Java泛型的本质 | 泛型</a></li><li><a href="https://www.zhihu.com/question/346911525">Java中的泛型会被类型擦除，那为什么在运行期仍然可以使用反射获取到具体的泛型类型？</a></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://zhuanlan.zhihu.com/p/31137677">仔细说说Java中的泛型</a></p></li><li><p><a href="https://www.cnblogs.com/wuqinglong/p/9456193.html">Java泛型类型擦除以及类型擦除带来的问题</a></p></li><li><p><a href="https://developer.aliyun.com/article/313280">java泛型学习（2）</a></p></li><li><p><a href="https://segmentfault.com/q/1010000007925818">java 如何继承泛型</a></p></li><li><p><a href="https://blog.csdn.net/ShierJun/article/details/51253870">泛型继承的几种写法</a></p></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E5%8F%8D%E5%B0%84/">反射</category>
      
      
      <category domain="https://eripe.me/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">基本概念</category>
      
      <category domain="https://eripe.me/tags/%E6%B3%9B%E5%9E%8B/">泛型</category>
      
      
      <comments>https://eripe.me/2021-06-04/the-generic-of-java.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>思考java中的访问控制</title>
      <link>https://eripe.me/2021-06-04/access-control-of-Java.html</link>
      <guid>https://eripe.me/2021-06-04/access-control-of-Java.html</guid>
      <pubDate>Fri, 04 Jun 2021 11:57:44 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;java中权限修饰符作用于两个地方，一个是类，另一个是类的成员。下面将分别详细讲解。&lt;/p&gt;
&lt;h2 id=&quot;java中的类权限修饰符&quot;&gt;&lt;a href=&quot;#java中的类权限修饰符&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>java中权限修饰符作用于两个地方，一个是类，另一个是类的成员。下面将分别详细讲解。</p><h2 id="java中的类权限修饰符"><a href="#java中的类权限修饰符" class="headerlink" title="java中的类权限修饰符"></a>java中的类权限修饰符</h2><p>在讲解类的权限的修饰符前，我们需要明确一个概念。在java中，任何可执行的语句都必须<strong>放在一个类中的方法</strong>，比如调用方法。不像c++，在类外也能定义函数，在java中，我们say no。不管你是创建别的类的对象，还是创建方法，成员，等等，这都必须放在一个类中。</p><p>java中的类只能有两种权限修饰符：<code>public</code>和默认的包权限，即什么都不写。</p><p>这里的类的访问控制是指在包A中能否使用导入的包B中的类。对于public类，就是放开了，只要导入public class所在的包，就能使用该类。而包权限的类是只能在所定义的包中使用，也就是所谓的包权限，例如class A所在的包为A。在包B中导入了包A，也就是把A中的所有类导入了包B然后使用，这里注意使用的地方是在包B，包A的包权限类只能在所定义的包A中使用。<strong>这里的使用指的是能够解析类名</strong>，至于能不能创建具体的对象是另外一回事。</p><h2 id="java中的成员权限修饰符"><a href="#java中的成员权限修饰符" class="headerlink" title="java中的成员权限修饰符"></a>java中的成员权限修饰符</h2><p>能修饰成员的权限描述符为：<code>public</code>、<code>private</code>、<code>protected</code>和包权限。这里有一个前提：<br>访问类的成员和方法的前提是能够访问该类！所以不同包下的包权限类中的成员设置成什么权限都无所谓。使用权限修饰符成员是为了隔离同一包下的类和不同包的public类。</p><p>成员修饰符的存在是为了什么？是为了阻止在<strong>不同类</strong>下访问不该访问的东西。什么意思？也就是说，即使类把自己的数据成员私有化，在自己类中创建自己的对象时仍能够访问类的私有数据成员。l例如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> </span>&#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-comment">//protected static int c;</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>show();<br>        <span class="hljs-comment">//输出为10tim</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cat</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br><span class="hljs-keyword">super</span>();<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>Cat cat=<span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;tim&quot;</span>,<span class="hljs-number">10</span>);<br>System.out.println(cat.age+cat.name);<br>&#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述代码仍能够正常运行，即使Cat类的<code>name</code>、<code>age</code>都是私有化的，但是对象<code>cat</code>仍能访问。所以我们可以得出一个结论：能否访问类的成员关键在于我们是在哪访问。在类本身中我们可以访问一切属于该类的资源。比如上述代码中的<code>cat</code>对象。</p><p>所以接下来理解成员的四种访问权限修饰符就很容易了。</p><p><strong>private</strong></p><p>对于private成员，只要出了成员被定义的类，那么我们就不能访问。</p><p><strong>包权限</strong></p><p>对于包权限的成员，只要在同一包下，无论是在成员被定义的类中，还是在同一包下的其他类都可以访问。</p><p><strong>public</strong></p><p>在任何类下都可随意访问，但是前提是：能否访问public成员所在的类，否则一切都是白搭。</p><p><strong>protected</strong></p><p>对于<code>protected</code>，这个是包权限的增强版。被<code>protected</code>修饰的成员，只要在同一包下就能访问，不管是不是在成员被定义的类中。这一点与包权限相同。增强是增强在在不同包下的子类。</p><p>当在不同包下时：如果是非子类，只能访问public成员。如果是子类，则能访问protected成员。这里的能访问指的是什么？</p><p>对于protected的成员函数，指的是<strong>在子类中</strong>子类有资格去访问、重写这个父类的protected函数。注意访问、重写是在<strong>子类</strong>中,而不能在别的类中。在别的类中，不管是通过子类对象，还是父类对象，都不能访问protected成员。下面的代码给出了一个很好的栗子。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Cat</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show3</span><span class="hljs-params">()</span> </span>&#123;<br>Dog d=<span class="hljs-keyword">new</span> Dog();<br>        <span class="hljs-comment">//编译成功，因为是在子类本身中，这里的父类指的Object类</span><br>d.clone();<br>&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">lion</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show5</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>Dog d=<span class="hljs-keyword">new</span> Dog();<br>        <span class="hljs-comment">//编译失败，在其他类中就不能访问Dog类中的protected成员了</span><br>d.clone();<br>&#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>如果在子类中重写了父类的protected函数，在其他类中又可以通过子类的对象来访问，这是为什么？</p><p>因为你一旦在子类中重写了父类的protected成员函数，在子类中就显示有了自己的protected函数，那么在一个包下的其他类当然可以访问本包内的所有protected成员。对应的如果类B与子类又不在同一包内，仍然不能访问子类的proteced函数。</p><p>简而言之，记住一句话，就可以通杀这些问题：</p><blockquote><p>权限修饰符是<strong>针对类的、针对类的、针对类的</strong>！而不是针对对象的。重要的话说三遍。</p></blockquote>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/java/">java</category>
      
      
      <category domain="https://eripe.me/tags/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/">访问控制</category>
      
      
      <comments>https://eripe.me/2021-06-04/access-control-of-Java.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>动态代理的原理</title>
      <link>https://eripe.me/2021-06-04/analysis-of-dynamic-proxy.html</link>
      <guid>https://eripe.me/2021-06-04/analysis-of-dynamic-proxy.html</guid>
      <pubDate>Fri, 04 Jun 2021 11:57:44 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1.</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>代理分为静态代理和动态代理。静态代理就是我们手动地将代理类写出来，而动态代理就是由虚拟机在运行时自动地将代理类构造出来。下面我就简单地阐述静态代理的用法以及缺点。</p><p>首先在下面声明需要代理的类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//实体类实现的接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">search</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//实体类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the add method.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the delete method&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the update method&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">search</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the search method&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>被代理的类<code>UserDaoImpl</code>实现了接口<code>UserDao</code>。</p><h2 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2. 静态代理"></a>2. 静态代理</h2><p>所谓的静态代理就是手动地构造一个类，并实现被代理类的所有接口，在代理类调用被代理类的目标方法，下面我们构造一个实现<code>UserDao</code>接口的方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.learn.proxy;<br><br><span class="hljs-keyword">import</span> com.learn.dao.UserDao;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">staticProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span></span>&#123;<br>    <span class="hljs-keyword">private</span> UserDao user;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUser</span><span class="hljs-params">(UserDao user)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.user = user;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the method:add&quot;</span>);<br>        user.add();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the method:delete&quot;</span>);<br>        user.delete();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the method:update&quot;</span>);<br>        user.update();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">search</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the method:search&quot;</span>);<br>        user.search();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，如果被代理的类方法过多，在每个代理类的方法都得写上同样的代码，太冗余，而且容易出错，是个体力活。所谓为了解决这个缺点，产生了动态代理。</p><h2 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3. 动态代理"></a>3. 动态代理</h2><p>动态代理有两种实现方式：</p><ul><li>使用Java原生API：Proxy+InvocationHandler</li><li>使用cglib</li></ul><p>这里先讲讲Java原生API是怎么用的，有什么缺点。</p><h3 id="3-1-基于原生API的动态代理"><a href="#3-1-基于原生API的动态代理" class="headerlink" title="3.1 基于原生API的动态代理"></a>3.1 基于原生API的动态代理</h3><p>原生API要求被代理的类必须实现接口，动态代理由<code>Proxy</code>类的静态方法<code>newProxyInstance</code>生成，并且要求用于生成动态代理的类必须实现接口<code>InvocationHandler</code>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> UserDao user;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUser</span><span class="hljs-params">(UserDao user)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.user = user;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxyObject</span><span class="hljs-params">()</span></span>&#123;<br>        System.getProperties().put(<span class="hljs-string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<span class="hljs-keyword">this</span>.getClass().getClassLoader(), user.getClass().getInterfaces(),<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;using &quot;</span>+method.getName());<br>        <span class="hljs-comment">//去user对象中查找有没有method对应的方法</span><br>        Object result=method.invoke(user, args);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中<code>public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code>需要我们提供四个参数：</p><ol><li>loader：用于定义动态代理类的ClassLoader</li><li>interfaces：被代理的类已经实现的接口</li><li>h：InvocationHandler对象</li></ol><p>这三个参数没有什么难理解的，我们需要主要关注<code>invoke</code>方法的构成。我们需要在方法调用前执行的操作以及在方法调用后执行的操作都需要在书写在<code>invoke</code>函数。其中最重要就是不能忘记调用<code>method.invoke</code>，这一句完成了实际方法的调用。</p><p>那么为什么要这么写，动态生成的代理类到底长什么样？我们来瞅瞅（如果没有找到动态代理类，一般是因为没有保存至磁盘，只需要添加虚拟机启动参数<code>-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true</code>即可）。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//动态代理类继承了Proxy类，并且实现了我们传递的接口参数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">Proxy0</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m1;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m2;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m3;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m5;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m6;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m0;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m4;<br><br>    <span class="hljs-keyword">public</span> $Proxy0(InvocationHandler var1) <span class="hljs-keyword">throws</span>  &#123;<br>        <span class="hljs-keyword">super</span>(var1);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object var1)</span> <span class="hljs-keyword">throws</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Boolean)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m1, <span class="hljs-keyword">new</span> Object[]&#123;var1&#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var3) &#123;<br>            <span class="hljs-keyword">throw</span> var3;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var4) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var4);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (String)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m2, (Object[])<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Integer)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m0, (Object[])<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);<br>        &#125;<br>    &#125;<br>    ...<br><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m3, (Object[])<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);<br>        &#125;<br>    &#125;<br>    <br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            m1 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;equals&quot;</span>, Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>));<br>            m2 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;toString&quot;</span>);<br>            m3 = Class.forName(<span class="hljs-string">&quot;com.learn.dao.UserDao&quot;</span>).getMethod(<span class="hljs-string">&quot;add&quot;</span>);<br>            m5 = Class.forName(<span class="hljs-string">&quot;com.learn.dao.UserDao&quot;</span>).getMethod(<span class="hljs-string">&quot;delete&quot;</span>);<br>            m6 = Class.forName(<span class="hljs-string">&quot;com.learn.dao.UserDao&quot;</span>).getMethod(<span class="hljs-string">&quot;search&quot;</span>);<br>            m0 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;hashCode&quot;</span>);<br>            m4 = Class.forName(<span class="hljs-string">&quot;com.learn.dao.UserDao&quot;</span>).getMethod(<span class="hljs-string">&quot;update&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException var2) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchMethodError(var2.getMessage());<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoClassDefFoundError(var3.getMessage());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看出，动态代理类继承了<code>Proxy</code>类，并且实现了我们传递的接口，也就是被代理类实现的接口<code>UserDao</code>。所以也就实现了该接口的所有方法。对于<code>add</code>方法，仅仅只有一句代码：<code>super.h.invoke(this, m3, (Object[])null);</code>，调用了父类属性<code>InvocationHandler</code>的<code>invoke</code>方法。而这个<code>InvocationHandler</code>就是我们在调用<code>newProxyInstance</code>时传递进去的参数<code>this</code>。所以其<code>invoke</code>的方法就是我们<code>UserDaoProxy</code>类中实现的<code>invoke</code>方法。</p><p>上述就是基于JDK的动态代理原理。可以看到，我们在生成代理对象时，必须传递被代理类实现的接口。如果我们想代理一个没有实现接口的参数怎么办？cglib解决了这个问题。</p><h3 id="3-2-基于cglib的代理"><a href="#3-2-基于cglib的代理" class="headerlink" title="3.2 基于cglib的代理"></a>3.2 基于cglib的代理</h3><p>cglib是基于ASM框架的一个高性能代码生成库，而ASM是一个Java字节码操控框架。它能被用来动态生成类或者增强现有类的功能。那么cglib到底是如何使用的呢？</p><p>第一步当然是导入对应的jar包，很简单，在maven respo中搜索即可：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>在cglib中，想要实现代理最重要的一步就是设置回调函数（callback），所谓的回调函数就是在调用目标方法之前或者之后设置需要实现的代理操作。并且在callback中调用真正的目标方法。cglib的callback有很多种类型，最常用的就是实现callback的子接口<code>MethodInterceptor</code>，这个接口会拦截被代理的所有方法，如下面的代码所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the method before:&quot;</span> + method.getName());<br>        <span class="hljs-comment">//调用被代理类的方法</span><br>        Object o1 = methodProxy.invokeSuper(o, objects);<br>        System.out.println(<span class="hljs-string">&quot;call the method after:&quot;</span> + method.getName());<br>        <span class="hljs-keyword">return</span> o1;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Proxy&#123;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>然后构造一个代理类，这需要借助工具类<code>Enhancer</code>（意为增强，比较好理解），cglib实现代理的原理是继承被代理类，所以需要完成的操作包括：</p><ol><li>生成工具类Enhancer</li><li>设置父类</li><li>设置回调函数callback</li><li>生成被代理类</li></ol><p>如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">testCG</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="hljs-string">&quot;D:\\cglib&quot;</span>);<br>        Enhancer enhancer=<span class="hljs-keyword">new</span> Enhancer();<br>        <span class="hljs-comment">//设置父类</span><br>        enhancer.setSuperclass(DaoImpl.class);<br>        <span class="hljs-comment">//设置回调函数callback</span><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> Proxy());<br>        <span class="hljs-comment">//生成被代理类</span><br>        DaoImpl en = (DaoImpl)enhancer.create();<br>        en.add();<br>        en.toString();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>cglib代理的实现原理较复杂，目前没有时间深究，列出两篇原理的讲解，以后有时间在学习。但是有一点值得我们注意：<strong>对于从Object中继承的方法，cglib也会进行动态代理。</strong></p><ol><li><a href="https://blog.csdn.net/P19777/article/details/103998918">CGLIB入门系列三，CGLIB生成的代理类详解</a></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1.<a href="https://objectcomputing.com/resources/publications/sett/november-2005-create-proxies-dynamically-using-cglib-library">CREATE PROXIES DYNAMICALLY USING CGLIB LIBRARY</a></p><ol start="2"><li><a href="https://www.cnblogs.com/xrq730/p/6661692.html">Cglib及其基本使用</a></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/java/">java</category>
      
      
      <category domain="https://eripe.me/tags/dynamic-proxy/">dynamic proxy</category>
      
      
      <comments>https://eripe.me/2021-06-04/analysis-of-dynamic-proxy.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java中的GC</title>
      <link>https://eripe.me/2021-06-04/the-GC-of-Java.html</link>
      <guid>https://eripe.me/2021-06-04/the-GC-of-Java.html</guid>
      <pubDate>Fri, 04 Jun 2021 11:57:44 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;Java中的自动垃圾回收是其一大优点。本文将从以下三个方面简介相关知识：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何定义垃圾&lt;/li&gt;
&lt;li&gt;垃圾回收的时机&lt;/li&gt;
&lt;li&gt;垃圾回收的策略&lt;/li&gt;
&lt;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>Java中的自动垃圾回收是其一大优点。本文将从以下三个方面简介相关知识：</p><ol><li>如何定义垃圾</li><li>垃圾回收的时机</li><li>垃圾回收的策略</li><li>具体的垃圾回收器</li></ol><p>在介绍相关的知识前，我们需要知道一个词：<code>stop-the-world</code>，这个词专门为GC而生，因为Java会在进行垃圾回收的时候除了GC线程外，会暂停所有工作线程，也就是所谓的“停止世界运转”。那么GC优化时，我们的目标可能就是减少GC时<code>stop-the-world</code>的时间（这句话网上抄的，当然大部分内容都是）。</p><h2 id="1-如何定义垃圾"><a href="#1-如何定义垃圾" class="headerlink" title="1. 如何定义垃圾"></a>1. 如何定义垃圾</h2><p>在Java中，定义一个对象为垃圾的策略分为两种：</p><ol><li>引用计数法</li><li>可达性算法</li></ol><p>所谓的<strong>引用计数法</strong>，也就是说：对于一个对象A，如果它的被引用次数为0，就说明没有别的对象在使用A，那么A自然而然地称为垃圾。但是这种会存在循环引用的问题。我们看看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>    <span class="hljs-keyword">private</span> B b;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setB</span><span class="hljs-params">(B b)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.b=b;<br>    &#125;<br>    ...<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;<br>    <span class="hljs-keyword">private</span> A a;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setA</span><span class="hljs-params">(A a)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.a=a;<br>    &#125;<br>    ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    A a=<span class="hljs-keyword">new</span> A();<br>    B b=<span class="hljs-keyword">new</span> B();<br>    a.setB(b);<br>    b.setA(a);<br>    a=<span class="hljs-keyword">null</span>;<br>    b=<span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面的代码中，在将a、b设置为null后，看似会被回收，但是实例a中仍然持有实例b的引用，实例b同理。这样实例a和b的引用计数各位1。如果以后不再使用这两个实例，那么就会造成内存泄漏。</p><p>可达性算法就是为了解决上述循环引用的问题。按照我的理解，所谓的可达性分析，是指一个实例的调用链，而调用链又是通过一个名叫<code>GCRoot</code>的数据结构维持的。所谓的<code>GCRoot</code>可以由以下四种中任意一个组成：</p><ol><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>虚拟机栈中引用的对象</li><li>本地native栈中引用的对象</li></ol><h2 id="2-垃圾回收的时机"><a href="#2-垃圾回收的时机" class="headerlink" title="2. 垃圾回收的时机"></a>2. 垃圾回收的时机</h2><p>Java把它的内存区域在逻辑上划分为三类：新生代、老年代、永久代。Java对这三类采用了不同的垃圾回收时机。</p><h3 id="2-1-新生代"><a href="#2-1-新生代" class="headerlink" title="2.1 新生代"></a>2.1 新生代</h3><p>所谓的新生代就是Java在构造实例的时候会使用这块内存，大对象（需要使用连续内存的对象）会直接放在老年代。</p><p>Java又把新生代划分为三个区域：Eden、survivor0和survivor1，每次只会使用Eden区和某一个survivor。假设在初始时，我们使用的Eden区和survivor0区，那么当这两个子区满了之后，会将它们中存活的对象复制到survivor1，这个过程叫做<strong>MinorGC</strong>，也就是次要的垃圾回收，当然MinorGC并不一定要Eden区满了才执行，有可能会经常执行（存疑）。此后survivor1和survivor0的角色交换。JVM使用Eden和survivor1。满了之后重复上述过程。</p><p><strong>特别的，当survivor1区也不足以存放eden区和survivor0区的存活对象时，就将存活对象直接存放到老年代。</strong></p><p><strong>新生代的回收时机就是Eden和某一个survivor内存用尽。</strong></p><h3 id="2-2-老年代"><a href="#2-2-老年代" class="headerlink" title="2.2 老年代"></a>2.2 老年代</h3><p>至于老年代，存放的都是一些生命周期较长的对象，就像上面所叙述的那样，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。</p><p>如果老年代也满了，就会触发一次<strong>FullGC</strong>，也就是<strong>新生代、老年代都进行回收</strong>。当然FullGC执行的频率比较低。导致FullGC的原因包括：老年代被写满、永久代（Perm）被写满和System.gc()被显式调用等。</p><h3 id="2-3-永久代"><a href="#2-3-永久代" class="headerlink" title="2.3 永久代"></a>2.3 永久代</h3><p>永久代主要用于存放静态文件，如Java类、方法等。</p><h2 id="3-垃圾回收的策略"><a href="#3-垃圾回收的策略" class="headerlink" title="3. 垃圾回收的策略"></a>3. 垃圾回收的策略</h2><p>Java的垃圾回收策略主要有三种：</p><ol><li>标记清除</li><li>复制交换</li><li>标记整理</li></ol><h3 id="3-1-标记清除算法"><a href="#3-1-标记清除算法" class="headerlink" title="3.1 标记清除算法"></a>3.1 标记清除算法</h3><p>标记-清除算法分为标记和清除两个阶段。该算法首先从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象并进行回收，</p><p>标记-清除算法的主要不足有两个：</p><ol><li><strong>效率问题</strong>：标记和清除两个过程的效率都不高;</li><li><strong>空间问题</strong>：标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，因此标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ol><h3 id="3-2-复制算法"><a href="#3-2-复制算法" class="headerlink" title="3.2 复制算法"></a>3.2 复制算法</h3><p>所谓的复制算法就是将堆区一分为二，分为A和B。每次只使用一个，当A满了之后，将A中存活的对象复制到B中。这种算法非常适用于存活率低的对象。因为需要复制的内容不会很多，并且复制时只需要调整指针，也不需要考虑内存碎片的问题，并且这种策略已经用于商业虚拟机中的新生代回收算法，<strong>因为研究发现，新生代中的对象每次回收都基本上只有10%左右的对象存活，所以需要复制的对象很少，效率还不错。</strong></p><h3 id="3-3-标记整理算法"><a href="#3-3-标记整理算法" class="headerlink" title="3.3 标记整理算法"></a>3.3 标记整理算法</h3><p>标记整理算法与标记清除算法类似，唯一的不同时，前者会在清除完毕后，有一个整理内存碎片的操作。这样就解决了标记清除算法中的空间问题。</p><h2 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4. 垃圾回收器"></a>4. 垃圾回收器</h2><p>可以按照垃圾回收器作用的内存区域分类：</p><p>作用于新生代的包括：</p><ul><li>ParNew收集器 (复制算法)，<strong>并行</strong></li><li>Parallel Scavenge收集器，<strong>并行</strong>，追求高吞吐量</li></ul><p>作用于老年代的包括：</p><ul><li>CMS，<strong>并行</strong>，使用标记清除策略，追求最短GC回收停顿时间。</li><li>Parallel Old收集器，<strong>并行</strong>，使用标记-整理策略，追求高吞吐量</li></ul><p>作用于两者的包括：</p><ul><li>G1收集器，<strong>并行</strong>，使用标记整理策略</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://segmentfault.com/a/1190000023637649">java面试官最爱问的垃圾回收机制，这位阿里P7大佬分析的属实到位</a></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/java/">java</category>
      
      
      <category domain="https://eripe.me/tags/garbage-collection/">garbage collection</category>
      
      
      <comments>https://eripe.me/2021-06-04/the-GC-of-Java.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java的字符串</title>
      <link>https://eripe.me/2021-06-04/the-String-of-Java.html</link>
      <guid>https://eripe.me/2021-06-04/the-String-of-Java.html</guid>
      <pubDate>Fri, 04 Jun 2021 11:57:44 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;java的所有字符串都会保存在全局字符串池中，在了解全局字符串池之前，我们需要明白：在java中，所有的字符串字面值都会被解释为一个字符串对象。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;All</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>java的所有字符串都会保存在全局字符串池中，在了解全局字符串池之前，我们需要明白：在java中，所有的字符串字面值都会被解释为一个字符串对象。</p><blockquote><p>All string literals in Java programs, such as “abc”, are implemented as instances of this class</p></blockquote><p>接下来我们聊聊全局字符串池。全局字符串池在jdk1.7后也是堆的一部分，不属于某个类，被所有线程共享。那么这个字符串池有啥用？</p><blockquote><p>String pool helps in saving a lot of space for Java Runtime although it takes more time to create the String.</p></blockquote><p>由上可知，字符串池的创建是为了在运行时节省空间。字符串常量池跟创建字符串的方式息息相关。首先创建字符串的方式有两种：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String s1=<span class="hljs-string">&quot;test&quot;</span>;<br>String s2=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;test&quot;</span>);<br>String s3=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br>String s4=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;bc&quot;</span>);<br>String s5=<span class="hljs-string">&quot;a&quot;</span>+s4;<br><br>System.out.println()<br></code></pre></div></td></tr></table></figure><p>首先我们应该明白一个理念：就是所有能够在编译时确定的常量都会放在<code>constant_pool table</code>中，相对应的任何引用在编译期都无法确定。比如上面代码中的<code>test</code>、<code>abc</code>字面值都会作为String对象并在编译后加入当前class的<code>constant_pool table</code>中。在运行时会被解释为String对象加入字符串常量池。String的intern方法非常特殊。下面来详解关于String intern的一切。</p><h2 id="Intern的用法"><a href="#Intern的用法" class="headerlink" title="Intern的用法"></a>Intern的用法</h2><p>在解释关于intern的相关操作时，我们首先需要知道什么是intern。</p><blockquote><p>String.intern()是一个Native方法，它的作用是 ： 如果字符串常量池已经包含一个内容等于当前String对象的字符串对象，则返回代表字符串常量池中的内容相同的字符串的对象；否则将此 String对象的引用地址（堆中）添加到字符串常量池中。<strong>jdk 1.7 后的字符串常量池存在于堆中。</strong></p></blockquote><h3 id="字符串已加入字符串池后Intern"><a href="#字符串已加入字符串池后Intern" class="headerlink" title="字符串已加入字符串池后Intern"></a>字符串已加入字符串池后Intern</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String s1=<span class="hljs-string">&quot;abc&quot;</span>;<br>String s2=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br>String s2Intern=s2.intern();<br>System.out.println(<span class="hljs-string">&quot;s2Intern==s2: &quot;</span>+(s2Intern==s2));<span class="hljs-comment">//flase</span><br>System.out.println(<span class="hljs-string">&quot;s1==s2Intern: &quot;</span>+(s1==s2Intern));<span class="hljs-comment">//true</span><br></code></pre></div></td></tr></table></figure><p>在加载类后，<code>abc</code>这个字面值已经加入字符串池。因为这个在编译时就能确定。</p><p>在执行第一句后，<code>abc</code>会加入字符串池中，s1是指向该字符串的引用。</p><p>在执行第二句时，会在堆内创建一个String对象。该对象的字面值为<code>abc</code>。</p><p>第三句s2调用Intern时，会使用<code>equals</code>方法在字符串池中找与s2内容相同的字符串，能找到吗？当然，因为前一句执行完，<code>abc</code>这个字面值已经加入字符串池中。</p><p>第四句比较<code>s2</code>与<code>s2Intern</code>，<code>s2</code>是堆中<code>abc</code>的引用，<code>s2Intern</code>是字符串池中<code>abc</code>的引用。结果自然为false，因为都不是一个东西。</p><p>而第五句比较<code>s1``s2Intern</code>是否相等。<code>s1</code>是字符串池中<code>abc</code>的引用，<code>s2Intern</code>得到的也是字符串池中<code>abc</code>的引用，结果自然为true。</p><h3 id="字符串未加入字符串池Intern"><a href="#字符串未加入字符串池Intern" class="headerlink" title="字符串未加入字符串池Intern"></a>字符串未加入字符串池Intern</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String bb = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;123&quot;</span>) + <span class="hljs-string">&quot;456&quot;</span>;<br>String bbIntern = bb.intern();<br>System.out.println(<span class="hljs-string">&quot;bb==bbIntern    &quot;</span> + (bb == bbIntern));<span class="hljs-comment">//true</span><br><br>String str=<span class="hljs-string">&quot;123456&quot;</span>;<br>System.out.println(<span class="hljs-string">&quot;str== bb: &quot;</span>+(str==bb));<span class="hljs-comment">//true</span><br>System.out.println(<span class="hljs-string">&quot;str==bbIntern: &quot;</span>+(str==bbIntern));<span class="hljs-comment">//true</span><br><br>String cc=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;12&quot;</span>)+<span class="hljs-string">&quot;3&quot;</span>;<br>String ccIntern=cc.intern();<br>System.out.println(<span class="hljs-string">&quot;ccIntern==cc: &quot;</span>+(ccIntern==cc));<span class="hljs-comment">//false</span><br></code></pre></div></td></tr></table></figure><p>仍然对每句进行解读：</p><p>第一句：<code>123</code>、<code>456</code>这两个字面值会加入字符串池，但是<code>123456</code>并没有字符串池。</p><p>第二句：bb调用intern()查看在字符串池中是否有<code>123456</code>，当然没有。那就把堆中包含<code>123456</code>的对象bb的引用加入字符串池中并返回该引用。</p><p>第三句：<code>bb</code>和<code>bbIntern</code>保存的都是堆中<code>123456</code>对象的引用，地址自然相等。</p><p>第四句：<code>str</code>中保存的是字符串池<code>123456</code>的引用，也就是对象bb的引用，二者自然相等。</p><p>第五句：在字符串池中查找<code>123456</code>找到了，就是执行第二句时新添加到池中引用。二者自然相同。</p><p>第六句：把<code>12</code>、<code>3</code>两个字面值加入字符串池中，和<code>123</code>还是有区别的。</p><p>第七句：<code>cc</code>调用intern(),返回的当然是早已在第一句已经添加到池中的<code>123</code>的引用。</p><p>第八句：<code>ccIntern</code>保存的是池中<code>123</code>引用，而<code>cc</code>保存的是堆中<code>123</code>的引用，地址自然不相同</p><h3 id="字符串到底创建几次的经典问题"><a href="#字符串到底创建几次的经典问题" class="headerlink" title="字符串到底创建几次的经典问题"></a>字符串到底创建几次的经典问题</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String str=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;123&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>上述代码中到底创建了几个对象?<br>这得看常量池中有没有<code>123</code>这个String对象，如果有，那么只会在堆中创建一个String对象，然后该String对象中的<code>123</code>字符串对象会引用字符串常量池中的<code>123</code>String对象。如果没有，那么<code>123</code>这个String对象会被添加到字符串池中，然后在堆中也会创建一个包含<code>123</code>的String对象。<strong>注意这两个对象一个在堆里面，一个在字符串池里面，肯定不是一个东西</strong></p><p>可以看出，字符串池相当于一个共享缓存，如果引用的字符串的字面值相同，那么它们就会引用字符串池中的同一个字符串。(前提是使用intern()方法)</p><h3 id="intern-方法小结"><a href="#intern-方法小结" class="headerlink" title="intern()方法小结"></a>intern()方法小结</h3><p>如果查询的字符串在字符串池中有，那么就返回字符串池中引用。如果没有，就把堆中的字符串对象引用加入字符串池中，然后返回该引用。</p><h3 id="字符串进入字符串池的时机"><a href="#字符串进入字符串池的时机" class="headerlink" title="字符串进入字符串池的时机"></a>字符串进入字符串池的时机</h3><p>我觉的如果时<code>String s1=&quot;abc&quot;</code>这种形式构造字符串，那么就确定了s1中的内容，不需要等到运行时解决，应该直接会加入字符串池中。反之，如果使用<code>String s2=new String(&quot;123&quot;)</code>这种形式构造字符串，s2的值是没办法编译时解决的，但是<code>123</code>这个字面值还是会放到类常量池中。</p><p>这个问题我现在还没有答案，待定。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>constant_pool table是<code>.class</code>文件的一部分，run time constant table是类的一部分，而类又被放在方法区中，方法区又是堆的一部分。String pool也是堆的一部分<br>常量池是为了避免频繁的创建和销毁对象而影响系统性能。</p><p><strong>参考文献</strong><br><a href=https://www.journaldev.com/797/what-is-java-string-pool>字符串池解析</a><br><a href=https://examples.javacodegeeks.com/core-java/lang/string/java-string-pool-example/>字符串简单剖析</a><br><a href=https://juejin.im/entry/5a4ed02a51882573541c29d5>深度解析字符串池,必看</a><br><a href=https://cloud.tencent.com/developer/article/1450501>深度解析java常量池</a></p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/Java/">Java</category>
      
      
      <category domain="https://eripe.me/tags/String/">String</category>
      
      
      <comments>https://eripe.me/2021-06-04/the-String-of-Java.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>HashMap源码分析(三)-删除源码</title>
      <link>https://eripe.me/2021-06-04/HashMap-analysis-part-three.html</link>
      <guid>https://eripe.me/2021-06-04/HashMap-analysis-part-three.html</guid>
      <pubDate>Fri, 04 Jun 2021 11:57:44 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;HashMap的删除操作一般通过&lt;code&gt;remove&lt;/code&gt;完成。在remove方法中,同样存在fast-fail机制,不了解的可以去看看&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>HashMap的删除操作一般通过<code>remove</code>完成。在remove方法中,同样存在fast-fail机制,不了解的可以去看看<a href="../Collection/List/ArrayList-source-code-analysis.md">ArrayList中的fast-fail</a>。通过fast-fail机制检查后,会调用真正的删除方法<code>removeNode</code>,如下面代码所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">removeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key, Object value,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">boolean</span> matchValue, <span class="hljs-keyword">boolean</span> movable)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, index;<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>            <span class="hljs-comment">//通过hash找出一个Node p</span><br>            (p = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>        Node&lt;K,V&gt; node = <span class="hljs-keyword">null</span>, e; K k; V v;<br>        <span class="hljs-comment">//注意,Hash相等不一定是同一个key,因为可能发生hash冲突</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>                <span class="hljs-comment">//如果是同一个对象或者使用equals返回true</span><br>                <span class="hljs-comment">//那么p就是我们要删除的点</span><br>            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            node = p;<br>        <span class="hljs-comment">//在链表中或RB树中查找目标节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = p.next) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key ||<br>                            (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<br>                        node = e;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    p = e;<br>                &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||<br>                                (value != <span class="hljs-keyword">null</span> &amp;&amp; value.equals(v)))) &#123;<br>            <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-comment">//从RB树中删除目标节点</span><br>                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="hljs-keyword">this</span>, tab, movable);<br>            <span class="hljs-comment">//如果目标节点在数组中</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == p)<br>                <span class="hljs-comment">//直接把链表的头部去除</span><br>                tab[index] = node.next;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">//如果此时HashMap仍然是以双向链表存储,那么直接链接后一个节点即可</span><br>                p.next = node.next;<br>            ++modCount;<br>            --size;<br>            afterNodeRemoval(node);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中<code>matchValue</code>表示删除元素时需要value匹配才能删除,<code>movable</code>为<code>false</code>表示当移除元素时不会移动其他节点。在<code>HashMap</code>中<code>matchValue</code>默认为false。在具体阅读源码之前,我们需要了解,<code>HashMap</code>中的链表或者RB树都是hash冲突的元素。<br>所以这个方法的逻辑比较简单:</p><ol><li>首先通过<code>key</code>的hash找出目标桶。</li><li>然后从对应的链表或者RB树找到对应的节点。注意这里对应的节点要求<code>key</code>与<code>value</code>都完全匹配,因为hash冲突。</li><li>如果当前存储形式为RB树,那么调用当前节点的<code>removeTreeNode</code>方法删除自身</li></ol><p>这里需要着重分析的是<code>TreeNode</code>的<code>removeTreeNode</code>方法,该方法非常复杂,需要耐心观看。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeTreeNode</span><span class="hljs-params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-keyword">boolean</span> movable)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> index = (n - <span class="hljs-number">1</span>) &amp; hash;<br>    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;<br>    TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;<br>    <span class="hljs-comment">//删除节点有两种视角,分别是链表视角和红黑树视角</span><br>    <span class="hljs-comment">//能这样操作是因为TreeNode既可以作为红黑树的节点，也可以作为链表节点</span><br>    <span class="hljs-comment">//这里先将hashmap作为链表处理，如果删除完毕节点个数不多于6个,那么直接就将RB树转为链表即可</span><br>    <span class="hljs-comment">//如果想要删除的节点就是根节点</span><br>    <span class="hljs-keyword">if</span> (pred == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-comment">//那么直接使用后继节点补上</span><br>        tab[index] = first = succ;<br>    <span class="hljs-keyword">else</span><br>        pred.next = succ;<br>    <span class="hljs-keyword">if</span> (succ != <span class="hljs-keyword">null</span>)<br>        succ.prev = pred;<br>    <span class="hljs-keyword">if</span> (first == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (root.parent != <span class="hljs-keyword">null</span>)<br>        root = root.root();<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span><br>        || (movable<br>            &amp;&amp; (root.right == <span class="hljs-keyword">null</span><br>                || (rl = root.left) == <span class="hljs-keyword">null</span><br>                || rl.left == <span class="hljs-keyword">null</span>))) &#123;<br>        tab[index] = first.untreeify(map);  <span class="hljs-comment">// too small</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">/******以RB树的视角删除节点************</span><br><span class="hljs-comment">    下面的代码目标是找到替换p的节点replacement然后将p进行真正的删除</span><br><span class="hljs-comment">    */</span><br>        TreeNode&lt;K,V&gt; p = <span class="hljs-keyword">this</span>, pl = left, pr = right, replacement;<br>    <span class="hljs-comment">//如果当前节点的左右子树都不为空</span><br>    <span class="hljs-keyword">if</span> (pl != <span class="hljs-keyword">null</span> &amp;&amp; pr != <span class="hljs-keyword">null</span>) &#123;<br>        TreeNode&lt;K,V&gt; s = pr, sl;<br>        <span class="hljs-comment">//那么就找到右子树的最左节点</span><br>        <span class="hljs-keyword">while</span> ((sl = s.left) != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// find successor</span><br>            s = sl;<br>        <span class="hljs-comment">//交换待删除节点p和p的右子树最左节点的颜色</span><br>        <span class="hljs-keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="hljs-comment">// swap colors</span><br>        <span class="hljs-comment">//此时的s是没有左子树的</span><br>        TreeNode&lt;K,V&gt; sr = s.right;<br>        TreeNode&lt;K,V&gt; pp = p.parent;<br>        <span class="hljs-comment">/***********接下来的操作就是交换s节点和p节点************</span><br><span class="hljs-comment">            * s是p右子树的最左节点</span><br><span class="hljs-comment">            * 总要要设置的就是s和p的left、right、parent三类指针</span><br><span class="hljs-comment">            * pp的left或right指针</span><br><span class="hljs-comment">            * sr的parent指针、pl和pr的parent指针***/</span><br>        <span class="hljs-comment">//如果s是p的右节点,那么就将p设置为s的右节点</span><br>        <span class="hljs-keyword">if</span> (s == pr) &#123; <span class="hljs-comment">// p was s&#x27;s direct parent</span><br>            p.parent = s;<br>            s.right = p;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            TreeNode&lt;K,V&gt; sp = s.parent;<br>            <span class="hljs-comment">//设置p的parent指针,如果s的父节点不为空,将s的父节点设置为p的父节点</span><br>            <span class="hljs-keyword">if</span> ((p.parent = sp) != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (s == sp.left)<br>                    sp.left = p;<br>                <span class="hljs-keyword">else</span><br>                    sp.right = p;<br>            &#125;<br>            <span class="hljs-comment">//设置s的right指针,如果p的右子树不空,那么把p的右子树接到s的右边</span><br>            <span class="hljs-keyword">if</span> ((s.right = pr) != <span class="hljs-keyword">null</span>)<br>                <span class="hljs-comment">//设置pr的parent指针</span><br>                pr.parent = s;<br>        &#125;<br>        <span class="hljs-comment">//设置p的left指针,因为s就是没有左子树的,所以交换后p的left指向null</span><br>        p.left = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//设置p的right指针,将s的右子树接到p的右边</span><br>        <span class="hljs-keyword">if</span> ((p.right = sr) != <span class="hljs-keyword">null</span>)<br>            sr.parent = p;<br>        <span class="hljs-comment">//设置s的left指针,将p的左子树接到s的左边</span><br>        <span class="hljs-keyword">if</span> ((s.left = pl) != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-comment">//设置pl的parent指针</span><br>            pl.parent = s;<br>        <span class="hljs-comment">//设置s的parent指针,设置s的父节点为p的父节点</span><br>        <span class="hljs-keyword">if</span> ((s.parent = pp) == <span class="hljs-keyword">null</span>)<br>            root = s;<br>        <span class="hljs-comment">//设置pp的left指针或者right指针</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == pp.left)<br>            pp.left = s;<br>        <span class="hljs-keyword">else</span><br>            pp.right = s;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">            * sr还是原来s的右子节点,这里并没有产生变化</span><br><span class="hljs-comment">            */</span><br>        <span class="hljs-keyword">if</span> (sr != <span class="hljs-keyword">null</span>)<br>            replacement = sr;<br>        <span class="hljs-keyword">else</span><br>            replacement = p;<br>    &#125;<br>    <span class="hljs-comment">//只有左子树,那么直接使用左子树的根节点替换</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pl != <span class="hljs-keyword">null</span>)<br>        replacement = pl;<br>    <span class="hljs-comment">//只有右子树,那么直接使用右子树的根节点替换</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pr != <span class="hljs-keyword">null</span>)<br>        replacement = pr;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">//当左右子树都为空时,当前节点就是被替换的节点</span><br>        replacement = p;<br>    <span class="hljs-comment">//如果replacement和p不是同一个节点,那么将二者交换</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 这里仅仅是简单的将pp变成replacement的父节点</span><br><span class="hljs-comment">        * 将p的所有指针都置空,方便垃圾回收</span><br><span class="hljs-comment">        */</span><br>    <span class="hljs-keyword">if</span> (replacement != p) &#123;<br>        TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;<br>        <span class="hljs-keyword">if</span> (pp == <span class="hljs-keyword">null</span>)<br>            root = replacement;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == pp.left)<br>            pp.left = replacement;<br>        <span class="hljs-keyword">else</span><br>            pp.right = replacement;<br>        p.left = p.right = p.parent = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-comment">/**如果p是红色,那么可以直接删除红节点</span><br><span class="hljs-comment">        * 否则从replacement开始调整颜色,此时p可以说是已经完全脱离RB树了</span><br><span class="hljs-comment">        */</span><br>        TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);<br>    <span class="hljs-comment">//只有p的左右子树都为空才会走下面的if分支</span><br>    <span class="hljs-keyword">if</span> (replacement == p) &#123;  <span class="hljs-comment">// detach</span><br>        TreeNode&lt;K,V&gt; pp = p.parent;<br>        p.parent = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (pp != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (p == pp.left)<br>                pp.left = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == pp.right)<br>                pp.right = <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (movable)<br>        moveRootToFront(tab, r);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>该方法的<code>this</code>指针就指向当前待删除的节点。在代码中我也写了,该方法删除节点有两种视角,因为<code>TreeNode</code>既可以作为RB树的节点,也可以作为双链表的节点。该方法的思路如下:</p><ol><li>首先以双链表的视角,删除当前节点,如果删除后RB树的节点不多于6个,那么就会执行<code>untreeify</code>方法,将RB树退化为单链表</li><li>当前剩余节点多于6,那么以RB树的视角删除当前节点,这里的核心思想是找到一个节点<code>s</code>替换当前待删除节点<code>p</code>。</li><li>如果节点<code>p</code>是红的,那么直接删除就好,因为删除红节点不会影响平衡性</li><li>如果节点<code>p</code>是黑的,删除节点<code>p</code>后,我们需要从从<code>replacement</code>节点开始调整RB树的颜色,这里的<code>replacement</code>是<code>p</code>的左或者右孩子,或者是<code>s</code>交换前的右孩子,或者是p本身</li></ol><p>经过上述四步,已经完成删除节点操作了,当然其中调整RB树平衡性的方法<code>balanceDeletion</code>是重中之重,但是记下来非常困难,看懂理解就好了。该方法的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 如果能进入到这个函数,那么删除的必是黑节点</span><br><span class="hljs-comment">    * 并且从x开始调整RB树的颜色</span><br><span class="hljs-comment">    * 返回的是RB树的根节点</span><br><span class="hljs-comment">    */</span><br><span class="hljs-keyword">static</span> &lt;K,V&gt; <span class="hljs-function">TreeNode&lt;K,V&gt;  <span class="hljs-title">balanceDeletion</span><span class="hljs-params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123;<br>        <span class="hljs-comment">//如果x是根节点,那么不用调整</span><br>        <span class="hljs-comment">//直接返回root</span><br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span> || x == root)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-comment">//如果x的父节点为空,那么x就是新的父节点</span><br>        <span class="hljs-comment">//直接返回x</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((xp = x.parent) == <span class="hljs-keyword">null</span>) &#123;<br>            x.red = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>        <span class="hljs-comment">//如果x是红节点,因为删除了一个黑节点,需要补上一个黑节点,否则破坏了RB树的完美黑平衡</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.red) &#123;<br>            x.red = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">            * 到这里为止,x必是黑色,因为从x到叶子节点的路径中</span><br><span class="hljs-comment">            * 少了一个黑节点,所有必须想办法把这个黑节点从别的地方补回来</span><br><span class="hljs-comment">            * 我们需要关注的节点就是x</span><br><span class="hljs-comment">            * 下面的代码就是在不断地变换x的指针</span><br><span class="hljs-comment">            * 下面的case1的四种情况图示可以参考:http://jackhuang.online/2019/08/09/red-black-tree%E7%AE%80%E4%BB%8B/</span><br><span class="hljs-comment">            *  case2为镜像分布</span><br><span class="hljs-comment">            */</span><br><br>        <span class="hljs-comment">//case1</span><br>        <span class="hljs-comment">//如果x是其父节点的左孩子</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((xpl = xp.left) == x) &#123;<br>            <span class="hljs-comment">//如果x有右兄弟并且右兄弟是红的,那么就把这个红色移到左边来</span><br>            <span class="hljs-comment">//因为x是xp的左孩子</span><br>            <span class="hljs-comment">//case1-1:</span><br>            <span class="hljs-keyword">if</span> ((xpr = xp.right) != <span class="hljs-keyword">null</span> &amp;&amp; xpr.red) &#123;<br>                xpr.red = <span class="hljs-keyword">false</span>;<br>                xp.red = <span class="hljs-keyword">true</span>;<br>                root = rotateLeft(root, xp);<br>                xpr = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.right;<br>            &#125;<br>            <span class="hljs-comment">//向左旋转后,x没有兄弟,重新设置x为xp</span><br>            <span class="hljs-keyword">if</span> (xpr == <span class="hljs-keyword">null</span>)<br>                x = xp;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">/**到此为止,x必有右兄弟,至于黑红目前还不知道</span><br><span class="hljs-comment">                */</span><br>                TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;<br>                <span class="hljs-comment">//如果右兄弟孩子双全并且都是黑孩子</span><br>                <span class="hljs-comment">//或者有一个孩子并且孩子是黑的</span><br>                <span class="hljs-comment">//case1-2:</span><br>                <span class="hljs-keyword">if</span> ((sr == <span class="hljs-keyword">null</span> || !sr.red) &amp;&amp;<br>                    (sl == <span class="hljs-keyword">null</span> || !sl.red)) &#123;<br>                    xpr.red = <span class="hljs-keyword">true</span>;<br>                    x = xp;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//走到这x的右兄弟必有孩子,因为如果没有孩子不会进入这个else分支</span><br>                    <span class="hljs-comment">//如果有一个孩子,那么该孩子必是红的</span><br>                    <span class="hljs-comment">//如果有两个孩子,必然是一个黑色,一个红色,或者两个都是红色</span><br>                    <span class="hljs-comment">/**</span><br><span class="hljs-comment">                        * 在这我们关注的都是xpr的右孩子</span><br><span class="hljs-comment">                        */</span><br><br><br>                    <span class="hljs-comment">//case1-3:如果xpr没有右孩子或者右孩子是黑的</span><br>                    <span class="hljs-keyword">if</span> (sr == <span class="hljs-keyword">null</span> || !sr.red) &#123;<br>                        <span class="hljs-keyword">if</span> (sl != <span class="hljs-keyword">null</span>)<br>                            sl.red = <span class="hljs-keyword">false</span>;<br>                        xpr.red = <span class="hljs-keyword">true</span>;<br>                        root = rotateRight(root, xpr);<br>                        xpr = (xp = x.parent) == <span class="hljs-keyword">null</span> ?<br>                            <span class="hljs-keyword">null</span> : xp.right;<br>                    &#125;<br>                    <span class="hljs-comment">//走到这,xpr的必有右孩子且右孩子是红的</span><br><br><br>                    <span class="hljs-comment">//case1-4</span><br>                    <span class="hljs-keyword">if</span> (xpr != <span class="hljs-keyword">null</span>) &#123;<br>                        xpr.red = (xp == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">false</span> : xp.red;<br>                        <span class="hljs-keyword">if</span> ((sr = xpr.right) != <span class="hljs-keyword">null</span>)<br>                            sr.red = <span class="hljs-keyword">false</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;<br>                        xp.red = <span class="hljs-keyword">false</span>;<br>                        root = rotateLeft(root, xp);<br>                    &#125;<br>                    x = root;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//case2</span><br>        <span class="hljs-comment">//如果x是其父节点的右孩子,这根上面是镜像的</span><br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// symmetric</span><br>            <span class="hljs-keyword">if</span> (xpl != <span class="hljs-keyword">null</span> &amp;&amp; xpl.red) &#123;<br>                xpl.red = <span class="hljs-keyword">false</span>;<br>                xp.red = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-comment">//与上面相似,这里将红色往右边移,因为x是xp的右节点</span><br>                root = rotateRight(root, xp);<br>                xpl = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.left;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (xpl == <span class="hljs-keyword">null</span>)<br>                x = xp;<br>            <span class="hljs-keyword">else</span> &#123;<br>                TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;<br>                <span class="hljs-keyword">if</span> ((sl == <span class="hljs-keyword">null</span> || !sl.red) &amp;&amp;<br>                    (sr == <span class="hljs-keyword">null</span> || !sr.red)) &#123;<br>                    xpl.red = <span class="hljs-keyword">true</span>;<br>                    x = xp;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (sl == <span class="hljs-keyword">null</span> || !sl.red) &#123;<br>                        <span class="hljs-keyword">if</span> (sr != <span class="hljs-keyword">null</span>)<br>                            sr.red = <span class="hljs-keyword">false</span>;<br>                        xpl.red = <span class="hljs-keyword">true</span>;<br>                        root = rotateLeft(root, xpl);<br>                        xpl = (xp = x.parent) == <span class="hljs-keyword">null</span> ?<br>                            <span class="hljs-keyword">null</span> : xp.left;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (xpl != <span class="hljs-keyword">null</span>) &#123;<br>                        xpl.red = (xp == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">false</span> : xp.red;<br>                        <span class="hljs-keyword">if</span> ((sl = xpl.left) != <span class="hljs-keyword">null</span>)<br>                            sl.red = <span class="hljs-keyword">false</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;<br>                        xp.red = <span class="hljs-keyword">false</span>;<br>                        root = rotateRight(root, xp);<br>                    &#125;<br>                    x = root;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>在该方法中,<code>x</code>就是我们一直需要关注的节点,主要思想就是从x开始不断地由下向上调整整颗RB树的颜色,其主要逻辑如下:</p><ol><li>如果<code>x</code>没有父节点或者其本身就是root节点,表示并不需要调整什么</li><li>如果<code>x</code>是红节点,那么把<code>x</code>变黑即可,因为原来从根节点到叶节点包含<code>x</code>的这条路径,少了一个黑节点,这里补上的话就没有什么问题了</li><li>如果<code>x</code>是黑节点,那么比较惨,调整操作就比较复杂了,这里分成了两个大case,每个case里面有四种小case,具体见代码注释,并且这四种小case的图解可以<a href="http://jackhuang.online/2019/08/09/red-black-tree%E7%AE%80%E4%BB%8B/">参考</a>,就像图片的作者所说,我也认为这里不要去怀疑这些移动策略的正确性,仅作了解,看懂了即可。</li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</category>
      
      
      <category domain="https://eripe.me/tags/HashMap/">HashMap</category>
      
      
      <comments>https://eripe.me/2021-06-04/HashMap-analysis-part-three.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LinkedList源码分析</title>
      <link>https://eripe.me/2021-06-04/LinkedList-source-code-analysis.html</link>
      <guid>https://eripe.me/2021-06-04/LinkedList-source-code-analysis.html</guid>
      <pubDate>Fri, 04 Jun 2021 11:57:44 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;&lt;code&gt;LinkedList&lt;/code&gt;弥补了&lt;code&gt;ArrayList&lt;/code&gt;插入元素慢的缺点,当然也带了查找元素慢的缺点。&lt;code&gt;LinkedList&lt;/code&gt;同时实</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p><code>LinkedList</code>弥补了<code>ArrayList</code>插入元素慢的缺点,当然也带了查找元素慢的缺点。<code>LinkedList</code>同时实现了<code>List</code>和<code>Queue</code>接口,其底层采用双向链表实现。当然<code>LinkedList</code>也有一个父类<code>AbstractSequentialList</code>用于实现一般的方法。下面是<code>LinkedList</code>的继承图:</p><p><img src="images/LinkedList-hierarchy.png" alt="LinkedList-hierarchy"></p><p>可以看到<code>LinkedList</code>实现了<code>Cloneable</code>、<code>Serializable</code>接口,当然也是其<code>clone()</code>实现的也是shadow copy(浅拷贝)。并且<code>LinkedList</code>支持序列化。</p><h2 id="0x0-LinkedList的属性"><a href="#0x0-LinkedList的属性" class="headerlink" title="0x0 LinkedList的属性"></a>0x0 LinkedList的属性</h2><p><code>LinkedList</code>的属性非常简单,就三个:</p><ul><li>链表长度</li><li>链表头指针</li><li>链表尾指针</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//双向链表的头指针</span><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<br>    <span class="hljs-comment">//双向链表的尾指针</span><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br><br>    <span class="hljs-comment">//链表的节点定义</span><br>    <span class="hljs-comment">//非常简单,前向和后向指针,再加一个数据项</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>        E item;<br>        Node&lt;E&gt; next;<br>        Node&lt;E&gt; prev;<br><br>        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>            <span class="hljs-keyword">this</span>.item = element;<br>            <span class="hljs-keyword">this</span>.next = next;<br>            <span class="hljs-keyword">this</span>.prev = prev;<br>        &#125;<br>    &#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="0x1-LinkedList的构造方法"><a href="#0x1-LinkedList的构造方法" class="headerlink" title="0x1 LinkedList的构造方法"></a>0x1 LinkedList的构造方法</h2><p><code>LinkedList</code>的构造方法就两,一个是不带参的构造方法,另一个是使用集合初始化的构造函数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>();<br>    <span class="hljs-comment">//addAll函数应该跟ArrayList差不多</span><br>    addAll(c);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="0x2-LinkedList的重要方法"><a href="#0x2-LinkedList的重要方法" class="headerlink" title="0x2 LinkedList的重要方法"></a>0x2 LinkedList的重要方法</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>因为<code>LinkedList</code>同时实现了<code>List</code>和<code>Queue</code>接口,势必有一大堆<code>addXXX</code>、<code>offerXXX</code>、<code>removeXXX</code>、<code>pollXXX</code>方法。实现都非常简单,这里挑一些内部方法看看。</p><p>比如<code>offerLast()</code>方法内部调用<code>linkLast()</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Links e as last element.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(l, e, <span class="hljs-keyword">null</span>);<br>        last = newNode;<br>        <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)<br>            first = newNode;<br>        <span class="hljs-keyword">else</span><br>            l.next = newNode;<br>        size++;<br>        modCount++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkFirst</span><span class="hljs-params">()</span></span>&#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-comment">//在指定节点之前插入</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkBefore</span><span class="hljs-params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;<br>        ...<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>这里的<code>modCount</code>和<code>ArrayList</code>中的<code>modCount</code>差不多,每当对<code>LinkedList</code>做出结构性改变时,就会改变modCount。当然<code>LinkedList</code>也是线程不安全的,也同时实现了fast-fail机制。</p><p>回到主题,<code>linkLast</code>就是把新节点链到双向链表末尾。<code>linkFirst</code>当然同理咯。</p><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>删除头尾的方法也非常简单,没有什么特别值得关注：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//移除头节点</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">unlinkFirst</span><span class="hljs-params">(Node&lt;E&gt; f)</span> </span>&#123;<br>    <span class="hljs-comment">// assert f == first &amp;&amp; f != null;</span><br>    <span class="hljs-keyword">final</span> E element = f.item;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; next = f.next;<br>    f.item = <span class="hljs-keyword">null</span>;<br>    f.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>    first = next;<br>    <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>)<br>        last = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">else</span><br>        next.prev = <span class="hljs-keyword">null</span>;<br>    size--;<br>    modCount++;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br><br><span class="hljs-comment">//移除尾节点</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">unlinkLast</span><span class="hljs-params">(Node&lt;E&gt; l)</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-comment">//指定移除某节点</span><br><span class="hljs-function">E <span class="hljs-title">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> </span>&#123;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>在增和删的方法中我们都看到了,在指定某节点前插入、删除某个指定节点。那么这个指定是怎么获取的?</p><p>当然<code>LinkedList</code>还是贴心的实现了查找某个位置的节点:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-comment">//检查下标是否越界</span><br>    checkElementIndex(index);<br>    <span class="hljs-comment">//获取指定位置的node的value</span><br>    <span class="hljs-keyword">return</span> node(index).item;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkElementIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!isElementIndex(index))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isElementIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; size;<br>&#125;<br><span class="hljs-comment">//可以看出,node只在第一次找位置时使用了一次二分,</span><br><span class="hljs-comment">//然后使用for循环遍历一半元素,是非常慢的</span><br><span class="hljs-function">Node&lt;E&gt; <span class="hljs-title">node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-comment">// assert isElementIndex(index);</span><br><br>    <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>        Node&lt;E&gt; x = first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)<br>            x = x.next;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;E&gt; x = last;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size - <span class="hljs-number">1</span>; i &gt; index; i--)<br>            x = x.prev;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="0x3-小结"><a href="#0x3-小结" class="headerlink" title="0x3 小结"></a>0x3 小结</h2><p>因为之前分析过了<code>ArrayList</code>与<code>ArrayDeque</code>,再来分析<code>LinkedList</code>就比较简单了。</p><ul><li><code>LinkedList</code>虽然插入元素非常快,但是都快在头尾插入。如果在中间插入,就需要找到某一位置的节点,而插入操作又是非常慢的。</li><li>因为<code>LinkedList</code>没有实现<code>RandomAccess</code>接口,所以使用它实现的迭代器或者for-each遍历都比普通的for循环快。并且在遍历时不允许对<code>LinkedList</code>做出结构性改变,除非使用它自己的迭代器来改变。</li><li><code>LinkedList</code>是线程不安全的,支持fast-fail机制</li></ul>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</category>
      
      
      <category domain="https://eripe.me/tags/LinkedList/">LinkedList</category>
      
      
      <comments>https://eripe.me/2021-06-04/LinkedList-source-code-analysis.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Queue接口分析</title>
      <link>https://eripe.me/2021-06-04/Queue-interface-analysis.html</link>
      <guid>https://eripe.me/2021-06-04/Queue-interface-analysis.html</guid>
      <pubDate>Fri, 04 Jun 2021 11:57:44 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;0x1-基本概念&quot;&gt;&lt;a href=&quot;#0x1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;0x1 基本概念&quot;&gt;&lt;/a&gt;0x1</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="0x1-基本概念"><a href="#0x1-基本概念" class="headerlink" title="0x1 基本概念"></a>0x1 基本概念</h2><p><code>Queue</code>接口继承自超级接口<code>Collection</code>,其不仅实现了<code>Coolection</code>中的基本方法,而且额外增加了适用于队列的增、删、差方法。并且对应这三种操作,Queue提供了两套方法,一套在操作失败时抛出异常,另一套在操作失败时返回<code>null</code>,不过在文档中说到:</p><blockquote><p>The latter form of the insert operation is designed specifically for use with capacity-restricted Queue implementations</p></blockquote><p>说是后者是专门为容量有限的队列而设计的,why?这点不是很懂。</p><p>更新:2020-07-23 19:12:32</p><p>现在懂了,如果对于<strong>容量有限</strong>的队列,比如<code>ArrayBlockingQueue</code>,它是继承自抽象类<code>AbstractQueue</code>,如果调用其<code>offer</code>方法(在<code>AbstractQueue</code>中实现),添加元素失败后只会返回true,否则返回false。而调用<code>add</code>的话,如果插入失败,就会抛出状态异常。所以说,offer类方法可用于检查队列是否已满,比add类方法优秀点。但是对于<code>LinkedList</code>、<code>ArrayQueue</code>等带自动扩容属性的队列来说,二者效果差不多,不过offer类可以返回操作是否成功的信息。还是推荐使用offer类。</p><p>两组方法如下图所示:</p><p><img src="images/methods.png" alt="methods"></p><h2 id="0x2-抽象类AbstractQueue"><a href="#0x2-抽象类AbstractQueue" class="headerlink" title="0x2 抽象类AbstractQueue"></a>0x2 抽象类AbstractQueue</h2><p>当然,跟<code>Collection</code>接口差不多,<code>Queue</code>也有一个抽象类用于实现一般的方法:</p><figure class="highlight java"><figcaption><span>"AbstractQueue"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractCollection</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    ...<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>可以看到,因为<code>Queue</code>本身就继承自<code>Clooection</code>,所以<code>AbstractQueue</code>的实现继承自<code>AbstractClloection</code>没有任何异议吧。当然为了实现了Queue的特有方法,也实现了接口<code>Queue</code>。下面简单分析一下<code>offer()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (offer(e))<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Queue full&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>add在内部调用了offer,所以用谁不用我多说了吧。不过一开始我看到写法还是一愣,这<code>offer()</code>方法的实现在哪啊?</p><p>后来一想,抽象类不一定要实现嘛,把这个方法留到子类去实现也行奥。</p><h2 id="0x3-Deque接口"><a href="#0x3-Deque接口" class="headerlink" title="0x3 Deque接口"></a>0x3 Deque接口</h2><p>Deque就是<code>double ended queue</code>,也就是所谓的双端队列,什么是双端队列我就不说了,来看看其规定的抽象方法:</p><figure class="highlight java"><figcaption><span>"Deque"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <br>    <span class="hljs-comment">//双端队列方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(E e)</span></span>;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offerFirst</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offerLast</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">removeLast</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">pollFirst</span><span class="hljs-params">()</span></span>;<br> <br>    <span class="hljs-function">E <span class="hljs-title">pollLast</span><span class="hljs-params">()</span></span>;<br> <br>    <span class="hljs-function">E <span class="hljs-title">getFirst</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">getLast</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">peekFirst</span><span class="hljs-params">()</span></span>;<br> <br>    <span class="hljs-function">E <span class="hljs-title">peekLast</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">removeFirstOccurrence</span><span class="hljs-params">(Object o)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">removeLastOccurrence</span><span class="hljs-params">(Object o)</span></span>;<br><br>    <span class="hljs-comment">// 单向队列方法</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">element</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>;<br><br><br>    <span class="hljs-comment">//栈方法</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//重写Collection的部分方法</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Iterator&lt;E&gt; <span class="hljs-title">descendingIterator</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br><br></code></pre></div></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</category>
      
      
      <category domain="https://eripe.me/tags/Queue/">Queue</category>
      
      
      <comments>https://eripe.me/2021-06-04/Queue-interface-analysis.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>HashMap源码分析(一)-HashMap中的那些常量</title>
      <link>https://eripe.me/2021-06-04/HashMap-analysis-part-one.html</link>
      <guid>https://eripe.me/2021-06-04/HashMap-analysis-part-one.html</guid>
      <pubDate>Fri, 04 Jun 2021 11:57:44 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HashMap实现了接口<code>Map</code>、<code>Cloneable</code>、<code>Serializable</code>,后两个都是标记接口,注意HasnMap的<code>clone</code>方法也仅仅是浅复制(shadow copy)。而<code>Map</code>是跟<code>Collection</code>并列的顶级接口。HashMap并且继承抽象类<code>AbstractMap</code>。</p><p>本文将首先简单说说接口<code>Map</code>,因为<code>AbstarctMap</code>作为实现接口<code>Map</code>的骨架,仅实现了一些基本方法,没什么好说的。</p><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br>    ...<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>Map提供了三种方法来遍历自身:</p><ul><li>通过<code>keySet()</code>方法返回Map中所有键组成的Set</li><li>通过<code>values()</code>返回Map中values组成的Collection</li><li>通过<code>entrySet()</code>返回由<code>Map.Entry</code>组成的Set</li></ul><p>前两种都比较常规。值得一提的是第三种方式中的<code>Map.Entry</code>。在<code>Map</code>接口定义了一个内部接口<code>Entry</code>。Entry维护了一组键值对,类似于c++HashMap中的pair结构。这个Entry结构只能通过Map的迭代器获得。并且这些Entry集合<strong>只</strong>在遍历的过程中有效,如果在遍历过程中修改了集合,那么对Entry的操作是未定义的,除非使用Entry定义的<code>setValue()</code>方法。</p><h2 id="1-HashMap中的常量"><a href="#1-HashMap中的常量" class="headerlink" title="1. HashMap中的常量"></a>1. HashMap中的常量</h2><p>HashMap中定义了一些比较重要的常量,如下所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//默认初始容量,必须是2的倍数</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br><br><span class="hljs-comment">//HashMap最大的容量,也就是2^30,因为必须是2的倍数</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br><span class="hljs-comment">//扩容因子,如果当前存储的Entry个数达到容量的75%,那么就进行扩容</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The bin count threshold for using a tree rather than list for a</span><br><span class="hljs-comment"> * bin.  Bins are converted to trees when adding an element to a</span><br><span class="hljs-comment"> * bin with at least this many nodes. The value must be greater</span><br><span class="hljs-comment"> * than 2 and should be at least 8 to mesh with assumptions in</span><br><span class="hljs-comment"> * tree removal about conversion back to plain bins upon</span><br><span class="hljs-comment"> * shrinkage.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//当一条链表上的数据容量达到8时就采用红黑树存储</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The bin count threshold for untreeifying a (split) bin during a</span><br><span class="hljs-comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span><br><span class="hljs-comment"> * most 6 to mesh with shrinkage detection under removal.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//当一条链表上的数据少于等于6个时,就从红黑树转为链表存储一个桶中的数据</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The smallest table capacity for which bins may be treeified.</span><br><span class="hljs-comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span><br><span class="hljs-comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span><br><span class="hljs-comment"> * between resizing and treeification thresholds.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//如果一旦采用红黑树存储,那么HashMap的容量至少为64</span><br><span class="hljs-comment">//当然用红黑树存储一个桶中的数据时,那么就至少是4*TREEIFY_THRESHOLD的容量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;<br></code></pre></div></td></tr></table></figure><p>下面将罗列一些常见的关于HashMap常量的问题。</p><h3 id="1-1-为什么Map的容量都是2的整数幂"><a href="#1-1-为什么Map的容量都是2的整数幂" class="headerlink" title="1.1 为什么Map的容量都是2的整数幂?"></a>1.1 为什么Map的容量都是2的整数幂?</h3><p>有两个理由:</p><ul><li>寻找bucket索引更快</li><li>让扩容方法resize()效率更高，在理想情况下，能够等概率地将一个长链表分为两半，一半在原位置，一半移动到新扩容的地方</li></ul><p>对于第一点,因为在JDK8中,HashMap计算bucket的索引方法如下:</p><blockquote><p>i = (n - 1) &amp; hash == hash % n == (n-1) &amp; (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</p></blockquote><p>tab就是用来存储bucket的数组。n是数组的容量。如果n是2的整数幂,那么<code>(n-1)&amp; hash== hash% n</code>,其中hash是一个32位整数。没错,就是这么神奇。这样计算索引只需移位操作,比取模更快。所以都是2的整数幂。</p><p>对于第二点:每次HashMap扩容都是变为原来的两倍,扩容是一个代价高昂的操作。在扩容时不仅需要复制元素,而且需要更新对应的索引。如果HashMap的容量都是2的整数幂。那么它的索引要么在原来位置,要么偏移了2的整数次幂(<strong>偏移了原始容量的距离</strong>)。</p><p>对于这一点,我们随便设一个hash做验证,令hashcode=0x00008435。未扩容前的容量为2^4=16。那么当前计算出的索引:</p><blockquote><p>0000 0000 0000 0000 1000 0100 0001 0101 -&gt; hash<br>0000 0000 0000 0000 0000 0000 0000 1111 -&gt; n-1</p></blockquote><p>计算出的索引为:0101b &amp; 1111b=101b=5。现在将容量扩张为原来的2倍:</p><blockquote><p>0000 0000 0000 0000 0000 0000 0001 1111 -&gt; n-1</p></blockquote><p>计算出的索引为:11111b &amp; 10101b=10101b=21。索引移动了2的整数幂。再将容量扩充为原来的2倍:</p><blockquote><p>0000 0000 0000 0000 0000 0000 0011 1111 -&gt; n-1</p></blockquote><p>计算出的索引为:111111b &amp; 010101b=10101b=21。索引没有变化。</p><p>从上面的结果可以看出,索引动与不动随机的取决于hashcode某1bit是0还是1。后者是0还是1的概率为0.5。</p><p>将容量扩充为原来的两倍的同时,也公平的将每个桶的容量也扩充为原来的两倍,因为桶中的元素移动于不移动完全是等概率的,取决于hashcode某bit是1还是0。</p><blockquote><p>值得注意的是,JDK1.8中,HashMap扩容不会讲链表倒置,而JDK1.7会</p></blockquote><h3 id="1-2-为什么hash要这么计算"><a href="#1-2-为什么hash要这么计算" class="headerlink" title="1.2 为什么hash要这么计算?"></a>1.2 为什么hash要这么计算?</h3><p>在JDK1.8中,Map计算hashcode采用了新的方法:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-comment">//null的hash为0</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>    <span class="hljs-comment">//这里调用的key的hashCode方法,实际上调用的key的具体实现类,而不是Object的hashCode</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>是将key的hash高16位于低16位进行异或。最后的hash高16位还是原来的高16位,低16位是异或后的结果。为什么要这么做呢?</p><p>简单来说是为了增加hash的随机性。比如两个整数:365(11110101b),165(01110101b)。如果只采用Integer自己实现的hash算法,那么计算出来的hash就是365于165。</p><p>现在进行索引的计算(map容量为16):<code>(n-1) &amp; 16</code>。计算出的结果都为<code>101b</code>,发生了hash碰撞。但是这两个数差别还是蛮大的。所以将对象的原始hash的高16位与低16位异或,这么做也是为了在低16中保留高16位的特性,加大低16位的随机性。</p><p>所以说最终目的就是为了<strong>防止hash碰撞</strong>。JDK1.7的hash算法并不怎么随机,曾经产生了dos攻击。<a href="https://coolshell.cn/articles/6424.html">HASH COLLISION DOS 问题</a></p><p><strong>最后,null的hash为0!</strong></p><h3 id="1-3-为什么HashMap的默认容量为16"><a href="#1-3-为什么HashMap的默认容量为16" class="headerlink" title="1.3 为什么HashMap的默认容量为16?"></a>1.3 为什么HashMap的默认容量为16?</h3><p>既然HashMap的容量必须是2的整数幂,那么为什么不是2,4,或者16,32。emm,这个问题我在网上看到的回答是:</p><blockquote><p>如果是2、4、8之类的,容量太小,容易导致频繁扩容。上文说过,扩容代价很高的。而不设置成32、64等更大的值是因为太大了,用到的概率不大。避免浪费空间。</p></blockquote><p>这个答案还行吧,好像有那么一点道理。</p><h3 id="1-4-为什么桶中节点数到8才采用RB树"><a href="#1-4-为什么桶中节点数到8才采用RB树" class="headerlink" title="1.4 为什么桶中节点数到8才采用RB树?"></a>1.4 为什么桶中节点数到8才采用RB树?</h3><p>答案存在于源码中的开发笔记。这里仅摘抄最重要的部分。</p><blockquote><p>Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use(see TREEIFY_THRESHOLD). And when they become too small (due to removal or resizing) they are converted back to plain bins.  In usages with well-distributed user hashCodes, tree bins are rarely used.  Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution (<a href="http://en.wikipedia.org/wiki/Poisson_distribution">http://en.wikipedia.org/wiki/Poisson_distribution</a>) with a parameter of about 0.5 on average for the default resizing threshold of 0.75, although with a large variance because of resizing granularity.</p></blockquote><p>大致意思是说,采用红黑树的存储所消耗的空间是采用链表存储的两倍。所以仅在链表中数据足够多的情况下会转为红黑树存储,当节点数减少到一定数量,就会再次退化为链表存储。<strong>如果使用足够好的hash算法</strong>,那么计算出的hashcode应该是足够分散的。</p><p>在理想hash下,每个桶中的节点数符合参数为0.5的泊松分布。分布公式为<code>(exp(-0.5) * pow(0.5, k) / * factorial(k))</code>。通过公式的计算,每个桶中各个节点数出现的情况如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">0</span>:    <span class="hljs-number">0.60653066</span><br><span class="hljs-number">1</span>:    <span class="hljs-number">0.30326533</span><br><span class="hljs-number">2</span>:    <span class="hljs-number">0.07581633</span><br><span class="hljs-number">3</span>:    <span class="hljs-number">0.01263606</span><br><span class="hljs-number">4</span>:    <span class="hljs-number">0.00157952</span><br><span class="hljs-number">5</span>:    <span class="hljs-number">0.00015795</span><br><span class="hljs-number">6</span>:    <span class="hljs-number">0.00001316</span><br><span class="hljs-number">7</span>:    <span class="hljs-number">0.00000094</span><br><span class="hljs-number">8</span>:    <span class="hljs-number">0.00000006</span><br></code></pre></div></td></tr></table></figure><p>可以看到,一个桶中出现出现8个节点的概率为千万分之六。几乎是不可能出现的情况。当然,回归现实,不可能每次都出现理想hash。所以采用8个节点作为分界点。一个桶中达到8个节点,就转为红黑树存储。</p><p>这里又可以引申出一个问题,<strong>为什么泊松分布的参数要设置为0.5?</strong></p><blockquote><p>emmm,从注释中看,应该也是一个经验值吧。</p></blockquote><h3 id="1-5-为什么桶中节点数减少为6才采用链表"><a href="#1-5-为什么桶中节点数减少为6才采用链表" class="headerlink" title="1.5 为什么桶中节点数减少为6才采用链表?"></a>1.5 为什么桶中节点数减少为6才采用链表?</h3><p>在节点数减少到6时才桶中元素采用RB树转为链表,为什么不是5或者7?</p><p>不设置为5、4、3的原因显而易见,节点太少,用红黑树存储从空间角度上来说不划算,因为是链表存储的2倍。</p><p>那么为什么不设置为7呢?</p><p>因为如果设置为7,那么加一个entry,变为8就要升级红黑树,减一个entry就变为7降级为链表。如果对HashMap频繁的进行增删操作,那么桶的存储方式就得频繁的在红黑树和链表之间转换,这个开销是不可忽视的。所以设为6,有一个缓冲的空间。</p><h3 id="1-6-为什么factor设为0-75"><a href="#1-6-为什么factor设为0-75" class="headerlink" title="1.6 为什么factor设为0.75?"></a>1.6 为什么factor设为0.75?</h3><p>在官方注释中,下面的节选部分解释了为什么<code>load factor</code>是0.75。</p><blockquote><p>As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs.  Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the <tt>HashMap</tt> class, including <tt>get</tt> and <tt>put</tt>).  The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of<br>rehash operations.  If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.</p></blockquote><p>简而言之,0.75是一个经验值,在时间和空间两个方面达到了平衡。<strong>这也就解释为什么不是0.5或是1?</strong></p><p>如果factor是<strong>0.5</strong>,那么就会导致map频繁扩容,代价比较高。而且空间利用率也比较低。但是链表中的内容或者RB树的节点就比较少,提升了查询效率。<strong>是以空间换时间的方式。</strong></p><p>如果factor设置为<strong>1</strong>,虽然空间利用率达到了100%,在使用完才会扩容,一定程度增加了put的时间。并且可能会发生大量的hash碰撞,此时的查询效率是非常低的。<strong>是以时间换空间的方式。</strong></p><p><strong>那么为什么不是0.6或者0.8?</strong></p><p>首先如果<code>load factor</code>为0.75,那么每次<code>load factor * capacity</code>都会得到一个整数。</p><p>其次,在StackOverflow上有一个<a href="https://stackoverflow.com/questions/10901752/what-is-the-significance-of-load-factor-in-hashmap">回答</a>,采用了二项分布的方式计算出了<code>load factor</code>与<code>capacity</code>的最佳比例:</p><p>他首先规定,在完美情况下,在每次插入时所选取的桶应该是一个空桶。泊松分布的极限就是二项分布。在n次插入实验中,每次插入都选取空桶的概率总和应该为0.5。计算公式为:</p><blockquote><p>1/2=P=C(n, 0) * (1/s)^0 * (1 - 1/s)^(n - 0),其中s是桶的数量,n是试验次数</p></blockquote><p>我一直不明白<code>1/s</code>代表的是什么?每次都选取的是非空桶?那么解释不了<code>1/s</code>啊。而且StackOverflow新人还不能评论,可恶啊。</p><p>进行简单变化,在s趋于正无穷时,<code>n/s=load factor</code>趋近于<code>ln(2)</code>。所以他得出load facotr在<code>ln(2)~0.75</code>之间HashMap都能有很出色的表现。</p><p>我对上述回答产生了如下疑问:</p><ol><li>也不一定要求每次插入都必须要求空桶吧?</li><li><code>1/s</code>的数学意义到底代表着什么?</li></ol><h2 id="2-HashMap的属性"><a href="#2-HashMap的属性" class="headerlink" title="2. HashMap的属性"></a>2. HashMap的属性</h2><p>HashMap中的magic number在上面已经分析过,下面是HashMap的一些属性:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The table, initialized on first use, and resized as</span><br><span class="hljs-comment">* necessary. When allocated, length is always a power of two.</span><br><span class="hljs-comment">* (We also tolerate length zero in some operations to allow</span><br><span class="hljs-comment">* bootstrapping mechanics that are currently not needed.)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//用来存储bucket的底层数组,无论是初始化HashMap还是扩容,容量一直都是2的整数幂</span><br><span class="hljs-comment">//当然上面也指出了在某些时候允许长度为0,从而允许一些当前不需要的引导机制????这是啥意思</span><br><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Holds cached entrySet(). Note that AbstractMap fields are used</span><br><span class="hljs-comment">* for keySet() and values().</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The number of key-value mappings contained in this map.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//这是HashMap中实际的Entry数量,不是容量哦</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The number of times this HashMap has been structurally modified</span><br><span class="hljs-comment">* Structural modifications are those that change the number of mappings in</span><br><span class="hljs-comment">* the HashMap or otherwise modify its internal structure (e.g.,</span><br><span class="hljs-comment">* rehash).  This field is used to make iterators on Collection-views of</span><br><span class="hljs-comment">* the HashMap fail-fast.  (See ConcurrentModificationException).</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//modCount曾在分析ArrayList的源码解释过,用于支持fast-fail机制,从而也说明HashMap是线程不安全的</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The next size value at which to resize (capacity * load factor).</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// (The javadoc description is true upon serialization.</span><br><span class="hljs-comment">// Additionally, if the table array has not been allocated, this</span><br><span class="hljs-comment">// field holds the initial array capacity, or zero signifying</span><br><span class="hljs-comment">// DEFAULT_INITIAL_CAPACITY.)</span><br><br><span class="hljs-comment">//注释中的大致意思就是下一次扩容时的容量,如果HashMap还未初始化,那么就存储初始化的容量,或者0(表示默认初始化容量)</span><br><span class="hljs-keyword">int</span> threshold;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The load factor for the hash table.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//HashMap的装载因子,一旦确定,不可更改</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;<br></code></pre></div></td></tr></table></figure><p>更新:2020-08-02 18:57:49</p><p><code>HashMap</code>中的<code>threshold</code>=<code>loadFactor*capacity</code>,并<strong>不是</strong>下一次扩容的容量,当然如果HashMap还未初始化,并且用户指定了初始化容量,那么存储的就是根据用户指定容量计算出的元素数量阈值,否则0就是表示默认值12。       </p><p><code>table</code>数组的元素是Node,这又是什么呢?来一起康康:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>        <span class="hljs-comment">//key的Hash值,是一个32bit的int,不可更改</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;<br>        <span class="hljs-comment">//key,不可更改</span><br>        <span class="hljs-keyword">final</span> K key;<br>        V value;<br>        <span class="hljs-comment">//next指针,因为刚开始就是使用链表存储的Entry的</span><br>        Node&lt;K,V&gt; next;<br>        <span class="hljs-comment">//构造函数</span><br>        <span class="hljs-comment">//注意:没有默认构造函数</span><br>        Node(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-keyword">this</span>.hash = hash;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.value = value;<br>            <span class="hljs-keyword">this</span>.next = next;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span>        </span>&#123; <span class="hljs-keyword">return</span> key; &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span>      </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">&quot;=&quot;</span> + value; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">setValue</span><span class="hljs-params">(V newValue)</span> </span>&#123;<br>            V oldValue = value;<br>            value = newValue;<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Map.Entry) &#123;<br>                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;<br>                <span class="hljs-keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;<br>                    Objects.equals(value, e.getValue()))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>从上面可以看出,Node是在HashMap使用链表存储模式时一组key-value的wrapper类。而<code>Map.Entry</code>是在<code>Map</code>接口中定义的一个内部接口,规定了一些<code>Entry</code>必须实现的方法。基本上就可以说这个<code>Entry</code>就相当于c++中的<code>pair</code>结构。保存一对key-value。<code>Entry</code>的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-function">K <span class="hljs-title">getKey</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">V <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">V <span class="hljs-title">setValue</span><span class="hljs-params">(V value)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K extends Comparable&lt;? <span class="hljs-keyword">super</span> K&gt;, V&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByKey() &#123;<br>        <span class="hljs-keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)<br>            (c1, c2) -&gt; c1.getKey().compareTo(c2.getKey());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V extends Comparable&lt;? <span class="hljs-keyword">super</span> V&gt;&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByValue() &#123;<br>        <span class="hljs-keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)<br>            (c1, c2) -&gt; c1.getValue().compareTo(c2.getValue());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey(Comparator&lt;? <span class="hljs-keyword">super</span> K&gt; cmp) &#123;<br>        Objects.requireNonNull(cmp);<br>        <span class="hljs-keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)<br>            (c1, c2) -&gt; cmp.compare(c1.getKey(), c2.getKey());<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue(Comparator&lt;? <span class="hljs-keyword">super</span> V&gt; cmp) &#123;<br>        Objects.requireNonNull(cmp);<br>        <span class="hljs-keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)<br>            (c1, c2) -&gt; cmp.compare(c1.getValue(), c2.getValue());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在<code>Entry</code>中定义了四个获取比较器的静态方法,对于不熟悉java8新语法的同学来说,静态方法内部的实现可能让人摸不着头脑。</p><p>首先,<code>(c1, c2) -&gt; c1.getKey().compareTo(c2.getKey());</code>其实是lambda表达式,它的一般格式如下:</p><blockquote><p>(type1 arg1,type2 arg2…)-&gt;{ body…}</p></blockquote><p>lambda有<a href="http://blog.oneapm.com/apm-tech/226.html">以下特点</a>:</p><ul><li>一个 Lambda 表达式可以有零个或多个参数</li><li>参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同</li><li>所有参数需包含在圆括号内，参数之间用逗号相隔。例如：(a, b) 或 (String a, int b, float c)<br>空圆括号代表参数集为空。例如：() -&gt; 42</li><li>当只有一个参数，且其类型可推导时，<strong>圆括号</strong>（）可省略。例如：a -&gt; return a*a</li><li>Lambda 表达式的主体可包含零条或多条语句</li><li>如果 Lambda 表达式的主体只有<strong>一条</strong>语句，<strong>花括号</strong>{}可省略。匿名函数的返回类型与该主体表达式一致</li><li>如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</li></ul><p>关于lambda表达式更高级知识可以了解一下函数式语言中的闭包,java中的lambda就是最接近闭包的概念。</p><p>接下来再看看为什么一个lambda表达式能够强转为接口。<code>Comparator</code>是一个函数式接口(<code>@FunctionalInterface</code>)。函数式接口的标准就是其内部只能定义一个抽象方法。在java8中,每个lambda表达式都能隐式的赋值给函数时接口。当然lambda表达式的返回值和参数得和接口中定义的抽象方法一样才行。</p><p>然而我们去实际看<code>Comparator</code>接口源码时,却发现<code>Comparator</code>有两个抽象方法:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(T o1, T o2)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span>;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>竟然和函数式接口的定义不一样?然而答案在<code>FunctionInterface</code>的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html">官方文档</a>中。</p><blockquote><p>If an interface declares an abstract method overriding one of the public methods of java.lang.Object, that also does not count toward the interface’s abstract method count since any implementation of the interface will have an implementation from java.lang.Object or elsewhere.</p></blockquote><p>意思就是说如果函数式接口的抽象方法如果重写自<code>object</code>,那么是不计入函数式接口定义的方法个数中的,因为<code>Object</code>中的方法肯定都会在自身中实现或者override于其他地方。</p><p>最后强转的类型是竟然是<code>(Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</code>,两个类型还能进行与操作?</p><p>其实这也是java8中的新语法,StackOverflow上关于此问题的<a href="https://stackoverflow.com/questions/28509596/java-lambda-expressions-casting-and-comparators">回答</a>如下:</p><blockquote><p>The lambda is initialized with its target type as Comparator and Serializable. Note the return type of method is just Comparator, but because Serializable is also inscribed to it while initialization, it can always be serialized even though this message is lost in method signature.</p></blockquote><p>简而言之就是lambda表达式的初始化的目标类型是<code>Comparator</code>和<code>Serializable</code>。但是最后的<strong>返回类型</strong>却只是<code>Comparator</code>,但是<code>Serializable</code>类型已经在表达式初始化时注册(inscribe)过了。所以尽管在函数签名中丢失了该信息,但是返回值是一定总是可以初始化的。</p><p>ok,经过上述的简单科普,相信返回比较器的代码实现已经不是问题了。上述所有的点都是java8的新语法,包括在接口中定义<code>default</code>方法和<code>static</code>方法。</p><h2 id="3-HashMap的构造方法"><a href="#3-HashMap的构造方法" class="headerlink" title="3. HashMap的构造方法"></a>3. HashMap的构造方法</h2><p><code>HashMap</code>总共有4个构造方法,除了<code>HashMap(Map&lt;? extends K, ? extends V&gt; m)</code>以外,其他3个构造函数都是仅仅设置装载因子<code>load factor</code>,在这三个构造函数中,除了默认构造函数,<del>另外两个都会设置初始容量</del>。</p><p><del>这里传入的初始容量仅仅是为了设置threshold,而不是设置初始容量</del>,这里再次收回所说的话,虽然表面上看仅仅是将传入容量修正为最近的2的整数幂,并赋值给threshold。</p><p><strong>但是在第一次put元素时</strong>,会将刚才设置好的threshold赋值给table的新容量,也就实现的指定HashMap的容量的操作。但是这三个构造都不会进行table内存的分配,<strong>只会在第一次put时调用resize()进行分配</strong>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +<br>                                           initialCapacity);<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                           loadFactor);<br>    <span class="hljs-keyword">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br><br><span class="hljs-comment">//默认构造函数不会设置threshold</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span><br>&#125;<br><br><span class="hljs-comment">//会在putEntries中设置threshold    </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>    putMapEntries(m, <span class="hljs-keyword">false</span>);<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>在第四个使用<code>Map</code>对象构造HashMap的构造函数中,其调用了<code>putMapEntries(Map,boolean)</code>方法,这个函数值得一提,因为其第二个参数的意义会在后面用到:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Implements Map.putAll and Map constructor.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> m the map</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> evict false when initially constructing this map, else</span><br><span class="hljs-comment">     * true (relayed to method afterNodeInsertion).</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putMapEntries</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m, <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> s = m.size();<br>        <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (table == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// pre-size</span><br>                <span class="hljs-comment">//下面的操作是在计算完全存储m中的元素需要的capacity,注意不是threshold</span><br>                <br>                <span class="hljs-comment">//下面的加1.0F是为在计算出的loadFactor为小数时向上取整</span><br>                <span class="hljs-keyword">float</span> ft = ((<span class="hljs-keyword">float</span>)s / loadFactor) + <span class="hljs-number">1.0F</span>;<br>                <span class="hljs-keyword">int</span> t = ((ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY) ?<br>                         (<span class="hljs-keyword">int</span>)ft : MAXIMUM_CAPACITY);<br>                <span class="hljs-comment">//查看所需的capacity是否比当前HashMap的扩容阈值还大,比阈值还大的情况下,不可能存储下m的所有元素,即使当前HashMap为空</span><br>                <span class="hljs-comment">//那么就需要更新当前HashMap的阈值</span><br>                <span class="hljs-keyword">if</span> (t &gt; threshold)<br>                    threshold = tableSizeFor(t);<br>            &#125;<br>            <span class="hljs-comment">//当调用HashMap的putAll方法时,会再次调用该方法执行到下面的else if </span><br>            <span class="hljs-comment">//这里的resize相当于一次预判,如果m的元素个数比当前hashmap的元素个数阈值threshold还高的话</span><br>            <span class="hljs-comment">//那么即使当前HashMap为空,也无法存储m的所有元素,所以必须扩容</span><br>            <span class="hljs-comment">//当然即使s&lt;=threshold,当前HashMap还是有可能存储不下,这会在putVal内部进行扩容</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &gt; threshold)<br>                resize();<br>            <span class="hljs-keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;<br>                K key = e.getKey();<br>                V value = e.getValue();<br>                putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, evict);<br>            &#125;<br>        &#125;<br>    &#125; <br></code></pre></div></td></tr></table></figure><p>在<code>else if</code>中的扩容操作体现了HashMap的扩容懒汉模式,仅仅在已经确定没有足够空间存储的情况中才会进行扩容操作,因为扩容操作的代价太高了。</p><p><strong>evict参数:</strong></p><p>如果当前<code>HashMap</code>的table还未进行分配,那么就会将参数<code>evict</code>设置为false,表示当前正处于构造模式。这个单词本身的意思具有驱逐的意思,主要应用于<code>LinkedHashMap</code>构造<code>LRU</code>时使用。与<code>HashMap</code>中的意义不同。</p><p>最后代码中经常使用<code>tableSizeFor(int)</code>方法就是把用户输入的容量调整到最近的2的整数幂。其代码与<code>ArrayQueue</code>的调整方式基本一致。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACIT      Y : n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>唯一与<code>ArrayQueue</code>不同的时,当把容量调整到离cap最近的2的整数幂-1时:</p><ul><li>如果已经溢出,那么会将容量设为1</li><li>如果此时的容量小于<code>2^31</code>但是大于<code>2^30</code>,那么就将容量修正为<code>2^30</code></li><li>否则最新容量就是最近的2的整数幂。</li></ul><p><a href="https://stackoverflow.com/questions/857420/what-are-the-reasons-why-map-getobject-key-is-not-fully-generic">为什么HashMap的get方法没有写成泛型？</a></p><h2 id="0x3-JDK1-8与JDK1-7的HashMap异同"><a href="#0x3-JDK1-8与JDK1-7的HashMap异同" class="headerlink" title="0x3 JDK1.8与JDK1.7的HashMap异同"></a>0x3 JDK1.8与JDK1.7的HashMap异同</h2><ol><li><p>实现方式不同,在JDK1.7中,HashMap采用数组+链表的方式实现,1.8则采用数组+链表+红黑树实现。</p></li><li><p>扩容与插入顺序不同,1.7在链表中扩容是需要时再扩,也就是在插入时发现实在没办法插入再进行扩容,然后重新完成插入操作。我认为这很正常,没地方放再扩容不是正常逻辑?<br>JDK1.8中是先把节点放入map中,最后再决定是否要调用<code>resize</code>,我认为这是因为1.8中链表和RB树会进行相互转换。如果先进行扩容,那么本来需要进行树化的链表由于扩容被迫拆为两条小链表,可能会浪费空间。例如链表为7个,插入后为8个需要进行树化,但是先扩容导致该链表的长度减为4,又不需要树化了。</p></li><li><p>链表的插入顺序不同,1.7中是采用头插法,1.8中采用尾插法。</p></li></ol><h2 id="0x4-JDK1-7的HashMap中存在的问题"><a href="#0x4-JDK1-7的HashMap中存在的问题" class="headerlink" title="0x4 JDK1.7的HashMap中存在的问题"></a>0x4 JDK1.7的HashMap中存在的问题</h2><ol><li>死循环问题,因为1.7中采用头插法,在多线程环境下进行扩容操作时(resize过后在调用transfor时可能会出现问题)可能会形成循环链表,导致在进行get操作时陷入死循环。这种情况出现在原hashmap中有:3-&gt;5-&gt;7,扩容后的hashmap分割为：5-&gt;3和7，这时可能会产生死循环</li></ol><p>对于1.7hashmap的transform方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Entry[] newTable)</span> </span>&#123;<br>    Entry[] src = table;<br>    <span class="hljs-keyword">int</span> newCapacity = newTable.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; src.length; j++) &#123;<br>        Entry&lt;K,V&gt; e = src[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            src[j] = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">do</span> &#123;<br>                Entry&lt;K,V&gt; next = e.next;<br>                <span class="hljs-keyword">int</span> i = indexFor(e.hash, newCapacity);<br>                <span class="hljs-comment">//如果线程1在这就被挂起，那么当前这个do...while循环本身就不会结束</span><br>                e.next = newTable[i];<br><br>                <span class="hljs-comment">//死循环产生点</span><br>                <span class="hljs-comment">//线程1正准备执行下面一句时被挂起，才会出现get时死循环</span><br>                newTable[i] = e;<br>                <br>                e = next;<br>            &#125; <span class="hljs-keyword">while</span> (e != <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="2"><li>数据丢失问题,同样是因为头插法,原始链表的末尾数据可能会产生丢失问题。</li></ol><p>这种情况出现在原hashmap中有:3-&gt;5-&gt;7,扩容后的hashmap分割为：7-&gt;3和5，这时可能会丢失数据3。详情见：<a href="https://www.cnblogs.com/bendandedaima/p/13259284.html">HashMap为什么线程不安全（死循环+数据丢失过程分析）</a></p><h2 id="0x5-JDK1-8的HashMap中存在的问题"><a href="#0x5-JDK1-8的HashMap中存在的问题" class="headerlink" title="0x5 JDK1.8的HashMap中存在的问题"></a>0x5 JDK1.8的HashMap中存在的问题</h2><p>仍然会出现死循环以及数据丢失的问题。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">....<br><span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>    tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>...<br></code></pre></div></td></tr></table></figure><p>上述是<code>putVal</code>中的部分代码,在多线程环境下,如果线程1已经通过if检查但是被迫放弃cpu,而线程2因为hash相同已经完成了插入操作,线程1重新获取cpu,此时再进行插入就会覆盖线程2插入的线程。</p><p>数据丢失问题是多线程环境下必然产生的问题。而1.8下的死循环原因却不相同,在对链表进行树化(<code>treeify</code>)或者调整树平衡(<code>balanceInsertion</code>)时仍然会产生死循环问题。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://runzhuoli.me/2018/09/20/why-hashmap-size-power-of-2.html">为什么容量都是2的整数幂</a></p></li><li><p><a href="https://albenw.github.io/posts/df45eaf1/">关于HashMap的一些理解</a></p></li><li><p><a href="https://blog.csdn.net/reliveIT/article/details/82960063?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param">HashMap defaultLoadFactor = 0.75和泊松分布没有关系</a></p></li><li><p><a href="https://juejin.im/post/5d5d25e9f265da03f66dc517">HashMap面试必问的6个点，你知道几个</a></p></li><li><p><a href="https://www.cnblogs.com/liang1101/p/12728936.html">1.7与1.8HashMap的异同</a></p></li><li><p><a href="https://stackoverflow.com/questions/10901752/what-is-the-significance-of-load-factor-in-hashmap">1.8散列因子为0.75的可能原因</a></p></li><li><p><a href="https://www.cnblogs.com/xrq730/p/5037299.html">1.7中HashMap存在的问题</a></p></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</category>
      
      
      <category domain="https://eripe.me/tags/HashMap/">HashMap</category>
      
      
      <comments>https://eripe.me/2021-06-04/HashMap-analysis-part-one.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
