<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>一颗胡杨树</title>
    <link>https://eripe.me/</link>
    
    <image>
      <url>https://eripe.me/img/panda.png</url>
      <title>一颗胡杨树</title>
      <link>https://eripe.me/</link>
    </image>
    
    <atom:link href="https://eripe.me/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>欢迎乘坐八楼的二路公交车</description>
    <pubDate>Mon, 27 Sep 2021 03:21:24 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Hello World</title>
      <link>https://eripe.me/articles/hello-world.html</link>
      <guid>https://eripe.me/articles/hello-world.html</guid>
      <pubDate>Mon, 27 Sep 2021 03:21:24 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo server<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo generate<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content:encoded>
      
      
      
      
      <comments>https://eripe.me/articles/hello-world.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>工厂模式扫盲</title>
      <link>https://eripe.me/articles/factory-pattern.html</link>
      <guid>https://eripe.me/articles/factory-pattern.html</guid>
      <pubDate>Wed, 09 Jun 2021 11:51:05 GMT</pubDate>
      
      <description>本文将对网上几种常见的工厂模式进行简单总结，最后阐述了工厂方法与抽象工厂的区别。</description>
      
      
      
      <content:encoded><![CDATA[<p>工厂模式基本上可分为四种种：静态工厂模式、简单工厂模式、工厂方法模式以及抽线工厂模式。本文将对这四种设计模式进行了简单介绍。</p><h2 id="1-为什么需要工厂模式"><a href="#1-为什么需要工厂模式" class="headerlink" title="1. 为什么需要工厂模式"></a>1. 为什么需要工厂模式</h2><p>这个问题的答案很容易想到，工厂模式是为了将对象的使用与创建这两个步骤分开，实现代码的解耦，不然一个很明显的问题就是如果我们修改了对象的创建方法，那么需要修改的地方将无法想象。工厂模式避免了这一窘境。</p><h2 id="2-静态工厂模式"><a href="#2-静态工厂模式" class="headerlink" title="2. 静态工厂模式"></a>2. 静态工厂模式</h2><p>静态工厂模式比较简单，基本定义为：一个类中的方法根据不同的参数返回不同的实例，不过一般是一个单独的类来定义这个唯一的方法，demo代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> function <span class="hljs-title">create</span><span class="hljs-params">(String type)</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (type) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;user&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;customer&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Customer();<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;admin&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Admin();<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&#x27;Wrong user type passed.&#x27;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>但是该模式的缺点就是如果产品类非常多，那么条件判断是一件非常麻烦的事，并且可能需要频繁更改简单工厂的代码，违反了开闭原则。我认为该模式适用于产品类较少的情况。</p><h2 id="3-工厂方法模式"><a href="#3-工厂方法模式" class="headerlink" title="3. 工厂方法模式"></a>3. 工厂方法模式</h2><p>根据我的探索，工厂方法有两种版本：</p><ol><li>经典版本，由GOF定义</li><li>无名氏版本</li></ol><p>首先工厂方法模式（factory method）的<a href="https://en.wikipedia.org/wiki/Factory_method_pattern">经典定义</a>如下（GOF版本）：</p><div class="note note-info">            <p>“Define an interface for creating an object, but let subclasses decide which class to <strong>instantiate</strong>. The Factory method lets a class defer instantiation it uses to subclasses.”</p>          </div><p>大意是指通过“接口”创建对象，但是具体的创建过程交由继承的子类来实现。定义很抽象，我们通过<a href="https://stackoverflow.com/a/50786084">jaco0646</a>提供的demo来了解一下：</p><figure class="highlight java"><figcaption><span>"factory method"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Creator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">anOperation</span><span class="hljs-params">()</span> </span>&#123;<br>        Product p = factoryMethod();<br>        p.whatever();<br>    &#125;<br>    <span class="hljs-comment">//factory method</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Product <span class="hljs-title">factoryMethod</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteCreator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Creator</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Product <span class="hljs-title">factoryMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProduct();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述代码中，抽象类“Creator”调用了自己的定义的工厂方法“factoryMethod”，但是方法具体的实现交给了子类“ConcreteCreator”，子类实现的工厂方法返回的是一个具体产品，很标准地实现了上述定义，但是美中不足是没有使用“interface”。<a href="https://stackoverflow.com/a/38668246">jaco0646</a>给出了回答：</p><div class="note note-info">            <p>First, we must note that neither Java nor C# existed when the GoF wrote their book. The GoF use of the term interface is unrelated to the interface types introduced by particular languages. Therefore, the concrete creator can be created from any API. The important point in the pattern is that <strong>the API consumes its own Factory Method</strong>, so an interface with only one method cannot be a Factory Method any more than it can be an Abstract Factory.</p>          </div><p>大意是指因为时代原因，GOF中的“interface”和具体语言中“interface”完全不同，我们可以通过任何形式的API使用工厂方法，但是需要注意该API必须消费自己的工厂方法。可能熟悉设计模式的同学发现，这就是模板方法啊，你到底懂不懂啊？很巧，我在<a href="https://stackoverflow.com/a/50786084">jaco0646</a>的回答中又发现了答案：</p><div class="note note-info">            <p>The Factory Method Pattern is nothing more than a specialization of the Template Method Pattern. The two patterns share an identical structure. They only differ in purpose. Factory Method is creational (it builds something) whereas Template Method is behavioral (it computes something).</p>          </div><p>大意是说工厂方法与模板方法的区别很微妙，前者是创建型方法（指创建具体的实例），而后者是行为型方法（指完成逻辑功能）。</p><p>上述是我了解的经典工厂方法，而无名氏版本是由抽象工厂、具体工厂、抽象产品、具体产品四类元素组成组成，demo如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//抽象产品</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Product</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shape</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//具体产品</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProduct</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shape</span><span class="hljs-params">()</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Creator</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">factoryMethod</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//具体工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteCreator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Creator</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Product <span class="hljs-title">factoryMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProduct();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其实这种版本应该没啥问题，但是当我学习抽象工厂模式时，我陷入了疑惑。</p><h2 id="4-抽象工厂模式"><a href="#4-抽象工厂模式" class="headerlink" title="4. 抽象工厂模式"></a>4. 抽象工厂模式</h2><p>抽象工厂模式的<a href="https://en.wikipedia.org/wiki/Abstract_factory_pattern#Definition">GOF定义</a>如下所示：</p><div class="note note-info">            <p>The essence of the Abstract Factory Pattern is to “Provide an interface for creating families of related or dependent objects without specifying their concrete classes.”（通过“接口”创建相关的系列产品，但是并不声明如何创建）</p>          </div><p>这里还是拿来主义，<a href="https://stackoverflow.com/a/50786084">jaco0646</a>提供的demo如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AbstractFactory_MessageQueue factory;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Client</span><span class="hljs-params">(AbstractFactory_MessageQueue factory)</span> </span>&#123;<br>        <span class="hljs-comment">// The factory creates message queues either for Azure or MSMQ.</span><br>        <span class="hljs-comment">// The client does not know which technology is used.</span><br>        <br>        <span class="hljs-comment">// inject AbstractFactory to Client </span><br>        <span class="hljs-keyword">this</span>.factory = factory;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//The client doesn&#x27;t know whether the OutboundQueue is Azure or MSMQ.</span><br>        OutboundQueue out = factory.createProductA();<br>        out.sendMessage(<span class="hljs-string">&quot;Hello Abstract Factory!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">receiveMessage</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//The client doesn&#x27;t know whether the ReplyQueue is Azure or MSMQ.</span><br>        ReplyQueue in = factory.createProductB();<br>        <span class="hljs-keyword">return</span> in.receiveMessage();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AbstractFactory_MessageQueue</span> </span>&#123;<br>    <span class="hljs-function">OutboundQueue <span class="hljs-title">createProductA</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">ReplyQueue <span class="hljs-title">createProductB</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactory_Azure</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AbstractFactory_MessageQueue</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OutboundQueue <span class="hljs-title">createProductA</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AzureMessageQueue();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ReplyQueue <span class="hljs-title">createProductB</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AzureResponseMessageQueue();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactory_Msmq</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AbstractFactory_MessageQueue</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OutboundQueue <span class="hljs-title">createProductA</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MsmqMessageQueue();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ReplyQueue <span class="hljs-title">createProductB</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MsmqResponseMessageQueue();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中“AbstractFactory_MessageQueue”作为抽象工厂，定义了两个创建产品的方法“createProductA()”、“createProductB()”。具体的实现交给抽象工厂的“继承者”具体工厂。该模式单独很好理解，但是与无名氏版工厂方法模式放在一块，就非常迷惑了？不免提出几个问题：</p><ol><li>工厂方法模式到底哪一版才是对的？</li><li>无名氏版工厂方法模式算是一种设计模式吗？</li><li>经典工厂方法与抽象工厂的区别到底是什么？</li></ol><p>对于第一个问题，我暂时还没有找到答案，我目前比较认同第一种版本，即GOF版本，因为我认为无名氏版本实质与抽象工厂没有区别。</p><p>对于第二个问题，我貌似找到了一个答案：</p><div class="note note-info">            <p>an interface with only one method cannot be a Factory Method any more than it can be an Abstract Factory, what do we call a creational interface with only one method?</p><p><strong>Answer:</strong><br>If the method is static, it is commonly called a Static Factory. If the method is non-static, it is commonly called a Simple Factory. Neither of these is a GoF pattern, but in practice they are far more commonly used!</p>          </div><p>对于第三个问题，网上有了比较明确的回答，我这里仅作简单摘要，因为内容较长，单独成为一节。</p><h2 id="5-传统工厂方法与抽象工厂的区别"><a href="#5-传统工厂方法与抽象工厂的区别" class="headerlink" title="5. 传统工厂方法与抽象工厂的区别"></a>5. 传统工厂方法与抽象工厂的区别</h2><p>针对<a href="https://stackoverflow.com/a/50786084">jaco0646</a> demo中的代码，他提出以下内容：</p><p>对于抽象工厂，我们需要知道：</p><p>（1）抽象工厂最重要的一点是它会被注入“Client”代码，这也就是为什么我们说抽象工厂是由组合实现，例如demo中“AbstractFactory”被注入了“Client”的代码，这也就是抽象方法被称由组合实现的原因。</p><div class="note note-info">            <p>The most important point to grasp here is that the abstract factory is injected into the client. This is why we say that Abstract Factory is implemented by Composition. Often, a dependency injection framework would perform that task; but a framework is not required for DI.</p>          </div><p>（2）抽象工厂的实现类并不是所谓的工厂方法。</p><p>（3）抽象工厂中的家族产品是指各个产品间在逻辑上具备关联，而不是指代码实现中具备继承关系。</p><p>对于工厂方法模式，我们需要知道：</p><p>（1）在demo中，工厂方法模式中的“Client”是指“ConcreteCreator”，“Client”的父类定义了工厂方法，这就是我们称工厂方法是由继承实现的原因。</p><div class="note note-info">            <p>The most important point to grasp here is that the ConcreteCreator is the client. In other words, the client is a subclass whose parent defines the factoryMethod(). This is why we say that Factory Method is implemented by Inheritance.)</p>          </div><p>（2）工厂方法模式与模板方法模式并无太大区别，前者是创建型方法，后者是行为型方法。</p><p>（3）我认为这点是传统工厂方法模式与抽象工厂最大的区别。在demo代码中父类“Creator”消费了自己的工厂方法“factoryMethod()”，如果将代码中的“anOperation()”删除，那么就不再是一个传统的工厂方法。</p><div class="note note-info">            <p>And finally, the third point to note is that the Creator (parent) class invokes its own factoryMethod(). If we remove anOperation() from the parent class, leaving only a single method behind, it is no longer the Factory Method pattern. In other words, Factory Method cannot be implemented with less than two methods in the parent class; and one must invoke the other.</p>          </div><p>如果仔细阅读了上面的内容，相信大家已经知道了GOF版本的工厂方法与抽象工厂的区别。核心就是<strong>工厂方法模式主要通过继承来实现，会消费自己定义的工厂方法。而抽象工厂模式主要通过组合与代码注入来实现</strong>。</p><h2 id="6-各种工厂模式的适用场景"><a href="#6-各种工厂模式的适用场景" class="headerlink" title="6. 各种工厂模式的适用场景"></a>6. 各种工厂模式的适用场景</h2><ol><li>对于简单工厂，一般适用于产品类较少，各个产品构造简单时适用。</li><li>对于传统工厂方法模式，如果不知道子类是如何创建对象或者需要子类客制化创建过程，那么使用它</li><li>对于抽象工厂模式，一般用来创建一系列配套的产品共同使用</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><p><a href="https://refactoring.guru/design-patterns/factory-comparison">Factory Comparison</a></p></li><li><p><a href="https://www.cnblogs.com/zhan520g/p/10461094.html">&lt;工厂方法&gt;比&lt;简单工厂&gt;多了啥（区别）</a></p></li><li><p><a href="https://stackoverflow.com/a/38668246/12893742">Design Patterns: Abstract Factory vs Factory Method</a></p></li><li><p><a href="https://stackoverflow.com/questions/5739611/what-are-the-differences-between-abstract-factory-and-factory-design-patterns/50786084#50786084">What are the differences between Abstract Factory and Factory design patterns?</a></p></li><li><p><a href="https://stackoverflow.com/a/30465141/12893742">Factory Pattern. When to use factory methods?</a></p></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
      
      
      <category domain="https://eripe.me/tags/factory/">factory</category>
      
      
      <comments>https://eripe.me/articles/factory-pattern.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java日志库扫盲</title>
      <link>https://eripe.me/articles/log-system-for-Java-abstract.html</link>
      <guid>https://eripe.me/articles/log-system-for-Java-abstract.html</guid>
      <pubDate>Mon, 07 Jun 2021 08:57:55 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;1-基本概念&quot;&gt;&lt;a href=&quot;#1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;1. 基本概念&quot;&gt;&lt;/a&gt;1.</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><p>slf4j：simple logging facade for Java，可以看作用来管理各个日志库的调度器，我们只需要通过配置slf4j后端具体的使用的日志库就可以完成日志操作，对用户隐藏了后端真正使用的日志库<br>log4j：一个日志库<br>Logback：日志库</p><h2 id="2-如何结合slf4j使用log4j"><a href="#2-如何结合slf4j使用log4j" class="headerlink" title="2. 如何结合slf4j使用log4j"></a>2. 如何结合slf4j使用log4j</h2><p>其实结合slf4j使用log4j并不难，但是因为不了解各个库的作用，浪费了一些时间。</p><p>在最初，我以为只用引入log4j为slf4j提供的适配器即可使用，因为我在maven仓库中看到适配器有三个依赖库：<br><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/log-system-for-Java-abstract.log4j-slf4j-impl-dependencies.png" alt="log-system-for-Java-abstract.log4j-slf4j-impl-dependencies"></p><p>但是会爆错：</p><blockquote><p>log4j-slf4j java.lang.ClassNotFoundException: org.slf4j.LoggerFactory</p></blockquote><p>到官网仔细一看，发现正常引用log4j只需要引入<code>log4j-core</code>、<code>log4j-api</code>，如下所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/log-system-for-Java-abstract.log4j.png" alt="log-system-for-Java-abstract.log4j"></p><p>但是我想配合<code>slf4j</code>使用，所以继续往下寻找，发现了一句至关重要的话：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/log-system-for-Java-abstract.slf-bridge.png" alt="log-system-for-Java-abstract.slf-bridge"></p><p>不要移出任何原有的<code>slf4j</code>依赖，所以恍然大悟，不仅要在<code>pom.xml</code>文件中引入<code>log4j-api</code>、<code>log4j-core</code>，想要结合<code>slf4j</code>,需要同时引入log4j提供的适配器<code>log4j-slf4j-impl</code>。</p><p>所以完整的依赖如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt;</span><br><span class="hljs-comment">&lt;!-- slf4j library--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-slf4j18-impl --&gt;</span><br><span class="hljs-comment">&lt;!--log4j为slf4j提供的适配器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.14.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --&gt;</span><br><span class="hljs-comment">&lt;!--log4j library--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.14.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-api --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.14.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="3-可能存在的问题"><a href="#3-可能存在的问题" class="headerlink" title="3. 可能存在的问题"></a>3. 可能存在的问题</h2><p>从官方maven仓库中拷贝的<code>log4j-slf4j-impl</code>依赖时带有<code>&lt;scope&gt;test&lt;/scope&gt;</code>，我们需要将其改为<code>complie</code>或删除，才能使适配器生效。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://logging.apache.org/log4j/2.x/maven-artifacts.html">Maven,Ivy,Gradle,and SBT Artifacts</a></li><li><a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">Introduction to the Denpendency Mechanism</a></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/tools/">tools</category>
      
      
      <category domain="https://eripe.me/tags/logging/">logging</category>
      
      
      <comments>https://eripe.me/articles/log-system-for-Java-abstract.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>配置tomcat调试环境</title>
      <link>https://eripe.me/articles/how-to-debug-tomcat.html</link>
      <guid>https://eripe.me/articles/how-to-debug-tomcat.html</guid>
      <pubDate>Mon, 26 Apr 2021 02:50:30 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;重点是配置好&lt;code&gt;CATALINA_HOME&lt;/code&gt;，该目录用于存放tomcat的配置信息。&lt;/p&gt;
&lt;p&gt;我们要将源码作为一个module放入整个项目中，即整个项目的结构如下所示：</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>重点是配置好<code>CATALINA_HOME</code>，该目录用于存放tomcat的配置信息。</p><p>我们要将源码作为一个module放入整个项目中，即整个项目的结构如下所示：</p><ul><li>&lt;project path&gt;<ul><li>&lt;source code path&gt;<ul><li>(source code)pom.xml</li></ul></li><li><CATALINA_HOME></li><li>(project)pom.xml</li></ul></li></ul><p>所以我们不仅要为整个项目配置<code>pom.xml</code>，同时也要为源码配置<code>pom.xml</code>。</p><p>项目的配置文件如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>    <br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    </span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span>    <br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>gxf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>apache-tomcat-8<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>apache-tomcat-8-source<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>    <br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>apache-tomcat-8.5.23-src<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>源码module的配置文件如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>    <br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span>    </span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    </span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <br>    <br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Tomcat8.0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Tomcat8.0<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>Tomcat8.0<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">sourceDirectory</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">sourceDirectory</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">testSourceDirectory</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">testSourceDirectory</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>    <br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>    <br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>    <br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">testResources</span>&gt;</span>    <br>            <span class="hljs-tag">&lt;<span class="hljs-name">testResource</span>&gt;</span>    <br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>    <br>            <span class="hljs-tag">&lt;/<span class="hljs-name">testResource</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">testResources</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>    <br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>    <br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <br>    <br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <br>                    <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span>    <br>                    <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span>    <br>                    <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span>    <br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>    <br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>    <br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.easymock<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>easymock<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ant<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ant<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>wsdl4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>wsdl4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.xml<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxrpc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.eclipse.jdt.core.compiler<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ecj<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>最后配置 VM options：</p><blockquote><p>-Dcatalina.home=catalina-home -Dcatalina.base=catalina-home<br>-Djava.endorsed.dirs=catalina-home/endorsed<br>-Djava.io.tmpdir=catalina-home/temp<br>-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager<br>-Djava.util.logging.config.file=catalina-home/conf/logging.properties</p></blockquote><p>处理乱码问题：</p><p>暴力解决，直接将所在区域设置为US，即：</p><blockquote><p>-DUser.region=US</p></blockquote><p>所以最后的虚拟机配置如下所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/how-to-debug-tomcat.tomcat-vm-options.png" alt="vm-options"><br>处理JSP解析问题：</p><p>在<code>org.apache.catalina.startup.ContextConfig.configStart</code>手动初始化jsp，添加如下代码：</p><blockquote><p>context.addServletContainerInitializer(new JasperInitializer(),null)</p></blockquote><p>添加位置如下所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/how-to-debug-tomcat.tomcat-jsp-position.png" alt="position"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://gongxufan.github.io/2017/10/20/tomcat-source-debug/">基于IntelliJ IDEA环境】Tomcat8源码的调试和项目部署</a></p></li><li><p><a href="https://www.cnblogs.com/davidwang456/p/11224923.html">编译Tomcat9源码及tomcat乱码问题解决</a></p></li><li><p><a href="https://github.com/gqzdev/tomcat-start">🐈🐈🐈Tomcat源码分析、理解Tomcat的架构及如何优化</a></p></li><li><p><a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">Java IntelLiJ IDEA中Tomcat控制台乱码解决方法</a></p></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/framework/">framework</category>
      
      
      <category domain="https://eripe.me/tags/tomcat/">tomcat</category>
      
      
      <comments>https://eripe.me/articles/how-to-debug-tomcat.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LongAdder源码解析</title>
      <link>https://eripe.me/articles/LongAdder-analysis.html</link>
      <guid>https://eripe.me/articles/LongAdder-analysis.html</guid>
      <pubDate>Wed, 14 Apr 2021 01:53:33 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;1-预备知识&quot;&gt;&lt;a href=&quot;#1-预备知识&quot; class=&quot;headerlink&quot; title=&quot;1. 预备知识&quot;&gt;&lt;/a&gt;1.</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1-预备知识"><a href="#1-预备知识" class="headerlink" title="1. 预备知识"></a>1. 预备知识</h2><p>在Java1.5中，JUC就已经提供了大数原子类<code>AtomicLong</code>，但是在Java1.8中，又提供了相同功能的大数原子类<code>LongAdder</code>。why？答案是如此的纯粹：为了效率。难道前者的效率就不行了吗？如果在轻微冲突的情况下，二者的效率几乎差不多。但是如果竞争非常激烈，那么因为每次对<code>AtomicLong</code>更新时都会使用CAS，激烈竞争导致CAS的成功的概率不大，所以有可能会执行多次无效的CAS操作。那么后者<code>LongAdder</code>在更新时采用了分段计数的方法，它在每次更新时不再直接更新具体的数，而是在内部维护了一个基数<code>base</code>和增量数组<code>cells</code>。在竞争激烈的情况下，每个线程会只会在增量数组中更新自己得到增量。那么如果想要获得最后的结果，只需要将<code>base</code>与<code>sum(cells[i])</code>相加即可。</p><p>那么分段计数的方法就如此完美吗？没有任何缺点吗？在该类的注释中说到：</p><blockquote><p>This class is usually preferable to AtomicLong when multiple threads update a common sum that is used for purposes such as collecting statistics, not for fine-grained synchronization control.</p></blockquote><p>大意是说该类一般<strong>用于收集一些统计数据</strong>，而不应该用于线程同步，因为增量数组中的值是瞬息万变的，那么是有可能直接略过了我们的目标值，比如我们的目标值是1，但是有可能直接从1增加到3。</p><h2 id="2-体系结构"><a href="#2-体系结构" class="headerlink" title="2. 体系结构"></a>2. 体系结构</h2><p><code>LongAdder</code>中采用的分段计数逻辑其实是由<code>Stripe64</code>类完成的，<code>LongAdder</code>的继承结构如下所示：</p><p><img src="./images/Stripe64.png" alt="Stripe64"></p><p>实现分段计数的属性增量数组<code>cells</code>与基数<code>base</code>均由<code>Stripe64</code>类维护。</p><p>对于增量数组中的一个元素<code>CounterCell</code>，它代表的是一个线程更新的增量。所以类似于hashmap，<code>Stripe64</code>使用<code>ThreadLocalRandom</code>为每个线程维护了一个随机数当作线程的哈希值，熟悉hashmap的同学都知道，hashmap的table长度必须是2的整数幂。类似的，<code>Stripe64</code>也规定了增量数组<code>cells</code>的长度也必须是2的整数幂。但是长度是有限的，如果达到了最大核心数，那么<code>cells</code>不会再扩容。</p><p>自旋锁<code>cellsBusy</code>则是用来控制数组的初始化及扩容操作。下面罗列了<code>Stripe64</code>的重要字段：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Striped64</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span> </span>&#123;<br>    <span class="hljs-meta">@sun</span>.misc.Contended <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cell</span> </span>&#123;<br>        <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> value;<br>        Cell(<span class="hljs-keyword">long</span> x) &#123; value = x; &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">cas</span><span class="hljs-params">(<span class="hljs-keyword">long</span> cmp, <span class="hljs-keyword">long</span> val)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapLong(<span class="hljs-keyword">this</span>, valueOffset, cmp, val);<br>        &#125;<br><br>        <span class="hljs-comment">// Unsafe mechanics</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> sun.misc.Unsafe UNSAFE;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> valueOffset;<br>        <span class="hljs-keyword">static</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                UNSAFE = sun.misc.Unsafe.getUnsafe();<br>                Class&lt;?&gt; ak = Cell.class;<br>                valueOffset = UNSAFE.objectFieldOffset<br>                    (ak.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(e);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//有效的CPU核心数，也就是增量数组cells的容量上限</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Table of cells. When non-null, size is a power of 2.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//增量数组cells，容量必须为2的倍数，因为跟HashMap类似，需要依靠hash值计算对应的索引</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<br><br>    <span class="hljs-comment">//基数</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> base;<br><br>    <br>    <span class="hljs-comment">//自旋锁，用于互斥访问增量数组cells</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> cellsBusy;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-计算逻辑"><a href="#3-计算逻辑" class="headerlink" title="3. 计算逻辑"></a>3. 计算逻辑</h2><p>整个<code>longAccumulate()</code>的逻辑可以划分为三个case（详情见注释）：</p><ol><li>case1：如果<code>CounterCell</code>数组已经初始化好了，那么直接尝试在当前线程对应槽位更新<code>CounterCell</code>对象</li><li>case2：<code>CounterCell</code>数组没有初始化，也没有加锁，那么会构建一个长度为2的<code>CounterCell</code>数组，因为至少存在两个同时更新的线程才会发生冲突</li><li>case3：<code>CounterCell</code>正在进行初始化或扩容，那么则直接尝试更新<code>baseCount</code></li></ol><p>其中我认为<code>case1</code>的情况稍微复杂点，我这里展示一下它的流程图：</p><p><img src="./images/longAccumulate.drawio.svg" alt="longAccumulate"></p><p>流程图可能有疏漏，后续再精进吧。下面的代码中添加了详细的注释：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">这个函数作用就是在当前线程对应的槽位更新cell对象，但是并不负责计算map最后的大小</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">有很多场景能用到这个函数，包括：</span><br><span class="hljs-comment">1. CounterCell数组未初始化</span><br><span class="hljs-comment">2. 对应槽位的CounterCell未初始化</span><br><span class="hljs-comment">3. CounterCell初始化，但是修改value时CAS失败</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">其中属性cellBusy是专门为该函数准备的自旋锁，在扩容或者构造新cell时使用</span><br><span class="hljs-comment">wasCounttended表示进入这个函数原因是是否未更新对应CounterCell对象失败，true为不是因为失败</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> x the value</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> fn the update function, or null for add (this convention</span><br><span class="hljs-comment"> * avoids the need for an extra field or function in LongAdder).</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> wasUncontended false if CAS failed before call</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">longAccumulate</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, LongBinaryOperator fn,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">boolean</span> wasUncontended)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-comment">//如果当前线程的hash值还为准备好，那么强制初始化</span><br>    <span class="hljs-keyword">if</span> ((h = getProbe()) == <span class="hljs-number">0</span>) &#123;<br>        ThreadLocalRandom.current(); <span class="hljs-comment">// force initialization</span><br>        h = getProbe();<br>        wasUncontended = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">boolean</span> collide = <span class="hljs-keyword">false</span>;                <span class="hljs-comment">// True if last slot nonempty</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Cell[] as; Cell a; <span class="hljs-keyword">int</span> n; <span class="hljs-keyword">long</span> v;<br>        <span class="hljs-comment">//case1:如果CounterCell数组已经初始化好了</span><br>        <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//对应槽位的CounterCell对象没有初始化，或者正在扩容，那么尝试构造新的Cell</span><br>            <span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-keyword">null</span>) &#123;<br>                 <span class="hljs-comment">//如果当前没有线程持有自旋锁</span><br>                <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span>) &#123;       <span class="hljs-comment">// Try to attach new Cell</span><br>                    <span class="hljs-comment">//先构造好一个cell对象</span><br>                    Cell r = <span class="hljs-keyword">new</span> Cell(x);   <span class="hljs-comment">// Optimistically create</span><br>                     <span class="hljs-comment">//尝试获取自旋锁cellsBusy</span><br>                    <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;<br>                        <span class="hljs-keyword">boolean</span> created = <span class="hljs-keyword">false</span>;<br>                        <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">// Recheck under lock</span><br>                            Cell[] rs; <span class="hljs-keyword">int</span> m, j;<br>                            <span class="hljs-comment">//再次检查cell数组是否为空</span><br>                            <span class="hljs-keyword">if</span> ((rs = cells) != <span class="hljs-keyword">null</span> &amp;&amp;<br>                                (m = rs.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                                rs[j = (m - <span class="hljs-number">1</span>) &amp; h] == <span class="hljs-keyword">null</span>) &#123;<br>                                 <span class="hljs-comment">//在cell数组的对应槽位上赋值我们先构造好的cell对象</span><br>                                rs[j] = r;<br>                                <span class="hljs-comment">//cell对象创建成功，那么可以退出循环了，设置标志位create</span><br>                                created = <span class="hljs-keyword">true</span>;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            <span class="hljs-comment">//释放自旋锁</span><br>                            cellsBusy = <span class="hljs-number">0</span>;<br>                        &#125;<br>                        <span class="hljs-comment">//如果创建cell对象成功，那么则退出循环</span><br>                        <span class="hljs-keyword">if</span> (created)<br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">continue</span>;           <span class="hljs-comment">// Slot is now non-empty</span><br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">//设置扩容标志</span><br>                collide = <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-comment">//走到这说明对应槽位的cell对象已经构造好了</span><br>            <span class="hljs-comment">//那么就判断进入这个函数的原因是不是因为更新对应cell的时候发生冲突</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wasUncontended)       <span class="hljs-comment">// CAS already known to fail</span><br>                <span class="hljs-comment">//如果是因为更新时cas发生冲突，那么就尝试进行一次rehash更新线程的hash值，并且只会更新一次</span><br>                wasUncontended = <span class="hljs-keyword">true</span>;      <span class="hljs-comment">// Continue after rehash</span><br>            <br>            <span class="hljs-comment">//在rehash之后再次尝试使用cas进行更新</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.cas(v = a.value, ((fn == <span class="hljs-keyword">null</span>) ? v + x :<br>                                            fn.applyAsLong(v, x))))<br>                <span class="hljs-keyword">break</span>;<br>             <span class="hljs-comment">//如果cell数组扩容了，或者大小已经超过了核心处理器数量，那么对于当前线程来说不会再扩容了</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt;= NCPU || cells != as)<br>                collide = <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// At max size or stale</span><br>            <span class="hljs-comment">//设置扩容标志，设为false只会走下面的else-if，不可能到达后面的扩容逻辑</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide)<br>                collide = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-comment">//尝试加锁扩容</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//再次判断cell数组没有被初始化</span><br>                    <span class="hljs-keyword">if</span> (cells == as) &#123;      <span class="hljs-comment">// Expand table unless stale</span><br>                        <br>                        Cell[] rs = <span class="hljs-keyword">new</span> Cell[n &lt;&lt; <span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>                            rs[i] = as[i];<br>                        cells = rs;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    cellsBusy = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-comment">//设置扩容标志</span><br>                collide = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">continue</span>;                   <span class="hljs-comment">// Retry with expanded table</span><br>            &#125;<br>            <span class="hljs-comment">//重新计算当先线程的hash值</span><br>            h = advanceProbe(h);<br>        &#125;<br>        <span class="hljs-comment">//case2:CounterCell数组没有被加锁，并且没有初始化</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;<br>            <span class="hljs-keyword">boolean</span> init = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//那么则尝试进行初始化</span><br>                <span class="hljs-keyword">if</span> (cells == as) &#123;<br>                    <span class="hljs-comment">//构造一个长度为2的cell数组，因为至少有两个线程竞争更改容量，才会进入这个函数</span><br>                    Cell[] rs = <span class="hljs-keyword">new</span> Cell[<span class="hljs-number">2</span>];<br>                    <span class="hljs-comment">//在当前线程的槽位上构造cell对象</span><br>                    rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Cell(x);<br>                    cells = rs;<br>                    init = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">//释放自旋锁</span><br>                cellsBusy = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-comment">//如果成功初始化，说明cell对象也构造好了，那么则退出循环</span><br>            <span class="hljs-keyword">if</span> (init)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//case3:CounterCell数组正在初始化，因为获取自旋锁CELLBUSY失败，则尝试直接在原来的baseCount上累加</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casBase(v = base, ((fn == <span class="hljs-keyword">null</span>) ? v + x :<br>                                    fn.applyAsLong(v, x))))<br>            <span class="hljs-keyword">break</span>;                          <span class="hljs-comment">// Fall back on using base</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p><code>LongAdder</code>出现的原因是因为原来的<code>AtomicLong</code>在竞争激烈的情况下效率很低，所以<code>LongAdder</code>则是将热点数据分散，每个线程只负责自己的部分。<code>ConcurrentHashMap</code>计算容量时就采用了这种方法。</p><p>而<code>LongAccumulator</code>则实现了重载符号的逻辑。<code>LongAdder</code>只能实现加法，而<code>LongAccumulator</code>允许我们自定义符号功能，类似于cpp中的符号重载。</p><p>类似的，<code>DoubleAdder</code>和<code>DoubleAccumulator</code>实现了<code>Double</code>类型的大数原子类，与<code>long</code>类型的实现逻辑几乎没有任务区别。</p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="https://eripe.me/tags/atomic/">atomic</category>
      
      
      <comments>https://eripe.me/articles/LongAdder-analysis.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>AtomicStampedReference源码解析</title>
      <link>https://eripe.me/articles/AtomicStampedReference-analysis.html</link>
      <guid>https://eripe.me/articles/AtomicStampedReference-analysis.html</guid>
      <pubDate>Tue, 13 Apr 2021 03:42:05 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;&lt;code&gt;AtomicStampeddReference&lt;/code&gt;解决了普通CAS操作的ABA问题，当然该类只能存储引用类型，因为泛型只支持引用。具体的解决方法就是为每个引用提供了一个时间</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p><code>AtomicStampeddReference</code>解决了普通CAS操作的ABA问题，当然该类只能存储引用类型，因为泛型只支持引用。具体的解决方法就是为每个引用提供了一个时间戳（实际用int代替），这两个数据由内部静态类<code>Pair</code>封装，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicStampedReference</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">final</span> T reference;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> stamp;<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T reference, <span class="hljs-keyword">int</span> stamp)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.reference = reference;<br>            <span class="hljs-keyword">this</span>.stamp = stamp;<br>        &#125;<br><br>        <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Pair&lt;T&gt; <span class="hljs-title">of</span><span class="hljs-params">(T reference, <span class="hljs-keyword">int</span> stamp)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pair&lt;T&gt;(reference, stamp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Pair&lt;V&gt; pair;<br></code></pre></div></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><code>AtomicStampedReference</code>的构造函数只有一个，该构造方法要求我们必须提供一个初始时间戳，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AtomicStampedReference</span><span class="hljs-params">(V initialRef, <span class="hljs-keyword">int</span> initialStamp)</span> </span>&#123;<br>    pair = Pair.of(initialRef, initialStamp);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h2><p>对于<code>AtomicStampedReference</code>的更新，提供了两种方式<code>compareAndSet</code>和<code>weakCompareAndSet</code>。对于后者来说，它有可能会“虚假”的失败，也就是说，实际上更新成功但是却返回false，并且后者并不提供“happens before”效果，更难使用，尽管后者在某些平台上效率更高。所以一般还是使用<code>compareAndSet</code>吧。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Atomically sets the value of both the reference and stamp</span><br><span class="hljs-comment">* to the given update values if the</span><br><span class="hljs-comment">* current reference is &#123;<span class="hljs-doctag">@code</span> ==&#125; to the expected reference</span><br><span class="hljs-comment">* and the current stamp is equal to the expected stamp.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(V   expectedReference,</span></span><br><span class="hljs-params"><span class="hljs-function">                                V   newReference,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-keyword">int</span> expectedStamp,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-keyword">int</span> newStamp)</span> </span>&#123;<br>    Pair&lt;V&gt; current = pair;<br>    <span class="hljs-keyword">return</span><br>        expectedReference == current.reference &amp;&amp;<br>        expectedStamp == current.stamp &amp;&amp;<br>        ((newReference == current.reference &amp;&amp;<br>            newStamp == current.stamp) ||<br>            casPair(current, Pair.of(newReference, newStamp)));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Atomically sets the value of both the reference and stamp</span><br><span class="hljs-comment">* to the given update values if the</span><br><span class="hljs-comment">* current reference is &#123;<span class="hljs-doctag">@code</span> ==&#125; to the expected reference</span><br><span class="hljs-comment">* and the current stamp is equal to the expected stamp.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* &lt;p&gt;&lt;a href=&quot;package-summary.html#weakCompareAndSet&quot;&gt;May fail</span><br><span class="hljs-comment">* spuriously and does not provide ordering guarantees&lt;/a&gt;, so is</span><br><span class="hljs-comment">* only rarely an appropriate alternative to &#123;<span class="hljs-doctag">@code</span> compareAndSet&#125;.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">weakCompareAndSet</span><span class="hljs-params">(V   expectedReference,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    V   newReference,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">int</span> expectedStamp,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">int</span> newStamp)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> compareAndSet(expectedReference, newReference,<br>                            expectedStamp, newStamp);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当然，每次更新时都需要提供旧时间戳，如果旧的不符合说明产生了ABA。</p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="https://eripe.me/tags/atomic/">atomic</category>
      
      
      <comments>https://eripe.me/articles/AtomicStampedReference-analysis.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>AtomicIntegerArray源码解析</title>
      <link>https://eripe.me/articles/AtomicIntegerArray-analysis.html</link>
      <guid>https://eripe.me/articles/AtomicIntegerArray-analysis.html</guid>
      <pubDate>Tue, 13 Apr 2021 02:56:46 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;&lt;code&gt;AtomicIntegerArray&lt;/code&gt;能够保证数组中的每个元素原子地更新。构造方法、增加、减少方法都没什么好说，我认为值得关注的点是仅有计算偏移的方法。我们先来看看它的静</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p><code>AtomicIntegerArray</code>能够保证数组中的每个元素原子地更新。构造方法、增加、减少方法都没什么好说，我认为值得关注的点是仅有计算偏移的方法。我们先来看看它的静态构造块：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicIntegerArray</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">2862133569453604235L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> base = unsafe.arrayBaseOffset(<span class="hljs-keyword">int</span>[].class);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> shift;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] array;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">//scale表示数组中每个元素的字节数，必须都是2的倍数</span><br>        <span class="hljs-keyword">int</span> scale = unsafe.arrayIndexScale(<span class="hljs-keyword">int</span>[].class);<br>        <span class="hljs-keyword">if</span> ((scale &amp; (scale - <span class="hljs-number">1</span>)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;data type scale not a power of two&quot;</span>);<br>        <span class="hljs-comment">//shift表示偏移量</span><br>        shift = <span class="hljs-number">31</span> - Integer.numberOfLeadingZeros(scale);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> <span class="hljs-title">checkedByteOffset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= array.length)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">&quot;index &quot;</span> + i);<br><br>        <span class="hljs-keyword">return</span> byteOffset(i);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">byteOffset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">long</span>) i &lt;&lt; shift) + base;<br>    &#125;<br>    ...<br></code></pre></div></td></tr></table></figure><p>首先静态构造块会计算当前数组元素类型的大小<code>scale</code>字段，要求类型只能是4的倍数，当然我们一般也只会用这个类存储int数组。接着会初始化单位偏移长度<code>shift</code>。那么对于每个元素在数组中的偏移就等于“元素个数 X 单位偏移长度”。比如我们的元素类型是int类型，那么单位偏移长度<code>shft</code>就为2。那么对应于索引为1的元素地址，就是<code>base + offset==1&lt;&lt;(shift==2)</code>。索引为i的元素地址同理。</p><p>那么我们如果想要更新数组中的某个元素，那么会调用<code>getAndSet()</code>，而该方法中又首先会调用<code>checkedByteOffset()</code>计算对应的偏移，最后使用<code>Unsafe</code>类的CAS操作完成更新。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> newValue)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndSetInt(array, checkedByteOffset(i), newValue);<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="https://eripe.me/tags/atomic/">atomic</category>
      
      
      <comments>https://eripe.me/articles/AtomicIntegerArray-analysis.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>AtomicInteger源码解析</title>
      <link>https://eripe.me/articles/AtomicInteger-analysis.html</link>
      <guid>https://eripe.me/articles/AtomicInteger-analysis.html</guid>
      <pubDate>Mon, 12 Apr 2021 03:46:51 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;整数型原子类&lt;code&gt;AtomicInteger&lt;/code&gt;，能够保证每次更新时都是原子操作。其中的CAS操作都需要依靠&lt;code&gt;Unsafe&lt;/code&gt;类来完成，我们需要关注的一般就是</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>整数型原子类<code>AtomicInteger</code>，能够保证每次更新时都是原子操作。其中的CAS操作都需要依靠<code>Unsafe</code>类来完成，我们需要关注的一般就是构造方法、增加方法与删除方法。</p><h2 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1. 构造方法"></a>1. 构造方法</h2><p><code>AtomicInteger</code>首先会调用类构造器，初始化当前对象的<code>valueoffset</code>用于进行CAS操作，具体值由volatile变量<code>value</code>负责维护，字段定义如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicInteger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">6214790243416807050L</span>;<br><br>    <span class="hljs-comment">// setup to use Unsafe.compareAndSwapInt for updates</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> valueOffset;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            valueOffset = unsafe.objectFieldOffset<br>                (AtomicInteger.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(ex); &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AtomicInteger</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialValue)</span> </span>&#123;<br>        value = initialValue;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a new AtomicInteger with initial value &#123;<span class="hljs-doctag">@code</span> 0&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AtomicInteger</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    ...<br></code></pre></div></td></tr></table></figure><h2 id="2-增加方法"><a href="#2-增加方法" class="headerlink" title="2. 增加方法"></a>2. 增加方法</h2><p>增加方法与删除方法的逻辑基本一致，就是通过<code>Unsafe</code>类来完成，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Atomically increments by one the current value.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> the previous value</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndIncrement</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-keyword">this</span>, valueOffset, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">decrementAndGet</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-keyword">this</span>, valueOffset, -<span class="hljs-number">1</span>) - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>原子类<code>AtomicBoolean</code>、<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicReference</code>其实没有本质区别，所以我这里仅简单介绍了一下<code>AtomicInteger</code>，所有的工作都会通过<code>Unsafe</code>类来完成。</p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="https://eripe.me/tags/atomic/">atomic</category>
      
      
      <comments>https://eripe.me/articles/AtomicInteger-analysis.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>原子类总览</title>
      <link>https://eripe.me/articles/atomic-class-overview.html</link>
      <guid>https://eripe.me/articles/atomic-class-overview.html</guid>
      <pubDate>Sun, 11 Apr 2021 12:37:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;J.U.C包提供了许多原子类，我按照功能分了四类，如下所示：&lt;br&gt;|  普通原子类   | 原子更新的数组  | 原子更新对象字段的updater  | 大数原子类  |&lt;br&gt;|  —- </description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>J.U.C包提供了许多原子类，我按照功能分了四类，如下所示：<br>|  普通原子类   | 原子更新的数组  | 原子更新对象字段的updater  | 大数原子类  |<br>|  —-  | —-  | —-  | —-  |<br>| AtomicBoolean AtomicInteger <br> AtomicLong AtomicReference atomicMarkableReference AtomicStampedReference | AtomicIntegerArray AtomicLongArray AtomicReferenceArray |  AtomicIntegerFiledUpdater AtomicLongFiledUpdater AtomicReferenceUpdater| LongAccumulator DoubleAccumulator LongAdder DoubleAdder |</p><p><strong>普通原子类</strong>下的六种，</p><h2 id="2-核心类Unsafe"><a href="#2-核心类Unsafe" class="headerlink" title="2. 核心类Unsafe"></a>2. 核心类Unsafe</h2><p>不管是原子类还是AQS锁以及其他的CAS操作，全都是依靠<code>sun.misc</code>包下的<code>Unsafe</code>类完成。之所以叫<code>Unsafe</code>，是因为该类的方法都是native方法，能够直接以类似于指针的方式操作对象中的数组，这样就破坏了Java程序所恪守的不使用指针，并且如果操作不当，可能会造成未知后果。所以只有通过启动类加载器加载的类才能使用该类。当然，我们可以通过反射破坏这一规则。</p><p><code>Unsafe</code>类采用的是饿汉单例模式，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Unsafe</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe theUnsafe;<br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Unsafe</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        registerNatives();<br>        Reflection.registerMethodsToFilter(Unsafe.class, <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;getUnsafe&quot;</span>&#125;);<br>        theUnsafe = <span class="hljs-keyword">new</span> Unsafe();<br>        ...<br>    &#125;<br>    <span class="hljs-meta">@CallerSensitive</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">getUnsafe</span><span class="hljs-params">()</span> </span>&#123;<br>        Class var0 = Reflection.getCallerClass();<br>        <span class="hljs-comment">//判断调用者的类加载器是否为null，因为null表示启动类加载器</span><br>        <span class="hljs-keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SecurityException(<span class="hljs-string">&quot;Unsafe&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> theUnsafe;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们可以使用<code>getUnsafe()</code>获取单例，当然使用这种方法的前提是该方法的调用者必须通过启动类加载器来加载。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>原子类非常多，但是大部分都只是数据类型不同，所以我仅分析了每个类别下的代表类：</p><ol><li>普通原子类：<ul><li><a href="./AtomicInteger-analysis.md">AtomicInteger</a></li><li><a href="./AtomicStampedReference-analysis.md">AtomicStampedReference</a></li></ul></li><li>原子数组：<ul><li><a href="./AtomicIntegerArray-analysis.md">AtomicIntegerArray</a></li></ul></li><li>原子更新对象的updater：<ul><li>AtomicIntegerFiledUpdater</li></ul></li><li>大数原子类<ul><li><a href="./LongAccumulator-analysis.md">LongAccumulator</a></li></ul></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="https://eripe.me/tags/atomic-class/">atomic class</category>
      
      
      <comments>https://eripe.me/articles/atomic-class-overview.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CopyOnWrite容器分析</title>
      <link>https://eripe.me/articles/CopyOnWrite-collections-analysis.html</link>
      <guid>https://eripe.me/articles/CopyOnWrite-collections-analysis.html</guid>
      <pubDate>Sat, 10 Apr 2021 13:39:01 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;1-预备知识&quot;&gt;&lt;a href=&quot;#1-预备知识&quot; class=&quot;headerlink&quot; title=&quot;1. 预备知识&quot;&gt;&lt;/a&gt;1.</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1-预备知识"><a href="#1-预备知识" class="headerlink" title="1. 预备知识"></a>1. 预备知识</h2><p><code>J.U.C</code>包提供了两种copy-on-wirte容器：<code>CopyOnWriteList</code>与<code>CopyOnWriteSet</code>。不了解copy-on-write技术的，可以去看<a href="http://wsfdl.com/algorithm/2016/09/29/Copy_on_write.html">理解 Copy On Write 技术</a>。</p><p><code>CopyOnWriteList</code>是<code>ArrayList</code>线程安全的版本。所有更改<code>CopyOnWriteList</code>内容的操作都基于copy-on-write，对于同一个元素，插入操作happens before读取操作。而<code>CopyOnWriteSet</code>与我们常见的set不同，它内部不是通过计算hash值找到对应的元素，而是内部维护了一个<code>CopyOnWriteList</code>。</p><p>本篇文章将分别解析<code>CopyOnWriteList</code>和<code>CopyOnWriteSet</code>。</p><h2 id="2-CopyOnWriteList解析"><a href="#2-CopyOnWriteList解析" class="headerlink" title="2. CopyOnWriteList解析"></a>2. CopyOnWriteList解析</h2><p>了解一个类，第一步应该是学习它的继承体系。<code>CopyOnWriteList</code>的继承体系比较简单，实现了<code>utils</code>包下的<code>List</code>接口，并支持随机访问、序列化、克隆等功能，继承关系如下所示：</p><p><img src="./images/CopyOnWriteList-arch.png" alt="CopyOnWriteList-arch"></p><p><code>CopyOnWriteList</code>本身的属性也比较简单，如下所示：</p><p><img src="./images/CopyOnWriteList-fields.png" alt="CopyOnWriteList-fields"></p><p>一般我们关注是独占锁与内部数组。内部数组是真正存储元素的地方，而独占锁保证了各线程互斥地访问。</p><h3 id="2-1-添加操作"><a href="#2-1-添加操作" class="headerlink" title="2.1 添加操作"></a>2.1 添加操作</h3><p><code>CopyOnWriteList</code>的增加逻辑主要由<code>add</code>方法完成，对于每次添加，都会上锁，否则会造成多个线程同时添加时复制出多份原数组。我这里就不细说了，下面的代码一看就懂：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Appends the specified element to the end of this list.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> e element to be appended to this list</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; (as specified by &#123;<span class="hljs-doctag">@link</span> Collection#add&#125;)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object[] elements = getArray();<br>        <span class="hljs-keyword">int</span> len = elements.length;<br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        newElements[len] = e;<br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-2-删除操作"><a href="#2-2-删除操作" class="headerlink" title="2.2 删除操作"></a>2.2 删除操作</h3><p>对于删除逻辑，其实和添加逻辑差不多。第一步先上锁，然后删除目标元素，最后再将剩余元素拷贝到新数组中，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Removes the element at the specified position in this list.</span><br><span class="hljs-comment">* Shifts any subsequent elements to the left (subtracts one from their</span><br><span class="hljs-comment">* indices).  Returns the element that was removed from the list.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object[] elements = getArray();<br>        <span class="hljs-keyword">int</span> len = elements.length;<br>        E oldValue = get(elements, index);<br>        <span class="hljs-keyword">int</span> numMoved = len - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//拷贝数组</span><br>        <span class="hljs-keyword">if</span> (numMoved == <span class="hljs-number">0</span>)<br>            setArray(Arrays.copyOf(elements, len - <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">else</span> &#123;<br>            Object[] newElements = <span class="hljs-keyword">new</span> Object[len - <span class="hljs-number">1</span>];<br>            System.arraycopy(elements, <span class="hljs-number">0</span>, newElements, <span class="hljs-number">0</span>, index);<br>            System.arraycopy(elements, index + <span class="hljs-number">1</span>, newElements, index,<br>                                numMoved);<br>            setArray(newElements);<br>        &#125;<br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-3-查询操作"><a href="#2-3-查询操作" class="headerlink" title="2.3 查询操作"></a>2.3 查询操作</h3><p>查询可以通过两种方法：</p><ol><li><code>get(int)</code>方法</li><li>迭代器</li></ol><p>第一种方法没什么好说的，不用上锁，直接读取即可，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> get(getArray(), index);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">get</span><span class="hljs-params">(Object[] a, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (E) a[index];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>迭代器遍历的方式还稍微有趣一点，<code>CopyOnWriteList</code>的迭代器会对当前内部数组做一个快照，所谓的快照并不是指真正的复制一份，而是持有一个旧数组的引用，在逻辑上做了一个“snapshot”，所以不会抛出<code>ConcurrentModificationException</code>，<strong>但是仍然不支持在迭代器修改</strong>。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">COWIterator</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">ListIterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/** Snapshot of the array */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] snapshot;<br>    <span class="hljs-comment">//游标</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cursor;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">COWIterator</span><span class="hljs-params">(Object[] elements, <span class="hljs-keyword">int</span> initialCursor)</span> </span>&#123;<br>        cursor = initialCursor;<br>        <span class="hljs-comment">//持有旧数组的引用，迭代器只会遍历旧数组的元素</span><br>        snapshot = elements;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-CopyOnWriteSet解析"><a href="#3-CopyOnWriteSet解析" class="headerlink" title="3. CopyOnWriteSet解析"></a>3. CopyOnWriteSet解析</h2><p><code>CopyOnWriteSet</code>通过内部维护的<code>CopyOnWriteList</code>实现了copy-on-write，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CopyOnWriteArraySet</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSet</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">5457747651344034263L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates an empty set.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CopyOnWriteArraySet</span><span class="hljs-params">()</span> </span>&#123;<br>        al = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么<code>CopyOnWriteSet</code>的插入、查询、操作完全依赖<code>CopyOnWriteList</code>。根本没有用到哈希的概念，所以这里就不再赘述了。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>CopyOnWriteArrayList的思想和实现整体上还是比较简单，它适用于处理“读多写少”的并发场景。通过上述对CopyOnWriteArrayList的分析，读者也应该可以发现该类存在的一些问题：</p><ol><li><p>内存的使用<br>由于CopyOnWriteArrayList使用了“写时复制”，所以在进行写操作的时候，内存里会同时存在两个array数组，如果数组内存占用的太大，那么可能会造成频繁GC,所以CopyOnWriteArrayList并不适合大数据量的场景。</p></li><li><p>数据一致性<br>CopyOnWriteArrayList只能保证数据的最终一致性，不能保证数据的实时一致性——读操作读到的数据只是一份快照。所以如果希望写入的数据可以立刻被读到，那CopyOnWriteArrayList并不适合。</p></li></ol><p>而CopyOnWriteSet因为内部维护了CopyOnWriteList，所以二者的优缺点差不多。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://coolshell.cn/articles/11175.html#%E4%BB%80%E4%B9%88%E6%98%AFCopyOnWrite%E5%AE%B9%E5%99%A8">JAVA中的COPYONWRITE容器</a></li><li><a href="https://segmentfault.com/a/1190000016214572">Java多线程进阶（二七）——J.U.C之collections框架：CopyOnWriteArrayList</a></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="https://eripe.me/tags/concurrent-collections/">concurrent collections</category>
      
      
      <comments>https://eripe.me/articles/CopyOnWrite-collections-analysis.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>BlockingQueue接口分析</title>
      <link>https://eripe.me/articles/interface-BlockingQueue-analysis.html</link>
      <guid>https://eripe.me/articles/interface-BlockingQueue-analysis.html</guid>
      <pubDate>Sat, 10 Apr 2021 07:54:12 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;1-基本概念&quot;&gt;&lt;a href=&quot;#1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;1. 基本概念&quot;&gt;&lt;/a&gt;1.</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><p><code>BlockingQueue</code>接口，提供了一组集合，一般用在生产者消费者模式中。它能搞保证在多线程环境下：当队列为空时，消费者线程会等待直到队列不空；当队列满时，生产者会等待直到队列不满。该接口提供了四种存储与删除模式：</p><table><thead><tr><th>/</th><th>操作失败抛出异常</th><th>操作失败返回特殊值</th><th>操作失败阻塞线程</th><th>操作具有时间限制</th></tr></thead><tbody><tr><td>插入操作</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>删除操作</td><td>remove()</td><td>poll(e)</td><td>take(e)</td><td>poll(time,unit)</td></tr><tr><td>查询操作</td><td>element()</td><td>peek(e)</td><td>/</td><td>/</td></tr></tbody></table><p>并且<code>BlockingQueue</code>和<code>ConcurrentHashMap</code>一样不允许插入<code>null</code>，因为<code>null</code>代表着<code>poll()</code>方法失败。同时对于同一元素，<code>BlockingQueue</code>的插入操作happens before获取操作。</p><h2 id="2-体系架构"><a href="#2-体系架构" class="headerlink" title="2. 体系架构"></a>2. 体系架构</h2><p><code>BlockingQueue</code>接口继承自<code>utils</code>包下的<code>Queue</code>接口，如下所示：</p><p><img src="./images/BlockingQueue-arch.png" alt="BlockingQueue-arch"></p><p>可以看到，所以的阻塞队列都继承了<code>utils</code>包下的抽象实现类<code>AbstracQueue</code>（负责实现一些队列的核心方法）。阻塞队列的种类非常丰富，我将其按照功能划分为三类：</p><ol><li>普通的阻塞队列：所谓的普通阻塞队列，它们的区别只是底层使用的存储结构不同<ul><li><code>LinkedBlockingQueue</code>:底层存储结构为链表</li><li><code>ArrayBlockingQueue</code>：底层存储为循环数组</li><li><code>PriorityBlockingQueue</code>：具备阻塞功能的优先级队列</li><li><code>LinkedBlockingDeque</code>：底层存储结构为链表的双向阻塞队列</li></ul></li><li>转移队列：消费者线程和生产者线程一一匹配，如果还没有消费，那么会将生产者阻塞在队列中，直到有匹配的消费者将节点取出<ul><li><code>LinkedTransferQueue</code></li><li><code>SynchronousQueue</code></li></ul></li><li>延迟队列：队列中的节点只有经过一定延时才能取出、<ul><li><code>DelayQueue</code></li><li><code>DelayedWorkQueue</code></li></ul></li></ol><p>划分标准还有很多，可以按照有锁、无锁、队列有限无限来区分，这里我直接抄个别人的，<a href="https://segmentfault.com/a/1190000016460411">分类来源</a>：</p><p>|   队列特性   | 有界队列  |  似无界队列  |  无界队列  |  特殊队列  |<br>|  —-  | —-  | —-  | —-  | —-  | —-  |<br>| 有锁算法  | ArrayBlockingQueue（单锁） | LinkedBlockingQueue（双锁），LinkedBlockingDeque（双锁） | / | PriorityBlockingQueue（单锁），DelayQueue（单锁） |<br>| 无锁算法  | / | / | / | LinkedTransferQueue | SynchronousQueue |</p><p>其中所谓的无锁是指实现中没有显示的使用其他同步锁，只使用了CAS；而有锁则一般都是使用<code>ReentrantLock</code>。</p><h2 id="3-已声明的方法"><a href="#3-已声明的方法" class="headerlink" title="3. 已声明的方法"></a>3. 已声明的方法</h2><p><code>BlockingQueue</code>与普通队列接口<code>Queue</code>所声明的抽象方法大差不差，都规定了一些增删查改的操作，如下所示：</p><p><img src="./images/BlockingQueue-methods.png" alt="BlockingQueue-methods"></p><p>其中一个比较新奇的就是<code>drainTo()</code>方法，该方法的主要作用就是将阻塞队列中的节点转移到一个集合中，如果在转移的时候出现错误，那么节点有可能存在于<code>BlockingQueue</code>和<code>Collection</code>或者都不存在或者仅存在于一处。并且在转移的时候不支持对传入的<code>Collection</code>进行修改。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>BlockingQueue的典型使用场景就是生产者与消费者模式，它的实现种类繁杂，后续我将简要分析各种类型的代表队列，文章列表如下所示：</p><ol><li>普通阻塞队列：<a href="./LinkedBlockingQueue-analysis.md">LinkedBlockingQueue源码分析</a></li><li>转移队列：<ul><li><a href="./LinkedTransferQueue-analysis.md">LinkedTransferQueue源码分析</a></li><li><a href="./SynchronousQueue-analysis.md">SynchronousQueue源码分析</a></li></ul></li><li>延迟队列：<a href="./DelayQueue-analysis.md">DelayQueue源码分析</a></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="https://eripe.me/tags/concurrent-collections/">concurrent collections</category>
      
      
      <comments>https://eripe.me/articles/interface-BlockingQueue-analysis.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ConcurrentHashMap扩容分析</title>
      <link>https://eripe.me/articles/ConcurrentHashMap-analysis-II.html</link>
      <guid>https://eripe.me/articles/ConcurrentHashMap-analysis-II.html</guid>
      <pubDate>Tue, 06 Apr 2021 02:02:09 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇继承于&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇继承于<a href="./ConcurrentHashMap-analysis-I.md">ConcurrentHashMap架构解析</a>，在了解了<code>ConcurrentHashMap</code>的整体架构与插入删除逻辑后，还有一个知识点：<strong>扩容逻辑</strong>需要学习，我认为这是<code>ConcurrentHashMap</code>核心中的核心。</p><p>废话不多说，对于<code>ConcurrentHashMap</code>来说，扩容可以整体分为两个部分：</p><ol><li>将属性table扩展为原来的两倍</li><li>将旧table中数据迁移到新table</li></ol><p>那么本文就按照这两个小点逐个击破JDK8下的<code>ConcurrentHashMap</code>。</p><h2 id="1-预备知识"><a href="#1-预备知识" class="headerlink" title="1. 预备知识"></a>1. 预备知识</h2><p>在真正学习扩容逻辑前，我们有必要了解<code>ConcurrentHashMap</code>中的两个重点字段：<code>sizeCtl</code>与<code>transferIndex</code>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Table initialization and resizing control.  When negative, the</span><br><span class="hljs-comment">* table is being initialized or resized: -1 for initialization,</span><br><span class="hljs-comment">* else -(1 + the number of active resizing threads).  Otherwise,</span><br><span class="hljs-comment">* when table is null, holds the initial table size to use upon</span><br><span class="hljs-comment">* creation, or 0 for default. After initialization, holds the</span><br><span class="hljs-comment">* next element count value upon which to resize the table.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">-1表示当前正在初始化table，在初始化完毕后，sizeCtl维护的是扩容阈值</span><br><span class="hljs-comment">为其他负数时，值的含义是：-(1+正在协作数据转移的线程数量)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> sizeCtl;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The next table index (plus one) to split while resizing.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> transferIndex;<br></code></pre></div></td></tr></table></figure><p><strong>sizeCtl</strong>的注释基本上解释了这个字段的含义：</p><ol><li>“-1”表示当前table正在初始化</li><li>“其他负数”的含义为-(1+当前正在协助扩容的线程数量)</li><li>当table为空，为初始值“0”或者用户自定义的容量</li><li>当table不为空，“其他正数”的含义为扩容阈值</li></ol><p>其中第二点需要我们注意，当<code>sizeCtl</code>为负数时，32位bit被一分为2：</p><ol><li>高16位是一个基于当前线程生成的特征码，用于标记线程是否正在协助扩容</li><li>低16位表示（1+当前正在协助扩容的线程数量）</li></ol><p>可能这里说的太抽象，后面了解具体的构造逻辑应该就不是问题了。</p><p>至于<strong>transferIndex</strong>则表示的是一个线程负责的迁移范围右边界的下一个索引。</p><h2 id="2-table扩展逻辑"><a href="#2-table扩展逻辑" class="headerlink" title="2. table扩展逻辑"></a>2. table扩展逻辑</h2><p>能进行<code>table</code>扩展的地方有很多，我目前仅了解到两处：</p><ol><li>在<code>putVal(K,V,boolean)</code>中，如果table未初始化，那么则会调用<code>initTable()</code>扩展<code>table</code></li><li>在链表过长调用<code>treeifyBin()</code>尝试树化时，如果<code>table</code>的容量小于64，那么仅仅会通过<code>tryPreSize(int)</code>完成<code>table</code>扩展以及数据迁移</li><li>在调用<code>putAll()</code>时，首先会调用<code>tryPresize()</code>尝试扩展table</li></ol><p>基本上会扩展<code>table</code>的场景就上面三种，那么我们依次来了解下它们具体的逻辑。</p><h3 id="2-1-table的初始化"><a href="#2-1-table的初始化" class="headerlink" title="2.1 table的初始化"></a>2.1 table的初始化</h3><p><code>table</code>初始化的逻辑还是比较简单的，在关键点我都写了注释：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-keyword">int</span> sc;<br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-keyword">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//如果状态码sizeCtl小于0，表示有其他线程正在扩展扩展，那么我们需要做的只有等待</span><br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br>            Thread.yield(); <span class="hljs-comment">// lost initialization race; just spin</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">//sc不为0，表示用户自定义了容量</span><br>                    <span class="hljs-keyword">int</span> n = (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br>                    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node&lt;?,?&gt;[n];<br>                    table = tab = nt;<br>                    <span class="hljs-comment">//设置sc=factor*capacity，也就是扩容阈值</span><br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-comment">//只初始化一次</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-2-table的预扩展"><a href="#2-2-table的预扩展" class="headerlink" title="2.2 table的预扩展"></a>2.2 table的预扩展</h3><p>所谓的预扩展，也就是方法<code>tryPresize(int)</code>，它作为关键先生，除了初始化table时不使用它，后续所有的扩展逻辑都需要通过<code>tryPresize()</code>扩展table（因为当table不为空，需要进行数据迁移，<code>initTable()</code>干不了这事），并在方法内部调用数据迁移方法<code>transfer()</code>。</p><p>那么所谓的“预”是指什么？我认为是指线程有资格尝试扩容，但不一定完成扩容。因为在一次扩容的过程中，可能有多个线程都想要完成相同的任务，比如从16扩展到32。那么肯定得防止多次扩容，只能允许第一个调用该方法的线程完成扩容的逻辑，后续的线程没资格扩展table，它们只能作为协助者帮助数据迁移。</p><p>了解了<code>tryPresize</code>的使用场景，我们看看它具体的实现逻辑：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Tries to presize table to accommodate the given number of elements.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> size number of elements (doesn&#x27;t need to be perfectly accurate)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryPresize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>    <span class="hljs-comment">//c表示table的新容量</span><br>    <span class="hljs-keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="hljs-number">1</span>)) ? MAXIMUM_CAPACITY :<br>        tableSizeFor(size + (size &gt;&gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> sc;<br>    <span class="hljs-comment">//如果控制码sizeCtl为非负数，说明当前线程没有在初始化或者扩容</span><br>    <span class="hljs-keyword">while</span> ((sc = sizeCtl) &gt;= <span class="hljs-number">0</span>) &#123;<br>        Node&lt;K,V&gt;[] tab = table; <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-comment">//case1：table还未初始化或者长度为0</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>) &#123;<br>            n = (sc &gt; c) ? sc : c;<br>            <span class="hljs-comment">//将sizeCtl设置为-1，表示正在初始化table</span><br>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-comment">//将旧table扩容原来的两倍</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (table == tab) &#123;<br>                        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node&lt;?,?&gt;[n];<br>                        table = nt;<br>                        sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">//设置新的状态码，也就是新的扩容阈值</span><br>                    sizeCtl = sc;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        case2：有可能传入的参数size过小，甚至比原始table的扩容阈值都小，这种情况是有可能发生的：</span><br><span class="hljs-comment">        在putAll()中，首先会将table扩展为传入map的两倍大小，那么有可能原来table就不为空，</span><br><span class="hljs-comment">        并且远大于传入map大小的两倍，那么此时根本就不需要扩展以及数据迁移，直接返回即可</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//case3：table不为空，并且已经扩容完毕，为数据迁移做准备工作</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tab == table) &#123;<br>            <span class="hljs-comment">//为当前线程生成唯一的扩容标识码，n是旧table的长度</span><br>            <span class="hljs-keyword">int</span> rs = resizeStamp(n);<br>            <span class="hljs-comment">/*****************************</span><br><span class="hljs-comment">            *           Question1        *</span><br><span class="hljs-comment">            *****************************/</span><br>            <span class="hljs-keyword">if</span> (sc &lt; <span class="hljs-number">0</span>) &#123;<br>                Node&lt;K,V&gt;[] nt;<br>                <span class="hljs-comment">//如果当前线程无法协作数据转移，则退出</span><br>                <span class="hljs-keyword">if</span> (<br>                    (sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs ||<br>                    sc == rs + <span class="hljs-number">1</span> || sc == rs + MAX_RESIZERS ||<br>                    (nt = nextTable) == <span class="hljs-keyword">null</span> ||<br>                    transferIndex &lt;= <span class="hljs-number">0</span><br>                    )<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">//当前线程可能会作为协作线程帮助进行数据迁移</span><br>                <span class="hljs-comment">//尝试使用cas操作负责把状态码sc中的协作线程数+1</span><br>                <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>))<br>                    transfer(tab, nt);<br>            &#125;<br>            <span class="hljs-comment">//本线程作为第一个作为数据迁移的线程，</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc,<br>                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))<br>                transfer(tab, <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>可以看到，<code>tryPresize(int)</code>中的<code>while</code>执行条件，只有当前table没有扩容或者初始化时才会执行后续操作，这也就防止多个线程执行相同的扩容操作。那么进入<code>while</code>后，会分为3个小场景：</p><ol><li>当table没有被初始化时，说明用户应该调用的是<code>putAll()</code>，那么则尝试将状态码<code>sizeCtl</code>设置为-1并初始化table</li><li>当table不为空时，如果新容量小于旧的扩容阈值，或者已经超过了最大容量，那么根本就不需要扩容，直接返回即可</li><li>当table没有被扩容，那么当前线程则尝试作为第一个进行数据迁移的线程，调用<code>transfer()</code></li></ol><p>上面比较难理解的是第三个场景，我这里详细解释一下。首先会通过调用<code>resizeStamp</code>为本轮扩容操作生成唯一的标识，它的逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//线程标识符生成逻辑</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">resizeStamp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="hljs-number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在生成标识符的过程中：首先会将数字<code>1</code>右移15位（RESIZE_STAMP_BITS值为16），将标识符的第16位（从右往左）设置为1，然后跟当前table长度的前导0个数进行或操作。那么根据这个逻辑，在同一轮扩容操作中，假设有n个线程在协助扩容，扩容完成前旧table的前导0个数必然是相等的，那么为这n个线程生成的标识符也必然相等。</p><p>下面是生成标识符后的代码逻辑，分为两个部分：</p><ol><li>当前table正在进行数据迁移，那么当前线程只能作为协助者去帮助</li><li>当前table没有在数据迁移，那么当前线程作为数据迁移的发起者 </li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//case3逻辑</span><br>...<br><span class="hljs-keyword">if</span> (sc &lt; <span class="hljs-number">0</span>) &#123;<br>    Node&lt;K,V&gt;[] nt;<br>    <span class="hljs-comment">//如果当前线程无法协作数据转移，则退出</span><br>    <span class="hljs-keyword">if</span> (<br>        (sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs ||<br>        sc == rs + <span class="hljs-number">1</span> || sc == rs + MAX_RESIZERS ||<br>        (nt = nextTable) == <span class="hljs-keyword">null</span> ||<br>        transferIndex &lt;= <span class="hljs-number">0</span><br>        )<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-comment">//当前线程可能会作为协作线程帮助进行数据迁移</span><br>    <span class="hljs-comment">//尝试使用cas操作负责把状态码sc中的协作线程数+1</span><br>    <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>))<br>        transfer(tab, nt);<br>&#125;<br><span class="hljs-comment">//本线程作为第一个作为数据迁移的线程，</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc,<br>                                (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))<br>    transfer(tab, <span class="hljs-keyword">null</span>);<br></code></pre></div></td></tr></table></figure><p>可以看到，如果当前线程想要作为协助者，必须要求局部变量<code>sc</code>小于0，那么“Question1”处的<code>if</code>语句什么时候会被执行？能进入<code>while</code>循环，那么局部变量<code>sc</code>（不存在竞争性）不是必定大于等于0？怎么可能小于0？</p><p>对于这个问题，我找了很久很久，终于在网上找到了答案，“Question1”是个bug：<a href="https://bugs.openjdk.java.net/browse/JDK-8215409">JDK-8215409</a>，在JDK11以后，就不存在这个问题了。例如JDK14，对应的<code>tryPresize()</code>如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryPresize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="hljs-number">1</span>)) ? MAXIMUM_CAPACITY :<br>        tableSizeFor(size + (size &gt;&gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> sc;<br>    <span class="hljs-keyword">while</span> ((sc = sizeCtl) &gt;= <span class="hljs-number">0</span>) &#123;<br>        Node&lt;K,V&gt;[] tab = table; <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>) &#123;<br>            ...<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">/**********************</span><br><span class="hljs-comment">        * question1对应的代码  *</span><br><span class="hljs-comment">        **********************/</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tab == table) &#123;<br>            <span class="hljs-keyword">int</span> rs = resizeStamp(n);<br>            <span class="hljs-keyword">if</span> (U.compareAndSetInt(<span class="hljs-keyword">this</span>, SIZECTL, sc,<br>                                    (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))<br>                transfer(tab, <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，JDK8中的if语句完全被删除了。ok，虽然bug的问题解决了，但是又产生了一个新的问题，JDK8中的<code>if</code>是用来使用其他线程帮助数据迁移的，直接删除了帮助的逻辑，这个“帮助”又怎么实现？我仔细查看了插入的逻辑，发现在调用<code>putVal</code>时，有可能会调用<code>helpTransfer()</code>达到“帮助数据迁移”的目的，这个方法我会和迁移逻辑<code>transfer()</code>方法一起分析。</p><hr><p><strong>Extension：</strong><br>对于这个问题，其实我觉的还有一点需要注意：我刚开始用中文英文都没有搜索到这个bug，why？我想原因可能是关键词没有写对，以后找JDK的bug，尽量使用<code>&lt;class name&gt;.&lt;method name&gt;</code>的格式，例如<code>ConcurrentHashMap.tryPresize()</code>。</p><hr><p>那么如果当前线程作为数据迁移的发起者，会尝试CAS<code>U.compareAndSwapInt(this, SIZECTL, sc,(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</code>将状态码<code>sizeCtl</code>设置为负数，这如何理解？</p><p>首先我们从前文知道，线程标识符<code>rs</code>的第16位一定是1，此时再右移16位，那么第16位的1一定会移动至第32位。ok，那么移动完成后<code>rs</code>一定是一个负数，并且第1~16位（从右往左）一定为0。此时再+2（1+1，其中一个1表示当前正在数据迁移的线程数量），就是最终的状态码<code>sizeCtl</code>。这也就达到了<code>sizeCtl</code>的第二种使用场景。</p><p>生成新的状态码后，第一个启动数据迁移的线程会调用<code>transfer()</code>完成真正的数据迁移，该方法的逻辑放在下一章中讲解。</p><h3 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2 小结"></a>2.2 小结</h3><p><code>ConcurrentHashMap</code>扩展table的核心方法是<code>tryPresize(int)</code>,它就是让属于同一轮扩容操作的线程一起完成数据迁移，加快效率。而不是让单个线程把整个table锁住，独自完成。</p><p>但是对于该方法，我也提出一个疑问：如果原始table中没有元素，那么初始化table后，没有数据转移啊，怎么结束<code>while</code>循环？目前我还没有明确的答案，我们在梳理完数据迁移函数<code>transfer()</code>的逻辑后，再来尝试回答这个问题。</p><hr><p>在此贴出答案：其中变量<code>c</code>只会在旧table为空时才会改变，所以只会被初始化一次。而一旦进入<code>transfer()</code>，生成的新table长度是2c，那么新的扩容阈值<code>sizeCtl</code>为<code>2c*0.75=1.5c</code>，所以再次进入while循环时，会进入case2，因为<code>c&lt;=sc</code>，直接退出循环。</p><hr><h2 id="3-数据迁移"><a href="#3-数据迁移" class="headerlink" title="3. 数据迁移"></a>3. 数据迁移</h2><p>数据迁移是扩容操作的核心，主要通过<code>transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</code>完成，如果第二个参数<code>nextTab</code>为空，说明调用该方法的是数据迁移发起者，不为空则说明当前线程是数据迁移协助者。</p><p>能够调用该方法的地方有很多，我罗列一下目前我已知的地方：</p><ol><li>在<code>putVal()</code>中，如果发现table正在进行数据迁移，那么插入线程会调用<code>helpTransfer()</code>帮助数据迁移</li><li>在<code>addCount()</code>中，更新table容量时会=可能会调用<code>transfer()</code>发起数据迁移</li><li>在<code>tryPresize()</code>，会调用<code>transfer()</code>发起数据迁移</li></ol><p>为了能够更快地理解<code>transfer()</code>地逻辑，我们首先需要了解一些前置知识：</p><ol><li>每一个进行数据迁移的线程都会负责一个范围的桶，范围的一般形式为 <strong>[left_bound,right_bound ]<strong>，其中</strong>right_bound-left_bound=stride</strong></li><li><code>stride</code>：表示一个线程需要负责转移多少连续的桶，最小值为16</li><li><code>transferIndex</code>：表示当前线程负责迁移范围的右边界的下一个位置，有<strong>transferIndex=right_bound+1</strong></li><li><code>ForwardingNode</code>：占位符，如果一个桶转移完毕，那么会在旧table中放入一个<code>ForwardingNode</code>作为标记</li><li><code>ConcurrentHashMap</code>是从后往前逐个转移每个桶的数据</li></ol><p>说了这么多，我们来看看<code>transfer()</code>到底长什么样：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 该方法在table扩容后，进行数据迁移的操作</span><br><span class="hljs-comment">* Moves and/or copies the nodes in each bin to new table. See</span><br><span class="hljs-comment">* above for explanation.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = tab.length, stride;<br>    <span class="hljs-keyword">if</span> ((stride = (NCPU &gt; <span class="hljs-number">1</span>) ? (n &gt;&gt;&gt; <span class="hljs-number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)<br>        stride = MIN_TRANSFER_STRIDE; <span class="hljs-comment">// subdivide range</span><br>    <span class="hljs-comment">//数据迁移发起者传入的参数nextTab一定为null，所以能够保证只会生成一个nextTab</span><br>    <span class="hljs-comment">//直接生成一个容量为旧table两倍的新table</span><br>    <span class="hljs-keyword">if</span> (nextTab == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// initiating</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="hljs-number">1</span>];<br>            nextTab = nt;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      <span class="hljs-comment">// try to cope with OOME</span><br>            sizeCtl = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//将nextTab赋值给nextTable</span><br>        nextTable = nextTab;<br>        transferIndex = n;<br>    &#125;<br>    <span class="hljs-keyword">int</span> nextn = nextTab.length;<br>    ForwardingNode&lt;K,V&gt; fwd = <span class="hljs-keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);<br>    <span class="hljs-comment">//advance为true表示当前线程已经把负责范围内的某个桶迁移完毕</span><br>    <span class="hljs-keyword">boolean</span> advance = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">//finishing字段表示整个旧table的数据迁移是否完成</span><br>    <span class="hljs-keyword">boolean</span> finishing = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// to ensure sweep before committing nextTab</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, bound = <span class="hljs-number">0</span>;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-keyword">int</span> fh;<br>        <span class="hljs-comment">//进行具体迁移任务前的预处理工作，主要是计算当前线程需要负责的桶索引</span><br>        <span class="hljs-keyword">while</span> (advance) &#123;<br>            <span class="hljs-comment">//所有协作线程的nextIndex初始值都为(old table).length</span><br>            <span class="hljs-keyword">int</span> nextIndex, nextBound;<br>            <span class="hljs-comment">//i表示当前线程处理的桶索引，如果i&gt;=bound，说明当前负责的范围还没有处理完毕,那么直接跳出循环，处理新桶</span><br>            <span class="hljs-comment">//其中bound表示当前线程负责范围的下界</span><br>            <span class="hljs-keyword">if</span> (--i &gt;= bound || finishing)<br>                advance = <span class="hljs-keyword">false</span>;<br>            <br>            <span class="hljs-comment">//transferIndex&lt;=0，表示整个table已经处理完毕了</span><br>            <span class="hljs-comment">//因为transferIndex表示的是迁移范围的下一个索引</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="hljs-number">0</span>) &#123;<br>                i = -<span class="hljs-number">1</span>;<br>                advance = <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-comment">//当前线程负责迁移的范围：[transferIndex-stride,transferIndex-1]</span><br>            <span class="hljs-comment">//每分配一次范围，将transferIndex从后往前移动stride的距离</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt<br>                        (<span class="hljs-keyword">this</span>, TRANSFERINDEX, nextIndex,<br>                        nextBound = (nextIndex &gt; stride ?<br>                                    nextIndex - stride : <span class="hljs-number">0</span>))) &#123;<br>                <span class="hljs-comment">//bound表示迁移范围的左边界</span><br>                bound = nextBound;<br>                i = nextIndex - <span class="hljs-number">1</span>;<br>                advance = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//case1：</span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;<br>            <span class="hljs-keyword">int</span> sc;<br>            <span class="hljs-comment">//如果扩容结束，那么则将控制码sizeCtl设置为新的扩容阈值：n*factor，并返回</span><br>            <span class="hljs-keyword">if</span> (finishing) &#123;<br>                nextTable = <span class="hljs-keyword">null</span>;<br>                table = nextTab;<br>                sizeCtl = (n &lt;&lt; <span class="hljs-number">1</span>) - (n &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">//将SizeCtl后16位表示的协作线程数量-1</span><br>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-comment">//如果当前线程不是最后一个完成迁移的线程，那么直接退出</span><br>                <span class="hljs-keyword">if</span> ((sc - <span class="hljs-number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)<br>                    <span class="hljs-keyword">return</span>;<br>                <span class="hljs-comment">//当前线程是最后一个完成协作的线程，将完成标志位finishing设为true</span><br>                finishing = advance = <span class="hljs-keyword">true</span>;<br>                i = n; <span class="hljs-comment">// recheck before commit</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//case2：如果当前桶为空，直接尝试使用cas往该桶中放入占位符ForwardingNode</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i)) == <span class="hljs-keyword">null</span>)<br>            advance = casTabAt(tab, i, <span class="hljs-keyword">null</span>, fwd);<br>        <span class="hljs-comment">//case3：如果当前桶的第一个节点是占位符ForwardingNode，那么说明当前桶已经完成了迁移</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            advance = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// already processed</span><br>        <span class="hljs-comment">//case4：</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//对唯一的一个桶上锁，然后开始转移一个桶内的节点，这与HashMap是类似的</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    Node&lt;K,V&gt; ln, hn;<br>                    <span class="hljs-comment">//当前桶的存储结构是链表</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        ...<br>                        setTabAt(nextTab, i, ln);<br>                        setTabAt(nextTab, i + n, hn);<br>                        <span class="hljs-comment">//设置占位符ForwardingNode</span><br>                        setTabAt(tab, i, fwd);<br>                        advance = <span class="hljs-keyword">true</span>;<br>                    &#125;<br>                    <span class="hljs-comment">//如果当前桶的存储结构是红黑树，则采用红黑树的迁移方法</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        ...<br>                        &#125;<br>                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :<br>                            (hc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;<br>                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :<br>                            (lc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;<br>                        setTabAt(nextTab, i, ln);<br>                        setTabAt(nextTab, i + n, hn);<br>                        setTabAt(tab, i, fwd);<br>                        advance = <span class="hljs-keyword">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>transfer()</code>的代码比较长，我们可以把它的逻辑分为如下两个部分：</p><ol><li>计算当前线程负责的迁移范围</li><li>进行具体的迁移操作</li></ol><p>下面我将分别详述这两个部分。</p><h3 id="3-1-迁移范围的计算"><a href="#3-1-迁移范围的计算" class="headerlink" title="3.1 迁移范围的计算"></a>3.1 迁移范围的计算</h3><p>当前线程负责的迁移范围由代码中的<code>while</code>循环负责计算，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">...<br><span class="hljs-keyword">while</span> (advance) &#123;<br>    <span class="hljs-comment">//所有协作线程的nextIndex初始值都为(old table).length</span><br>    <span class="hljs-keyword">int</span> nextIndex, nextBound;<br>    <span class="hljs-comment">//i表示当前线程处理的桶索引，如果i&gt;=bound，说明当前负责的范围还没有处理完毕,那么直接跳出循环，处理新桶</span><br>    <span class="hljs-comment">//其中bound表示当前线程负责范围的下界</span><br><br>    <span class="hljs-comment">/************************</span><br><span class="hljs-comment">    *        case1          *</span><br><span class="hljs-comment">    ************************/</span><br>    <span class="hljs-keyword">if</span> (--i &gt;= bound || finishing)<br>        advance = <span class="hljs-keyword">false</span>;<br>    <br>    <span class="hljs-comment">//transferIndex&lt;=0，表示整个table已经处理完毕了</span><br>    <span class="hljs-comment">//因为transferIndex表示的是迁移范围的下一个索引</span><br><br>    <span class="hljs-comment">/************************</span><br><span class="hljs-comment">    *        case2          *</span><br><span class="hljs-comment">    ************************/</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="hljs-number">0</span>) &#123;<br>        i = -<span class="hljs-number">1</span>;<br>        advance = <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//当前线程负责迁移的范围：[transferIndex-stride,transferIndex-1]</span><br>    <span class="hljs-comment">//每分配一次范围，将transferIndex从后往前移动stride的距离</span><br><br>    <span class="hljs-comment">/************************</span><br><span class="hljs-comment">    *        case3          *</span><br><span class="hljs-comment">    ************************/</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt<br>                (<span class="hljs-keyword">this</span>, TRANSFERINDEX, nextIndex,<br>                nextBound = (nextIndex &gt; stride ?<br>                            nextIndex - stride : <span class="hljs-number">0</span>))) &#123;<br>        <span class="hljs-comment">//bound表示迁移范围的左边界</span><br>        bound = nextBound;<br>        i = nextIndex - <span class="hljs-number">1</span>;<br>        advance = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br>...<br></code></pre></div></td></tr></table></figure><p>我们可以分为三种case来理解<code>while</code>，对于每种case的含义我注释已经写的比较清楚了，不再赘述。我这里模拟一下多线程协作时计算范围的场景（假设有三个线程A、B，旧table的长度为32，步长为16）：</p><ol><li>当第一个线程<code>A</code>进入while循环后，会进入<code>case3</code>，<code>nextIndex</code>默认为32，那么<code>nextBound</code>的结果为（32-16），所以A线程负责的范围为<code>[bound,nextIndex-1]</code> ==<code>[16,32-1]</code>，并且从索引31开始处理</li><li>当线程<code>B</code>进入while循环后，同样会进入<code>case3</code>，<code>nextIndex</code>的值为16，那么<code>nextBound</code>的结果为（16-16），所以B线程负责的范围为<code>[bound,nextIndex-1]</code> ==<code>[0,16-1]</code>，从索引15开始索引</li><li>当A线程处理完毕后，因为<code>case1</code>条件不符合，进入<code>case2</code>将i设为<code>-1</code>，最后完成一些收尾工作；如果旧table足够大的话，会进入<code>case3</code>申请新的迁移区间重复数据迁移的过程</li></ol><p>当整个旧table都迁移完成后，所有迁移线程都会进入<code>case2</code>将索引<code>i</code>设置为<code>-1</code>。</p><h3 id="3-2-迁移操作的四种情况"><a href="#3-2-迁移操作的四种情况" class="headerlink" title="3.2 迁移操作的四种情况"></a>3.2 迁移操作的四种情况</h3><p>在计算完当前线程需要负责的迁移范围后，会分为四种情况：</p><ol><li>当前线程的迁移工作已经结束</li><li>当前处理的桶为空，直接尝试使用cas往该桶中放入占位符ForwardingNode</li><li>当前桶的第一个节点是占位符ForwardingNode，那么说明当前桶已经完成了迁移，开始处理下一个桶</li><li>对当前桶进行迁移工作</li></ol><p>我在下面代码中已经注释了四种case：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">...<br><span class="hljs-comment">//case1：当前线程的迁移工作已经结束</span><br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;<br>    <span class="hljs-keyword">int</span> sc;<br>    <span class="hljs-comment">//如果扩容结束，那么则将控制码sizeCtl设置为新的扩容阈值：n*factor，并返回</span><br>    <span class="hljs-keyword">if</span> (finishing) &#123;<br>        nextTable = <span class="hljs-keyword">null</span>;<br>        table = nextTab;<br>        sizeCtl = (n &lt;&lt; <span class="hljs-number">1</span>) - (n &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//将SizeCtl后16位表示的协作线程数量-1</span><br>    <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-comment">//如果当前线程不是最后一个完成迁移的线程，那么直接退出</span><br>        <span class="hljs-comment">/*****************************</span><br><span class="hljs-comment">        *注意这里的sc和sizeCtl是两个值*</span><br><span class="hljs-comment">        ****************************/</span><br>        <span class="hljs-keyword">if</span> ((sc - <span class="hljs-number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//当前线程是最后一个完成协作的线程，将完成标志位finishing设为true</span><br>        finishing = advance = <span class="hljs-keyword">true</span>;<br>        i = n; <span class="hljs-comment">// recheck before commit</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//case2：如果当前桶为空，直接尝试使用cas往该桶中放入占位符ForwardingNode</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i)) == <span class="hljs-keyword">null</span>)<br>    advance = casTabAt(tab, i, <span class="hljs-keyword">null</span>, fwd);<br><span class="hljs-comment">//case3：如果当前桶的第一个节点是占位符ForwardingNode，那么说明当前桶已经完成了迁移</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>    advance = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// already processed</span><br><span class="hljs-comment">//case4：迁移当前桶的数据</span><br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//对唯一的一个桶上锁，然后开始转移一个桶内的节点，这与HashMap是类似的</span><br>    <span class="hljs-keyword">synchronized</span> (f) &#123;<br>        <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>            Node&lt;K,V&gt; ln, hn;<br>            <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                ...<br>                setTabAt(nextTab, i, ln);<br>                setTabAt(nextTab, i + n, hn);<br>                <span class="hljs-comment">//设置占位符ForwardingNode</span><br>                setTabAt(tab, i, fwd);<br>                advance = <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-comment">//如果当前桶的存储结构是红黑树，则采用红黑树的迁移方法</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                ...<br>                setTabAt(nextTab, i, ln);<br>                setTabAt(nextTab, i + n, hn);<br>                setTabAt(tab, i, fwd);<br>                advance = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>...<br></code></pre></div></td></tr></table></figure><p>我认为<code>case1</code>中的两个if<strong>非常</strong>值得注意：</p><ol><li><p><code>if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1))</code>：这么写的原因是因为当一个线程完成了迁移工作，那么就会将<code>sizeCtl</code>低16位维护的线程数量减1。如果是最后一个协助线程，那么<code>sizeCtl</code>的值为<code>(resizeStamp(old tab.length)&lt;&lt;RESIZE_STAMP_SHIFT)+1</code>，这会作为迁移工作完成的标志，因为最后一个线程会通过下面的if条件并设置标志位<code>finishing</code>。</p></li><li><p><code>if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</code>，这么写的原因是因为迁移工作的发起者会执行<code>sizeCtl=(resizeStamp(old tab.length)&lt;&lt;RESIZE_STAMP_SHIFT)+2</code>，如果该if条件通过，说明当前线程就是最后一个完成迁移的线程，将标志位<code>finishing</code>设为true，并且将索引<code>i</code>设为n，这样下一轮循环依然能进入上面迁移操作的逻辑中，再次进入case1更新<code>sizeCtl</code>、<code>table</code>后并返回</p></li></ol><p>至于其他三种case，我认为并不难理解，基本注释我已写在代码中，这里不再赘述。</p><h3 id="3-3-协助线程的入口"><a href="#3-3-协助线程的入口" class="headerlink" title="3.3 协助线程的入口"></a>3.3 协助线程的入口</h3><p>如果一个线程只能作为协助者的身份来迁移数据，那么它调用<code>tranfser()</code>进行协助的入口点只有<code>helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f)</code>。能够调用<code>helpTransfer()</code>的地方有很多，一般最常见的就是在<code>putVal()</code>中，如果插入桶的第一个节点hash值为<code>MOVED</code>，就会进入<code>helpTransfer()</code>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//putVal()中helpTransfer的入口点</span><br>...<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>        tab = helpTransfer(tab, f);<br></code></pre></div></td></tr></table></figure><p><code>helpTransfer()</code>的返回值是新table，基本的注释我都写在了代码中：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;<br>    Node&lt;K,V&gt;[] nextTab; <span class="hljs-keyword">int</span> sc;<br>    <span class="hljs-comment">//旧table不为空</span><br>    <span class="hljs-keyword">if</span> (tab != <span class="hljs-keyword">null</span> &amp;&amp;<br>    <span class="hljs-comment">//桶中第一个节点为标记节点ForwardingNode</span><br>    (f <span class="hljs-keyword">instanceof</span> ForwardingNode) &amp;&amp;<br>    <span class="hljs-comment">//标记节点ForwardingNode中存储的新table不为空</span><br>        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//计算出本轮扩容的标志码</span><br>        <span class="hljs-keyword">int</span> rs = resizeStamp(tab.length);<br>        <span class="hljs-comment">/*如果标记节点ForwardingNode中存储的新table和ConcurrentHashMap的属性nextTable是同一个table</span><br><span class="hljs-comment">        并且传入的旧table和ConcurrentHashMap的属性table是同一个table才能保证协助线程和发起线程实在操作同一轮扩容操作</span><br><span class="hljs-comment">        因为sizeCtl&lt;0可能是正在进行初始化table操作</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;<br>                (sc = sizeCtl) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-comment">//如果生成的标识符不一样，说明本轮扩容工作已经结束了</span><br>                (sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs ||<br>                <span class="hljs-comment">//表示扩容已经结束，原理在下面详解</span><br>                <span class="hljs-comment">/*******************</span><br><span class="hljs-comment">                *      Question1   *</span><br><span class="hljs-comment">                *******************/</span><br>                sc == rs + <span class="hljs-number">1</span> ||<br>                <span class="hljs-comment">//扩容的线程数达到最大值</span><br>                sc == rs + MAX_RESIZERS ||<br>                <span class="hljs-comment">//转移工作已经结束了</span><br>                transferIndex &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//将协助的线程数+1，并调用transfer进行协助</span><br>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>)) &#123;<br>                transfer(tab, nextTab);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nextTab;<br>    &#125;<br>    <span class="hljs-keyword">return</span> table;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我认为值得注意的是“Question1”处，<code>sc==rs+1</code>为什么表示当前迁移工作已经完成。原因我已在迁移操作四种情况中的case1处解释。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>我认为<code>ConcurrentHashMap</code>的扩容还是比较复杂的，当然我们要抓住核心：只会有一个线程发起数据迁移，而其他线程会作为协作者。并且每个线程会负责一段连续的桶。至于具体的数据迁移跟<code>HashMap</code>是类似的：对于链表，会随机地划分为高低两个链表；对于红黑树，会拆分成两颗子树，最后存入新table对应的位置。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/">ConcurrentHashMap扩容源码介绍</a></p></li><li><p><a href="https://segmentfault.com/a/1190000016124883">Java多线程进阶（二四）—— J.U.C之collections框架：ConcurrentHashMap(2) 扩容</a></p></li><li><p><a href="https://www.javadoop.com/post/hashmap">Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析</a></p></li><li><p><a href="https://programmer.group/concurrent-hashmap-source-detailed-analysis-jdk-1.8.html">Concurrent HashMap Source Detailed Analysis (JDK 1.8)</a></p></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="https://eripe.me/tags/concurrent-collections/">concurrent collections</category>
      
      
      <comments>https://eripe.me/articles/ConcurrentHashMap-analysis-II.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ConcurrentHashMap架构解析</title>
      <link>https://eripe.me/articles/ConcurrentHashMap-analysis-I.html</link>
      <guid>https://eripe.me/articles/ConcurrentHashMap-analysis-I.html</guid>
      <pubDate>Mon, 29 Mar 2021 01:56:54 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇主要介绍<code>ConcurrentHashMap</code>的基本架构、插入与删除操作的原理，对于它扩容的逻辑，放在第二部分讲解：<a href="./ConcurrentHashMap-analysis-II.md">ConcurrentHashMap扩容分析</a>。</p><hr><p>本文旨在介绍J.U.C包下的同步集合<code>ConcurrentHashMap</code>。因为Java自带的<code>HashMap</code>是线程不安全的，虽然也提供了线程安全的<code>HashTable</code>，但是后者是对整个哈希表加锁，势必效率不理想。而<code>ConcurrentHashMap</code>细化了锁的粒度，读取、插入、删除操作有可能达到并行的状态。</p><p>在具体讲述它的原理之前，我阅读了它相关的注释，非常长，我这里仅摘出我看的内容中比较重要的部分：</p><blockquote><p>1.More formally, an update operation for a given key bears a happens-before relation with any (non-null) retrieval for that key reporting the updated value</p></blockquote><p>简而言之，<code>ConcurrentHashMap</code>的插入操作 happens before 对于同一key的获取操作</p><blockquote><p>2.Iterators, Spliterators and Enumerations return elements reflecting the state of the hash table at some point at or since the creation of the iterator/enumeration.They do not throw ConcurrentModificationException. However, iterators are designed to be used by only one thread at a time.Bear in mind that the results of aggregate status methods including size, isEmpty, and containsValue are typically useful only when a map is not undergoing concurrent updates in other threads. Otherwise the results of these methods reflect transient states that may be adequate for monitoring or estimation purposes, but not for program control.</p></blockquote><p>对于迭代器、枚举函数之类操作的返回值仅仅是哈希表在某一点的状态，它们不会抛出<code>ConcurrentModificationException</code>。并且迭代器应该只用在一个时刻中在一个线程中使用。并且需要注意，当我们想要获取<code>ConcurrentHashMap</code>的一些状态时，比如大小，获得的结果仅仅是某一个时刻并且没有其他线程改变的结果，只能用来作为一些监视条件，而<strong>不能用来控制程序的流程</strong>。</p><blockquote><p>3.Like Hashtable but unlike HashMap, this class does not allow null to be used as a key or value.</p></blockquote><p><code>ConcurrentHashMap</code>和<code>Hashtable</code>一样，不支持为null的key或者value。</p><blockquote><p>4.ConcurrentHashMaps support a set of sequential and parallel bulk operations that, unlike most Stream methods, are designed to be safely, and often sensibly, applied even with maps that are being concurrently updated by other threads; for example, when computing a snapshot summary of the values in a shared registry. There are three kinds of operation, each with four forms, accepting functions with Keys, Values, Entries, and (Key, Value) arguments and/or return values. Because the elements of a ConcurrentHashMap are not ordered in any particular way, and may be processed in different orders in different parallel executions, the correctness of supplied functions should not depend on any ordering, or on any other objects or values that may transiently change while computation is in progress; and except for forEach actions, should ideally be side-effect-free. Bulk operations on Map.Entry objects do not support method setValue.</p></blockquote><p>其实上面这段注释我认为是<code>ConcurrentHashMap</code>最有特点的一部分。大致是说<code>ConcurrentHashMap</code>可以针对每一个节点开展函数式的批量操作，即使有其他线程在更新map。那么接受函数式操作的方法有三种：</p><ol><li>forEach</li><li>search</li><li>reduce</li></ol><p>上述三个方法的函数式操作可以支持四种类型的节点，包括key的类型、value的类型、Entry的类型或者返回值的类型进行操作。并且函数式的操作不应该依赖元素的顺序，也不应该依赖其他元素或者对象。</p><hr><p>分界线，<code>ConcurrentHashMap</code>的注释真是太长了，暂时就先看到这吧。对于本文来说，主要内容分为三个部分：</p><ol><li><code>ConcurrentHashMap</code>的整体架构</li><li><code>ConcurrentHashMap</code>的基本操作原理，包括插入、删除、获取等操作</li><li><code>ConcurrentHashMap</code>的计数操作</li></ol><h2 id="1-整体架构"><a href="#1-整体架构" class="headerlink" title="1. 整体架构"></a>1. 整体架构</h2><p>对于<code>ConcurrentHashMap</code>，我们可以通过它实现的接口与继承的父类做一个初步的了解，如下所示：<br><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/20210601112343.png" alt="20210601112343"></p><p>可以看到，<code>ConcurrentHashMap</code>与<code>HashMap</code>类似，通过继承抽象实现类<code>AbstractMap</code>完成了一个map应该有的大部分通用方法。当然，<code>ConcurrentHashMap</code>也实现了自定义的接口<code>ConcurrentMap</code>来完成一些特有的操作，如下所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/ConcurrentHashMap-analysis-I.ConcurrentMap-interface.png" alt="ConcurrentHashMap-analysis-I.ConcurrentMap-interface"></p><p>可以看到，虽然是特有接口，但是很多方法跟<code>HashMap</code>的方法重名了。那么它到底是如何保证线程安全的？与<code>HashMap</code>到底有什么异同？回答这个问题前，我们应该需要了解一下它的插入与删除操作。</p><h2 id="2-插入操作原理"><a href="#2-插入操作原理" class="headerlink" title="2. 插入操作原理"></a>2. 插入操作原理</h2><p>对于插入的操作，我们应该首先应该知道我们插入的是什么，然后再去梳理具体的插入逻辑。<code>ConcurrentHashMap</code>中的节点类型比较丰富，总计分为五种，详情请见下一小节。</p><h3 id="2-1-节点类型"><a href="#2-1-节点类型" class="headerlink" title="2.1 节点类型"></a>2.1 节点类型</h3><p><code>ConcurrentHashMap</code>的五种节点类型分别是：Node，TreeNode，TreeBin、ForwardingNode、ReservationNode，它们的关系如下所示：</p><p><img src="images/ConcurrentHashMap-node-arch.png" alt="node-type"></p><p>从上图可以看到，虽然节点类型丰富，但是都是继承自<code>Node</code>类，而<code>Node</code>类又实现了<code>Map.Entry</code>接口。其实我们可以对比<code>HashMap</code>中的<code>Node</code>类型，基本逻辑差不多。</p><p><strong>I. Node类型</strong></p><p>对于<code>Node</code>类型，它是整个<code>ConcurrentHashMap</code>中的基础节点，它通过<code>next</code>指针将发生哈希冲突的节点维护到一起，该节点字段如下所示：</p><p><img src="images/node.png" alt="Node"></p><p><strong>II. TreeNode类型</strong></p><p>对于<code>TreeNode</code>类型，其实它跟<code>HashMap</code>类似，是红黑树中的基础节点。只不过它并没有放弃维护单链表的属性，所以对于每一个节点它维护了一个<code>prev</code>指针，方便快速在单链表逻辑中删除对应的节点，字段如下所示：</p><p><img src="images/TreeNode.png" alt="TreeNode"></p><p><strong>III. TreeBin类型</strong></p><p><code>TreeBin</code>节点，是<code>TreeNode</code>的代理节点，提供针对红黑树的转换操作和锁控制，哈希值固定为“-2”。也就是说，如果我们在一个桶中使用红黑树存储产生哈希冲突的元素，与<code>HashMap</code>不同，红黑树的根节点并不直接存储在table中。而是存储的是一个对应的代理节点<code>TreeBin</code>，<code>TreeBin</code>实现了关于红黑树的读写锁。具体字段含义如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeBin</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    TreeNode&lt;K,V&gt; root; <span class="hljs-comment">//红黑树逻辑下的根节点</span><br>    <span class="hljs-keyword">volatile</span> TreeNode&lt;K,V&gt; first;<span class="hljs-comment">//链表逻辑下的头节点</span><br>    <span class="hljs-keyword">volatile</span> Thread waiter; <span class="hljs-comment">// 最近一个设置锁状态的线程（从网上抄的，这个我不确定）</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> lockState;<span class="hljs-comment">//当前读写锁的状态</span><br>    <span class="hljs-comment">// values for lockState</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> WRITER = <span class="hljs-number">1</span>; <span class="hljs-comment">// set while holding write lock，持有写锁时状态为1</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> WAITER = <span class="hljs-number">2</span>; <span class="hljs-comment">// set when waiting for write lock，等待写锁时状态为2</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> READER = <span class="hljs-number">4</span>; <span class="hljs-comment">// increment value for setting read lock，每当一个线程获取到读锁时，就会将锁状态加4</span><br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>III. ForwardingNode</strong></p><p>扩容时的标记节点。具体原理在扩容时再分析，哈希值固定为“-1”。</p><p><strong>IV. ReservationNode</strong></p><p>保留结点，ConcurrentHashMap中的一些特殊方法会专门用到该类结点，哈希值固定为“-3”。</p><h3 id="2-2-具体的插入逻辑"><a href="#2-2-具体的插入逻辑" class="headerlink" title="2.2 具体的插入逻辑"></a>2.2 具体的插入逻辑</h3><p><code>ConcurrentHashMap</code>插入操作大体逻辑上与<code>HashMap</code>的插入并没有什么太大的区别，只不过前者在Java1.8及以后会使用<code>synchronized</code>对哈希表中的某一个桶加锁，从而实现局部加锁的效果，加锁的位置我在代码中已经明显注释为<strong>lock</strong>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span> || value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-keyword">int</span> hash = spread(key.hashCode());<br>    <span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-keyword">int</span> n, i, fh;<br>        <span class="hljs-comment">//采用懒加载模式，如果table为空，那么则会初始化table</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            tab = initTable();<br>        <span class="hljs-comment">//走到这表示table不为空，查找当前key对应的桶索引</span><br><br>        <span class="hljs-comment">//如果对应的桶为空，表示当前是一个插入操作</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//如果cas插入失败，表示当前桶此刻已经有元素了，需要走后面的逻辑重新插入</span><br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-keyword">null</span>,<br>                            <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>)))<br>                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span><br>        &#125;<br>        <span class="hljs-comment">//发现ForwardingNode结点，说明此时table正在扩容，则尝试协助数据迁移</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-keyword">else</span> &#123;<br>            V oldVal = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-comment">/****************************************************************************</span><br><span class="hljs-comment">            *                                 lock                                       *</span><br><span class="hljs-comment">            *对桶中的第一个节点f进行加锁，这样就保证了在不操作同一个桶的情况下，可以实现读写并发*</span><br><span class="hljs-comment">            *****************************************************************************/</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    <span class="hljs-comment">//判断当前桶的存储模式是链表还是红黑树</span><br>                    <span class="hljs-comment">//因为红黑树的代理节点TreeBin的哈希值固定为-2</span><br>                    <span class="hljs-comment">//所以如果桶中的第一个节点哈希值&gt;=0，说明当前存储模式为链表</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        binCount = <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                            K ek;<br>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                ((ek = e.key) == key ||<br>                                    (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                oldVal = e.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    e.val = value;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            Node&lt;K,V&gt; pred = e;<br>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-keyword">null</span>) &#123;<br>                                pred.next = <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key,<br>                                                            value, <span class="hljs-keyword">null</span>);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">//hash&lt;0，判断桶中第一个元素是否为TreeBin，有可能正在发生扩容</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        Node&lt;K,V&gt; p;<br>                        binCount = <span class="hljs-number">2</span>;<br>                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                        value)) != <span class="hljs-keyword">null</span>) &#123;<br>                            oldVal = p.val;<br>                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                p.val = value;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//当链表过长时，会尝试进行树化，这个hashmap几乎是一样的</span><br>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                    treeifyBin(tab, i);<br>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-keyword">null</span>)<br>                    <span class="hljs-keyword">return</span> oldVal;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    addCount(<span class="hljs-number">1L</span>, binCount);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其实除了操作每一个桶的时候会加同步锁，其他与<code>HashMap</code>插入键值对的流程几乎一致。但是更新<code>ConcurrentHashMap</code>容量的逻辑就完全不同。</p><p><code>ConcurrentHashMap</code>统计大小的逻辑类似于原子类<code>LongAdder</code>自增方法<code>longAccumulate(long,LongBinaryOperator,boolean)</code>的分段计数原理。所谓的分段计数就是说，如果在更新map容量时候发生了冲突，那么<code>ConcurrentHashMap</code>提供了一个<code>baseCount</code>属性，然后分配一个数组<code>CounterCell[]</code>，用来保存多个线程各自新增的增量（所谓的增量就是当前线程往map中添加了几个元素）。那么最后整个map的大小就等于<code>baseCount</code>加上每个线程专属的增量。</p><p>那么<strong>为什么</strong>要这么做？答案很明显：提高并发效率。思考一个场景：<br>当多个线程插入操作很频繁，因为只有在更新map大小之后才表示插入完成。如果直接对<code>size</code>属性加锁，那么冲突的概率的是比较大的。上面的数组思路就是将<code>size</code>的值分散到数组中各线程对应的槽位，那么当需要获得<code>size</code>时，只需要将每个槽位求和获得总增量，再与基数<code>baseCount</code>相加就获得了真正的容量。将属性<code>size</code>这样一个热点数据分散，降低冲突的概率，能够更快的完成插入操作。</p><p>当然，<code>ConcurrentHashMap</code>仅仅会在万不得已发生冲突的情况下，才会采用分散热点数据的逻辑。不冲突时直接将增量加到基数上即可。<code>addCount(long,in)</code>。下面是<code>ConcurrentHashMap</code>扩容时的具体逻辑：</p><figure class="highlight java"><figcaption><span>"addCount"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">调用该方法尝试进行扩容时，首先会计算当前map的最新容量，接着才会尝试进行扩容</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCount</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, <span class="hljs-keyword">int</span> check)</span> </span>&#123;<br>    CounterCell[] as; <span class="hljs-keyword">long</span> b, s;<br>    <span class="hljs-comment">//如果CounterCell为null，表示计数过程没有发生过冲突，那么直接累加到原始容量就行了</span><br>    <span class="hljs-keyword">if</span> ((as = counterCells) != <span class="hljs-keyword">null</span> ||<br>        <span class="hljs-comment">//如果counterCells为空，那么直接尝试CAS更新容量</span><br>        <span class="hljs-comment">//下面的cas参数分别为：[对象地址]，[字段偏移]，[期望旧值]，[更新值]</span><br>        !U.compareAndSwapLong(<span class="hljs-keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;<br><br>        <span class="hljs-comment">//如果cas失败，说明更新容量时发生了冲突，那么则采用类似于分段计算的逻辑</span><br>        CounterCell a; <span class="hljs-keyword">long</span> v; <span class="hljs-keyword">int</span> m;<br>        <span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>            <span class="hljs-comment">//如果CounterCells不为空，那么就类似于HashMap，使用(hash&amp;(n-1))计算当前线程的槽索引</span><br>            <span class="hljs-comment">//最后获得对应的cellValue</span><br>            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="hljs-keyword">null</span> ||<br>            <span class="hljs-comment">//如果计算槽索引成功，那么就尝试使用CAS更新对应的cellValue，否则表示CounterCell对象还未构造</span><br>            <span class="hljs-comment">//如果更新成功，那么就会将各个CounterCell的值加起来，最后的结果就是整个map的大小</span><br>            <span class="hljs-comment">//如果更新失败，那么就会执行fullAddCount</span><br>            !(uncontended =<br>                U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;<br>            <br>            fullAddCount(x, uncontended);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (check &lt;= <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//计算一下插入后的最新大小</span><br>        s = sumCount();<br>    &#125;<br>    <span class="hljs-comment">//下半部分用来处理扩容的逻辑，可以暂时无视</span><br>    <span class="hljs-keyword">if</span> (check &gt;= <span class="hljs-number">0</span>) &#123;<br>        Node&lt;K,V&gt;[] tab, nt; <span class="hljs-keyword">int</span> n, sc;<br>        <span class="hljs-comment">//如果当前table的大小已经超过了扩容阈值</span><br>        <span class="hljs-keyword">while</span> (s &gt;= (<span class="hljs-keyword">long</span>)(sc = sizeCtl) &amp;&amp; <br>        (tab = table) != <span class="hljs-keyword">null</span> &amp;&amp;<br>        <span class="hljs-comment">//并且当前table的大小还未超过最大值</span><br>        <span class="hljs-comment">//那么就会走一个扩容的逻辑</span><br>        (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;<br>            <span class="hljs-keyword">int</span> rs = resizeStamp(n);<br>            <span class="hljs-keyword">if</span> (sc &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="hljs-number">1</span> ||<br>                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="hljs-keyword">null</span> ||<br>                    transferIndex &lt;= <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>))<br>                    transfer(tab, nt);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc,<br>                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))<br>                transfer(tab, <span class="hljs-keyword">null</span>);<br>            s = sumCount();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>根据上面的代码我梳理了一下<code>addCount()</code>的逻辑，如下所示：<br><img src="./images/addCount-workflow.drawio.svg" alt="addCount-workflow"></p><p><code>addCount(long,int)</code>的逻辑可以划分为三部分：</p><ol><li>如果<code>CounterCell</code>数组为空，那么会尝试直接更新基数<code>baseCount</code></li><li>如果<code>CounterCell</code>数组不为空，那么会尝试直接更新对应的<code>CounterCell</code>对象</li><li>最坏情况下调用<code>fullAddCount</code>重新构造<code>CounterCell</code>对象</li></ol><p><code>fullAddCount(long,boolean)</code>的逻辑还是比较复杂的，它会负责<code>CounterCell</code>数组的初始化以及当前线程对应<code>CounterCell</code>的更新，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">这个函数作用就是在当前线程对应的槽位更新cell对象，但是并不负责计算map最后的大小</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">有很多场景能用到这个函数，包括：</span><br><span class="hljs-comment">1. CounterCell数组未初始化</span><br><span class="hljs-comment">2. 对应槽位的CounterCell未初始化</span><br><span class="hljs-comment">3. CounterCell初始化，但是修改value时CAS失败</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">其中属性cellBusy是专门为该函数准备的自旋锁，在扩容或者构造新cell时使用</span><br><span class="hljs-comment">wasCounttended表示进入这个函数原因是是否未更新对应CounterCell对象失败，true为不是因为失败</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fullAddCount</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, <span class="hljs-keyword">boolean</span> wasUncontended)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-comment">//如果当前线程的hash值还为准备好，那么强制初始化</span><br>    <span class="hljs-keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="hljs-number">0</span>) &#123;<br>        ThreadLocalRandom.localInit();      <span class="hljs-comment">// force initialization</span><br>        h = ThreadLocalRandom.getProbe();<br>        wasUncontended = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">boolean</span> collide = <span class="hljs-keyword">false</span>;                <span class="hljs-comment">// True if last slot nonempty</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        CounterCell[] as; CounterCell a; <span class="hljs-keyword">int</span> n; <span class="hljs-keyword">long</span> v;<br>        <span class="hljs-comment">//case1:如果CounterCell数组已经初始化好了</span><br>        <span class="hljs-keyword">if</span> ((as = counterCells) != <span class="hljs-keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//对应槽位的CounterCell对象没有初始化，或者正在扩容，那么尝试构造新的Cell</span><br>            <span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">//如果当前没有线程持有互斥锁</span><br>                <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// Try to attach new Cell</span><br>                    <span class="hljs-comment">//先构造好一个cell对象</span><br>                    CounterCell r = <span class="hljs-keyword">new</span> CounterCell(x); <span class="hljs-comment">// Optimistic create</span><br>                    <span class="hljs-comment">//尝试获取自旋锁cellsBusy</span><br>                    <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp;<br>                        U.compareAndSwapInt(<span class="hljs-keyword">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                        <span class="hljs-keyword">boolean</span> created = <span class="hljs-keyword">false</span>;<br>                        <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">// Recheck under lock</span><br>                            CounterCell[] rs; <span class="hljs-keyword">int</span> m, j;<br>                            <span class="hljs-comment">//再次检查cell数组是否为空</span><br>                            <span class="hljs-keyword">if</span> ((rs = counterCells) != <span class="hljs-keyword">null</span> &amp;&amp;<br>                                (m = rs.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                                rs[j = (m - <span class="hljs-number">1</span>) &amp; h] == <span class="hljs-keyword">null</span>) &#123;<br>                                <span class="hljs-comment">//在cell数组的对应槽位上赋值我们先构造好的cell对象</span><br>                                rs[j] = r;<br>                                <span class="hljs-comment">//cell对象创建成功，那么可以退出循环了</span><br>                                created = <span class="hljs-keyword">true</span>;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            <span class="hljs-comment">//释放自旋锁</span><br>                            cellsBusy = <span class="hljs-number">0</span>;<br>                        &#125;<br>                        <span class="hljs-comment">//如果创建cell对象成功，那么则退出循环</span><br>                        <span class="hljs-keyword">if</span> (created)<br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-comment">//对应的槽位已经不为空了</span><br>                        <span class="hljs-keyword">continue</span>;           <span class="hljs-comment">// Slot is now non-empty</span><br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">//设置扩容标志</span><br>                collide = <span class="hljs-keyword">false</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//走到这说明对应槽位的cell对象已经构造好了</span><br>            <span class="hljs-comment">//那么就判断进入这个函数的原因是不是因为更新对应cell的时候发生冲突</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wasUncontended)       <span class="hljs-comment">// CAS already known to fail</span><br>                <span class="hljs-comment">//如果是因为更新时cas发生冲突，那么就尝试进行一次rehash更新线程的hash值，并且只会更新一次</span><br>                wasUncontended = <span class="hljs-keyword">true</span>;      <span class="hljs-comment">// Continue after rehash</span><br><br>            <span class="hljs-comment">//在rehash之后尝试进行cas操作</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//如果cell数组扩容了，或者大小已经超过了核心处理器数量，那么对于当前线程来说不会再扩容了</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (counterCells != as || n &gt;= NCPU)<br>                <span class="hljs-comment">//设置扩容标志，设为false只会走下面的else-if，不可能到达后面的扩容逻辑</span><br>                collide = <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// At max size or stale</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide)<br>                collide = <span class="hljs-keyword">true</span>;<br>            <br>            <span class="hljs-comment">//尝试加锁扩容</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp;<br>                        U.compareAndSwapInt(<span class="hljs-keyword">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//执行CounterCells数组扩容操作</span><br>                    <span class="hljs-keyword">if</span> (counterCells == as) &#123;<span class="hljs-comment">// Expand table unless stale</span><br>                        CounterCell[] rs = <span class="hljs-keyword">new</span> CounterCell[n &lt;&lt; <span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>                            rs[i] = as[i];<br>                        counterCells = rs;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    cellsBusy = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-comment">//设置扩容标志</span><br>                collide = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">continue</span>;                   <span class="hljs-comment">// Retry with expanded table</span><br>            &#125;<br><br>            <span class="hljs-comment">//重新计算当先线程的hash值</span><br>            h = ThreadLocalRandom.advanceProbe(h);<br>        &#125;<br>        <span class="hljs-comment">//case2:CounterCell数组没有被加锁，并且没有初始化</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; counterCells == as &amp;&amp;<br>                    U.compareAndSwapInt(<span class="hljs-keyword">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">boolean</span> init = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">//那么则尝试进行初始化</span><br>            <span class="hljs-keyword">try</span> &#123;                           <span class="hljs-comment">// Initialize table</span><br>                <span class="hljs-comment">//再次判断cell数组没有被初始化</span><br>                <span class="hljs-keyword">if</span> (counterCells == as) &#123;<br>                    <span class="hljs-comment">//构造一个长度为2的cell数组，因为至少有两个线程竞争更改容量，才会进入这个函数</span><br>                    CounterCell[] rs = <span class="hljs-keyword">new</span> CounterCell[<span class="hljs-number">2</span>];<br>                    <span class="hljs-comment">//在当前线程的槽位上构造cell对象</span><br>                    rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> CounterCell(x);<br>                    counterCells = rs;<br>                    init = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">//释放自旋锁</span><br>                cellsBusy = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-comment">//如果成功初始化，说明cell对象也构造好了，那么则退出循环</span><br>            <span class="hljs-keyword">if</span> (init)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//case3:CounterCell数组正在初始化，因为获取自旋锁CELLBUSY失败，则尝试直接在原来的baseCount上累加</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapLong(<span class="hljs-keyword">this</span>, BASECOUNT, v = baseCount, v + x))<br>            <span class="hljs-keyword">break</span>;                          <span class="hljs-comment">// Fall back on using base</span><br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>整个<code>fullAddCount()</code>的逻辑可以划分为三个case（详情见注释）：</p><ol><li>case1：如果<code>CounterCell</code>数组已经初始化好了，那么直接尝试在当前线程对应槽位更新<code>CounterCell</code>对象</li><li>case2：<code>CounterCell</code>数组没有初始化，也没有加锁，那么会构建一个长度为2的<code>CounterCell</code>数组，因为至少存在两个同时更新的线程才会发生冲突</li><li>case3：<code>CounterCell</code>正在进行初始化或扩容，那么则直接尝试更新<code>baseCount</code></li></ol><p>其中我认为<code>case1</code>的情况稍微复杂点，我这里展示一下它的流程图：</p><p><img src="./images/fullAddCount.drawio.svg" alt="fullAddCount"></p><p>流程图可能有疏漏，后续再精进吧。</p><h3 id="2-3-计数更新逻辑"><a href="#2-3-计数更新逻辑" class="headerlink" title="2.3 计数更新逻辑"></a>2.3 计数更新逻辑</h3><p>上面说了那么多如何更新基数<code>baseCount</code>与<code>CounterCell</code>数组，那么<code>ConcurrentHashMap</code>到底是如何利用这两个属性计算当前table的大小呢？答案就在<code>size()</code>函数中，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> n = sumCount();<br>    <span class="hljs-keyword">return</span> ((n &lt; <span class="hljs-number">0L</span>) ? <span class="hljs-number">0</span> :<br>            (n &gt; (<span class="hljs-keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :<br>            (<span class="hljs-keyword">int</span>)n);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sumCount</span><span class="hljs-params">()</span> </span>&#123;<br>    CounterCell[] as = counterCells; CounterCell a;<br>    <span class="hljs-keyword">long</span> sum = baseCount;<br>    <span class="hljs-keyword">if</span> (as != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-keyword">null</span>)<br>                sum += a.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>size()</code>方法的逻辑很简单，调用<code>sumCount()</code>方法。而<code>sumCount()</code>的逻辑就是将<code>counterCells</code>数组中的每个值累加到<code>baseCount</code>上，最后的结果就是<code>ConcurrentHashMap</code>在某一时刻的值，因为<code>size()</code>方法并不是线程安全的，有可能我们正在计数的时候，其他线程正在更改<code>counterCells</code>数组。</p><h3 id="2-4-扩容逻辑"><a href="#2-4-扩容逻辑" class="headerlink" title="2.4 扩容逻辑"></a>2.4 扩容逻辑</h3><p>扩容实际上是靠<code>addCount()</code>的后半部分来完成的，如果在<code>addCount</code>中，当前线程发现table的大小已经超过了扩容阈值，才会走一个迁移数据的逻辑，这里和<code>tryPresize()</code>的中调用<code>transfer</code>迁移逻辑完全一样，我在<a href="./ConcurrentHashMap-analysis-II.md">ConcurrentHashMap扩容分析</a>中已经详细解释了，这里不在赘述。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCount</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, <span class="hljs-keyword">int</span> check)</span></span>&#123;<br>    ...<br>    <span class="hljs-comment">//下半部分用来处理扩容的逻辑，可以暂时无视</span><br>    <span class="hljs-keyword">if</span> (check &gt;= <span class="hljs-number">0</span>) &#123;<br>        Node&lt;K,V&gt;[] tab, nt; <span class="hljs-keyword">int</span> n, sc;<br>        <span class="hljs-comment">//如果当前table的大小已经超过了扩容阈值</span><br>        <span class="hljs-keyword">while</span> (s &gt;= (<span class="hljs-keyword">long</span>)(sc = sizeCtl) &amp;&amp; <br>        (tab = table) != <span class="hljs-keyword">null</span> &amp;&amp;<br>        <span class="hljs-comment">//并且当前table的大小还未超过最大值</span><br>        <span class="hljs-comment">//那么就会走一个扩容的逻辑</span><br>        (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;<br>            <span class="hljs-keyword">int</span> rs = resizeStamp(n);<br>            <span class="hljs-keyword">if</span> (sc &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="hljs-number">1</span> ||<br>                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="hljs-keyword">null</span> ||<br>                    transferIndex &lt;= <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>))<br>                    transfer(tab, nt);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc,<br>                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))<br>                transfer(tab, <span class="hljs-keyword">null</span>);<br>            s = sumCount();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-删除操作原理"><a href="#3-删除操作原理" class="headerlink" title="3. 删除操作原理"></a>3. 删除操作原理</h2><p>删除操作就比较简单了，核心函数是<code>replaceNode(object,V,Object)</code>，该函数实现了两种功能：</p><ol><li>更新旧值</li><li>删除键值对</li></ol><p>那么具体采用哪种操作取决于第三个参数<code>cv</code>，当不为null时则表示当前操作是更新旧值操作。具体逻辑如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> replaceNode(key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Implementation for the four public remove/replace methods:</span><br><span class="hljs-comment">* Replaces node value with v, conditional upon match of cv if</span><br><span class="hljs-comment">* non-null.  If resulting value is null, delete.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/*该函数实现了替换旧值或者删除节点的操作</span><br><span class="hljs-comment">如果cv不为空，则表示当前是替换旧值的操作</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">replaceNode</span><span class="hljs-params">(Object key, V value, Object cv)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> hash = spread(key.hashCode());<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-keyword">int</span> n, i, fh;<br>        <span class="hljs-comment">//计算当前key对应的桶索引</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span> ||<br>            (f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//如果当前table正在扩容，那么尝试协助</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-keyword">else</span> &#123;<br>            V oldVal = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">boolean</span> validated = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">//与插入类似，先对当前key所在的桶加锁</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    <span class="hljs-comment">//如果当前桶采用链表存储</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        ...<br>                    &#125;<br>                    <span class="hljs-comment">//如果当前桶采用红黑树存储</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        ...<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (validated) &#123;<br>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>)<br>                        <span class="hljs-comment">//如果是删除操作，那么需要更新大小</span><br>                        addCount(-<span class="hljs-number">1L</span>, -<span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">return</span> oldVal;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>实在没什么好说的，只不过在插入的时候，类似的，如果发现当前处理的桶正在扩容，那么就会调用<code>helpTransfer()</code>作为协助者进行数据迁移。并且在删除后会调用<code>addCount</code>更新大小。</p><h2 id="4-疑问"><a href="#4-疑问" class="headerlink" title="4. 疑问"></a>4. 疑问</h2><ol><li>为什么在Java1.8之后，<code>ConcurrentHashMap</code>采用<code>synchronized</code>而放弃了分段锁？</li></ol><p>通过  JDK 的源码和官方文档看来， 他们认为的弃用分段锁的原因由以下几点：</p><ul><li>加入多个分段锁浪费内存空间。</li><li>生产环境中， map 在放入时竞争同一个锁的概率非常小，分段锁反而会造成更新等操作的长时间等待。</li><li>为了提高 GC 的效率</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://segmentfault.com/a/1190000016096542">Java多线程进阶（二三）—— J.U.C之collections框架：ConcurrentHashMap(1) 原理</a></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/Java/">Java</category>
      
      
      <category domain="https://eripe.me/tags/ConcurrentHashMap/">ConcurrentHashMap</category>
      
      
      <comments>https://eripe.me/articles/ConcurrentHashMap-analysis-I.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ThreadPoolExecutor线程池解析</title>
      <link>https://eripe.me/articles/ThreadPoolExecutor.html</link>
      <guid>https://eripe.me/articles/ThreadPoolExecutor.html</guid>
      <pubDate>Fri, 26 Mar 2021 02:52:34 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;0-预备知识&quot;&gt;&lt;a href=&quot;#0-预备知识&quot; class=&quot;headerlink&quot; title=&quot;0. 预备知识&quot;&gt;&lt;/a&gt;0.</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="0-预备知识"><a href="#0-预备知识" class="headerlink" title="0. 预备知识"></a>0. 预备知识</h2><p>在了解<code>ThreadPoolExecutor</code>之前，我们首先需要了解一些基本概念，下图是<code>ThreadPoolExecutor</code>的部分核心字段。我先依次对其进行解释。</p><p><img src="images/ThreadPoolExecutor-fields.png" alt="ThreadPoolExecutor"></p><h3 id="0-1-线程池状态"><a href="#0-1-线程池状态" class="headerlink" title="#0.1 线程池状态"></a>#0.1 线程池状态</h3><p>JUC为线程池规定了5种状态，如下图所示：<br><img src="images/Executor-state.drawio.svg" alt="executor-state"></p><p>对于每种状态，含义如下：</p><ol><li>RUNNING: 线程池能够接受任务并处理阻塞队列中的任务</li><li>SHUTDOWN: 不再接受新的任务，但是会把阻塞队列中的任务全部执行完毕</li><li>STOP: 不再接受新的任务，不再处理阻塞队列中的任务，并且会中断正在执行的任务</li><li>TIDYING:  所有的任务都被终止，工作线程的数量为0，并且在转化为该状态时，线程池会执行<code>terminated()</code>方法</li><li>TERMINATED: <code>terminated()</code>方法执行完毕</li></ol><p>了解了线程池的五种状态后，那么它底层到底是如何实现的呢？其实也不复杂。<code>ThreadPoolExecutor</code>通过一个<code>AtomicInterger</code>维护了这五种状态。实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY   = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// runState is stored in the high-order bits</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING    = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br></code></pre></div></td></tr></table></figure><p>对于一个32为的<code>AtomicInteger</code>来说，它的信息分为两部分：</p><ul><li>第30~32位：线程池的状态</li><li>第1~29位，线程池中的线程数量</li></ul><p>从上面的定义中我们得知：<code>ctl</code>属性维护上述的两组信息，并且在初始化时会将线程数量设为0。获取状态时只需要通过<code>runStateOf(int)</code>方法获取<code>ctl</code>属性的高3位即可，对于线程数量的获取同理。</p><h3 id="0-2-线程池互斥锁"><a href="#0-2-线程池互斥锁" class="headerlink" title="#0.2 线程池互斥锁"></a>#0.2 线程池互斥锁</h3><p><code>ThreadPoolExecutor</code>内部维护了一个<code>ReentrantLock</code>用来实现对工作线程集合的互斥访问，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">new</span> ReentrantLock();<br></code></pre></div></td></tr></table></figure><p>因为在多线程环境，操作一个hashSet可能会出现线程不安全的问题。至于为什么不适用一个线程安全的set，是因为使用锁可以对<code>interruptIdleWorkers()</code>的操作进行序列化，从而避免了不必要的中断风暴，尤其是在关闭线程池期间。并且还能够简化一些数据的统计。</p><h3 id="0-3-线程包装类Worker"><a href="#0-3-线程包装类Worker" class="headerlink" title="#0.3 线程包装类Worker"></a>#0.3 线程包装类Worker</h3><p>在<code>ThreadPoolExecutors</code>中，定义了一个不可变对象<code>Worker</code>作为线程的wrapper，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span></span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * This class will never be serialized, but we provide a</span><br><span class="hljs-comment">    * serialVersionUID to suppress a javac warning.</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">6138294804551838833L</span>;<br><br>    <span class="hljs-comment">//具体执行任务的线程，为null表示出现错误</span><br>    <span class="hljs-keyword">final</span> Thread thread;<br>    <span class="hljs-comment">//worker执行的第一个任务，可能为null</span><br>    Runnable firstTask;<br><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> completedTasks;<br><br>    Worker(Runnable firstTask) &#123;<br>        <span class="hljs-comment">//防止在当前线程执行runWorker之前，就收到中断</span><br>        setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>        <span class="hljs-keyword">this</span>.firstTask = firstTask;<br>        <span class="hljs-keyword">this</span>.thread = getThreadFactory().newThread(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        runWorker(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Lock methods</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// The value 0 represents the unlocked state.</span><br>    <span class="hljs-comment">// The value 1 represents the locked state.</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>            setExclusiveOwnerThread(Thread.currentThread());<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br>        setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>        setState(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span>        </span>&#123; acquire(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span>  </span>&#123; <span class="hljs-keyword">return</span> tryAcquire(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span>      </span>&#123; release(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLocked</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> isHeldExclusively(); &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">interruptIfStarted</span><span class="hljs-params">()</span> </span>&#123;<br>        Thread t;<br>        <span class="hljs-keyword">if</span> (getState() &gt;= <span class="hljs-number">0</span> &amp;&amp; (t = thread) != <span class="hljs-keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.interrupt();<br>            &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>之所以要包装呢，是因为<code>Worker</code>可以比<code>Thread</code>提供更多的信息。例如当前<code>worker</code>累计执行了多少个任务。其实我们还可以注意到<code>Worker</code>继承了AQS。那么这里就会出现两个问题：</p><ol><li>为什么要继承AQS？一个<code>Worker</code>要锁干嘛？一个<code>Worker</code>不是自己负责一个任务吗？难道会有多个线程访问同一个<code>Worker</code>？</li><li>使用线程的锁不行吗？为什么要自己实现一个锁？</li></ol><p>那么对于第一个问题，其实这个问题在注释中已经说明了：</p><blockquote><p>Class Worker mainly <strong>maintains interrupt control state</strong> for threads running tasks, along with other minor bookkeeping. This class opportunistically extends AbstractQueuedSynchronizer to simplify acquiring and releasing a lock <strong>surrounding each task execution</strong>. This protects against interrupts that are intended to wake up a worker thread waiting for a task from instead interrupting a task being run. </p></blockquote><blockquote><p>We implement a simple <strong>non-reentrant mutual exclusion lock</strong> rather than use ReentrantLock because we do not want worker tasks to be able to reacquire the lock when they invoke pool control methods like setCorePoolSize. Additionally, to suppress interrupts until the thread actually starts running tasks, we initialize lock state to a negative value, and clear it upon start (in runWorker).</p></blockquote><p>大致意思是说：<br><code>Worker</code>类会管理线程在执行任务时的中断状态，以及一些其他的信息。<code>Worker</code>继承AQS是为了实现一个简单的不可重入的锁，用来在执行任务前上锁，在任务完毕后后释放锁。<strong>上锁的原因是因为如果有中断发生，那么只希望中断那些正在等待任务的<code>Worker</code>，而不是中断那些正在执行任务的<code>Worker</code>。</strong></p><p>自己实现一个简单的<strong>不可重入</strong>的锁是因为已有的锁都是可重入的，线程池需要一个不可重入锁的才能达到上面的目的。那么为什么不可重入的就能达到目的呢？考虑下面一个场景：假设主线程调用了<code>setCorePoolSize(int)</code>调整线程池的大小，那么<code>ThreadPoolExecutor</code>希望这个调整的动作不要影响那些正在执行任务的<code>Worker</code>，所以就通过能否获取<code>Worker</code>对应的锁来判断当前<code>Worker</code>是否处于空闲状态，那么这里的锁只能是独占锁。若是可重入锁，那么，无论是等待任务的，还是正在执行的，都会被中断。<code>setCorePoolSize(int)</code>如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//调用该函数需要中断那些空闲的线程</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCorePoolSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (workerCountOf(ctl.get()) &gt; corePoolSize)<br>        interruptIdleWorkers();<br>    ...<br>&#125;<br><br><span class="hljs-comment">//判断一个线程是否空闲就是看能否获取对应worker的不可重入独占锁</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> onlyOne)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (Worker w : workers) &#123;<br>            Thread t = w.thread;<br>            <span class="hljs-comment">//能够成功获取不可重入锁就表示当前Worker没有执行任务，自然可以执行中断</span><br>            <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    t.interrupt();<br>                &#125;<br>                ...<br>            &#125;<br>            ...<br>        &#125;<br>    &#125;<br>    ...<br></code></pre></div></td></tr></table></figure><h3 id="0-4-线程工厂-ThreadFactory"><a href="#0-4-线程工厂-ThreadFactory" class="headerlink" title="#0.4 线程工厂:ThreadFactory"></a>#0.4 线程工厂:ThreadFactory</h3><p>所谓的线程的工厂，JUC提供了一个线程工厂接口<code>ThreadFactory</code>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ThreadFactory</span> </span>&#123;<br>    <span class="hljs-function">Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>唯一需要重写的方法就是生产新线程的方法<code>newThread(Runnable)</code>。对<code>ThreadPoolExecutor</code>，它内部实现了两种工厂类：<code>DefaultThreadFactory</code>和<code>PrivilegedThreadFactory</code>。</p><p>区别就是前者生产的线程优先级默认为5，后者对于新生产的线程和调用线程工厂的线程具有相同优先级，并具有相同的线程上下文类加载器。下面只列出默认工厂的代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ThreadFactory</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicInteger poolNumber = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadGroup group;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger threadNumber = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String namePrefix;<br><br>    DefaultThreadFactory() &#123;<br>        SecurityManager s = System.getSecurityManager();<br>        group = (s != <span class="hljs-keyword">null</span>) ? s.getThreadGroup() :<br>                                Thread.currentThread().getThreadGroup();<br>        namePrefix = <span class="hljs-string">&quot;pool-&quot;</span> +<br>                        poolNumber.getAndIncrement() +<br>                        <span class="hljs-string">&quot;-thread-&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(group, r,<br>                                namePrefix + threadNumber.getAndIncrement(),<br>                                <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (t.isDaemon())<br>            t.setDaemon(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-comment">//设置新线程的默认优先级为5</span><br>        <span class="hljs-keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)<br>            t.setPriority(Thread.NORM_PRIORITY);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="0-5-拒绝策略-defaultHandler"><a href="#0-5-拒绝策略-defaultHandler" class="headerlink" title="#0.5 拒绝策略:defaultHandler"></a>#0.5 拒绝策略:defaultHandler</h3><p>对于拒绝策略，我在讲解<a href="executor-interface.md">Executor框架</a>时曾说过，自带的拒绝策略有四种，而<code>ThreadPoolExecutor</code>默认采用的是AbortPolicy，直接拒绝提交的任务，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbortPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(<span class="hljs-string">&quot;Task &quot;</span> + r.toString() +<br>                                                <span class="hljs-string">&quot; rejected from &quot;</span> +<br>                                                e.toString());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="0-6-阻塞队列-workQueue"><a href="#0-6-阻塞队列-workQueue" class="headerlink" title="#0.6 阻塞队列:workQueue"></a>#0.6 阻塞队列:workQueue</h3><h2 id="1-任务添加流程"><a href="#1-任务添加流程" class="headerlink" title="1. 任务添加流程"></a>1. 任务添加流程</h2><p>阅读过源码的同学都知道，<code>ThreadPoolExecutor</code>并没有重写<code>ExecutorService</code>的<code>submit(Runnable)</code>的方法。当我们调用<code>submit</code>时实际调用的是<code>AbstractExecutorService</code>重写的<code>submit</code>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-keyword">null</span>);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在<code>submit</code>中又会调用<code>ThreadPoolExecutor</code>重写的<code>execute(Runnable)</code>方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <br>    <span class="hljs-keyword">int</span> c = ctl.get();<br>    <span class="hljs-comment">//如果当前线程池的线程数量小于核心线程数</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-comment">//尝试设置线程的第一个任务，因为通过execute调用addWorker，那么一定是</span><br>        <span class="hljs-comment">//因为有新任务进来了</span><br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br>    <span class="hljs-comment">//走到这说明线程数已经不小于核心线程数了</span><br>    <br>    <span class="hljs-comment">//如果线程池处于running状态，但是无法向阻塞队列中添加任务</span><br>    <span class="hljs-comment">//那么尝试添加新的worker</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-keyword">int</span> recheck = ctl.get();<br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))<br>        reject(command);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>主要的流程分为三步：</p><ol><li>如果当前活跃的线程的数量小于核心线程数，那么就尝试调用<code>addWaiter(Runnable,boolean)</code>增加一个线程，如果成功直接返回，否则执行2</li><li>走到这里说明线程数至少不小于核心线程数，那么尝试向阻塞队列中添加任务，如果添加成功，我们仍然需要通过双重检查是否应该增加线程（因为有可能在上次检查之后，线程池中的线程全部死亡），如果线程全部死亡，那么则尝试添加一个Worker。</li><li>如果无法向阻塞队列中添加任务，说明阻塞队列已满，如果此时无法增加worker，那么则会根据拒绝策略拒绝当前任务</li></ol><p>添加<code>worker</code>的方法<code>addWaiter(Runnable,boolean)</code>如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">返回true表示成功添加了工作线程并启动</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">但是返回false的情况有很多，但是都会进行回滚操作：</span><br><span class="hljs-comment">1. 表示线程池已经stop或者即将关闭</span><br><span class="hljs-comment">2. 线程创建失败，要么是因为线程工厂返回null，或者在启动线程的时候内存溢出，</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//第一个参数表示当前worker是否有第一个任务</span><br><span class="hljs-comment">//第二个参数core表示当前线程数量的上限是选核心线程数还是最大线程数</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;<br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-comment">//获取线程池状态</span><br>        <span class="hljs-keyword">int</span> rs = runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-comment">//如果当前线程池已经shutdown及之后的状态</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            <span class="hljs-comment">//线程不是shutdown状态，表示已经进入stop或tidying</span><br>            <span class="hljs-comment">//线程池是shutdown状态，并且firstTask不为空，但是shutdown状态不再接受任务，所以返回false</span><br>            <span class="hljs-comment">//线程池是shutdown状态，并且firstTask为空，并且阻塞队列为空，没有任务要执行，自然返回false</span><br><br>            ! (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span> &amp;&amp; ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br>            <span class="hljs-comment">//如果线程池的线程数量已经超过了最大容量，返回false</span><br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                <span class="hljs-comment">//如果以核心线程数作界限，那么就看当前线程数是否超过了核心线程数</span><br>                <span class="hljs-comment">//只有在队列满之后core才会为false</span><br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">//线程数没超标，那么添加线程</span><br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            <span class="hljs-comment">//cas失败说明有多个线程在同时添加任务</span><br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-comment">//如果线程池的状态发生改变，那么retry</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;<br>    Worker w = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//生成一个Worker</span><br>        w = <span class="hljs-keyword">new</span> Worker(firstTask);<br>        <span class="hljs-keyword">final</span> Thread t = w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck while holding lock.</span><br>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                <span class="hljs-comment">// shut down before lock acquired.</span><br>                <span class="hljs-keyword">int</span> rs = runStateOf(ctl.get());<br>                <span class="hljs-comment">//检查线程池是否已经关闭</span><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;<br>                    <span class="hljs-comment">//判断线程工厂创建线程是否成功</span><br>                    <span class="hljs-keyword">if</span> (t.isAlive())<br>                        <span class="hljs-comment">//预先检查新worker的状态</span><br>                        <span class="hljs-comment">//如果在我们没有启动线程的情况，线程就alive肯定要抛出异常</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();<br>                    <span class="hljs-comment">//将新生成的worker添加到线程池中，其实就是一个HashSet</span><br>                    workers.add(w);<br>                    <span class="hljs-keyword">int</span> s = workers.size();<br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                <span class="hljs-comment">//启动线程</span><br>                t.start();<br>                workerStarted = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中逻辑还是比较清晰的，在生成线程后如果能成功启动，那么则返回true，否则会调用<code>addWorkerFailed</code>进行回滚操作。</p><p>值得注意的是在访问<code>worker</code>集合<code>workers</code>的时候，需要保证互斥访问。具体原理在预备知识中已经介绍过。</p><h2 id="2-线程工作流程"><a href="#2-线程工作流程" class="headerlink" title="2. 线程工作流程"></a>2. 线程工作流程</h2><p>在启动<code>worker</code>之后，最后在<code>worker</code>的<code>run()</code>方法中会调用<code>runWorker(Worker)</code>实现不断的从阻塞队列中获取任务，并调用任务的<code>run()</code>执行。</p><p>值得注意的是：在当前<code>worker</code>获取到新任务时，会使用自身的不可重入独占锁进行一个加锁操作，这个操作标志着当前<code>worker</code>已经开始执行具体的任务了，暂时屏蔽线程池发出的中断。</p><p><code>runWorker(Worker)</code>代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runWorker</span><span class="hljs-params">(Worker w)</span> </span>&#123;<br>    Thread wt = Thread.currentThread();<br>    Runnable task = w.firstTask;<br>    w.firstTask = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//需要首先解锁一次，因为一个worker最初始的状态为-1，这么做是为了防止</span><br>    <span class="hljs-comment">//worker在执行runWorker之前就收到了中断，例如在主函数关闭了线程池，</span><br>    w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>    <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//如果获取不到新的任务，那么就会退出循环</span><br>        <span class="hljs-comment">//getTask在线程池至少处于shutdown时，会返回null</span><br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = getTask()) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//使用worker的锁，表示当前worker已经获得新任务，暂时屏蔽中断</span><br>            w.lock();<br><br>            <span class="hljs-comment">//如果线程池进入stopping状态，那么必须保证当前worker被中断</span><br>            <span class="hljs-comment">//否则，必须保证当前worker不能被中断</span><br>            <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>            <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>            <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>            <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                    <span class="hljs-comment">//这里做的是二次检查，有可能用户突然调用了shutdownNow</span><br>                    (Thread.interrupted() &amp;&amp;<br>                    runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())<br>                wt.interrupt();<br>            <span class="hljs-keyword">try</span> &#123;<br>                beforeExecute(wt, task);<br>                Throwable thrown = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//执行任务自己的run方法</span><br>                    task.run();<br>                <span class="hljs-comment">//捕捉任务可能抛出的异常，然后从线程池抛出</span><br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(x);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    afterExecute(task, thrown);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-keyword">null</span>;<br>                w.completedTasks++;<br>                w.unlock();<br>            &#125;<br>        &#125;<br>        completedAbruptly = <span class="hljs-keyword">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//如果一个线程无法再获取新的任务，那么就会将当前线程销毁</span><br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-1-获取新任务的流程"><a href="#2-1-获取新任务的流程" class="headerlink" title="2.1 获取新任务的流程"></a>2.1 获取新任务的流程</h3><p>每当<code>worker</code>完成一个任务后，会尝试调用<code>getTask()</code>从我们提供的阻塞队列中获取新的任务。当阻塞队列为空时，该函数可以无限时等待或者有限等待，这需要根据是否允许核心线程过期来抉择。</p><p>如果该函数返回null就表示当前worker已经结束使命了，可以终结了。返回null的情况很多：</p><ol><li>线程池已经处于STOPING状态</li><li>线程池已经处于SHUTDOWN状态并且阻塞队列为空</li><li>线程数已经超过最大值</li><li>当前worker等待新任务的时间过长，也就是说等待的时长超过了一个核心线程的存活时长</li></ol><p>否则返回一个新的任务具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title">getTask</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> timedOut = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-keyword">int</span> rs = runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-comment">//如果线程已经至少处于SHUTDOWN状态并且empty为空，因为后续都不可能有新任务提交，那么直接返回null</span><br>        <span class="hljs-comment">//表示当前worker的工作可以结束了</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            <span class="hljs-comment">//将线程数减1</span><br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br><br>        <span class="hljs-comment">// Are workers subject to culling?</span><br>        <span class="hljs-keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;<br><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Runnable r = timed ?<br>                <span class="hljs-comment">//收到中断时take会抛出InterruptException</span><br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-2-worker退出流程"><a href="#2-2-worker退出流程" class="headerlink" title="2.2 worker退出流程"></a>2.2 worker退出流程</h3><p>从上面<code>runWorker(Worker)</code>的处理流程可以看到，当一个<code>Worker</code>无法获得新任务时，那么就会调用<code>processWorkerExit(Worker,boolean)</code>将当前<code>Worker</code>移出线程集合，并根据当前池内的线程数量来决定是否要添加新的<code>Worker</code>，实现逻辑如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-keyword">boolean</span> completedAbruptly)</span> </span>&#123;<br>    <span class="hljs-comment">//如果工作线程的结束是因为用户的代码产生了异常</span><br>    <span class="hljs-keyword">if</span> (completedAbruptly) <span class="hljs-comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span><br>        decrementWorkerCount();<br><br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    <span class="hljs-comment">//对线程集合进行互斥访问</span><br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        completedTaskCount += w.completedTasks;<br>        <span class="hljs-comment">//将当前线程移出工作队列</span><br>        workers.remove(w);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br><br>    <span class="hljs-comment">//尝试关闭线程池</span><br>    tryTerminate();<br><br>    <span class="hljs-keyword">int</span> c = ctl.get();<br>    <span class="hljs-comment">//如果当前线程池处于RUNNING/SHUTDOWN状态</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 那么这里可能会产生一个问题：如果处于SHUTDOWN状态，我们应该将所有的Worker移出集合</span><br><span class="hljs-comment">    * 但是SHUTDOWN是可以通过下面的if条件，那么最后又会执行addWorker()，又往集合中添加一个新的worker</span><br><span class="hljs-comment">    * 那岂不是集合内的worker永远都无法彻底移出？</span><br><span class="hljs-comment">    * 其实这种担心是多虑的，因为addWorker()会首先检查当前线程池的状态，如果为SHUTDOWN，直接返回false</span><br><span class="hljs-comment">    * 并不会构造新的worker</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;<br>        <span class="hljs-comment">//如果工作线程是正常地结束</span><br>        <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;<br>            <span class="hljs-keyword">int</span> min = allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;<br>            <span class="hljs-comment">//如果核心线程有失效时间限制并且阻塞队列不为空</span><br>            <span class="hljs-comment">//那么线程池中至少要保留一个线程</span><br>            <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.isEmpty())<br>                min = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// replacement not needed</span><br>        &#125;<br>        <span class="hljs-comment">//如果线程数量小于min，那么需要补上一个新的worker</span><br>        addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在将无法获得任务的线程移出集合后，会根据当前是否允许核心线程过期获得线程池的最低线程数量：</p><ol><li>如果当前线程数量仍然不小于最低限度，直接返回即可，不需要重新补充<code>Worker</code></li><li>如果当前线程数小于最低限度，那么需要最后调用<code>addWorker()</code>重新补充一个<code>Worker</code></li></ol><h2 id="3-线程池终止流程"><a href="#3-线程池终止流程" class="headerlink" title="3. 线程池终止流程"></a>3. 线程池终止流程</h2><p><strong>对于线程池来说，关闭线程池（shutdown）和终止线程池（terminate）完全是两码事</strong>。所谓的关闭，是指线程池不再接受新的任务，而终止则是线程池中的所有工作线程都已经正确地关闭。</p><h3 id="3-1-shutdown-的执行逻辑"><a href="#3-1-shutdown-的执行逻辑" class="headerlink" title="3.1 shutdown()的执行逻辑"></a>3.1 shutdown()的执行逻辑</h3><p><code>ThreadPoolExectuor</code>提供了两种方法<code>shutdown</code>和<code>shutdownNow</code>用来关闭线程池。对于前者，它会保证已经提交到阻塞队列的任务被执行，并不是等到任务都执行完毕才会关闭线程池。在关闭的流程中，一直有一个问题困扰着我：为什么要通过调用<code>interrupt()</code>抛出中断当作线程池关闭的信号？带着这个问题，我首先梳理了<code>shutdown()</code>的逻辑。首先我们来看看<code>shutdown()</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//检查是否有权限关闭线程池</span><br>        checkShutdownAccess();<br>        <span class="hljs-comment">//将当前线程池升级到SHUTDOWN状态</span><br>        advanceRunState(SHUTDOWN);<br>        <span class="hljs-comment">//中断空闲的线程</span><br>        interruptIdleWorkers();<br>        <span class="hljs-comment">//为周期任务线程池准备的hook函数</span><br>        onShutdown();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    <span class="hljs-comment">//尝试真正地终止线程</span><br>    tryTerminate();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从源码中我们得知：当调用<code>shutdown()</code>方法后，首先会将线程池状态转化到SHUTDOWN。然后中断空闲的线程。那么这里就有两个问题：</p><ol><li>为什么要中断空闲线程？</li><li>为什么关闭线程池需要通过中断这个操作？</li></ol><p>对于第一个问题，先说说我的理解：所谓的关闭关闭线程池就是将每个工作线程正确关闭，又因为<code>shutdown()</code>不影响正在执行任务的线程，所以就先关闭空闲的线程。那么我们来看看<code>interruptIdleWorkers()</code>到底是如何运作的：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> onlyOne)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//遍历工作线程集合，找出空闲的线程并抛出中断</span><br>        <span class="hljs-keyword">for</span> (Worker w : workers) &#123;<br>            Thread t = w.thread;<br>            <span class="hljs-comment">//如果线程没有被中断并且能够获取worker的独占锁</span><br>            <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    t.interrupt();<br>                &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    w.unlock();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (onlyOne)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在分析<code>Worker</code>的工作流程时，曾说到，当一个<code>worker</code>正在执行任务时，会使用自身的独占不可重入锁上锁。那么在查询空闲<code>worker</code>时就利用了这个特点：<code>w.tryLock()</code>成功就说当前<code>worker</code>没有上锁，那也就是没有执行任务，自然可以关闭了。</p><p>那么这里的关闭的操作实际上调用当前<code>worker</code>的<code>interrupt()</code>函数发出一个中断，why？我们思考如下一个场景：</p><p>首先我们中断的都是空闲线程，那么空闲线程都在干嘛？是不是都在等待获取新的任务？那么如何等待？也就是通过调用阻塞队列的<code>take()</code>方法（无限等待场景下），当我们发生一个中断时，<code>take()</code>方法会抛出一个<code>InterruptException</code>，会在<code>getTask()</code>方法中被捕获。</p><p>捕获之后，也就说明被中断的<code>worker</code>已经被唤醒了。那么会重新执行循环，在循环初始部分，会判断当前线程池的状态，如果为SHUTDOWN或者类似的，会返回null。返回null表示什么？表示当前<code>worker</code>可以结束使命了，那么会跳出<code>runWorker()</code>中的循环，执行<code>processWorkerExit(Worker,boolean)</code>。在<code>processWorkerExit(Worker,boolean)</code>中，又会调用<code>tryTerminate()</code>尝试终止线程池。该函数的任务就是当线程池数量为0，将线程池状态转化为TIDYING状态，并执行hook函数<code>terminated()</code>。最后转化为TERMINATED状态。</p><p>值得注意的是，<code>tryTerminate()</code>中会调用<code>interruptIdleWorkers(ONLY_ONE)</code>传播线程池准备终止的信息。那么怎么传播呢？我们观察上述<code>interruptIdleWorkers()</code>函数的源码，因为我们传入的参数为true，那么会随机中断一个空闲线程<code>worker</code>。而空闲线程在被移出线程集合后，又会调用<code>processWorkerExit(Worker,boolean)</code>。周而复始，最后所有的空闲工作线程都会收到中断。<code>tryTerminate()</code>逻辑如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//这个方法只能在可能需要终止线程池的时候调用，例如剔除无用worker或者在shutdown状态移出队列任务</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryTerminate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-comment">//如果线程池处于RUNNING状态</span><br>        <span class="hljs-comment">//如果线程池正在处于终止状态</span><br>        <span class="hljs-comment">//或者线程池处于SHUTDOWN并且阻塞队列不为空</span><br>        <span class="hljs-comment">//那么就不需要再终止了，终止一次就够了</span><br>        <span class="hljs-keyword">if</span> (isRunning(c) ||<br>            runStateAtLeast(c, TIDYING) ||<br>            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//走到这说明线程池没有任务需要执行了，处于需要终止的状态</span><br><br>        <span class="hljs-comment">//如果线程数量不为0，那么就尝试中断最多一个空闲线程，并传播这个中断状态</span><br>        <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Eligible to terminate</span><br>            interruptIdleWorkers(ONLY_ONE);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//如果池中的线程数量为0，那么尝试将线程池状态转化为TIDYING</span><br>        <span class="hljs-comment">//如果转化成功，则会执行hook函数terminated()，并把线程池状态转化为TERMINATED</span><br>        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    terminated();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));<br>                    <span class="hljs-comment">//唤醒在awaitTermination条件上等待的线程</span><br>                    termination.signalAll();<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>        <span class="hljs-comment">// else retry on failed CAS</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么这里又有一个问题了，上面中断的都是空闲工作线程，如果我们执行<code>shutdown()</code>时，没有空闲线程怎么办？正在执行任务的线程如何被回收？岂不是会在<code>runWorker()</code>中，因为调用<code>getTask()</code>一直被阻塞直到获取新的任务，但是又永远都不会有新任务？我想了很久，最后发现答案竟然在<code>getTask()</code>的源码中。当我们的工作线程执行完当前任务后，会再次调用<code>getTask()</code>，而<code>getTask()</code>在一开始就会判断当前线程池的状态，如果状态为SHUTDOWN并且阻塞队列为空，那么直接返回，不会被阻塞。从而最后也会执行<code>processWorkerExit(Worker,boolean)</code>，传播中断状态。</p><h3 id="3-2-shutdownNow的区别"><a href="#3-2-shutdownNow的区别" class="headerlink" title="3.2 shutdownNow的区别"></a>3.2 shutdownNow的区别</h3><p>对于<code>shutdownNow()</code>方法，跟<code>shutdown()</code>流程差不多。唯一不同的是：<code>shutdownNow()</code>不管<code>worker</code>有没有执行任务，只要<code>worker</code>执行过<code>runWorker(Worker)</code>函数，就发出一个中断请求。我们需要注意的是：中断请求对于空闲线程来说是一定有限的；对于正在执行任务的线程，这需要用户任务的配合，也就说用户任务能够处理中断才能结束未完成的任务。后续的流程就跟<code>shutdown()</code>几乎一样。调用<code>tryTerminate()</code>尝试终止线程池。<code>shutdownNow()</code>方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Attempts to stop all actively executing tasks, halts the</span><br><span class="hljs-comment">* processing of waiting tasks, and returns a list of the tasks</span><br><span class="hljs-comment">* that were awaiting execution. These tasks are drained (removed)</span><br><span class="hljs-comment">* from the task queue upon return from this method.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* &lt;p&gt;This method does not wait for actively executing tasks to</span><br><span class="hljs-comment">* terminate.  Use &#123;<span class="hljs-doctag">@link</span> #awaitTermination awaitTermination&#125; to</span><br><span class="hljs-comment">* do that.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* &lt;p&gt;There are no guarantees beyond best-effort attempts to stop</span><br><span class="hljs-comment">* processing actively executing tasks.  This implementation</span><br><span class="hljs-comment">* cancels tasks via &#123;<span class="hljs-doctag">@link</span> Thread#interrupt&#125;, so any task that</span><br><span class="hljs-comment">* fails to respond to interrupts may never terminate.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span> </span>&#123;<br>List&lt;Runnable&gt; tasks;<br><span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>mainLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    checkShutdownAccess();<br>    advanceRunState(STOP);<br>    interruptWorkers();<br>    tasks = drainQueue();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    mainLock.unlock();<br>&#125;<br>tryTerminate();<br><span class="hljs-keyword">return</span> tasks;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="4-内置线程池"><a href="#4-内置线程池" class="headerlink" title="4. 内置线程池"></a>4. 内置线程池</h2><p>JUC中提供了四种基于<code>ThreadPoolExecutor</code>的内置线程池：</p><ol><li><p><strong>newFixedThreadPool</strong>：核心线程数和最大线程数相等的线程，阻塞队列无限长度。也就是说线程池的线程数量固定</p></li><li><p><strong>newCachedThreadPool</strong>：核心线程数为0的线程池，并且阻塞队列不存储任务。也就是说该线程池只会使用非核心线程来处理任务，如果超过60秒等不到新的任务，那么则会回收当前线程</p></li><li><p><strong>newSingleThreadExecutor</strong>：线程池的线程数量为1，阻塞队列无限长度。也就是线程数量固定为1的线程池。该线程池能够保证任务串行地完成</p></li><li><p><strong>newScheduledThreadPool</strong>：核心线程数固定地的周期任务线程池</p></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><p><a href="https://segmentfault.com/a/1190000016586578">Java多线程进阶（三九）—— J.U.C之executors框架：executors框架概述</a></p></li><li><p><a href="https://javamana.com/2021/02/20210228205934972L.html">Java并发之ThreadPoolExecutor源码解析（三）</a></p></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="https://eripe.me/tags/Executor/">Executor</category>
      
      
      <comments>https://eripe.me/articles/ThreadPoolExecutor.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Exectuor框架解析</title>
      <link>https://eripe.me/articles/Executor-interface.html</link>
      <guid>https://eripe.me/articles/Executor-interface.html</guid>
      <pubDate>Tue, 23 Mar 2021 13:48:05 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;1-Executor接口&quot;&gt;&lt;a href=&quot;#1-Executor接口&quot; class=&quot;headerlink&quot; title=&quot;1. Executor接口&quot;&gt;&lt;/a&gt;1.</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1-Executor接口"><a href="#1-Executor接口" class="headerlink" title="1. Executor接口"></a>1. Executor接口</h2><p>在JUC包中，还提供了Executor框架用来实现线程池，我们经常使用的线程池都是从Executor派生而来。我们可以看看整个Executor框架的继承结构：</p><p><img src="images/executor-framework.png" alt="executor-framework"></p><p>那么在这个框架中，我们第一步应该需要了解它的核心接口<code>Executor</code>。这个接口的作用在它的注释中说的很清楚：</p><blockquote><p>An object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An Executor is normally used instead of explicitly creating threads. For example, rather than invoking new Thread(new(RunnableTask())).start() for each of a set of tasks</p></blockquote><p>这个接口的作用就是让用户专注于线程的任务，至于线程怎么调用的，如何运行的，用户并不需要关心。具体的实现类可以任意实现线程之间的协作。唯一的抽象方法就是<code>execute</code>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Executor</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Executes the given command at some time in the future.  The command</span><br><span class="hljs-comment">     * may execute in a new thread, in a pooled thread, or in the calling</span><br><span class="hljs-comment">     * thread, at the discretion of the &#123;<span class="hljs-doctag">@code</span> Executor&#125; implementation.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> command the runnable task</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException if this task cannot be</span><br><span class="hljs-comment">     * accepted for execution</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NullPointerException if command is null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-ExecutorService接口"><a href="#2-ExecutorService接口" class="headerlink" title="2. ExecutorService接口"></a>2. ExecutorService接口</h2><p>那么对于Executor的增强类接口<code>ExecutorService</code>呢？我们看看它的注释：</p><blockquote><p>An Executor that provides methods to manage termination and methods that can produce a Future for tracking progress of one or more asynchronous tasks.<br>An ExecutorService can be shut down, which will cause it to reject new tasks. Two different methods are provided for shutting down an ExecutorService. The shutdown method will allow previously submitted tasks to execute before terminating, while the shutdownNow method prevents waiting tasks from starting and attempts to stop currently executing tasks. Upon termination, an executor has no tasks actively executing, no tasks awaiting execution, and no new tasks can be submitted. An unused ExecutorService should be shut down to allow reclamation of its resources.</p></blockquote><p>上述大致就是ExecutorService作为一个Executor，它提供一些方法用来终止当前对象提供服务以及一些方法用于产生一个<strong>Future</strong>表示异步任务执行的结果。并且一个ExecutorService可以被关闭，但是这可能会导致新任务被迫终止。它提供了两类方法用来终止自身。</p><ul><li>第一类是<code>shutdown</code>方法，这类方法会将停止之前已经提交的任务执行完毕</li><li>第二类是<code>shutdownNow</code>方法，这类方法会将已经提交但未执行的任务直接终止，并且尝试对终止正在执行的任务。</li></ul><p>终止后ExecutorService不会存在还在执行的任务，并且也无法提交任务。当我们不再需要ExecutorService时，就应将其关闭，避免资源浪费。</p><p>对ExecutorService有了一个初步的认识后，我们看看它提供的一些核心方法：</p><p><img src="images/ExecutorService.png" alt="ExecutorService"></p><p>其实还有一点可以值得关注，就是上述提到的<code>Future</code>。这其实也是一个顶级接口，简而言之就是用来保存异步线程执行的结果。后续再详细分析。</p><h3 id="2-1-AbstractExecuteService"><a href="#2-1-AbstractExecuteService" class="headerlink" title="2.1 AbstractExecuteService"></a>2.1 AbstractExecuteService</h3><p>对于ExecutorService接口，JUC提供了一个抽象实现类<code>AbstractExecutorService</code>负责实现了一些异步执行任务核心方法的实现，包括<code>submit</code>、<code>invokeAll</code>、<code>invokeAny</code>这三类。并且提供了一个包装函数，能够将提交的任务（callable或者runnable）包装为一个<code>FutureTask</code>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">RunnableFuture&lt;T&gt; <span class="hljs-title">newTaskFor</span><span class="hljs-params">(Callable&lt;T&gt; callable)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FutureTask&lt;T&gt;(callable);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>所谓的<code>FutureTask</code>其实是<code>Future</code>接口的实现类，这个我们后续在分析<code>Future</code>体系的时候再详细介绍。其实我们应该重点关注提交函数<code>submit</code>到底是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>   <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>   RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-keyword">null</span>);<br>   execute(ftask);<br>   <span class="hljs-keyword">return</span> ftask;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从上面得知，<code>submit</code>函数的逻辑比较简单，就是将提交后的<code>Runnable</code>或者<code>callable</code>实现类包装成<code>FutureTask</code>后，还是会调用顶级接口的<code>execute</code>方法来执行一个具体的任务。这里还是无法得知线程到底是如何调度的。</p><h3 id="2-2-ScheduledExecutorService"><a href="#2-2-ScheduledExecutorService" class="headerlink" title="2.2 ScheduledExecutorService"></a>2.2 ScheduledExecutorService</h3><p><code>ScheduledExecutorService</code>接口的最用其实很简单，正如在它的注释中所写的，用来执行一些定时任务或者周期任务：</p><blockquote><p>An ExecutorService that can schedule commands to run after a given delay, or to execute periodically.<br>The schedule methods create tasks with various delays and return a task object that can be used to cancel or check execution. The scheduleAtFixedRate and scheduleWithFixedDelay methods create and execute tasks that run periodically until cancelled.</p></blockquote><p>那么该接口定义四个抽象方法用来提交定时或周期任务：</p><p><img src="images/ScheduleExecutorService.png" alt="ScheduleExecutorService"></p><p>提交任务后同样会返回一个<code>Future</code>接口的实现类<code>ScheduleFuture</code>，根据不同的任务安排，<code>ScheduleFuture</code>代表的含义不同，具体可以查看API文档。</p><h2 id="3-线程池ThreadPoolExecutor"><a href="#3-线程池ThreadPoolExecutor" class="headerlink" title="3. 线程池ThreadPoolExecutor"></a>3. 线程池ThreadPoolExecutor</h2><p><code>ThreadPoolExecutor</code>是一个具体线程池类，它通过继承<code>AbstractExecutorService</code>来实现接口<code>Executor</code>。该类实现了具体调度线程的方法负责完成提交的任务。并且通过一组参数实现了很强的扩展性，包括：</p><ol><li>核心线程数与最大线程数</li><li>预先启动核心线程</li><li>新线程的生产方式</li><li>线程存活时间</li><li>阻塞队列</li><li>任务的拒绝策略</li><li>hook方法（在任务执行前后添加代理方法）</li><li>线程池的终止策略</li></ol><h3 id="3-1-核心线程数"><a href="#3-1-核心线程数" class="headerlink" title="3.1 核心线程数"></a>3.1 核心线程数</h3><p>因为线程池中的线程数量会根据参数<code>corePoolSize</code>和<code>maximumPoolSize</code>的大小进行动态调整。当在方法<code>execute(Runnable)</code>中提交新任务时：</p><ol><li>如果正在运行的线程数量<strong>少于</strong><code>corePoolSize</code>线程时，<strong>即使其他工作线程处于空闲状态</strong>，也会创建一个新线程来处理请求</li><li>如果运行的线程数<strong>大于</strong><code>corePoolSize</code>但小于<code>maximumPoolSize</code>，则<strong>仅在队列已满时才创建新线程</strong>。</li></ol><p>通过将corePoolSize和maximumPoolSize设置为相同的值，可以创建固定大小的线程池。 通过将maximumPoolSize设置为一个本质上不受限制的值（例如Integer.MAX_VALUE），可以允许池容纳任意数量的并发任务。通常，核心和最大池大小仅在构造时设置，但也可以使用setCorePoolSize和setMaximumPoolSize动态更改。</p><h3 id="3-2-预先启动核心线程"><a href="#3-2-预先启动核心线程" class="headerlink" title="3.2 预先启动核心线程"></a>3.2 预先启动核心线程</h3><p>所谓的预先启动核心线程是指：在默认情况下，核心线程的生产条件是有新的任务提交。但是有可能我们在不提交任务的情况下也有启动核心线程的需求。例如假设我们提供的阻塞队列非空，那么在不调用<code>submit</code>提交新任务的前提下，需要手动启动核心线程来处理阻塞队列中的任务。</p><p>那么手动启动核心线程的操作可以通过<code>prestartCoreThread</code>或者<code>prestartAllCoreThreads</code><br>来完成。</p><h3 id="3-3-线程的生产模式"><a href="#3-3-线程的生产模式" class="headerlink" title="3.3 线程的生产模式"></a>3.3 线程的生产模式</h3><p>所谓的线程的生产模式，也就是当我们存活的线程不足以处理提交的任务，那么我们就需要生产新的线程来处理。那么在<code>ThreadPoolExecutor</code>中，维护了一个线程工厂<code>threadFactory</code>来生产线程。</p><p>在Java中，线程工厂有许多种，如下图所示：</p><p><img src="images/ThreadFactory.png" alt="ThreadFactory"></p><p>对于<code>ThreadPoolExecutor</code>来说，采用的是默认的线程工厂<code>DefaultThreadFactory</code>，该线程池创建的所有线程全部都属于同一ThreadGroup中，并且具有相同的NORM_PRIORITY优先级和非守护程序状态。</p><p>通过提供不同的ThreadFactory，可以更改线程的名称，线程组，优先级，守护程序状态等。如果ThreadFactory在通过从newThread返回null返回要求时未能创建线程，执行器将继续执行，但可能无法执行 执行任何任务。 线程应具有“ modifyThread” RuntimePermission。 如果线程池的工作线程或其他线程不具有此许可权，则服务可能会降级：配置更改可能不会及时生效，并且关闭池可能保持在可能终止但未完成的状态。</p><h3 id="3-2-线程的存活时间"><a href="#3-2-线程的存活时间" class="headerlink" title="3.2 线程的存活时间"></a>3.2 线程的存活时间</h3><p>一般来说，线程的存活时间一般用来限制非核心线程的数量。</p><p>如果池当前具有的核心线程数超过corePoolSize，则多余的线程如果在keepAliveTime的时长内都没有处理任务，那么多余的线程将会被关闭。 我们可以使用<code>setKeepAliveTime(long，TimeUnit)</code>方法动态更改此参数。 使用<code>Long.MAX_VALUE TimeUnit.NANOSECONDS</code>可以有使空闲线程永远不会在线程池关闭之前终止。</p><p>对于线程的存活时间，有一点需要我们注意：<strong>只要keepAliveTime值不为零，调用方法<code>allowCoreThreadTimeOut(boolean)</code>可用于将此超时策略应用于核心线程</strong></p><h3 id="3-3-阻塞队列"><a href="#3-3-阻塞队列" class="headerlink" title="3.3 阻塞队列"></a>3.3 阻塞队列</h3><p>阻塞队列主要用来存储多余的任务，它与线程池交互的逻辑如下：</p><ol><li>如果正在运行的线程数量少于<code>corePoolSize</code>，则Executor会添加新线程而不是将任务添加到阻塞队列</li><li>如果正在运行的线程数量不少于<code>corePoolSize</code>，则Executor会选择将新任务添加到阻塞队列而不是创建新线程</li><li>如果阻塞队列已满，那么Executor会选择创建一个新线程。如果总的线程数量大于<code>maximumPoolSize</code>，那么线程池会执行拒绝策略。</li></ol><p>对于阻塞队列如何排队的逻辑，可以细分为三种：</p><ol><li><p><strong>直接交付</strong>。对于工作队列，一个很好的默认选择是SynchronousQueue，它可以将任务移交给线程，而不必另外保留它们。在这里，如果没有立即可用的线程来运行任务，则尝试将其排队的尝试将失败，因此将构造一个新线程。在处理可能具有内部依赖项的请求集时，此策略避免了锁定。直接切换通常需要无限制的maximumPoolSizes以避免拒绝新提交的任务。反过来，当平均而言，命令继续以比其可处理的速度更快到达时，这可能会带来无限线程增长的可能性。</p></li><li><p><strong>无界队列</strong>。使用无界队列（例如，没有预定义容量的LinkedBlockingQueue）将在所有corePoolSize线程繁忙时使新任务在队列中等待。因此，将仅创建corePoolSize线程。 （因此，maximumPoolSize的值没有任何作用。）当每个任务完全独立于其他任务时，这可能是适当的，因此任务不会影响彼此的执行。例如，在网页服务器中。尽管这种排队方式对于消除短暂的请求突发很有用，但它承认当命令平均继续以比处理速度更快的速度到达时，无限制的工作队列增长是可能的。</p></li><li><p><strong>有界队列</strong>。与有限的maximumPoolSizes一起使用时，有界队列（例如ArrayBlockingQueue）有助于防止资源耗尽，但调优和控制起来会更加困难。队列大小和最大池大小可能会相互折衷：使用大队列和小容量线程池可以最大程度地减少CPU使用率，操作系统资源和上下文切换开销，但会导致人为地降低吞吐量。如果任务频繁阻塞（例如都是I/O操作），则系统在完成任务时因为阻塞会花费更多的时间。使用小队列大容量线程池，CPU频繁切换线程的开销也是不可忽略的，这同样会降低吞吐量。</p></li></ol><h3 id="3-4-拒绝任务的策略"><a href="#3-4-拒绝任务的策略" class="headerlink" title="3.4 拒绝任务的策略"></a>3.4 拒绝任务的策略</h3><p>线程池拒绝任务的时机有两种：</p><ol><li>当线程池关闭后，线程会拒绝执行提交的任务</li><li>当线程池的线程数量已经达到最大，并且阻塞队列也没有空间的时候，线程池会拒绝执行提交的任务。</li></ol><p>拒绝的操作由线程池中的<code>RejectedExecutionHandler</code>属性来完成。那么具体的拒绝逻辑又可以分为四种：</p><ol><li><strong>ThreadPoolExecutor.AbortPolicy</strong>：这是线程池的<strong>默认</strong>拒绝策略。该策略在拒绝时会抛出运行时异常RejectedExecutionException。</li><li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>：该策略就是在线程池<strong>未关闭时</strong>直接调用<code>Runnable</code>实现类的<code>run</code>执行任务。这提供了一种简单的反馈控制机制，该机制将减慢新任务的提交速度。</li><li><strong>ThreadPoolExecutor.DiscardPolicy</strong>：直接忽略当前提交的任务</li><li><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong>：如果线程池未关闭，则会抛弃阻塞队列头部的任务，然后重新尝试让线程池执行当前任务（该操作可能再次失败，导致重复执行此操作）。</li></ol><p>当然我们自己也可以实现自定义拒绝策略，不过需要注意，策略只能在阻塞队列容量一定的情况下才生效。</p><h3 id="3-5-可hook方法"><a href="#3-5-可hook方法" class="headerlink" title="3.5 可hook方法"></a>3.5 可hook方法</h3><p><code>ThreadPoolExecutor</code>内部提供了可以被override的<code>beforeExecute(Thread,Runnable)</code>和<code>afterExecute(Runnable,Throwable)</code>，这两个方法会在每个任务执行前后调用。这两个hook函数可以用来执行一些特殊操作。 例如，重新初始化ThreadLocals，收集统计信息或添加日志。 另外，一旦执行程序完全终止，可以终止方法终止以执行需要执行的任何特殊处理。</p><p>并且<code>ThreadPoolExecutor</code>也提供了可被override的<code>terminated()</code>方法。这个方法一般用来进行一些特殊操作（当然只能一次），当Executor被完全关闭的时候。<br>如果钩子或回调方法引发异常，内部工作线程可能进而失败并突然终止。</p><p><strong>当然如果这些hook函数内部抛出了异常，那么工作线程可能会出现不可预知的错误。</strong></p><p>Queue maintenance<br>Method getQueue() allows access to the work queue for purposes of monitoring and debugging. Use of this method for any other purpose is strongly discouraged. Two supplied methods, remove(Runnable) and purge are available to assist in storage reclamation when large numbers of queued tasks become cancelled.</p><h3 id="3-6-线程池的回收"><a href="#3-6-线程池的回收" class="headerlink" title="3.6 线程池的回收"></a>3.6 线程池的回收</h3><p>如果一个线程池没有被引用，并且池内<strong>没有存活线程</strong>的情况下，线程池会自动关闭。那么如何保证在不使用线程池的情况下，池内没有存活线程才是关键。那么这个问题有两种解决方法：</p><ol><li>不设置线程池的核心线程数量，那么对于临时申请的工作线程会自动关闭。</li><li>调用<code>allowCoreThreadTimeOut(boolean)</code>，允许核心线程存在过期机制</li></ol><h2 id="4-系统提供的线程池"><a href="#4-系统提供的线程池" class="headerlink" title="4. 系统提供的线程池"></a>4. 系统提供的线程池</h2><p>可以看到，前文提到线程池的参数是多样化的，那么为了适用于不同的生产环境，JUC提供了一个<code>Executor</code>工厂：<code>Exexutors</code>类，这个类通过预定义不同的参数生产一些适用于不同场景的线程池，包括：</p><ol><li><code>Executors.newCachedThreadPool</code>：无限制线程池，并且可以自动回收</li><li><code>Executors.newFixedThreadPool</code>：线程数量固定</li><li><code>Executors.newSingleThreadExecutor</code>：只有一个线程的线程池</li></ol><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>本篇简要叙述了JUC中的Executor框架，以及两个核心接口<code>Executor</code>、<code>ExecutorService</code>。并且简单介绍了线程池实现类<code>ThreadPoolExecutor</code>的一部分配置参数以及一些内置的线程池。后续我们就需要详细研究<code>ThreadPoolExecutor</code>到底是如何工作的。</p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="https://eripe.me/tags/Executor/">Executor</category>
      
      
      <comments>https://eripe.me/articles/Executor-interface.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java中的GC</title>
      <link>https://eripe.me/articles/the-GC-of-Java.html</link>
      <guid>https://eripe.me/articles/the-GC-of-Java.html</guid>
      <pubDate>Sun, 21 Mar 2021 08:21:08 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;Java中的自动垃圾回收是其一大优点。本文将从以下三个方面简介相关知识：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何定义垃圾&lt;/li&gt;
&lt;li&gt;垃圾回收的时机&lt;/li&gt;
&lt;li&gt;垃圾回收的策略&lt;/li&gt;
&lt;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>Java中的自动垃圾回收是其一大优点。本文将从以下三个方面简介相关知识：</p><ol><li>如何定义垃圾</li><li>垃圾回收的时机</li><li>垃圾回收的策略</li><li>具体的垃圾回收器</li></ol><p>在介绍相关的知识前，我们需要知道一个词：<code>stop-the-world</code>，这个词专门为GC而生，因为Java会在进行垃圾回收的时候除了GC线程外，会暂停所有工作线程，也就是所谓的“停止世界运转”。那么GC优化时，我们的目标可能就是减少GC时<code>stop-the-world</code>的时间（这句话网上抄的，当然大部分内容都是）。</p><h2 id="1-如何定义垃圾"><a href="#1-如何定义垃圾" class="headerlink" title="1. 如何定义垃圾"></a>1. 如何定义垃圾</h2><p>在Java中，定义一个对象为垃圾的策略分为两种：</p><ol><li>引用计数法</li><li>可达性算法</li></ol><p>所谓的<strong>引用计数法</strong>，也就是说：对于一个对象A，如果它的被引用次数为0，就说明没有别的对象在使用A，那么A自然而然地称为垃圾。但是这种会存在循环引用的问题。我们看看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>    <span class="hljs-keyword">private</span> B b;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setB</span><span class="hljs-params">(B b)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.b=b;<br>    &#125;<br>    ...<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;<br>    <span class="hljs-keyword">private</span> A a;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setA</span><span class="hljs-params">(A a)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.a=a;<br>    &#125;<br>    ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    A a=<span class="hljs-keyword">new</span> A();<br>    B b=<span class="hljs-keyword">new</span> B();<br>    a.setB(b);<br>    b.setA(a);<br>    a=<span class="hljs-keyword">null</span>;<br>    b=<span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面的代码中，在将a、b设置为null后，看似会被回收，但是实例a中仍然持有实例b的引用，实例b同理。这样实例a和b的引用计数各位1。如果以后不再使用这两个实例，那么就会造成内存泄漏。</p><p>可达性算法就是为了解决上述循环引用的问题。按照我的理解，所谓的可达性分析，是指一个实例的调用链，而调用链又是通过一个名叫<code>GCRoot</code>的数据结构维持的。所谓的<code>GCRoot</code>可以由以下四种中任意一个组成：</p><ol><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>虚拟机栈中引用的对象</li><li>本地native栈中引用的对象</li></ol><h2 id="2-垃圾回收的时机"><a href="#2-垃圾回收的时机" class="headerlink" title="2. 垃圾回收的时机"></a>2. 垃圾回收的时机</h2><p>Java把它的内存区域在逻辑上划分为三类：新生代、老年代、永久代。Java对这三类采用了不同的垃圾回收时机。</p><h3 id="2-1-新生代"><a href="#2-1-新生代" class="headerlink" title="2.1 新生代"></a>2.1 新生代</h3><p>所谓的新生代就是Java在构造实例的时候会使用这块内存，大对象（需要使用连续内存的对象）会直接放在老年代。</p><p>Java又把新生代划分为三个区域：Eden、survivor0和survivor1，每次只会使用Eden区和某一个survivor。假设在初始时，我们使用的Eden区和survivor0区，那么当这两个子区满了之后，会将它们中存活的对象复制到survivor1，这个过程叫做<strong>MinorGC</strong>，也就是次要的垃圾回收，当然MinorGC并不一定要Eden区满了才执行，有可能会经常执行（存疑）。此后survivor1和survivor0的角色交换。JVM使用Eden和survivor1。满了之后重复上述过程。</p><p><strong>特别的，当survivor1区也不足以存放eden区和survivor0区的存活对象时，就将存活对象直接存放到老年代。</strong></p><p><strong>新生代的回收时机就是Eden和某一个survivor内存用尽。</strong></p><h3 id="2-2-老年代"><a href="#2-2-老年代" class="headerlink" title="2.2 老年代"></a>2.2 老年代</h3><p>至于老年代，存放的都是一些生命周期较长的对象，就像上面所叙述的那样，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。</p><p>如果老年代也满了，就会触发一次<strong>FullGC</strong>，也就是<strong>新生代、老年代都进行回收</strong>。当然FullGC执行的频率比较低。导致FullGC的原因包括：老年代被写满、永久代（Perm）被写满和System.gc()被显式调用等。</p><h3 id="2-3-永久代"><a href="#2-3-永久代" class="headerlink" title="2.3 永久代"></a>2.3 永久代</h3><p>永久代主要用于存放静态文件，如Java类、方法等。</p><h2 id="3-垃圾回收的策略"><a href="#3-垃圾回收的策略" class="headerlink" title="3. 垃圾回收的策略"></a>3. 垃圾回收的策略</h2><p>Java的垃圾回收策略主要有三种：</p><ol><li>标记清除</li><li>复制交换</li><li>标记整理</li></ol><h3 id="3-1-标记清除算法"><a href="#3-1-标记清除算法" class="headerlink" title="3.1 标记清除算法"></a>3.1 标记清除算法</h3><p>标记-清除算法分为标记和清除两个阶段。该算法首先从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象并进行回收，</p><p>标记-清除算法的主要不足有两个：</p><ol><li><strong>效率问题</strong>：标记和清除两个过程的效率都不高;</li><li><strong>空间问题</strong>：标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，因此标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ol><h3 id="3-2-复制算法"><a href="#3-2-复制算法" class="headerlink" title="3.2 复制算法"></a>3.2 复制算法</h3><p>所谓的复制算法就是将堆区一分为二，分为A和B。每次只使用一个，当A满了之后，将A中存活的对象复制到B中。这种算法非常适用于存活率低的对象。因为需要复制的内容不会很多，并且复制时只需要调整指针，也不需要考虑内存碎片的问题，并且这种策略已经用于商业虚拟机中的新生代回收算法，<strong>因为研究发现，新生代中的对象每次回收都基本上只有10%左右的对象存活，所以需要复制的对象很少，效率还不错。</strong></p><h3 id="3-3-标记整理算法"><a href="#3-3-标记整理算法" class="headerlink" title="3.3 标记整理算法"></a>3.3 标记整理算法</h3><p>标记整理算法与标记清除算法类似，唯一的不同时，前者会在清除完毕后，有一个整理内存碎片的操作。这样就解决了标记清除算法中的空间问题。</p><h2 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4. 垃圾回收器"></a>4. 垃圾回收器</h2><p>可以按照垃圾回收器作用的内存区域分类：</p><p>作用于新生代的包括：</p><ul><li>ParNew收集器 (复制算法)，<strong>并行</strong></li><li>Parallel Scavenge收集器，<strong>并行</strong>，追求高吞吐量</li></ul><p>作用于老年代的包括： </p><ul><li>CMS，<strong>并行</strong>，使用标记清除策略，追求最短GC回收停顿时间。</li><li>Parallel Old收集器，<strong>并行</strong>，使用标记-整理策略，追求高吞吐量</li></ul><p>作用于两者的包括：</p><ul><li>G1收集器，<strong>并行</strong>，使用标记整理策略</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://segmentfault.com/a/1190000023637649">java面试官最爱问的垃圾回收机制，这位阿里P7大佬分析的属实到位</a></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/Java/">Java</category>
      
      
      <category domain="https://eripe.me/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">垃圾回收</category>
      
      
      <comments>https://eripe.me/articles/the-GC-of-Java.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>动态代理的原理</title>
      <link>https://eripe.me/articles/analysis-of-dynamic-proxy.html</link>
      <guid>https://eripe.me/articles/analysis-of-dynamic-proxy.html</guid>
      <pubDate>Sat, 13 Mar 2021 11:45:18 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1.</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>代理分为静态代理和动态代理。静态代理就是我们手动地将代理类写出来，而动态代理就是由虚拟机在运行时自动地将代理类构造出来。下面我就简单地阐述静态代理的用法以及缺点。</p><p>首先在下面声明需要代理的类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//实体类实现的接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">search</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//实体类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the add method.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the delete method&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the update method&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">search</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the search method&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>被代理的类<code>UserDaoImpl</code>实现了接口<code>UserDao</code>。</p><h2 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2. 静态代理"></a>2. 静态代理</h2><p>所谓的静态代理就是手动地构造一个类，并实现被代理类的所有接口，在代理类调用被代理类的目标方法，下面我们构造一个实现<code>UserDao</code>接口的方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.learn.proxy;<br><br><span class="hljs-keyword">import</span> com.learn.dao.UserDao;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">staticProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span></span>&#123;<br>    <span class="hljs-keyword">private</span> UserDao user;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUser</span><span class="hljs-params">(UserDao user)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.user = user;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the method:add&quot;</span>);<br>        user.add();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the method:delete&quot;</span>);<br>        user.delete();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the method:update&quot;</span>);<br>        user.update();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">search</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the method:search&quot;</span>);<br>        user.search();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，如果被代理的类方法过多，在每个代理类的方法都得写上同样的代码，太冗余，而且容易出错，是个体力活。所谓为了解决这个缺点，产生了动态代理。</p><h2 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3. 动态代理"></a>3. 动态代理</h2><p>动态代理有两种实现方式：</p><ul><li>使用Java原生API：Proxy+InvocationHandler</li><li>使用cglib</li></ul><p>这里先讲讲Java原生API是怎么用的，有什么缺点。</p><h3 id="3-1-基于原生API的动态代理"><a href="#3-1-基于原生API的动态代理" class="headerlink" title="3.1 基于原生API的动态代理"></a>3.1 基于原生API的动态代理</h3><p>原生API要求被代理的类必须实现接口，动态代理由<code>Proxy</code>类的静态方法<code>newProxyInstance</code>生成，并且要求用于生成动态代理的类必须实现接口<code>InvocationHandler</code>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> UserDao user;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUser</span><span class="hljs-params">(UserDao user)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.user = user;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxyObject</span><span class="hljs-params">()</span></span>&#123;<br>        System.getProperties().put(<span class="hljs-string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<span class="hljs-keyword">this</span>.getClass().getClassLoader(), user.getClass().getInterfaces(),<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;using &quot;</span>+method.getName());<br>        <span class="hljs-comment">//去user对象中查找有没有method对应的方法</span><br>        Object result=method.invoke(user, args);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中<code>public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code>需要我们提供四个参数：</p><ol><li>loader：用于定义动态代理类的ClassLoader</li><li>interfaces：被代理的类已经实现的接口</li><li>h：InvocationHandler对象</li></ol><p>这三个参数没有什么难理解的，我们需要主要关注<code>invoke</code>方法的构成。我们需要在方法调用前执行的操作以及在方法调用后执行的操作都需要在书写在<code>invoke</code>函数。其中最重要就是不能忘记调用<code>method.invoke</code>，这一句完成了实际方法的调用。</p><p>那么为什么要这么写，动态生成的代理类到底长什么样？我们来瞅瞅（如果没有找到动态代理类，一般是因为没有保存至磁盘，只需要添加虚拟机启动参数<code>-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true</code>即可）。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//动态代理类继承了Proxy类，并且实现了我们传递的接口参数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">Proxy0</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m1;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m2;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m3;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m5;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m6;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m0;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m4;<br><br>    <span class="hljs-keyword">public</span> $Proxy0(InvocationHandler var1) <span class="hljs-keyword">throws</span>  &#123;<br>        <span class="hljs-keyword">super</span>(var1);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object var1)</span> <span class="hljs-keyword">throws</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Boolean)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m1, <span class="hljs-keyword">new</span> Object[]&#123;var1&#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var3) &#123;<br>            <span class="hljs-keyword">throw</span> var3;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var4) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var4);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (String)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m2, (Object[])<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Integer)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m0, (Object[])<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);<br>        &#125;<br>    &#125;<br>    ...<br><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m3, (Object[])<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);<br>        &#125;<br>    &#125;<br>    <br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            m1 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;equals&quot;</span>, Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>));<br>            m2 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;toString&quot;</span>);<br>            m3 = Class.forName(<span class="hljs-string">&quot;com.learn.dao.UserDao&quot;</span>).getMethod(<span class="hljs-string">&quot;add&quot;</span>);<br>            m5 = Class.forName(<span class="hljs-string">&quot;com.learn.dao.UserDao&quot;</span>).getMethod(<span class="hljs-string">&quot;delete&quot;</span>);<br>            m6 = Class.forName(<span class="hljs-string">&quot;com.learn.dao.UserDao&quot;</span>).getMethod(<span class="hljs-string">&quot;search&quot;</span>);<br>            m0 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;hashCode&quot;</span>);<br>            m4 = Class.forName(<span class="hljs-string">&quot;com.learn.dao.UserDao&quot;</span>).getMethod(<span class="hljs-string">&quot;update&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException var2) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchMethodError(var2.getMessage());<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoClassDefFoundError(var3.getMessage());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看出，动态代理类继承了<code>Proxy</code>类，并且实现了我们传递的接口，也就是被代理类实现的接口<code>UserDao</code>。所以也就实现了该接口的所有方法。对于<code>add</code>方法，仅仅只有一句代码：<code>super.h.invoke(this, m3, (Object[])null);</code>，调用了父类属性<code>InvocationHandler</code>的<code>invoke</code>方法。而这个<code>InvocationHandler</code>就是我们在调用<code>newProxyInstance</code>时传递进去的参数<code>this</code>。所以其<code>invoke</code>的方法就是我们<code>UserDaoProxy</code>类中实现的<code>invoke</code>方法。</p><p>上述就是基于JDK的动态代理原理。可以看到，我们在生成代理对象时，必须传递被代理类实现的接口。如果我们想代理一个没有实现接口的参数怎么办？cglib解决了这个问题。</p><h3 id="3-2-基于cglib的代理"><a href="#3-2-基于cglib的代理" class="headerlink" title="3.2 基于cglib的代理"></a>3.2 基于cglib的代理</h3><p>cglib是基于ASM框架的一个高性能代码生成库，而ASM是一个Java字节码操控框架。它能被用来动态生成类或者增强现有类的功能。那么cglib到底是如何使用的呢？</p><p>第一步当然是导入对应的jar包，很简单，在maven respo中搜索即可：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>在cglib中，想要实现代理最重要的一步就是设置回调函数（callback），所谓的回调函数就是在调用目标方法之前或者之后设置需要实现的代理操作。并且在callback中调用真正的目标方法。cglib的callback有很多种类型，最常用的就是实现callback的子接口<code>MethodInterceptor</code>，这个接口会拦截被代理的所有方法，如下面的代码所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;call the method before:&quot;</span> + method.getName());<br>        <span class="hljs-comment">//调用被代理类的方法</span><br>        Object o1 = methodProxy.invokeSuper(o, objects);<br>        System.out.println(<span class="hljs-string">&quot;call the method after:&quot;</span> + method.getName());<br>        <span class="hljs-keyword">return</span> o1;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Proxy&#123;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>然后构造一个代理类，这需要借助工具类<code>Enhancer</code>（意为增强，比较好理解），cglib实现代理的原理是继承被代理类，所以需要完成的操作包括：</p><ol><li>生成工具类Enhancer</li><li>设置父类</li><li>设置回调函数callback</li><li>生成被代理类</li></ol><p>如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">testCG</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="hljs-string">&quot;D:\\cglib&quot;</span>);<br>        Enhancer enhancer=<span class="hljs-keyword">new</span> Enhancer();<br>        <span class="hljs-comment">//设置父类</span><br>        enhancer.setSuperclass(DaoImpl.class);<br>        <span class="hljs-comment">//设置回调函数callback</span><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> Proxy());<br>        <span class="hljs-comment">//生成被代理类</span><br>        DaoImpl en = (DaoImpl)enhancer.create();<br>        en.add();<br>        en.toString();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>cglib代理的实现原理较复杂，目前没有时间深究，列出两篇原理的讲解，以后有时间在学习。但是有一点值得我们注意：<strong>对于从Object中继承的方法，cglib也会进行动态代理。</strong></p><ol><li><a href="https://blog.csdn.net/P19777/article/details/103998918">CGLIB入门系列三，CGLIB生成的代理类详解</a></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1.<a href="https://objectcomputing.com/resources/publications/sett/november-2005-create-proxies-dynamically-using-cglib-library">CREATE PROXIES DYNAMICALLY USING CGLIB LIBRARY</a></p><ol start="2"><li><a href="https://www.cnblogs.com/xrq730/p/6661692.html">Cglib及其基本使用</a></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/java/">java</category>
      
      
      <category domain="https://eripe.me/tags/dynamic-proxy/">dynamic proxy</category>
      
      
      <comments>https://eripe.me/articles/analysis-of-dynamic-proxy.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>IOC到底是什么？</title>
      <link>https://eripe.me/articles/what-is-IOC.html</link>
      <guid>https://eripe.me/articles/what-is-IOC.html</guid>
      <pubDate>Fri, 12 Mar 2021 10:48:08 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;这篇博文：&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>这篇博文：<a href="https://www.cnblogs.com/DebugLZQ/archive/2013/06/05/3107957.html">浅谈IOC–说清楚IOC是什么</a>讲的不错，我在此就是做一些摘抄。</p><hr><h2 id="1-IOC是什么？"><a href="#1-IOC是什么？" class="headerlink" title="1. IOC是什么？"></a>1. IOC是什么？</h2><p>IOC，Inversion of Control，译为控制反转。并不是一种设计模式，但是可以算作一种方法论。</p><p><del>1996年，Michael Mattson在其论文:<a href="https://www.researchgate.net/publication/2238535_Object-Oriented_Frameworks">Object-Oriented FrameworksA survey of methodological issues</a>中，首先提出了IOC这个概念</del>。根据<a href="https://martinfowler.com/bliki/InversionOfControl.html">Martin Fowler</a>的追溯，Johnson and Foote于1988年在论文<a href="http://www.laputan.org/drc/drc.html">Designing Reusable Classes</a>首次提出了术语“Inversion of Control”。</p><p>简单来说，IOC的概念仅适用于面向对象的框架，而不面向于库函数。如果使用了框架，那么不再是程序员控制程序的所有流程，而是框架控制我们书写的程序，我们写的程序仅仅是为了适应框架。</p><p>对于面向对象的框架，IOC用于把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。</p><p><strong>IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。</strong></p><h2 id="2-控制了什么？"><a href="#2-控制了什么？" class="headerlink" title="2. 控制了什么？"></a>2. 控制了什么？</h2><p><img src="https://images0.cnblogs.com/blog/281227/201305/30130748-488045b61d354b019a088b9cb7fc2d73.png" alt="origin"></p><p>软件系统在没有引入IOC容器之前，如上图所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，<strong>自己必须主动</strong>去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</p><p><img src="https://images0.cnblogs.com/blog/281227/201305/30131727-a8268fe6370049028078e6b8a1cbc88f.png" alt="IOC"><br>软件系统在引入IOC容器之后，这种情形就完全改变了，如上图所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。</p><p>通过前后的对比，我们不难看出来：<strong>对象A获得依赖对象B的过程,由主动行为变为了被动行为</strong>，控制权颠倒过来了，这就是“控制反转”这个名称的由来。<strong>所谓的控制就是依赖资源的控制权</strong>。</p><h2 id="3-反转了什么？"><a href="#3-反转了什么？" class="headerlink" title="3. 反转了什么？"></a>3. 反转了什么？</h2><p>2004年，Martin Fowler探讨了同一个问题，既然IOC是控制反转，那么到底是“哪些方面的控制被反转了呢？”，经过详细地分析和论证后，他得出了答案：<strong>“获得依赖对象的过程被反转了”</strong>。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。于是，他给“控制反转”取了一个更合适的名字叫做“依赖注入（Dependency Injection）”。他的这个答案，实际上给出了实现IOC的方法：注入。所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p><p>所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。</p><h2 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4. 代码示例"></a>4. 代码示例</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> UserDao u;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserServiceImpl</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//UserServiceImpl的依赖对象是通过其自己生成的，耦合度较高</span><br>        <span class="hljs-comment">//如果现在想用Oracle的实现类，那么就需要手动更改下面的代码</span><br>        u=<span class="hljs-keyword">new</span> MySQLImpl();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">()</span></span>&#123;<br>        u.use();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面代码中的<code>UserServiceImpl</code>和其依赖的资源<code>UserDao</code>是一个强耦合的现象，<strong>我们需要知道具体调用的是哪个实现类，构造方法的参数是什么</strong>，如果想要换成另外的实现类，复杂程度会随着应用的复杂程度而增加。所以为了降低对象之间的耦合度，可以采取以下注入的方式的降低耦合度：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> UserDao u;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserServiceImpl</span><span class="hljs-params">(UserDao u)</span></span>&#123;<br>        <span class="hljs-comment">//通过注入的方式将UserServiceImpl的依赖添加进来</span><br>        <span class="hljs-keyword">this</span>.u=u;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">()</span></span>&#123;<br>        u.use();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>所以上面实现了一次控制反转，在<code>UserServiceImpl</code>中我们并<strong>不需要知道UserDao具体的实现类是什么，如何生成的，我们只管使用</strong>。依赖资源的生成不再由主动使用方控制，而是由第三方控制，被动地接收第三方提供的资源。这里的第三方在Spring中就是IOC容器。</p><h2 id="5-使用IOC容器有什么好处？"><a href="#5-使用IOC容器有什么好处？" class="headerlink" title="5. 使用IOC容器有什么好处？"></a>5. 使用IOC容器有什么好处？</h2><p>如果我们手动地实现控制反转，那么我们必须手动地写很多new，并且需要了解各个对象的构造函数，例如对于上面的<code>UserServiceImpl</code>，使用的流程一般如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    ...main()&#123;<br>        UserDao u=<span class="hljs-keyword">new</span> MySQLImpl();<br>        UserServiceImpl i=<span class="hljs-keyword">new</span> UserServiceImpl(u);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>如上所示，还是显示的使用了new，当依赖对象一旦多了起来，new的数量就会急剧增加，并且还要了解各个依赖对象的构造方法。所以IOC容器的好处就是：</p><ol><li>因为采用了依赖注入，在初始化的过程中就不可避免的会写大量的new。这里IoC容器就解决了这个问题。这个容器可以自动对你的代码进行初始化，你只需要维护一个Configuration（可以是xml可以是一段代码）</li><li>我们在创建实例的时候不需要了解其中依赖资源的细节</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://labs.madisoft.it/about-inversion-of-control/">About inversion of control</a></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/framework/">framework</category>
      
      
      <category domain="https://eripe.me/tags/Spring/">Spring</category>
      
      
      <comments>https://eripe.me/articles/what-is-IOC.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring MVC原理</title>
      <link>https://eripe.me/articles/what-is-spring-mvc.html</link>
      <guid>https://eripe.me/articles/what-is-spring-mvc.html</guid>
      <pubDate>Thu, 04 Mar 2021 10:40:10 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;1-MVC是什么？&quot;&gt;&lt;a href=&quot;#1-MVC是什么？&quot; class=&quot;headerlink&quot; title=&quot;1. MVC是什么？&quot;&gt;&lt;/a&gt;1.</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1-MVC是什么？"><a href="#1-MVC是什么？" class="headerlink" title="1. MVC是什么？"></a>1. MVC是什么？</h2><p>MVC是一种设计规范，并不是一种设计模式。该规范将一个web分割成3部分来处理：请求首先经过控制器Controller；经过业务处理得到数据模型Model；最后通过model渲染视图View并响应给客户端。</p><p>我们完全利用Servlet自己实现MVC规范，如下图所示：<br><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/what-is-spring-mvc.servlet-mvc.png" alt="servlet-mvc"></p><p>基本流程为：</p><ol><li>用户发请求</li><li>Servlet（作为Controller）接收请求数据，解析数据模型model，并调用对应的业务逻辑方法</li><li>业务处理完毕，返回更新后的model给Controller</li><li>Controller将model转向到JSP，由JSP来渲染页面</li><li>响应给前端更新后的页面</li></ol><p>当然，上述模型存在的严重缺陷<a href="#refer-anchor-1"><sup>[1]</sup></a>，包括：</p><ol><li><p>控制器出现的问题：随着web应用的复杂，<strong>控制器的添加</strong>一般需要将将映射配置在web文件中，可能不同的页面就要对应于一个Controller，难于维护；请求参数到模型的<strong>封装麻烦</strong>，需要根据具体的参数选择不同的业务逻辑；<strong>视图的选择</strong>严重依赖于Servlet API，因为最后获得数据数据后，最后会调用getDispatcherServlet将请求内部转发到tomcat内置的JspServlet进行处理，局限于JSP视图技术</p></li><li><p>此处数据模型使用JavaBean，可能造成JavaBean组件类很庞大，一般现在项目都是采用三层架构（Service、DAO、Entity）而不采用JavaBean</p></li><li><p>视图层出现的问题：被绑定在JSP，很难更换视图，比如Velocity、FreeMarker；比如我要支持Excel、PDF视图等等,同样严重依赖Servlet API。</p></li></ol><h2 id="2-SpringMVC解决了什么问题？"><a href="#2-SpringMVC解决了什么问题？" class="headerlink" title="2. SpringMVC解决了什么问题？"></a>2. SpringMVC解决了什么问题？</h2><p>SpringMVC基于Servlet容器，主要解决的是Web层的编码问题以及视图层的显示问题。</p><ol><li><p>在WebMVC中，根据请求路径配置Controller是一件很难维护的事情，SpringMVC相当于提供了一个Controller分发器，能够自动地根据不同的请求路径选择不同的Controller。并且能够自动将请求参数参数封装成数据模型提供给业务层处理。</p></li><li><p>视图的渲染并不由开发者实际控制，仅需要给SpringMVC提供视图的名字，具体的视图渲染交给SpringMVC提供的渲染器或者我们自己的渲染器解决，方便了视图技术的切换，不再严重依赖Servlet API。</p></li></ol><p>在SpringMVC中，<code>DispatcherServlet</code>的角色就相当于Controller分发器，官方名称<strong>前端控制器</strong>，其工作流程图如下所示：<br><img src="images/springmvc-workflow.png" alt="DispatcherServlet-workflow"></p><p>从图中可以看出<code>DispatcherServlet</code>、<code>HandlerMapping</code>、<code>HandlerAdapter</code>、<code>ViewResolver</code>是维持SpringMVC正常工作的核心组件。</p><p>按道理来说，使用HandlerMapping就足够了，为什么还要个适配器？经网上查阅，这是由于Spring的handler多样化，采用了适配器模式，具体原因仍待研究。<code>DispatcherServlet</code>工作流程如下：</p><ol><li><p>HTTP请求：客户端向应用程序发起Http请求，tomcat将请求转到DispatchServlet(Spring提供的前端控制器 ) ，所有的请求通过DispatchServlet进行分发</p></li><li><p>寻找处理器： 在DiispatchServlet在将请求分发给Controller之前， 通过HandlerMapping，根据请求url查找Handler。HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。</p></li><li><p>HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler，也就是Controller。将请求提交给Controller，Controller需要为并发用户处理，需要Controller实现Controller接口，必须保证是线程安全的</p></li><li><p>调用业务处理服务：Controller会调用 业务处理 Service， 并返回ModelAndView，给到前端控制器，ModelAndView包含应用程序所需要的数据信息（Model）以及视图讯息（View）</p></li><li><p>得到处理信息：DispatchServlet得到ModelAndView对象，会调用Viewresolver视图解析器。也就是找到ModelAndView所对应的视图，对Model数据进行渲染</p></li></ol><hr><p><strong>注意：</strong> 实际的视图渲染工作是通过<strong>具体的渲染器</strong>完成的，而不是SpringMVC完成的，SpringMVC只负责找到视图并将渲染请求发送到渲染器。</p><p>例如在渲染jsp时，SpringMVC实际上是将数据model封装到Response对象，然后进行内部转发，随后tomcat调用内部Servlet来处理渲染工作。</p><hr><h2 id="3-SpringMVC基本使用"><a href="#3-SpringMVC基本使用" class="headerlink" title="3. SpringMVC基本使用"></a>3. SpringMVC基本使用</h2><p>基于tomcat使用SpringMVC时，首先我们需要配置前端控制器<code>DispatcherServlet</code>，然后配置<code>DispatcherServlet</code>的三大件：handler映射器，handler适配器，视图解析器。最原始的方式就是使用Spring配置文件来硬编码这三项的配置。</p><p>第一步在web应用的<code>web.xml</code>文件配置<code>DispatcherServlet</code>,就像配置Servlet那样：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注册DispatcherServlet--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <br>            <span class="hljs-comment">&lt;!--配置SpringMVC使用的配置文件</span><br><span class="hljs-comment">            默认配置文件名称:[servlet name]-servlet.xml--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--设置servlet的启动级别--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--将任意uri交给DispatcherServlet来处理--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.html<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>其中<code>DispatcherServlet</code>的<code>url pattern</code>配置会存在一点小问题，这个后面来讲。然后在SpringMVC需要使用的配置文件中配置三大件：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--配置HandlerMapping--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--配置HandlerAdapter--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--视图解析器，DispatcherServlet将HandlerAdapter返回的ModelAndView传递给viewResolver</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    viewResolver做了3件事：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    1. 提取MV对象中的数据</span><br><span class="hljs-comment">    2. 根据规定的前缀与后缀 拼接视图的名字并找到对应的视图，例如视图的名字是hello，最后拼接的是/WEB-INF/jsp/hello.jsp</span><br><span class="hljs-comment">    3. 使用数据对视图进行渲染</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    最后DispatcherServlet根据视图的名字返回渲染好的视图</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-comment">&lt;!--配置视图解析器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--前缀--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--后缀--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;/index&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.g.HelloController&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ol start="4"><li><h2 id="DispatcherServlet的url-pattern为什么要配置为"><a href="#DispatcherServlet的url-pattern为什么要配置为" class="headerlink" title="DispatcherServlet的url-pattern为什么要配置为/?"></a><code>DispatcherServlet</code>的url-pattern为什么要配置为<code>/</code>?</h2></li></ol><p>在配置<code>DispatcherServlet</code>时，建议将<code>url-pattern</code>配置成<code>/</code>而不是<code>*/</code>。这跟tomcat路径映射的优先级有关。在tomcat中，路径匹配分成四个模式<a href="#refer-anchor-2"><sup>[2]</sup></a>：</p><ol><li>以<code>/*</code>开头的前缀匹配</li><li>以<code>*.</code>开头的后缀匹配</li><li><code>/</code>表示默认匹配</li><li>其他情况，表示精确匹配</li></ol><p>这四种模式是有优先级的，我们从上到下以优先级的高低进行说明：</p><ol><li><p>规则1：精确匹配，</p></li><li><p>规则2：前缀匹配，也就是url-pattern是<code>/*</code></p></li><li><p>规则3：扩展名匹配，也是就url-pattern是<code>*.</code></p></li><li><p>规则4：使用资源文件来处理servlet，</p></li></ol><p>…</p><ol start="7"><li>规则7：使用默认的servlet，也就是url-pattern为<code>/</code></li></ol><p>也就是说，如果把<code>DispatcherServlet</code>的<code>url-pattern</code>配置为或者<code>/</code>或者<code>/*</code>，所有的请求都会由<code>DispatcherServlet</code>处理，那么为什么建立采用<code>/</code>？我对此进行了进行了调研与简单的实验。</p><p>实验准备：</p><p>Controller代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Controller</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();<br>        mv.addObject(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;hello mvc&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;run in controller&quot;</span>);<br>        mv.setViewName(<span class="hljs-string">&quot;index&quot;</span>);<br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>视图解析器的配置文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--前缀--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--后缀--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;/index&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.g.HelloController&quot;</span> /&gt;</span><br></code></pre></div></td></tr></table></figure><p>DispatcherServlet的路径映射配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--将任意uri交给DispatcherServlet来处理--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>根据解析器后缀与路径映射的组合产生了四种情况：</p><ol><li>把路径映射设置为<code>/</code>，解析器后缀为<code>.jsp</code>时，能够处理请求</li><li>把路径映射设置为<code>/</code>，解析器后缀为<code>.html</code>时，无法处理请求，错误原因：<code>noHandlerFound No mapping for GET /WEB-INF/jsp/index.html</code></li><li>把路径映射设置为<code>/*</code>，解析器后缀为<code>.jsp</code>时，无法处理请求，错误原因：<code>noHandlerFound No mapping for GET /WEB-INF/jsp/index.jsp</code></li><li>把路径映射设置为<code>/*</code>，解析器后缀为<code>.html</code>时，无法处理请求，错误原因：<code>noHandlerFound No mapping for GET /WEB-INF/jsp/index.html</code></li></ol><p>对于这四种情况，目前已知Controller都能够成功打印<code>run in controller</code>，说明<code>DispatcherServlet</code>能够成功分发请求，那么为什么只有第一种情况能够正确响应？</p><p>我怀疑是视图解析的过程出现了问题，<a href="#refer-anchor-3">参考文章.[3]</a>也验证了我的猜想，但是文章只告诉了我DispatcherServlet会循环处理请求,并没有说它为什么会循环处理。我产生了一个猜想：既然能够循环处理，那岂不是又经过了一次tomcat处理路径映射？</p><p>带着这个问题，我去研究了<code>DispatcherServlet</code>的视图解析过程，尝试寻找解析过程的转发请求流程，根据<a href="#refer-anchor-4">参考文章.[4]</a>，渲染的调用链如下：</p><blockquote><p>doService()—&gt;doDispatch()—&gt;processDispatchResult()—&gt;render()</p></blockquote><p><code>processDispatcherResult</code>主要处理异常、请求状态及触发请求完成事件,最后把视图的渲染工作交给了render()。针对JSP提供的InternalResourceViewResolver与InternalResourceView。</p><p>render首先需要借助InternalResourceViewResolver通过view的名称解析并获得view对象，</p><p><img src="images/view-render-1.png" alt="render-1"></p><p>然后调用view对象的render方法进行渲染，如下图所示：</p><p><img src="images/view-render-2.png" alt="render-2"></p><p>这里的render具体实现在<code>AbstractView</code>，如下所示：<br><img src="images/view-render-3.png" alt="render-3"></p><p>该方法最后又会调用<code>renderMergedOutputModel</code>，具体实现在<code>InternalResourcecView</code>，代码如下所示：<br><img src="images/view-render-4.png" alt="render-4"></p><p>下面是进行重复请求的重点，首先将数据model存入request，通过RequestDispatcher调用forward或者include方法，如下所示：<br><img src="images/view-render-5.png" alt="render-5"></p><p>了解了渲染流程之后，根据<a href="#refer-anchor-3">参考文章.[3]</a>可知，tomcat的配置文件<code>conf/web.xml</code>配置了一个内部处理jsp的servlet，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- The mappings for the JSP servlet --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>jsp<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.jspx<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>jsp<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.apache.jasper.servlet.JspServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>fork<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>xpoweredBy<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>所以我们配置的视图后缀为<code>.jsp</code>时，url的名称为<code>/WEB-INF/jsp/index.jsp</code>，SpringMVC进行forward之后，tomcat又会进行一次url-pattern匹配，寻找具体的渲染器来渲染视图</p><ol><li>如果DispatcherServlet的pattern为<code>/</code>，内部jsp servlet的url-pattern<code>*.jsp</code>比<code>/</code>优先级高，这个请求会交给内部jsp的servlet来处理，不会导致DispatcherServlet循环处理</li><li>如果DispatcherServlet的pattern为<code>/*</code>，内部servlet的url-pattern<code>*.jsp</code>比<code>/*</code>优先级低，这个请求会交给DispatcherServlet处理，而我们又没有配置该url的Controller进行处理，所以报错 no handler mapping</li></ol><p>当视图后置配置为<code>.html</code>时，解析后的url全称为<code>/WEB-INF/jsp/index.html</code>，SpringMVC进行forward之后，tomcat又会进行一次url-pattern匹配：</p><ol><li>如果DispatcherServlet的pattern为<code>/</code>，内部jsp servlet的url-pattern无法匹配该url，所以最后还是交给DispatcherServlet处理，而我们又配置该url的Controller进行处理，所以报错 no handler mapping</li><li>如果DispatcherServlet的pattern为<code>/*</code>，这个请求会直接交给DispatcherServlet处理，而我们又配置该url的Controller进行处理，所以报错 no handler mapping</li></ol><p>那么我们难道只能把视图后缀配置为jsp吗？当然不是的，解决办法就是使用就是名为<code>default</code>的servlet，它的作用和jsp的大概一样，大家知道它是拿来配置静态资源的，却很少了解它怎么来的。这个Servlet也是存在与<code>conf/web.xml</code>，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>debug<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>listings<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <br><span class="hljs-comment">&lt;!-- The mapping for the default servlet --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>注意它的url-pattern为 **/**。，如果我们在自己的<code>web.xml</code>中配置<code>default</code>servlet，就会覆盖tomcat中的<code>default</code>，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.html<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>这样当我们的url为<code>/WEB-INF/jsp/index.html</code>时：</p><ol><li>如果<code>DispatcherServlet</code>的url-pattern为<code>/</code>时，<code>*.html</code>的优先级比<code>/</code>高，tomcat就会把请求匹配到<code>default</code> servlet而不是<code>DispatcherServlet</code><br>如果<code>DispatcherServlet</code>的url-pattern为<code>/*</code>时，<code>/*</code>的优先级比<code>*.html</code>高，tomcat就会把请求匹配到<code>DispatcherServlet</code> servlet而不是<code>default</code>，而我们又没有配置该url的Controller进行处理，所以报错 no handler mapping</li></ol><p>这里又有一个问题出现了，为什么tomcat配置文件的<code>conf/web.xml</code>的<code>jsp</code>servlet在我们不配置的情况下能够默认生效，而<code>default</code>servlet却需要我们手动配置呢？答案是因为<code>default</code>servlet的url-pattern为<code>/</code>，我们配置的<code>DispatcherServet</code>的url-pattern也为<code>/</code>，这里我猜测是因为配置的<code>/</code>覆盖的了<code>default</code>servlet的<code>/</code>。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>对于tomcat配置文件<code>conf/web.xml</code>中的servlet，是供<strong>所有</strong>已经部署的webapp使用的，如果我们在自己的配置文件中覆盖了tomcat的同名servlet或者同名url-pattern，则以我们自己编写的<code>web.xml</code>为准。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><div id="refer-anchor-1"></div><ol><li><p><a href="https://blog.csdn.net/u012881904/article/details/51291387">webMVC模型存在的问题</a></p></li><li><p><a href="https://www.cnblogs.com/fangjian0423/p/servletcontainer-tomcat-urlpattern.html">Servlet容器Tomcat中web.xml中url-pattern的配置详解[附带源码分析]</a></p></li><li><p><a href="https://ddnd.cn/2018/12/24/springmvc-view-webxml/">我是如何一步步解决问题 让Spring MVC返回HTML类型的视图</a></p></li><li><p><a href="https://www.cnblogs.com/wdpnodecodes/p/7820295.html">SpringMVC DispatcherServlet——-视图渲染过程</a></p></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/framework/">framework</category>
      
      
      <category domain="https://eripe.me/tags/Spring-MVC/">Spring MVC</category>
      
      
      <comments>https://eripe.me/articles/what-is-spring-mvc.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计网热门问题</title>
      <link>https://eripe.me/articles/top-questions-for-network.html</link>
      <guid>https://eripe.me/articles/top-questions-for-network.html</guid>
      <pubDate>Sat, 16 Jan 2021 07:06:05 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;本篇不为别的，只为记录面试过程中关于计网的热门问题。&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1-点击一个链接后，发生了什么&quot;&gt;&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>本篇不为别的，只为记录面试过程中关于计网的热门问题。</p><p>[TOC]</p><hr><h2 id="1-点击一个链接后，发生了什么"><a href="#1-点击一个链接后，发生了什么" class="headerlink" title="1. 点击一个链接后，发生了什么"></a>1. 点击一个链接后，发生了什么</h2><p>首先，我们需要有一个总的概念：在点击一个链接后，网卡首先会将http请求使用http协议封装，接着将数据包经由tcp/udp协议封装，最后使用ip协议将数据包在各个网段之间传输直至到达目的地。http协议的封装这里不作详细介绍。tcp连接的建立和ip数据包的转发才是重点。</p><ol><li>tcp连接建立的基础是使用ip协议将数据包转发到目标主机</li><li>使用ip的前提是知道目标主机的ip地址</li><li>而ip地址的获取需要靠dns解析</li></ol><p>所以点击链接后发生的事，主要分为域名解析、ip数据包转发、tcp连接，我们依次分析这三小部分。</p><p><strong>I. 域名解析</strong></p><p>dns解析的流程比较简单，查询步骤如下：</p><ol><li><p>首先查询浏<strong>览器缓存</strong>，如若失败则执行2，否则执行6</p></li><li><p>查询本机<strong>host文件</strong>，如若失败则执行3，则执行6</p></li><li><p>查询<strong>本地dns服务器</strong>（一般是指由用户设置的dns服务器），如果失败，如果采用迭代模式，则执行4；如果采用递归模式，则执行5</p></li><li><p>本地dns服务器采用递归模式的查询流程如下所示：</p></li></ol><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.dns-recursion.png" alt="top-questions-for-network.dns-recursion"></p><ol start="5"><li>本地dns采用迭代模式的查询流程如下所示：</li></ol><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.dns-iteration.png" alt="top-questions-for-network.dns-iteration"></p><ol start="6"><li>返回域名对应的ip地址</li></ol><p>上图中所谓的根服务器的概念与域名的级别有关系，根服务器负责管理13个顶级域名服务器，如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.root.png" alt="top-questions-for-network.root"></p><hr><p>延申问题：</p><p><strong>Q1. 域名解析是通过dns映射完成的，那么这个映射是如何建立？</strong></p><details><summary>展开</summary><p>映射一般需要我们手动建立，建立的类型一般就是两种：A类和CNAME类。</p><ul><li><p>A类可以简单理解为域名到ip地址的直接映射。</p></li><li><p>CNAME类（Canonical Name）就是域名到域名的映射。</p></li></ul><p>CNAME类解析的用处多多，我们可以像使用环境变量一样设置CNAME<a href="#refer-anchor-1"><sup>[1]</sup></a>。例如如果我们在域名<code>test.com</code>下有三个子域名<code>a.test.com</code>、<code>b.test.com</code>、<code>c.test.com</code>。现在我们想把这三个子域名解析到我们的ip<code>10.10.1.11</code>，当然我们可以为每个子域名设置一个A类解析，但是如果更改了ip地址，那么需要更改的地方是非常多的。<br>反之，我们将这三个子域名都是用CNAME解析到域名<code>test.com</code>，那么解析时就把问题转化为<code>test.com</code>的ip地址是多少。当ip地址改变时，只需要更改<code>test.com</code>的A记录</p><p> 主机名 | 记录类型 | 目标 |<br>| :—–| —-: | :—-: |<br>| test.com |A     | 10.10.1.11 |<br>| a.test.com | CNAME | test.com |<br>| b.test.com | CNAME | test.com |<br>| c.test.com | CNAME | test.com |</p><p>那么CNAME这么好用，它有什么缺陷呢？</p><ol><li>CNAME只能解析到另一个域名，不能解析ip</li><li>增加一次解析的负担，一般可以使用cdn加速</li></ol></details><p><strong>Q2. 多个域名绑定到同一ip怎么区分？</strong></p><details><summary>展开</summary><p>如上所述，我们可以将多个子域名绑定到同一ip，一般我们需要根据端口来区分针对不同域名发起的请求。但是为了用户体验，我们希望多个域名都访问80端口，这时一般使用nginx实现反向代理<a href="#refer-anchor-9"><sup>[13]</sup></a>来区分不同域名。nginx为什么能够区分？因为http请求头中都会包含请求的域名。</p><p>或者使用虚拟主机，直接将子域名映射到二级目录就行。</p></details><p><strong>Q3. 上面提到的子域名是什么？</strong></p><details><summary>展开</summary>正如前文所述，域名是有等级的。根据[维基百科](https://en.wikipedia.org/wiki/Domain_name)，一级域名是13个顶级域名。一级域名左侧为二级域名，二级域名左侧为三级域名，以此类推。<p>例如域名<code>lol.qq.com</code>，一级域名为<code>com</code>、二级域名为<code>qq</code>、三级域名为<code>lol</code>。域名所有者可以任意配置所有域名下的子域名<a href="#refer-anchor-2"><sup>[2]</sup></a>。</p><p>但是站在使用者的角度，我们一般称<code>qq.com</code>为一级域名，因为单单使用<code>com</code>什么都不是。</p></details><hr><p><strong>II. ip数据包的转发</strong></p><p>请求到目标域名的ip后，ip数据包首先需要传输到网关，然后再经过层层路由转发至目标主机<a href="#refer-anchor-3"><sup>[3-5]</sup></a>。而ip数据包的转发实际还要依靠链路层，而链路层的转发依靠的是mac地址。所以需要完成ip地址到mac地址之间的映射，这个工作交由arp协议来完成,由上可知<strong>arp工作在链路层</strong>。</p><p><strong>arp的请求是广播，而响应是单播</strong>，因为在一个局域网中，主机A只知道路由器B的ip地址，而不知道路由器B的mac地址是多少，必须发起广播，并且只有路由器B才会响应这个arp请求。那么为什么主机能够知道需要将数据包转发至路由器B呢？这里我们可以将这个路由器B看作<strong>默认网关</strong>，这一般都会自动获取，而网关之后的转发流程就是网关的事了。</p><p>完成ip到mac的映射后，数据包会从主机A转发到路由器B。路由器B解析ip数据包后，发现目的ip为<code>111.222.333.444</code>。那么接下来怎么转发才能到这个地址呢？这就需要以来路由器中的路由表。而路由表的生成有专门的协议来负责，后面将会介绍。查询路由表后，一般都会知道下一跳路由器的ip地址，这时再使用arp协议请求mac地址，重复上面的操作就会层层路由到ip为<code>111.222.333.444</code>的主机了。</p><hr><p>延申问题</p><p><strong>Q1：路由表是如何生成的？</strong></p><details><summary>展开</summary><p>首先我们需要知道根据不同的网络服务商，会组成不同的、各自的超大局域网，一般将超大局域网成为自治系统(autonomous system)。AS内部之间的路由协议称为<strong>内部网关协议</strong>( interior gateway protocol )，而AS之间的路由协议称为<strong>外部网关协议</strong>(Exterior gateway protocol)。</p><p>需要注意的是：参考<a href="https://en.wikipedia.org/wiki/Exterior_gateway_protocol">维基百科</a>，IGP是内部网关协议的总称，并不是一个具体的协议。而EGP既是外部网关协议的总称，而且确实有一种外部网关协议叫做EGP。</p><p>具体来说，IGP主要有两种类型：距离矢量类型和链路状态类型，所谓的距离矢量就是靠源地址与目标地址之间的路由跳数来决定路由路径。而距离矢量类型是指通过路径长度、可靠性、延迟、带宽、负载和通信开销来决定路由路径。距离适量类型的代表路由协议是<strong>路由信息协议RIP</strong>、<strong>内部网络路由协议IGRP</strong>。链路状态类型的代表路由协议有开放式最短路由协议<strong>OSPF</strong>、<strong>IS-IS</strong>。</p><p>EGP运行于AS之间，代表协议主要包括EGP、BGP（EGP的升级版）、EBGP等。</p></details><hr><p><strong>III. 建立tcp连接</strong></p><p>tcp连接的建立需要经过三次握手，如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.tcp-three-handshake.png" alt="top-questions-for-network.tcp-three-handshake"></p><ol><li>客户发送的第一个段是 SYN 段。这个段仅有 SYN 标志被置位，它用于序号同步。<strong>它占用一个序号，不能携带数据</strong>。当数据传输开始时，客户<strong>随机</strong>选择一个数字作为初始序号(ISN)。注意，这个段不包含确认号。它也没有定义窗口大小；窗口大小的定义只有当段包含确认号时才有意义。<br>&nbsp;</li><li>服务器发送第二个段，两个标志位SYN和ACK置位的段，即 SYN  +ACK 段。这个段有两个目的。首先，它是另一方向通信的 SYN 段。服务器使用这个段来<strong>随机</strong>初始化序号，这个序号用来给从服务器发向客户的字节编号。服务器也通过给 ACK 置位并展示下一个序号来确认已经接收到来自客户的SYN，这里的下一个序号是服务器预期从客户接收的序号。因为它包含确认，它也需要定义接收窗口，即 rwnd（供客户参考使用）。因为这个段起到 SYN段的作用，它需要被确认。因此，<strong>它占用一个序号。但SYN + ACK 段不携带数据</strong>。<br>&nbsp;</li><li>客户发送第三个段。这个段仅仅是一个 ACK 段。它使用 ACK 标志和确认序号字段来确认收到了第二个段。<strong>该段可携带或者不携带数据</strong>。注意，如果不携带数据，ACK段没有占用任何序号，但是一些实现允许这第三个段在连接阶段从客户端携带第一块数据，在这种情况下，段消耗的序号与数据字节数相同。</li></ol><p>标志位小结：</p><p>SYN：可以理解为谁需要同步序号，谁就要设置SYN标志位<br>ACK：谁收到了数据包，谁就要设置ACK标志位</p><hr><p>扩展问题：</p><p><strong>Q1: 为什么需要三次握手？</strong></p><details><summary>展开</summary>相信大家都知道，tcp连接的建立需要三次握手，但是想要明白为什么需要三次握手，我们首先就需要知道tcp的连接[<sup>[4]</sup>](#refer-anchor-4)和握手到底是什么意思。<p>根据<a href="https://tools.ietf.org/html/rfc793">RFC 793 - Transmission Control Protocol </a>的规定，tcp的连接定义如下：</p><blockquote><p>The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream. The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.</p></blockquote><p>大致是说，为了防止网络的不确定性可能会导致数据包的缺失和顺序颠倒等问题，需要为每一个数据流初始化和保持确定的状态信息，包括socket、数据包序号、窗口大小。这些状态信息叫做一个连接。</p><p>那么握手到底是啥意思？我认为所谓的握手是指：对于一个<strong>数据包</strong>来说，它经历了一组收发的过程，就叫一次握手。如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/tcp-handshake.drawio.svg" alt="what-is-a-handshake"></p><p>明白了<strong>连接</strong>和<strong>握手</strong>的概念，我们再来讨论握手的次数。因为tcp是双工的，收方和发方都是可以发送信息的，所以就需要为收发两端同步上述的状态信息，而<strong>两次握手都不能完成同步信息(主要是序列号ISN)的任务</strong>。如何理解？</p><p><a href="https://tools.ietf.org/html/rfc793">RFC 793 - Transmission Control Protocol </a>指出使用三次连接原因主要是为了防止重复的连接初始化信息出现，导致连接错乱：</p><blockquote><p>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</p></blockquote><p>试想如下一个场景：<br>因为网络延迟较高，发送方A发出连接请求后，如果这个请求经过了很长时间才到达收方B。那么B无法判断这个请求是正常还是超时的。如果B采用两次握手，贸然建立连接，那么对A发出响应信息后，A是不会作出响应的，因为这个连接已经过时了。那么B建立连接的资源就一直无法释放。这是一个非常严重的问题。</p><p>那么为什么三次握手就能解决这个问题呢？其实我们可以把三次握手退化成四次握手，如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/tcp-four-handshake.drawio.svg" alt="four-handshake"></p><p>经过四次握手后，主机A和主机B都确认对方能够收到数据，就会建立tcp连接。如果此时再出现A发送的连接请求超时到达，B不会建立连接，而是向A发送应答请求，并且试图同步序列号，如果同步失败，连接就不会建立，主机A和B都能很快的释放资源。但是其中数据包2、3是可以一起发送的。四次就退化成三次握手，如下所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.tcp-three-handshake.png" alt="top-questions-for-network.tcp-three-handshake"></p><p>图中三次握手的重点就是<strong>同步序列号</strong>，序列号之所以如此重要，是因为它能够防止以下情况出现：</p><ol><li>数据包丢失、超时到达</li><li>数据包重发</li><li>数据包乱序</li></ol></details><p><strong>Q2: 为什么ISN是随机的？</strong></p><details><summary>展开</summary><p>简单来说，随机ISN防止了一些历史数据包和新数据包的冲突以及ISN欺骗攻击。</p><p><strong>数据包冲突问题</strong><br>如果ISN每次开始都是固定的、静止的起始值。想象如下一个场景：如果初始ISN固定为0，旧连接已经断开，因为网络问题旧数据包1-10仍残存于网络中。如果某时刻复用此旧链接，ISN又从0开始，那么新的数据包1-10和旧的数据包1-10有可能发生冲突。所以解决办法就是动态地随着时间增长生成ISN。但是这样同样存在下面的安全问题。</p><p><strong>ISN欺骗攻击</strong><br>如果ISN是根据当前时间计算，那么服务器生成的ISN有可能被破解，这就有可能发生ISN猜测攻击。下面是一个攻击场景<a href="#refer-anchor-5"><sup>[9]</sup></a>：现在我们有三台主机A、B、C</p><p>HOST A &lt;—-&gt; HOST B<br>^<br>|<br>|<br>HOST C</p><p>在这里，主机A和主机B是受信任的主机。主机A接受来自主机B的连接，因为它是受信任的源。此处的识别参数只是ip地址（示例是rlogin应用程序，网络中的主机受信任并允许执行命令。请参阅rlogin以查看其工作原理）</p><p>现在，HOST C想要欺骗主机B并与A建立连接。步骤如下：</p><ol><li>C（欺骗B）—-&gt;将SYN数据包发送给A，序列号为ISN_C。欺骗手段C发送以IP地址B作为源IP的数据包。</li><li>A用具有自己的序列号的SYN（ISN_A）+ ACK（ISN_C + 1）数据包响应SYN。但这不会达到C。这是因为B是受信任的源，并且A可以直接向B发送数据。A向B发送一个SYN + ACK数据包。但是B对此一无所知，并且可以选择重置连接。在这一阶段，我们必须通过使B充满垃圾数据包来使B保持忙碌，以便它不会响应A</li><li>现在，C知道ISN_C，但不知道ISN_A，因为它没有收到数据包。如果<strong>C可以预测ISN_A</strong>，则可以发送具有确认号ISN_A + 1的第三个ACK数据包。这样，我们与A建立了3种方式的握手。（通过具有可预测的序列号，我们可以建立连接。）</li></ol><p>现在我们可以将命令从C发送到A，它将执行该命令，因为我们正在欺骗可信任的源。这是一个严重的安全问题。同样，我们可以重置连接或将数据注入流中。</p><p>当然，上述攻击方式是有限制的：<br>1.如果C与A＆B在同一个网络中，并且可以嗅探数据包，则只需嗅探数据包就可以轻松看到ISN。随机序列号不会阻止这种情况。如果您与A和B位于不同的网络上，则可以防止受到攻击。</p><p>2.由于存在可信源（rlogin，rsh等）的概念且未进行任何加密，因此可能会发生这种攻击。如果具有任何类型的加密，则这种欺骗将不起作用。</p><p><strong>ISN计算公式</strong><br><a href="https://www.ietf.org/rfc/rfc1948.txt">RFC1948 Defending Against Sequence Number Attacks</a>提出的ISN计算方法如下：</p><blockquote><p>ISN = M + F(localhost, localport, remotehost, remoteport).</p></blockquote><p>其中M是一个4微妙计时器，F是一个秘密的hash算法。这防止了一部分ISN猜测攻击</p></details><p><strong>Q3：SYN泛洪攻击是什么？如何防范？</strong></p><details><summary>展开</summary><p>SYN泛洪攻击时大量tcp连接发送到服务器，但是只进行前两次握手，导致服务器的资源无法释放。</p><p>解决策略： 当服务器接受到 SYN 报文段时，不直接为该 TCP 分配资源，而只是打开一个半开的套接字。接着会使用 SYN 报文段的源Id，目的Id，端口号以及只有服务器自己知道的一个秘密函数生成一个 cookie，并把 cookie 作为序列号响应给客户端。</p><p>如果客户端是正常建立连接，将会返回一个确认字段为 cookie + 1 的报文段。接下来服务器会根据确认报文的源Id，目的Id，端口号以及秘密函数计算出一个结果，如果结果的值 + 1等于确认字段的值，则证明是刚刚请求连接的客户端，这时候才为该 TCP 分配资源</p><p>这样一来就不会为恶意攻击的 SYN 报文段分配资源空间，避免了攻击。</p></details><hr><h2 id="2-https的是什么？原理是什么？"><a href="#2-https的是什么？原理是什么？" class="headerlink" title="2. https的是什么？原理是什么？"></a>2. https的是什么？原理是什么？</h2><p>https全称为Hyper Text Transfer Protocol over Secure Socket Layer，也就是对http数据包使用tls/ssl协议加密。那么https的原理就是tls协议是如何工作的。</p><p>tls协议简单来说就是将http的明文数据包加密后再发送，那么如何同步客户端与服务端的加密套件、密钥呢？这些前提工作都会在tls握手的时候完成，这是我们需要重点理解的。</p><p>对于加密套件，我们都知道对称密钥算法的强度高，难破解。所以我们只需要为客户端和服务端同步一个对称加密算法。但是对称密钥在网络中的同步是十分困难的。所以对称密钥的同步是tls握手的重点，这一操作又称为密钥协商算法。常用的密钥协商算法分为基于RSA和基于DH两种类型。</p><p><strong>I. 基于RSA的密钥协商算法</strong></p><p>基于RSA的协商算法较为简单：客户端首先生成一个随机数，并使用服务端的公钥加密生成密文发送给服务端，服务端利用自己的私钥解密即可获得服务端生成的随机数。</p><p>但是<strong>RSA密钥交换的简单性是它最大的弱点</strong>。用于加密pre master key的服务器公钥，一般会保持多年不变。任何能够接触到对应私钥的人都可以解密第三个随机数，并构建相同的master key，从而危害到会话安全性。只要密钥泄露，就可以解密之前记录的所有流量了。</p><p><strong>基于DH的协商算法</strong></p><p>DH密钥协商基于一个数学难题，这个不详细介绍。我们只需要知道，对于求模公式<code>b = a^x mod p</code>：已知a计算b很容易，但是已知b计算a却很困难<a href="#refer-anchor-6"><sup>[10]</sup></a>，其中参数a、p均公开。</p><p>使用DH协商密钥的流程如下：</p><ol><li><p>服务器决定a、p两个参数，同时服务器首先生成一个随机数Xs，计算Ys=a^Xs mod p，将参数a、p和Ys发送给客户端，Xs保密</p></li><li><p>客户端生成随机数Xc，计算Yc=a^Xc mod p，发送给服务器，Xc保密</p></li><li><p>客户端利用公式Kc = Ys^Xc mod p计算公钥，服务器利用公式Ks = Yc^Xs mod p计算密钥，最终Kc和Ks一定相同，证明见<a href="#refer-anchor-6"><sup>[10]</sup></a>。</p></li></ol><p>现在比较流程的基于DH的协商算法有ECDH（elliptic curve Diffie-Hellman），ECDH仅仅将基于求模的数学难题替换为基于椭圆曲线的数学难题，后者同样会选择合适的参数a和p。</p><p>tls将密钥分为了三个部分：</p><ol><li>客户端生成的随机数</li><li>服务端生成的随机数</li><li>pre master key</li></ol><p>tls最终会基于这三个部分计算最终的master key。其中前两个随机数的协商较为简单，明文传输即可；对于pre master key的协商则会应用上述基于RSA或DH的协商算法。<br><strong>II. tls流程分析</strong></p><p>tls的握手流程如下所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/tls-workflow.drawio.svg" alt="tls-workflow"></p><p>接下来我们根据抓取访问淘宝的数据包来分析上图的各个阶段，我访问的ip地址为<code>140.205.94.189</code>，实际的握手数据包如下所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.taobao-tls.png" alt="top-questions-for-network.taobao-tls"></p><p><strong>A. Client Hello</strong></p><p>该阶段就是客户端向服务器发起tls认证，向客户端发送了第一个随机数，,并声明客户端支持的算法套件。内容如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.client-hello.png" alt="top-questions-for-network.client-hello"></p><p><strong>B. Server hello</strong></p><p>该阶段确定了密钥算法，并向客户端发送了第二个随机数，如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.server-hello.png" alt="top-questions-for-network.server-hello"><br><strong>C. Certificate</strong></p><p>该阶段将服务器的证书发送给客户端验证，如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.certificate.png" alt="top-questions-for-network.certificate"></p><p><strong>D. Server key Exchange</strong></p><p>该阶段服务器会选择好a、p两个参数（这里的协商算法基于ECDH），并计算出Ys发送给客户端，如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.server-key-exchange.png" alt="top-questions-for-network.server-key-exchange"></p><p><strong>E. client key Excnahge</strong></p><p>该阶段客户端将自己的Yc发送给服务端，如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.client-key-exchange.png" alt="top-questions-for-network.client-key-exchange"></p><p><strong>F. Change Chiper Spec</strong></p><p>客户端和服务端都会存在该阶段，这一阶段表示握手需要的信息发送完毕了，下面就可以使用生成的master key加密数据传输了。</p><p><strong>G. New Session Ticket</strong></p><p>该阶段的工作就是服务器传递给客户端一个Session用以维持https连接，不然每次都像上面这么连接是十分浪费资源的，此次传递的session如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.session-ticket.png" alt="top-questions-for-network.session-ticket"></p><p>至此，同步了session后，客户端和服务端的握手流程结束，可以使用协商好的master key进行加密与解密了。</p><hr><p>扩展问题：</p><p><strong>Q1：tls为什么要使用两个随机数？</strong></p><details><summary>展开</summary><p>以下答案摘自<a href="https://coolcao.com/2018/08/06/https/">https运行原理解析笔记</a>：</p><blockquote><p>前两个随机数采用明文传输，存在被拦截的风险，最终对话密钥安全性只和第三个随机数有关，那么前两个随机数有没有必要？<br>“不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来*<em>保证协商出来的密钥的随机性</em>8。</p></blockquote><blockquote><p>对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。</p></blockquote><blockquote><p>pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。”</p></blockquote><p>所以简单来说，采用三个随机数是为了是最终的对话密钥更“随机”。</p></details><p><strong>Q2：tls使用的证书了解吗</strong></p><details><summary>展开</summary><p>证书按照认证等级可以划分为DV、OV、IV、EV，从左到右，安全性依次增强，当然价格也依次增高。</p><p>数字证书的作用就相当于我们的身份证。对于一个网站A来说，它没办法向客户端证明它是A，就好像我们证明自己身份时需要借助身份证一样。所以这时一般需要借助一个权威的机构来做信用背书，这个权威的机构向客户端证明网站A的真实性。我们是可以完全相信这些权威机构的，所以间接的，我们就相信网站A真的是它自己了。这里的权威机构就是CA（Certificate Authority）。</p><p>那么这里存在一个问题，CA证明我们的网站是真的，那么谁来证明这些CA是真的？答案很简单：因为CA是有等级的，会构成一条形如：网站A-&gt;普通CA-&gt;中等CA-&gt;顶级CA的信用链。顶级CA没有理由作假，因为没有必要砸自己的饭碗。所以顶级CA证明自己的方法就是在给自己颁发的证书上自签名，这一类自己给自己证明的证书叫<strong>自签证书</strong>，又称<strong>根证书</strong>。浏览器和操作系统一般都会将可信度的根证书内置，方便认证。</p><p>那么CA机构颁发数字证书的一般流程是怎么样的呢？</p><ol><li>首先向CA机构提供CSR(certificate signing request),CSR大致个人信息和公钥</li><li>CA验证我们提交的信息，主要是验证我们是否对域名有真正的控制权。如果验证通过，则会使用我们提交的CSR和公钥生成对应的CA证书，并使用自己的私钥对CA进行签名</li></ol><p>上述的认证过程肯定是要花钱的，那么是不是我们一定要花钱才能获得数字证书呢？当然不，因为上面曾提到顶级CA会发布自签证书，我们也可以利用开源软件，比如<a href="https://www.gokuweb.com/operation/d95eae05.html">openssl发布自定义自签证书</a>，再用自定义自签证书发布普通的CA证书。哎，那么那些花钱的人是不是傻？有免费的不用？</p><p>天下没有免费的午餐，自签证书虽然不花钱，但是它最大的缺点就是自签证书<strong>非常</strong>容易被伪造。并且浏览器一般无法认证由自定义自签证书签署的CA证书，会出现下面这种情况：</p><p><img src="images/self-signed.png" alt="self-signed"></p><p>这时因为自签根证书没有内置，信用链的顶部没有可信度。当然我们可以把自定义自签证书安装在浏览器中，就不会出现这种问题。当然，这可能会遭受中间人攻击。</p><p>自签名根证书可能被伪造，如果在主机中安装了伪造的根证书，这时中间人使用了伪造的自签名证书，就不会出现错误提示，劫持了正常流量，这样中间人和主机之间使用自签名的伪造证书建立了https链接，而中间人又和目标网站使用网站正规的CA证书建立了https链接，那么流量对于中间人来说，完全是明文的</p></details><p><strong>Q3：https一定安全吗？</strong></p><details><summary>展开</summary><p><strong>只要我们不信任不安全的CA的证书，https就是安全的。</strong></p><p>因为权威CA签署的证书不容易被篡改。如果篡改了证书内容，新的摘要无法使用CA机构的私钥加密。那么当客户端使用CA机构的公钥解密摘要时，明文和客户端自己计算的证书摘要对不上号，导致证书不被信任，拒绝连接。</p><p>当然仍然有办法攻破https，我发现了两个可能成功的办法：</p><p><strong>方法1：DNS欺骗+安装自定义根证书</strong></p><p>但是上面曾说道，我们可以发布自定义自签根证书，我们使用<a href="https://blog.cuiyongjian.com/safe/https-attack/">dns劫持+伪造证书</a>开展中间人攻击，https将不再安全。攻击方法如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/https-hijack.drawio.svg" alt="https-hijack"></p><p>攻击前提是攻击者已经预先在主机中安装了自签名的根证书A，然后基本的攻击场景如下：</p><ol><li>首先主机对目标网站发起https连接，这时通过<strong>dns劫持</strong>将流量定向到攻击者的机器上</li><li>攻击者返回使用自定义根证书A签名的CA证书，这时由于根证书已经预先安装到主机上，浏览器不会发出警告。所以主机与攻击者之间建立了https连接，主机发送的数据对攻击者来说完全是可见的</li><li>攻击者再与真正的目标网站建立https连接，将主机发送给自己的数据完全转发到目标网站，同理网站的响应数据也将由攻击者转发到主机上</li></ol><p>经过上述的步骤，主机似乎与网站建立了安全的https连接，但是数据完全被中间人窃听了。</p><p><strong>方法2：sslStrip</strong></p><p>SSLStrip<a href="#refer-anchor-11"><sup>[15]</sup></a>方法也是中间人攻击一种。攻击前提时用户使用http发起第一次连接，因为用户一般只会写域名，而不会声明特定的协议。</p><p>该方法的核心操作是利用arp欺骗或dns欺骗将主机流量定向到攻击者机器上并建立http连接，而攻击者与目标网站建立真正的https连接。</p><p>那么如何防范上述攻击呢？这要从客户端和服务端两个方面防范：</p><ul><li>服务端：开启HSTS，拒绝http连接等等</li><li>客户端：不要相信不安全的证书、不要使用http连接</li></ul></details><p><strong>Q4：http如何升级为https？</strong></p><details><summary>展开</summary><p>将http升级为https的方法一般以下两种方法：</p><ol><li>302重定向</li><li>服务端开启HSTS(HTTP Strict Transport Security)<a href="#refer-anchor-8"><sup>[12]</sup></a></li></ol><p>重定向的方法很简单，简单让浏览器重定向访问即可，但是非常不安全。因为第一次连接使用http协议的，这有可能被劫持实施SSLStrip。而且即便当前连接是https，页内的连接仍有可能是http的，又给了黑客一次机会。所以这种方法很不安全。</p><p>上面的缺陷可以总结为两点：</p><ul><li>用户书签是http或者手动输入了http</li><li>https连接的页面内可能有http连接</li></ul><p>而HSTS能够在一定程度上解决上面的缺陷。因为开启HSTS后，浏览器内部会将http使用307重定向为https，并且HSTS还能够完全拒绝危险的证书。因为上面曾说过，浏览器虽然会对自签证书发出警告，但是用户可以选择忽略警告，继续访问，如下图所示：</p><p><img src="images/HSTS.png" alt="hsts"></p><p>HSTS则不会显示此选项，用户不能忽略警告。</p><p><strong>HSTS开启的方法</strong></p><p>只需要在http添加以下内容即可：</p><blockquote><p>Strict-Transport-Security: max-age=31536000; includeSubDomains</p></blockquote><p>其中<code>max-age</code>表示HSTS有效的时间。</p><p><strong>HSTS的缺陷</strong></p><p>HSTS虽然厉害，但仍然有缺点：用户首次访问某网站是不受HSTS保护的。这是因为首次访问时，浏览器还未收到HSTS，所以仍有可能通过明文HTTP来访问。解决这个问题的方法有两点<a href="#refer-anchor-10"><sup>[14]</sup></a>：</p><p>一是浏览器预置HSTS域名列表，Google Chrome、Firefox、Internet Explorer和Spartan实现了这一方案。google坚持维护了一个“HSTS preload list”的站点域名和子域名，并通过<a href="https://hstspreload.appspot.com/">https://hstspreload.appspot.com/</a>提交其域名。该域名列表被分发和硬编码到主流的web浏览器。客户端访问此列表中的域名将主动的使用HTTPS，并拒绝使用HTTP访问该站点。</p><p>二是将HSTS信息加入到域名系统记录中。但这需要保证DNS的安全性，也就是需要部署域名系统安全扩展。截至2014年这一方案没有大规模部署。</p></details><hr><h2 id="3-tcp的断开机制？"><a href="#3-tcp的断开机制？" class="headerlink" title="3. tcp的断开机制？"></a>3. tcp的断开机制？</h2><p>tcp的断开有两种情况：理想情况下的三次握手，或者<strong>半关闭</strong>的四次握手。</p><p>因为tcp是双工的，所以当tcp断开来接时，收发两端都需要确定对方收到了自己准备要断开连接的信息。所以与tcp建立连接的三次握手类似，在理想情况下，三次握手就能够保证收发两端收到足够的信息断开连接。过程如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.tcp-remove-three-handshake.png" alt="top-questions-for-network.tcp-remove-three-handshake"></p><p>而所谓的半关闭，是指在一方断开了连接的请款下，另一方仍能够发送剩余的信息。半关闭就需要四次握手才能传递足够的信息,这是因为理想情况下的第二次握手被拆分成了两次。如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.tcp-remove-four-handshake.png" alt="top-questions-for-network.tcp-remove-four-handshake"></p><hr><p>扩展问题</p><p><strong>Q1：TIME_WAIT状态了解吗？</strong></p><p>tcp连接与释放的过程中，会形成11种状态，如下图所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.11-status.png" alt="top-questions-for-network.11-status"></p><p>而<code>TIME_WAIT</code>状态是<strong>断开</strong>连接时<strong>主动方独有</strong>的状态。当主动方进入该状态时，等待2MSL后，才会完全释放当前资源。</p><p>我们以半关闭四次握手的状态转化为例，了解什么时候会进入该状态：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.time-wait-status-in-four.png" alt="top-questions-for-network.time-wait-status-in-four"></p><p>从上图中看出，当主动方发出FIN后，会经历FIN-WAIT-1 –&gt; FIN-WAIT-2 –&gt; TIME-WAIT  –&gt; CLOSED的状态转化。</p><p>而被动方第一次收到主动方的FIN后，会经历CLOSE-WAIT –&gt; LAST-ACK –&gt; CLOSED状态。</p><p><strong>Q2：TIME_WAIT为什么被设置为2MSL？</strong></p><p>有两点原因<a href="#refer-anchor-13"><sup>[17]</sup></a>：</p><ol><li>防止复用旧链接的ip、端口建立新链接时，旧链接的数据包还存活</li><li>保证tcp正确的被关闭，即被动关闭一方收到ACK</li></ol><p>首先MSL（maximum segment lifetime）是segment能够在网络中存活的最长时间。那么为什么2MSL就能保证旧链接的数据包不会存活呢？</p><p>在进入TIME-WAIT状态后，主动方会发送ACK，这个ACK最坏在刚好经过1MSL时，到达了被动收方。而被动收方在ACK到达前一直在重发FIN。如果在0.9999MSL时，被动收方发送了最后一个FIN，它最多在网络中存活1MSL。那么主动收方等待2MSL后，主动方发送的最后一个ACK、被动方发送的最后一个FIN都会在网络中消失。<br>那么旧链接的普通数据包肯定会在最后一个ACK和FIN之前发出，所以普通数据包也肯定会在网络中消失。</p><p>当主动方每次收到FIN,会重设2MSL的等待时间。</p><p>如果Server在长时间收不到ACK，重传FIN的次数达到某一设定值时，会向Client发送RESET报文段，表明“异常终止”，然后完全结束本次TCP连接（它不再操心客户是否收到RESET报文段），避免无限占用资源。（对应上图中的Stop Sending FIN)</p><hr><h2 id="4-tcp是如何保证可靠性的？"><a href="#4-tcp是如何保证可靠性的？" class="headerlink" title="4. tcp是如何保证可靠性的？"></a>4. tcp是如何保证可靠性的？</h2><p>保障可靠性主要有三个方面：流量控制、差错控制（校验和、确认机制、超时机制）、拥塞控制。</p><p>流量控制仅仅是考虑两台机器之间的传输能力，而拥塞控制则考虑了网络传输的能力。</p><h2 id="5-tcp的流量控制？"><a href="#5-tcp的流量控制？" class="headerlink" title="5. tcp的流量控制？"></a>5. tcp的流量控制？</h2><p>流量控制通过滑动窗口来实现，并且发送方的窗口通过接收方来控制。接收方会维护一个名为<code>rwind</code>的滑动窗口。还需更新</p><p>一般有一个要求：<br>新的ackNo+新rwnd&gt;=旧的ackNo+旧rwnd，也就是说滑动窗口的右沿一般不移动</p><hr><p><strong>Q1：糊涂窗口综合症是什么？如何避免？</strong></p><p>糊涂窗口综合症有两种：发方糊涂和收方糊涂。</p><p><strong>发方糊涂</strong>是指发送方每次发送的数据很少，极端情况下有效数据仅有一个字节，而tcp头部达到四十字节，极大降低效率。解决办法是nagle算法：</p><ol><li>nagle算法定义是任意时刻，最多只能有一个未被确认的小段。 所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。流程如下图所示：</li></ol><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.nagle.png" alt="top-questions-for-network.nagle"></p><p><strong>收方糊涂</strong>是指收方处理数据很慢，每次都只能处理一个字节，而发送方一次也只能发送一个字节。处理的方法一般有以下两种：</p><ol><li><p>延迟确认，这表示当一个报文段到达时并不立即发送确认。接收端在确认收到的报文段之前一直等待，直到缓存有足够的空间为止。</p></li><li><p>Clark解决方法，这表示只要有数据到达就发送确认，但宣布的窗口大小为零，直到或者缓存空间已能放入具有最大长度的报文段，或者缓存空间的一半已经空了。</p></li></ol><hr><h2 id="6-tcp的拥塞控制？"><a href="#6-tcp的拥塞控制？" class="headerlink" title="6. tcp的拥塞控制？"></a>6. tcp的拥塞控制？</h2><p>tcp提出了四种拥塞策略：慢启动，拥塞避免，快速重传，快恢复。而实际的拥塞算法可以按照判断拥塞的标准分为基于丢包的拥塞算法和基于网络延迟的拥塞算法<a href="#refer-anchor-14"><sup>[18]</sup></a>：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.base-packet-loss.png" alt="top-questions-for-network.base-packet-loss"><br><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.base-time.png" alt="top-questions-for-network.base-time"></p><p>而上述四种拥塞策略主要应用在传统的基于丢包的拥塞算法上：</p><ul><li>taho：采用慢启动和拥塞避免策略。并且用相同的拥塞策略对待超时和三次ACk</li><li>reno：采用慢启动、拥塞避免、快速恢复策略</li><li>new reno：采用慢启动、拥塞避免、快速恢复策略</li></ul><p>以下内容详细介绍了这四种策略的步骤，以及在三种算法中的应用。引自<a href="https://www.cnblogs.com/fll/archive/2008/06/10/1217013.html">TCP拥塞控制算法</a>：</p><p>最初由V. Jacobson在1988年的论文中提出的TCP的拥塞控制由“慢启动(Slow start)”和“拥塞避免(Congestion avoidance)”组成，后来TCP Reno版本中又针对性的加入了“快速重传(Fast retransmit)”、“快速恢复(Fast Recovery)”算法，再后来在TCP NewReno中又对“快速恢复”算法进行了改进，近些年又出现了选择性应答( selective acknowledgement,SACK)算法。</p><p>TCP的拥塞控制主要原理依赖于一个拥塞窗口(cwnd)来控制，在之前我们还讨论过TCP还有一个对端通告的接收窗口(rwnd)用于流量控制。TCP的拥塞控制算法就是要在这两者之间权衡，选取最好的cwnd值，从而使得网络吞吐量最大化且不产生拥塞，一般来说选择min(cwind,rwind)。</p><p>关于cwnd的单位，在TCP中是以<strong>字节</strong>来做单位的，我们假设TCP每次传输都是按照MSS大小来发送数据的，因此你可以认为cwnd按照数据包个数来做单位也可以理解，所以有时我们说cwnd增加1也就是相当于字节数增加1个MSS大小。</p><p><strong>I. 慢启动</strong></p><p>最初的TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此新建立的连接不能够一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量，以避免上述现象的发生。具体来说，当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加1个MSS大小。这样cwnd的值就随着网络往返时间(Round Trip Time,RTT)呈指数级增长，事实上，慢启动的速度一点也不慢，只是它的起点比较低一点而已。我们可以简单计算下：</p><ol><li><p>开始           —&gt;     cwnd = 1</p></li><li><p>经过1个RTT后   —&gt;     cwnd = 2*1 = 2</p></li><li><p>经过2个RTT后   —&gt;     cwnd = 2*2= 4</p></li><li><p>经过3个RTT后   —&gt;     cwnd = 4*2 = 8</p></li></ol><p>如果带宽为W，那么经过RTT*log2W时间就可以占满带宽。</p><p><strong>II. 拥塞避免</strong></p><p>从慢启动可以看到，cwnd可以很快的增长上来，从而最大程度利用网络带宽资源，但是cwnd不能一直这样无限增长下去，一定需要某个限制。TCP使用了一个叫慢启动门限(ssthresh)的变量，当cwnd超过该值后，慢启动过程结束，进入拥塞避免阶段。对于大多数TCP实现来说，ssthresh的值是65536(同样以字节计算)。<strong>拥塞避免的主要思想是加法增大，也就是cwnd的值不再指数级往上升，开始加法增加</strong>。此时当窗口中所有的报文段都被确认时，cwnd的大小加1，cwnd的值就随着RTT开始线性增加，这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。</p><p>上面讨论的两个机制都是没有检测到拥塞的情况下的行为，那么当发现拥塞了cwnd又该怎样去调整呢？</p><p>首先来看TCP是如何确定网络进入了拥塞状态的，<strong>TCP认为网络拥塞的主要依据是它重传了一个报文段</strong>。上面提到过，TCP对每一个报文段都有一个定时器，称为重传定时器(RTO)，当RTO超时且还没有得到数据确认，那么TCP就会对该报文段进行重传，当发生超时时，那么出现拥塞的可能性就很大，某个报文段可能在网络中某处丢失，并且后续的报文段也没有了消息，在这种情况下，TCP反应比较“强烈”：</p><ol><li><p>把ssthresh降低为cwnd值的一半</p></li><li><p>把cwnd重新设置为1</p></li><li><p>重新进入慢启动过程。</p></li></ol><p>从整体上来讲，TCP拥塞控制窗口变化的原则是AIMD原则，即加法增大、乘法减小。可以看出TCP的该原则可以较好地保证流之间的公平性，因为一旦出现丢包，那么立即减半退避，可以给其他新建的流留有足够的空间，从而保证整个的公平性。</p><p>其实TCP还有一种情况会进行重传：那就是收到3个相同的ACK。TCP在收到乱序到达包时就会立即发送ACK，TCP利用3个相同的ACK来判定数据包的丢失，此时进行<strong>快速重传</strong>，快速重传做的事情有：</p><ol><li><p>把ssthresh设置为cwnd的一半</p></li><li><p>把cwnd再设置为ssthresh的值(具体实现有些为ssthresh+3)</p></li><li><p>重新进入拥塞避免阶段。</p></li></ol><p><strong>III. 快速恢复</strong></p><p>后来的快速恢复算法是在上述的“快速重传”算法后添加的，当收到3个重复ACK时，TCP最后进入的不是拥塞避免阶段，而是快速恢复阶段。快速重传和快速恢复算法一般同时使用。快速恢复的思想是“数据包守恒”原则，即同一个时刻在网络中的数据包数量是恒定的，只有当“老”数据包离开了网络后，才能向网络中发送一个“新”的数据包，如果发送方收到一个重复的ACK，那么根据TCP的ACK机制就表明有一个数据包离开了网络，于是cwnd加1。如果能够严格按照该原则那么网络中很少会发生拥塞，事实上拥塞控制的目的也就在修正违反该原则的地方。</p><p>具体来说快速恢复的流程如下所示：</p><p><img src="https://eripe.oss-cn-shanghai.aliyuncs.com/img/top-questions-for-network.reno.png" alt="top-questions-for-network.reno"></p><ol><li><p>当收到3个重复ACK时，把ssthresh设置为cwnd的一半，把cwnd设置为ssthresh的值加3，然后重传丢失的报文段，加3的原因是因为收到3个重复的ACK，表明有3个“老”的数据包离开了网络。 </p></li><li><p>再收到重复的ACK时，拥塞窗口增加1。</p></li><li><p>当收到新的数据包的ACK时，把cwnd设置为第一步中的ssthresh的值。原因是因为该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。</p></li></ol><p>快速重传算法首次出现在4.3BSD的Tahoe版本，快速恢复首次出现在4.3BSD的Reno版本，也称之为Reno版的TCP拥塞控制算法。</p><p>可以看出Reno的快速重传算法是针对一个包的重传情况的，然而在实际中，一个重传超时可能导致许多的数据包的重传，因此当多个数据包从一个数据窗口中丢失时并且触发快速重传和快速恢复算法时，问题就产生了。因此NewReno出现了，它在Reno快速恢复的基础上稍加了修改，可以恢复一个窗口内多个包丢失的情况。具体来讲就是：Reno在收到一个新的数据的ACK时就退出了快速恢复状态了，而NewReno需要收到该窗口内所有数据包的确认后才会退出快速恢复状态，从而更一步提高吞吐量。</p><p>SACK就是改变TCP的确认机制，最初的TCP只确认当前已连续收到的数据，SACK则把乱序等信息会全部告诉对方，从而减少数据发送方重传的盲目性。比如说序号1，2，3，5，7的数据收到了，那么普通的ACK只会确认序列号4，而SACK会把当前的5，7已经收到的信息在SACK选项里面告知对端，从而提高性能，当使用SACK的时候，NewReno算法可以不使用，因为SACK本身携带的信息就可以使得发送方有足够的信息来知道需要重传哪些包，而不需要重传哪些包。</p><h2 id="7-加不加www有什么区别？"><a href="#7-加不加www有什么区别？" class="headerlink" title="7. 加不加www有什么区别？"></a>7. 加不加www有什么区别？</h2><p>其实是因为早期服务器资源有限，一个服务器往往要承担多项任务，所以在主域名前面加子域名<code>www</code>表示万维网服务<a href="#refer-anchor-12"><sup>[16]</sup></a>，例如<code>www.example.com</code>表示互联网，<code>mail.example.com</code>表示邮件服务。</p><p>而后来资源丰富，仍然加上www仅仅是为了纪念万维网的建立，</p><h2 id="8-http常用的状态码有哪些？"><a href="#8-http常用的状态码有哪些？" class="headerlink" title="8. http常用的状态码有哪些？"></a>8. http常用的状态码有哪些？</h2><ol><li>2xx状态码：操作成功。200 OK</li><li>3xx状态码：重定向。301 永久重定向；302暂时重定向</li><li>4xx状态码：客户端错误。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found；</li><li>5xx状态码：服务端错误。500服务器内部错误；501服务不可用</li></ol><h2 id="9-既然IP层已经分片了，TCP为什么还要分段？"><a href="#9-既然IP层已经分片了，TCP为什么还要分段？" class="headerlink" title="9. 既然IP层已经分片了，TCP为什么还要分段？"></a>9. 既然IP层已经分片了，TCP为什么还要分段？</h2><p>因为ip是没有重传机制的，如果tcp不分段，那么如果ip层丢失了某个报文片，就需要重传整个报文。</p><h2 id="10-GET和POST的区别？"><a href="#10-GET和POST的区别？" class="headerlink" title="10. GET和POST的区别？"></a>10. GET和POST的区别？</h2><ol><li><p>POST与相比GET，A通常在请求主体中具有相关信息。（一个GET不应该有主体，因此除了cookie之外，唯一可以传递信息的地方就是URL。）除了保持URL相对整洁之外，POST还可以让您发送更多的信息（由于URL的长度受到限制，因此在实际操作中用途），并让您几乎可以发送任何类型的数据（例如，文件上传表单不能使用GET-它们必须使用，还要POST加上特殊的内容类型/编码）。</p></li><li><p>除此之外，POST表示请求将更改某些内容，并且不应随意重做。这就是为什么您有时会在单击“后退”按钮时看到浏览器询问您是否要重新提交表单数据的原因。</p></li><li><p>GET另一方面，它应该是幂等的，这意味着您可以做一百万次，并且服务器每次都会做相同的事情（并且基本上显示出相同的结果）</p></li><li><p>最后，在使用AJAX发送GET请求时，一个重要的考虑因素是某些浏览器（尤其是IE）会缓存GET请求的结果。因此，例如，如果您使用相同的GET请求进行轮询，即使您正在查询的数据正在服务器端更新，您也将始终获得相同的结果。缓解此问题的一种方法是，通过附加时间戳使每个请求的URL唯一。</p></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><div id="refer-anchor-1"></div><p>[1] <a href="https://www.pythonthree.com/what-is-cname/">什么是CNAME记录？CNAME记录如何使用</a></p><div id="refer-anchor-1"></div><p>[2] <a href="https://www.zhihu.com/question/29998374">顶级域名 一级域名 二级域名 三级域名什么区别?</a></p><div id="refer-anchor-3"></div><p>[3] <a href="https://blog.csdn.net/lnboxue/article/details/52220928">一步一步学习IP路由流程</a></p><p>[4] <a href="https://cloud.tencent.com/developer/article/1173761">转发表(MAC表)、ARP表、路由表总结</a></p><p>[5] <a href="https://www.cnblogs.com/michael9/p/13345911.html">数据包的通信过程</a></p><p>[6] <a href="https://zhuanlan.zhihu.com/p/21392419">浅谈路由协议</a></p><div id="refer-anchor-4"></div><p>[7] <a href="https://draveness.me/whys-the-design-tcp-three-way-handshake/">为什么 TCP 建立连接需要三次握手</a></p><p>[8] <a href="https://developer.aliyun.com/article/742739">阿里面试官： HTTP、HTTPS、TCP/IP、Socket通信、三次握手四次挥手过程？（附全网最具深度的三次握手、四次挥手讲解）</a></p><div id="refer-anchor-5"></div><p>[9] <a href="https://www.quora.com/Why-in-a-TCP-sequence-is-a-number-taken-as-a-random-number-and-what-is-the-actual-number-at-the-start">Why in a TCP sequence, is a number taken as a random number and what is the actual number at the start?</a></p><div id="refer-anchor-6"></div><p>[10] <a href="http://wsfdl.com/algorithm/2016/02/04/%E7%90%86%E8%A7%A3Diffie-Hellman%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95.html">理解 Deffie-Hellman 密钥交换算法</a></p><div id="refer-anchor-7"></div><p>[11] <a href="https://razeencheng.com/post/ssl-handshake-detail">HTTPS篇之SSL握手过程详解</a></p><div id="refer-anchor-8"></div><p>[12] <a href="https://www.acunetix.com/blog/articles/what-is-hsts-why-use-it/">What Is HSTS and Why Should I Use It?</a></p><div id="refer-anchor-9"></div><p>[13] <a href="https://www.digitalocean.com/community/tutorials/understanding-nginx-http-proxying-load-balancing-buffering-and-caching">Understanding Nginx HTTP Proxying, Load Balancing, Buffering, and Caching</a></p><div id="refer-anchor-10"></div><p>[14] <a href="https://blog.csdn.net/weixin_44316575/article/details/103698819">nginx启用HSTS以支持从http到https不通过服务端而自动跳转</a></p><div id="refer-anchor-11"></div><p>[15] <a href="https://jjayyyyyyy.github.io/2017/04/27/HSTS.html">HSTS学习笔记</a></p><div id="refer-anchor-12"></div><p>[16] <a href="https://www.zhihu.com/question/20064691">为什么有些网址前面没有www？</a></p><div id="refer-anchor-13"></div><p>[17] <a href="https://www.zhihu.com/question/67013338">为什么TCP4次挥手时等待为2MSL？</a></p><div id="refer-anchor-14"></div><p>[18] <a href="https://my.oschina.net/u/3872630/blog/4434563">万字长文|全网最强 TCP/IP 拥塞控制总结…</a></p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/network/">network</category>
      
      
      
      <comments>https://eripe.me/articles/top-questions-for-network.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
