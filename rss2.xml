<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>一颗胡杨树</title>
    <link>https://eripe.me/</link>
    
    <image>
      <url>https://eripe.me/img/panda.png</url>
      <title>一颗胡杨树</title>
      <link>https://eripe.me/</link>
    </image>
    
    <atom:link href="https://eripe.me/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>欢迎乘坐八楼的二路公交车</description>
    <pubDate>Mon, 14 Jun 2021 11:50:07 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>反射初体验</title>
      <link>https://eripe.me/articles/%E5%8F%8D%E5%B0%84%E5%88%9D%E4%BD%93%E9%AA%8C.html</link>
      <guid>https://eripe.me/articles/%E5%8F%8D%E5%B0%84%E5%88%9D%E4%BD%93%E9%AA%8C.html</guid>
      <pubDate>Mon, 14 Jun 2021 11:50:07 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h3 id=&quot;0x0-反射是什么&quot;&gt;&lt;a href=&quot;#0x0-反射是什么&quot; class=&quot;headerlink&quot; title=&quot;0x0 反射是什么&quot;&gt;&lt;/a&gt;0x0</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h3 id="0x0-反射是什么"><a href="#0x0-反射是什么" class="headerlink" title="0x0 反射是什么"></a>0x0 反射是什么</h3><p>反射是java中非常重要的一个概念。简而言之，反射就是在程序<strong>运行时</strong>可以<strong>动态</strong>的获取一个类的对象、执行某个类的方法等等。这里采用<a href="https://stackoverflow.com/questions/4453349/what-is-the-class-object-java-lang-class">overflow</a>上的一个回答。</p><blockquote><p>In order to fully understand the class object, let go back in and understand we get the class object in the first place. You see, every .java file you create, when you compile that .java file, the jvm will creates a .class file, this file contains all the information about the class, namely:</p></blockquote><blockquote><p>Fully qualified name of the class<br>Parent of class<br>Method information<br>Variable fields<br>Constructor<br>Modifier information<br>Constant pool<br>The list you see above is what you typically see in a typical class. Now, up to this point, your .java file and .class file exists on your hard-disk, when you actually need to use the class i.e. executing code in main() method, the jvm will use that .class file in your hard drive and load it into one of 5 memory areas in jvm, which is the method area, immediately after loading the .class file into the method area, the jvm will use that information and a Class object that represents that class that exists in the heap memory area.</p></blockquote><blockquote><p>Here is the top level view,<br>.java –compile–&gt; .class –&gt;when you execute your script–&gt; .class loads into method area –jvm creates class object from method area–&gt; a class object is born</p></blockquote><p>With a class object, you are obtain information such as class name, and method names, everything about the class.</p><p>反射机制是通过一个名为Class对象的概念来实现的。在编译每个.java文件后，都会生成一个对应的.class文件。这个.class文件包含了我们所编写的类的所有信息。比如类的全限定名、属性、方法、修饰符等等。然后当我们需要使用所编写的类时（这里记为target），.class文件会被加载至方法区，并且jvm会在堆区创建一个target类对应的Class对象。然后targt类的所有实例都由这个Class对象来产生。</p><p>注意，对于一个类，jvm只会生成一个对应的Class对象。</p><h3 id="0x1-反射有什么用"><a href="#0x1-反射有什么用" class="headerlink" title="0x1 反射有什么用"></a>0x1 反射有什么用</h3><p>反射最主要的作用的我认为就是提高了对未知应用的扩展能力。</p><p>试想一个场景：</p><p>项目的云服务我们最先使用的是阿里云，然后某天不爽想换成腾讯云，然后又换成什么亚马逊，七牛等等，需求不停的在变。如果我们在代码里写死了业务代码，那么每换一次，就要更新一次代码，烦不烦，你说烦不烦。</p><p>那么这是肯定有人想，写个配置文件，到时候我们在代码里判断到底用的是哪个云服务不就完事了？用什么反射，自找麻烦。</p><p>但是想过没有，我们if判断的条件只能是已知的，如果某天市场上杀出一个新的厂商，怎么办？还是得更新业务代码。得重新编译、重新运行。</p><p>所以为了处理这种未知的状况，就不得不使用使用反射了。我们把类名写在配置文件里，然后利用反射加载对应的类，这样以不变应万变。配置文件变化时只需要重新应用就行了，<strong>无需重新编译代码!!!</strong></p><p>当然，这些服务应该还有统一的接口，不然不可能实现一份代码适配多种情况。</p><h3 id="0x2-反射怎么用"><a href="#0x2-反射怎么用" class="headerlink" title="0x2 反射怎么用"></a>0x2 反射怎么用</h3><h4 id="1-获取反射对象"><a href="#1-获取反射对象" class="headerlink" title="1. 获取反射对象"></a>1. 获取反射对象</h4><p>想使用反射，我们必须得首先获得Class对象，获得Class对象的方法有三种：</p><ul><li>使用Class类的静态方法forName，参数为类的全限定名</li><li>直接使用某个类的class属性</li><li>调用某个对象的getClass()方法</li></ul><figure class="highlight java"><figcaption><span>"获取Class对象的三种方式"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//获取class对象的方法有三种</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getClassObject</span><span class="hljs-params">(Employee employee)</span></span>&#123;<br>        <span class="hljs-comment">//第一种通过全限定名获取</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Class c1=Class.forName(<span class="hljs-string">&quot;ReflectionBase.Employee&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">//第二种通过类的class属性获取</span><br>        Class&lt;ReflectionBase.Employee&gt; c2=Employee.class;<br><br>        <span class="hljs-comment">//第三种通过对象的getClass()方法获取</span><br>        Class&lt;? extends ReflectionBase.Employee&gt; c3=employee.getClass();<br>    &#125;<br></code></pre></div></td></tr></table></figure><h4 id="2-通过Class对象创造实例"><a href="#2-通过Class对象创造实例" class="headerlink" title="2. 通过Class对象创造实例"></a>2. 通过Class对象创造实例</h4><p>主要有两种方法：</p><ul><li>调用Class对象的newInstance()方法。</li><li>通过Class对象获取想要的Constructor，然后通过Constructor生成实例</li></ul><figure class="highlight java"><figcaption><span>"通过反射获取类的实例"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//通过newInstance方法</span><br><span class="hljs-keyword">try</span> &#123;<br>    Employee instance = c2.newInstance();<br>&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>    e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//通过获取Constructor来构造实例</span><br><span class="hljs-comment">//其中的参数填充要根据我们想要的构造函数</span><br><span class="hljs-keyword">try</span> &#123;<br>    Constructor&lt;Employee&gt; constructor = c2.getDeclaredConstructor(String.class, <span class="hljs-keyword">int</span>.class, String.class, <span class="hljs-keyword">int</span>.class, String.class, <span class="hljs-keyword">double</span>.class);<br>    <span class="hljs-comment">//取消访问检查</span><br>    constructor.setAccessible(<span class="hljs-keyword">true</span>);<br>    Employee e = constructor.newInstance(<span class="hljs-string">&quot;bob&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;eng&quot;</span>, <span class="hljs-number">200.2</span>);<br>    e.sayHello();<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，第一种方法只能通过默认无参构造方法构造对象，那么如果我们的类米有无参构造函数怎么办？这也许就是它被放弃的理由吧。</p><p>第二种可以获取任意一个构造函数，无论有参无参、私有公共，不过就是参数必须一一对应。</p><h4 id="3-获取修饰符"><a href="#3-获取修饰符" class="headerlink" title="3. 获取修饰符"></a>3. 获取修饰符</h4><p>修饰符的信息封装在<code>Modifier</code>类中，常见的用法通过<code>getModifiers()</code>返回一个用于描述Field、Method和Constructor的修饰符的整形数值，然后再由Modifier的静态方法<code>toString()</code>转为字符串。</p><p>以及一些常用的判断是否为<code>static</code>字段。</p><h4 id="4-获取类的属性"><a href="#4-获取类的属性" class="headerlink" title="4. 获取类的属性"></a>4. 获取类的属性</h4><p>类的属性都由Filed类管理。常用的方法有：</p><ul><li><code>getFields()</code>,获取该类所有的public属性，但不包括父类的属性。</li><li><code>getDeclaredFields()</code>,获取该类的所有属性，包括私有，但同样不包括父类的属性</li></ul><figure class="highlight java"><figcaption><span>"获取类的所有属性"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">parseFields</span><span class="hljs-params">(Class c)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    StringBuilder sb=<span class="hljs-keyword">new</span> StringBuilder();<br>    Field[] fields = c.getFields();<br><br>    <span class="hljs-keyword">for</span> (Field elem : fields) &#123;<br><br>        sb.append(SPLIT);<br>        <span class="hljs-keyword">int</span> modifiers = elem.getModifiers();<br>        <span class="hljs-keyword">if</span> (Modifier.toString(modifiers).length() &gt; <span class="hljs-number">0</span>) &#123;<br>            sb.append(Modifier.toString(modifiers)).append(SPLIT);<br><br>        &#125;<br>        Class&lt;?&gt; type = elem.getType();<br>        <span class="hljs-keyword">if</span> (type != <span class="hljs-keyword">null</span>) &#123;<br>            sb.append(type.getName()).append(SPLIT);<br>        &#125;<br>        sb.append(elem.getName());<br>        sb.append(<span class="hljs-string">&quot;;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br></code></pre></div></td></tr></table></figure><h4 id="5-获取类的构造方法"><a href="#5-获取类的构造方法" class="headerlink" title="5. 获取类的构造方法"></a>5. 获取类的构造方法</h4><p>同样，类的构造方法也会被封装在<code>Constructor</code>类中。<code>getDeclaredConstructors()</code>可以获取该类的所有构造方法。但是不包含<strong>父类的构造方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">parseConstructor</span><span class="hljs-params">(Class c)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    StringBuilder sb=<span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-comment">//获得该类的所有共有构造方法</span><br>    Constructor[] constructors = c.getConstructors();<br>    <span class="hljs-keyword">for</span>(Constructor elem:constructors)&#123;<br>        sb.append(SPLIT);<br>        <span class="hljs-keyword">int</span> modifiers = elem.getModifiers();<br>        <span class="hljs-keyword">if</span>(Modifier.toString(modifiers).length()&gt;<span class="hljs-number">0</span>)&#123;<br>            sb.append(Modifier.toString(modifiers)).append(SPLIT);<br>        &#125;<br>        sb.append(elem.getName()).append(<span class="hljs-string">&quot;(&quot;</span>);<br>        Class[] types = elem.getParameterTypes();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;types.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>)&#123;<br>                sb.append(<span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>            sb.append(types[i].getName());<br>        &#125;<br>        sb.append(<span class="hljs-string">&quot;);\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br></code></pre></div></td></tr></table></figure><h4 id="6-获取类的所有方法"><a href="#6-获取类的所有方法" class="headerlink" title="6. 获取类的所有方法"></a>6. 获取类的所有方法</h4><p>与上面类似，方法被封装在Method类中，同样，<code>getDeclaredMethod()</code>获取的方法<strong>不包括</strong>父类的方法。<code>getMethods()</code>获取公共的、父类或接口的所有方法。</p><figure class="highlight java"><figcaption><span>"获取类的所有方法"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">parseMethods</span><span class="hljs-params">(Class c)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    StringBuilder sb=<span class="hljs-keyword">new</span> StringBuilder();<br>    Method[] methods = c.getDeclaredMethods();<br>    <span class="hljs-keyword">for</span>(Method elem:methods)&#123;<br>        sb.append(SPLIT);<br>        <span class="hljs-keyword">int</span> modifiers = elem.getModifiers();<br>        <span class="hljs-keyword">if</span>(Modifier.toString(modifiers).length()&gt;<span class="hljs-number">0</span>)&#123;<br>            sb.append(Modifier.toString(modifiers)).append(SPLIT);<br>        &#125;<br>        Class&lt;?&gt; returnType = elem.getReturnType();<br>        sb.append(returnType.getName()).append(SPLIT);<br>        sb.append(elem.getName()).append(<span class="hljs-string">&quot;(&quot;</span>);<br>        Class&lt;?&gt;[] parameterTypes = elem.getParameterTypes();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;parameterTypes.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>)&#123;<br>                sb.append(<span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>            sb.append(parameterTypes[i].getName());<br>        &#125;<br>        sb.append(<span class="hljs-string">&quot;);\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>获取了方法，我们如何使用？非常简单，调用Method类的<code>invoke(Object invoke(Object obj, Object... args)</code> 执行方法，第一个参数执行该方法的对象，如果是static修饰的类方法，则传null即可方法。</p><p>通过获取Method对象时，仍然需要通过准确的参数类型才能找到我们想要的method对象。</p><h4 id="7-解析类的基本信息"><a href="#7-解析类的基本信息" class="headerlink" title="7. 解析类的基本信息"></a>7. 解析类的基本信息</h4><p>有了上面的工具我们就可以通过class文件来解析该类的基本信息了，我们构造两个类，Person和Employee类，后者继承前者：</p><figure class="highlight java"><figcaption><span>"Person类"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> String hobby;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String hobby)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.hobby = hobby;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getHobby</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> hobby;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHobby</span><span class="hljs-params">(String hobby)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.hobby = hobby;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><hr><figure class="highlight java"><figcaption><span>"Employee类"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> employeeId;<br>    <span class="hljs-keyword">protected</span> String title;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String hobby, <span class="hljs-keyword">int</span> employeeId, String title, <span class="hljs-keyword">double</span> salary)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name, age, hobby);<br>        <span class="hljs-keyword">this</span>.employeeId = employeeId;<br>        <span class="hljs-keyword">this</span>.title = title;<br>        <span class="hljs-keyword">this</span>.salary = salary;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;Hello, 我是 %s, 今年 %s 岁, 爱好是%s, 我目前的工作是%s, 月入%s元\n&quot;</span>,<br>                name, age, getHobby(), title, salary));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;My name is %s, 工作中勿扰.&quot;</span>, name));<br><br>    &#125;<br></code></pre></div></td></tr></table></figure><p>构造了上述类，我们就可以通过反射获取该类的字段、构造器、方法等等，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseClass</span><span class="hljs-params">(String className)</span></span>&#123;<br><br>    StringBuilder result=<span class="hljs-keyword">new</span> StringBuilder();<br>    Class c= <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        c = Class.forName(className);<br>        <span class="hljs-keyword">int</span> modifiers = c.getModifiers();<br>        <span class="hljs-comment">//打印类的修饰符</span><br>        result.append(Modifier.toString(modifiers));<br>        result.append(SPLIT);<br>        result.append(c.getName()).append(SPLIT);<br>        Class superclass = c.getSuperclass();<br>        <span class="hljs-keyword">if</span>(superclass!=<span class="hljs-keyword">null</span> &amp;&amp; superclass!=Object.class)&#123;<br>            result.append(<span class="hljs-string">&quot;extends&quot;</span>).append(SPLIT).append(superclass.getName());<br>        &#125;<br>        result.append(<span class="hljs-string">&quot;&#123;\n&quot;</span>);<br>        <span class="hljs-comment">//打印属性</span><br>        result.append(parseFields(c));<br>        <span class="hljs-comment">//打印构造函数</span><br>        result.append(parseConstructor(c));<br>        <span class="hljs-comment">//打印成员方法</span><br>        result.append(parseMethods(c));<br><br>        result.append(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>        System.out.println(result.toString());<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>        e.getMessage();<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ReflectionBase.Employee extends ReflectionBase.Person&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> employeeId;<br>    <span class="hljs-keyword">public</span> java.lang.String name;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="8-解析类的数据"><a href="#8-解析类的数据" class="headerlink" title="8. 解析类的数据"></a>8. 解析类的数据</h4><p>上面的解析是解析类的基本结构，那么如何获取一个对象的具体数据呢？与上面类似，我们将对象的类型分为三种，字符串、数组、普通对象。采用递归的方法解析所有字段。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">parseObject</span><span class="hljs-params">(Object obj)</span></span>&#123;<br><br>    <span class="hljs-keyword">if</span>(obj==<span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    StringBuilder sb=<span class="hljs-keyword">new</span> StringBuilder();<br><br>    Class&lt;?&gt; c = obj.getClass();<br>    <span class="hljs-comment">//判断是否为字符串类</span><br>    <span class="hljs-keyword">if</span>(c==String.class)&#123;<br>        <span class="hljs-keyword">return</span> (String)obj;<br>    &#125;<br>    <span class="hljs-comment">//判断对象是否为数组</span><br>    <span class="hljs-keyword">if</span>(c.isArray())&#123;<br>        sb.append(c.getComponentType()).append(<span class="hljs-string">&quot;[]&#123;\n&quot;</span>);<br>        System.out.println(Array.getLength(obj));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;Array.getLength(obj);i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>)&#123;<br>                sb.append(<span class="hljs-string">&quot;,\n&quot;</span>);<br>            &#125;<br>            sb.append(<span class="hljs-string">&quot;\t&quot;</span>);<br>            Object o = Array.get(obj, i);<br>            <span class="hljs-comment">//数组元素类型为8种普通类型，直接打印即可</span><br>            <span class="hljs-keyword">if</span>(c.getComponentType().isPrimitive())&#123;<br>                sb.append(o.toString());<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//数组元素类型为类，递归解析</span><br>                sb.append(parseObject(o));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.append(<span class="hljs-string">&quot;\n&#125;&quot;</span>).toString();<br>    &#125;<br>    <span class="hljs-comment">//既不是数组，也不是字符串，那就是普通对象</span><br>    <span class="hljs-keyword">while</span>(c!=<span class="hljs-keyword">null</span>)&#123;<br>        sb.append(c.getName());<br>        sb.append(<span class="hljs-string">&quot;[&quot;</span>);<br>        Field[] fields = c.getDeclaredFields();<br>        AccessibleObject.setAccessible(fields,<span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;fields.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!Modifier.isStatic(fields[i].getModifiers())) &#123;<br>                <span class="hljs-keyword">if</span> (!sb.toString().endsWith(<span class="hljs-string">&quot;[&quot;</span>)) &#123;<br>                    sb.append(<span class="hljs-string">&quot;,&quot;</span>);<br>                &#125;<br>                sb.append(fields[i].getName()).append(<span class="hljs-string">&quot;=&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//属性为8种普通类型，直接打印即可</span><br>                    <span class="hljs-keyword">if</span> (fields[i].getType().isPrimitive()) &#123;<br>                        sb.append(fields[i].get(obj));<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">//属性为类，继续递归解析</span><br>                        sb.append(parseObject(fields[i].get(obj)));<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        sb.append(<span class="hljs-string">&quot;]&quot;</span>);<br>        c=c.getSuperclass();<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>测试代码为：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        list.add(i*i);<br>    &#125;<br><br>    System.out.println(ReflectionUtil.parseObject(list).toString());<br><br></code></pre></div></td></tr></table></figure><hr><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">java.util.ArrayList[elementData=<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Object</span>[]</span>&#123;<br>    java.lang.Integer[value=<span class="hljs-number">1</span>]java.lang.Number[]java.lang.Object[],<br>    java.lang.Integer[value=<span class="hljs-number">4</span>]java.lang.Number[]java.lang.Object[],<br>    java.lang.Integer[value=<span class="hljs-number">9</span>]java.lang.Number[]java.lang.Object[],<br>    ,<br>    ,<br>    ,<br>    ,<br>    ,<br>    ,<br>&#125;,size=<span class="hljs-number">3</span>]java.util.AbstractList[modCount=<span class="hljs-number">3</span>]java.util.AbstractCollection[]java.lang.Object[]<br></code></pre></div></td></tr></table></figure><p>这里的空白行是为ArrayList的默认容量为10。</p><p>小结：我们通过Filed类的<code>getType()</code>的方法来获取属性的类型，通过Field类的<code>get(Object o)</code>获取该属性的值，参数为我们当前想要查看的对象。</p><h3 id="0x4-反射机制的优缺点"><a href="#0x4-反射机制的优缺点" class="headerlink" title="0x4 反射机制的优缺点"></a>0x4 反射机制的优缺点</h3><p>优点：</p><ul><li>就是灵活，提高了对未知代码的兼容性</li></ul><p>缺点：</p><ul><li>对性能有影响，反射的性能消耗比不使用的要高很多</li><li>而且打破了安全限制，使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</li><li>破坏了封装性</li></ul><p>所以能不用反射，就不用反射。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&mid=2247483785&idx=1&sn=f696c8c49cb7ecce9818247683482a1c&chksm=e9c2ed84deb564925172b2dd78d307d4dc345fa313d3e44f01e84fa22ac5561b37aec5cbd5b4&scene=0#rd">java反射机制详解</a></p></li><li><p><a href="https://laijianfeng.org/2018/12/Java-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/">动态代理详解</a></p></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E5%8F%8D%E5%B0%84/">反射</category>
      
      
      <category domain="https://eripe.me/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">基本概念</category>
      
      
      <comments>https://eripe.me/articles/%E5%8F%8D%E5%B0%84%E5%88%9D%E4%BD%93%E9%AA%8C.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java的内存布局</title>
      <link>https://eripe.me/articles/java-memory-layout.html</link>
      <guid>https://eripe.me/articles/java-memory-layout.html</guid>
      <pubDate>Mon, 14 Jun 2021 11:50:07 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>众所周知,java虚拟机的内存布局和传统的内存布局都差不多,都分为栈、堆啥的。准确的来说，jvm的内存分为以下几个部分:</p><ul><li>程序计数器(就是eip)</li><li>堆</li><li>方法区</li><li>本地方法栈</li><li>虚拟机栈</li></ul><p>其中堆和方法区是所有线程锁共享的,而程序计数器、栈肯定都是线程私有的,因为这与程序的正常运行息息相关。</p><p>上述的五个区域都可能产生内存溢出,有的还可能产生内存泄漏(虽然内存由jvm管理,但是并不能保证内存不会泄露奥)。下面我将一一介绍上述四个区域(不包括程序计数器)产生内存溢出的一般情况,当然大部分内容还是来自&lt;&lt;深入理解JVM&gt;&gt;一书,我在这里仅仅做个概括加上自己一点的感想。</p><h2 id="0x1-虚拟机栈"><a href="#0x1-虚拟机栈" class="headerlink" title="0x1 虚拟机栈"></a>0x1 虚拟机栈</h2><p>虚拟机栈跟传统汇编里的栈感觉差不多,只不过这里用所谓的局部变量槽来保存(Slot)。当然栈就是用来存储局部变量和返回地址的，内容肯定和传统栈一样。当然本地方法栈和虚拟机栈在性质上就是一类东西,<strong>仅仅是用途不同而已</strong>。所以就不单独分开说本地方法栈了。</p><p>Tips:</p><blockquote><p>当进入一个方法时,这个方法需要多少个局部变量槽是确定的,局部变量所需的内存在编译时期分配完成,而具体内存是多少个byte是不确定的,因为局部变量槽的实现方式不在JVM规范中。由虚拟机厂商所决定。</p></blockquote><p>上面这个我也是才注意的,不像传统栈可以不停的push,使用的大小完全无法确定。</p><p>进入正题,虚拟机栈可能会发生两种内存错误:</p><ul><li>StackOverFlow</li><li>OutOfMemeory</li></ul><p>StackOverFlow要么是死递归造成的栈空间不够,要么是局部变量太多。感觉后者不太可能发生,因为需要的局部变量太多儿。所以出现StackOverFlow的第一直觉就是死递归。</p><p>第二种出现于允许栈可扩展的虚拟机中。虚拟机之王HotSpot是不支持虚拟机栈扩展的。但是仍然可能出现OOM,当线程申请栈空间失败时。反之申请成功就永远不会出现OOM。</p><h2 id="0x2-堆"><a href="#0x2-堆" class="headerlink" title="0x2 堆"></a>0x2 堆</h2><p>堆是所有线程共享的内存区域,堆中能出现的内存错误当然是OOM辣。在Java中,几乎所有的对象实例都在堆中分配(具体解释来自深入理解JVM:page45)。</p><p>堆的可以被实现为固定的或者可扩展的。hotSpot中堆属于可扩展的。堆的大小可以通过参数<code>-Xms</code>(初始堆的大小)和<code>-Xmx</code>(堆的最大值)来控制。</p><p>当在堆中无法完成对象的分配时,在堆上就会出现OOM。</p><h3 id="0x2-1-方法区"><a href="#0x2-1-方法区" class="headerlink" title="0x2-1 方法区"></a>0x2-1 方法区</h3><p>方法区跟堆一样也是属于所有线程共享的内存区域。其中主要存储由虚拟机加载的类型信息、常量、静态变量、JIT编译后的缓存数据等等。</p><p>在JDK8以前,HotSopt采用了永久代的方法实现了方法区,从而能够像管理堆一样管理方法区。<strong>但是这是一个陋习</strong>。永久代有上限,这就导致在加载过多类后会出现内存溢出。</p><p>所以在JDK7中,oracle已经将方法区中的常量池、静态变量移出了永久代。在JDK8中,在方法区中彻底废除了永久代,通过在本地内存中实现元空间(与J9类似)保存剩余的信息,大部分都是类型信息。</p><p>虚拟机规范对方法区的要求是非常宽松的,比如方法区可以<strong>不执行内存回收</strong>,当然在方法区执行内存回收也是比较麻烦的。</p><p>当在方法区中无法申请到满足要求的内存时,就会出现OOM错误。</p><h3 id="0x2-2-运行时常量池"><a href="#0x2-2-运行时常量池" class="headerlink" title="0x2-2 运行时常量池"></a>0x2-2 运行时常量池</h3><p>运行时常量池本来是属于方法区的东西(注意oralce在JDK7是把常量池移出了永久代,而不是移出了方法区)。在Class文件中有一项信息为常量表,存储的是编译时期的各种常量与符号引用。这部分内容将在类加载完成后存放至方法区的运行时常量池。</p><p>当然常量池的内容不一定得是编译时的常量，也可以在运行时将新常量加入到池中。所以说运行时常量池与Class文件的常量池相比,前者具有动态性。</p><p>运行时常量池既然是方法区的东西,自然也会受到方法区的限制,当无法申请到足够多的内存时,就会出现OOM。</p><h2 id="0x3-直接内存"><a href="#0x3-直接内存" class="headerlink" title="0x3 直接内存"></a>0x3 直接内存</h2><p>直接内存并不是虚拟机规范中定义的内存区域,但是逐渐变得很重要。</p><p>在JDK1.4中,java引入了NIO。注意IO操作可以是要频繁跟本地堆的内容进行交互的。所以在NIO中：</p><blockquote><p>引入了一种基于管道和缓冲区的IO方式,可以直接使用native函数库分配native堆,然后通过一个存储在java堆中的DirectByteBuffer对象作为native堆的引用来操作native堆</p></blockquote><p>上述这种操作就避免了在java堆中和native中频繁的复制数据。</p><p>native堆的分配大小一般都会忽略,导致各个内存区域的大小总和超过了本机主机内存,从而出现OOM。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://medium.com/platform-engineer/understanding-java-memory-model-1d0863f6d973">Understanding Java Memory Model</a></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/jvm/">jvm</category>
      
      
      <category domain="https://eripe.me/tags/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/">内存布局</category>
      
      
      <comments>https://eripe.me/articles/java-memory-layout.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>双亲委派模型</title>
      <link>https://eripe.me/articles/parents-delegation-model.html</link>
      <guid>https://eripe.me/articles/parents-delegation-model.html</guid>
      <pubDate>Mon, 14 Jun 2021 11:50:07 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先在了解双亲委派模型前，我们有必要了解它的英文名字：<code>parents delegation model</code>。其实在具体的模型中，并没有所谓的“双亲”，只有一个逻辑意义上的父类，详情见下文。</p><h2 id="1-类加载器"><a href="#1-类加载器" class="headerlink" title="1. 类加载器"></a>1. 类加载器</h2><p>在《深入理解java虚拟机》一书中写道：</p><blockquote><p>java团队有意将类加载阶段中的“通过一个类的全限定名来获取该类的二进制字节流”这个动作放到java虚拟机外部去实现<br>完成这个动作的代码就称为类加载器，以前不理解放到虚拟机外部是什么意思，现在我的理解是我们能够在编写程序时就能够编写目标类的加载过程，这也就是所谓的在虚拟机外部。这样如此，我们自定义的类加载器就能够处理我们自定义的字节码。</p></blockquote><p>值得一提的是：类加载器与类共同确定了该类在虚拟机中是否唯一。也就是说，在虚拟机要比较两个类是否相同，比较的前提是<strong>待比较的两个类是由同一个类加载器加载到虚拟机中的</strong>，才有比较的意义。</p><p>这里的比较包括：<code>instanceof</code>、Class对象的<code>equals()</code>、<code>isAssignableForm()</code>、<code>isInstance()</code>方法。</p><h2 id="2-双亲委派模型"><a href="#2-双亲委派模型" class="headerlink" title="2. 双亲委派模型"></a>2. 双亲委派模型</h2><p>在了解双亲委派模型前，我们需要知道，jvm中有三类自带的类加载器：</p><ul><li><code>bootstrap class loader</code>，启动类加载器</li><li><code>extension class loader</code>，扩展类加载器</li><li><code>Application class laoder</code>，应用程序类加载器</li></ul><p><strong>启动类加载器</strong><br>启动类加载器由cpp编写，在java代码中无法直接引用。该加载器负责加载java的核心库，包括<code>&lt;JAVA_HOME&gt;/lib/</code>下的库，例如rt.jar、tools.jar；或者由<code>-Xbootclasspath</code>指定的，并且存放在lib目录下的符合规则的库，这里的规则是库的名字由jvm指定，不符合名字要求的即使由参数指定，也不会被加载。</p><p>前面说到，该加载器由cpp编写时，所以在编写代码时如果我们需要使用到该加载器，我们可以用null指代启动类加载器，这一规则由java团队约定。</p><p><strong>扩展类加载器</strong><br>扩展类加载器由java编写，负责加载<code>&lt;JAVA_HOME&gt;/lib/ext/</code>目录下的库，或者由环境变量<code>java.extdirs</code>指定目录下的库。</p><p><strong>应用程序加载器</strong><br>应用程序类加载器通用由java编写，在代码中可以直接引用。该加载器是我们接触最多的加载器了，默认情况下，我们编写的class都由其加载至jvm中。它负责加载由<code>classpath</code>参数指定路径下的类库。</p><blockquote><p>应用程序类加载器由<code>sun.misc.Launcher$AppClassLoader</code>实现。并且应用程序类加载器是ClassLoader中的getSystemClassLoader()方法的返回值</p></blockquote><p>这三个加载器的关系如下所示：</p><p><img src="images/jvmclassloader.jpg" alt="jvm class loader"></p><p>可以看到，<code>BootStrap ClassLoader</code>作为顶层的父类，<code>Extension ClassLoader</code>作为<code>BootStrap ClassLoader</code>的子类，而<code>Application ClassLoader</code>又作为<code>Extension ClassLoader</code>的子类。我们可以看到，这里并没有所谓的双亲，只有单亲，而这么翻译可能是因为第一个翻译的人看到的是parents吧。</p><blockquote><p>这里的父类与子类并不是传统意义上的使用extends保持的继承关系，而是通过内部包含来实现逻辑意义上的继承关系</p></blockquote><p><strong>三类加载器的初始化过程</strong></p><p>下图显示了<code>ExtClassLoader</code>、<code>AppClassLoader</code>、<code>ClassLoader</code>三者真正的继承关系。<br><img src="images/Inheritance.png" alt="继承体系"></p><p><code>ExtClassLoader</code>和<code>AppClassLoader</code>处于平级的关系，那么如何实现所谓的双亲委派？这一切都要靠抽象类<code>ClassLoader</code>中的<code>parent</code>字段来实现，如下图所示：</p><p><img src="images/parents-field.png" alt="parent字段"></p><p>每生成一个新的<code>ClassLoader</code>,都会用父类加载器去初始化它。那么这三个加载器是如何初始化的呢？这一切都起源于<code>Launcher</code>类。 <strong>该类由<code>Bootstrap ClassLoader</code>来加载。</strong> 我们来看看它的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Launcher</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Launcher launcher = <span class="hljs-keyword">new</span> Launcher();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String bootClassPath = System.getProperty(<span class="hljs-string">&quot;sun.boot.class.path&quot;</span>);<br>    <span class="hljs-keyword">private</span> ClassLoader loader;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Launcher <span class="hljs-title">getLauncher</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> launcher;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Launcher</span><span class="hljs-params">()</span> </span>&#123;<br>        Launcher.ExtClassLoader var1;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//初始化ExtClassLoader</span><br>            var1 = Launcher.ExtClassLoader.getExtClassLoader();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException var10) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(<span class="hljs-string">&quot;Could not create extension class loader&quot;</span>, var10);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//初始化loader字段，将其设置为AppClassLoader</span><br>            <span class="hljs-keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException var9) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(<span class="hljs-string">&quot;Could not create application class loader&quot;</span>, var9);<br>        &#125;<br>        <span class="hljs-comment">//设置线程上下文加载器，也就是AppClassLoader</span><br>        Thread.currentThread().setContextClassLoader(<span class="hljs-keyword">this</span>.loader);<br>        ...<br>    &#125;<br>    ...<br></code></pre></div></td></tr></table></figure><p>在<code>Bootstrap ClassLoader</code>把<code>Launcher</code>加载进虚拟机后，<code>Launcher</code>会初始化静态字段<code>Launcher</code>，然后会调用构造方法。在构造方法中，我们目前只需关注三个部分：</p><ol><li><p>使用<code>Launcher.ExtClassLoader.getExtClassLoader()</code>生成扩展类加载器<code>ExtClassLoader</code></p></li><li><p>使用<code>Launcher.AppClassLoader.getAppClassLoader(var1)</code>生成应用类加载器<code>App ClassLoader</code>,其中<code>var1</code>就是第一步生成的扩展类加载器，其用来初始化<code>parent</code>字段</p></li><li><p>使用<code>Thread.currentThread().setContextClassLoader(this.loader)</code>初始化线程上下文加载器，其中<code>loader</code>字段就是第二步生成的应用类加载器</p></li></ol><p>此外我们还需要关注以下<code>App ClassLoader</code>的生成方法，因为其与<code>classpath</code>的设置息息相关。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClassLoader <span class="hljs-title">getAppClassLoader</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ClassLoader var0)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//读取系统属性classpath</span><br>    <span class="hljs-comment">//这里读取的是一个整个字符串，因为在windows上由“;”将多个路径拼接成一个string</span><br>    <span class="hljs-comment">//linux平台使用“:”拼接多个路径组成一个string</span><br>    <span class="hljs-keyword">final</span> String var1 = System.getProperty(<span class="hljs-string">&quot;java.class.path&quot;</span>);<br>    <span class="hljs-comment">//将多个路径抽象为File</span><br>    <span class="hljs-keyword">final</span> File[] var2 = var1 == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> File[<span class="hljs-number">0</span>] : Launcher.getClassPath(var1);<br>    <span class="hljs-keyword">return</span> (ClassLoader)AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Launcher.AppClassLoader&gt;() &#123;<br>        <span class="hljs-keyword">public</span> Launcher.<span class="hljs-function">AppClassLoader <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">//将多个路径转化为URL数组</span><br>            URL[] var1x = var1 == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> URL[<span class="hljs-number">0</span>] : Launcher.pathToURLs(var2);<br>            <span class="hljs-comment">//使用URl路径和Ext ClassLoader生成新的AppClassLoader</span><br>            <span class="hljs-comment">//具体的初始化逻辑见下</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Launcher.AppClassLoader(var1x, var0);<br>        &#125;<br>    &#125;);<br>&#125;<br><br>AppClassLoader(URL[] var1, ClassLoader var2) &#123;<br>    <span class="hljs-comment">//调用父类URLClassLoader的构造函数保存多个classpath路径</span><br>    <span class="hljs-keyword">super</span>(var1, var2, Launcher.factory);<br>    <span class="hljs-keyword">this</span>.ucp.initLookupCache(<span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-comment">//父类URLClassLoader的构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">URLClassLoader</span><span class="hljs-params">(URL[] urls, ClassLoader parent,</span></span><br><span class="hljs-params"><span class="hljs-function">                        URLStreamHandlerFactory factory)</span> </span>&#123;<br>    <span class="hljs-comment">//初始化parent字段</span><br>    <span class="hljs-keyword">super</span>(parent);<br>    ...<br>    <span class="hljs-comment">//实际使用ucp字符保存多个classpath路径</span><br>    ucp = <span class="hljs-keyword">new</span> URLClassPath(urls, factory, acc);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>经过上面的源码学习，我们已经非常清楚这三类加载器如何实现<strong>双亲</strong>的逻辑，并且还顺便搞懂了classpath的初始化过程。那么委派是什么呢？下面的加载流程很好地解释了什么是委派：</p><ol><li><p>在传统情况下，一个类的加载会由默认的类加载器加载，而一般情况下<code>Application ClassLoader</code>会作为默认的类加载器。类加载器首先会将请求委派给父类，而不是由自己来加载。</p></li><li><p><code>Application ClassLoader</code>会将加载请求委派给父类<code>Extension ClassLoader</code>,而<code>Extension ClassLoader</code>又会将请求委派给父类<code>BootStrap ClassLoader</code>。</p></li><li><p>如果<code>BootStrap ClassLoader</code>加载失败，那么具体的加载会由<code>Extension ClassLoader</code>完成。如果<code>Extension ClassLoader</code>加载失败，具体的加载会由<code>Extension ClassLoader</code>完成。如果再次不能完成，那么就会抛出异常。</p></li></ol><p>可以看到，加载请求会一级一级向上传递，直到传到根加载器。然后如果不能完成，请求又会一级一级从上到下传递到底部加载器。<strong>那么为什么要这么做呢？</strong></p><p>答案来自《深入理解java虚拟机》：</p><blockquote><p>这样做的一个显而易见的好处是，被加载的类随着它的加载器一起具备了一种优先级的层次关系。</p></blockquote><p>试想加载类<code>Object</code>,这个类肯定最终由<code>bootstrap ClassLoader</code>来加载。如果没有这种委派关系，我们随便写一个同名的类<code>Object</code>,虚拟机无法保证使用加载正确的<code>Object</code>类。那么最基础的核心类都无法保证正确加载，那就出大问题了。</p><p><strong>双亲委派模型的代码实现</strong></p><p>双亲委派的原理简单，代码实现也非常简单，下面的短短几十行代码就完成了操作：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>        <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// First, check if the class has already been loaded</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">long</span> t0 = System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//如果父类不为空，那么就使用父类的加载方法</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//否则使用根加载器加载</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                <span class="hljs-comment">// to find the class.</span><br>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br>                c = findClass(name);<br>                ...<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>系统类加载器的设置</strong></p><p>update：2021-01-18 00:31:03</p><p>复习到这时，我提出了一个问题：系统类加载器的设置和三类加载器之间的关系是怎么样的？是谁调用谁的？</p><p>目前我只能回答这个问题的一半：某个函数会首先调用<code>getSystemClassLoader()</code>，然后调用链如下：<code>getSystemClassLoader()</code>—&gt;<code>initSystemClassLoader</code>—&gt;<code>sun.misc.Launcher.getLauncher()</code></p><hr><p>我曾在上面提到，如果没有意外发生，那么在jvm中，<code>AppClassLoader</code>会被设置为默认的系统类加载器，这也是为什么会在某些场合称其为“系统类加载器”。那么这一设置是什么时候完成的呢？这一切都起源于<code>ClassLoader</code>中的方法<code>getSystemClassLoader</code>。其注释写道：</p><blockquote><p>If the system property “java.system.class.loader” is defined<br>when this method is first invoked then the value of that property is<br>taken to be the name of a class that will be returned as the system<br>class loader.  The class is loaded using the default system class loader<br>and must define a public constructor that takes a single parameter of<br>type ClassLoader which is used as the delegation parent.  An<br>instance is then created using this constructor with the default system<br>class loader as the parameter.  The resulting class loader is defined<br>to be the system class loader.</p></blockquote><p>如果设置为系统属性<code>java.system.class.loader</code>，那么在第一次调用<code>getSystemClassLoader</code>时，会将该系统属性指向的类设置为系统类加载器。值得注意的是，自定义的系统类加载器必须声明一个带有一个参数的公共构造方法，并且唯一参数用来当作委派父类。下面我们来看看这一方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClassLoader <span class="hljs-title">getSystemClassLoader</span><span class="hljs-params">()</span> </span>&#123;<br>    initSystemClassLoader();<br>    <span class="hljs-keyword">if</span> (scl == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    SecurityManager sm = System.getSecurityManager();<br>    <span class="hljs-keyword">if</span> (sm != <span class="hljs-keyword">null</span>) &#123;<br>        checkClassLoaderPermission(scl, Reflection.getCallerClass());<br>    &#125;<br>    <span class="hljs-keyword">return</span> scl;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们看到，该方法内部会调用<code>initSystemClassLoader()</code>，那么这个方法又做了什么事情呢？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initSystemClassLoader</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!sclSet) &#123;<span class="hljs-comment">//如果系统类加载器还没有被设置</span><br>        <span class="hljs-keyword">if</span> (scl != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;recursive invocation&quot;</span>);<br>        sun.misc.Launcher l = sun.misc.Launcher.getLauncher();<br>        <span class="hljs-keyword">if</span> (l != <span class="hljs-keyword">null</span>) &#123;<br>            Throwable oops = <span class="hljs-keyword">null</span>;<br>            scl = l.getClassLoader();<span class="hljs-comment">//获得ApplicationClassLoader</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                scl = AccessController.doPrivileged(<br>                    <span class="hljs-keyword">new</span> SystemClassLoaderAction(scl));<span class="hljs-comment">//设置系统类加载器</span><br>            &#125; <span class="hljs-keyword">catch</span> (PrivilegedActionException pae) &#123;<br>                oops = pae.getCause();<br>                <span class="hljs-keyword">if</span> (oops <span class="hljs-keyword">instanceof</span> InvocationTargetException) &#123;<br>                    oops = oops.getCause();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (oops != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (oops <span class="hljs-keyword">instanceof</span> Error) &#123;<br>                    <span class="hljs-keyword">throw</span> (Error) oops;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// wrap the exception</span><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(oops);<br>                &#125;<br>            &#125;<br>        &#125;<br>        sclSet = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中<code>sclSet</code>是<code>ClassLoader</code>的属性，如果是第一次调用，那么会通过<code>Launcher</code>调用<code>getSystemLoader</code>获取<code>Launcher</code>内部字段<code>loader</code>的值。不知道大家还记不记得，<code>loader</code>字段会被设置为<code>AppClassLoader</code>。此后<code>scl</code>会被设置为<code>AppCLassLoader</code>。</p><p>然后会使用<code>SystemClassLoaderAction</code>读取系统属性<code>java.system.class.loader</code>,完成系统类加载器的设置，我们来看看其源码。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemClassLoaderAction</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">PrivilegedExceptionAction</span>&lt;<span class="hljs-title">ClassLoader</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> ClassLoader parent;<br><br>    SystemClassLoaderAction(ClassLoader parent) &#123;<br>        <span class="hljs-keyword">this</span>.parent = parent;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ClassLoader <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String cls = System.getProperty(<span class="hljs-string">&quot;java.system.class.loader&quot;</span>);<br>        <span class="hljs-keyword">if</span> (cls == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> parent;<br>        &#125;<br>        Constructor&lt;?&gt; ctor = Class.forName(cls, <span class="hljs-keyword">true</span>, parent)<br>            .getDeclaredConstructor(<span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123; ClassLoader.class &#125;);<br>        ClassLoader sys = (ClassLoader) ctor.newInstance(<br>            <span class="hljs-keyword">new</span> Object[] &#123; parent &#125;);<br>        Thread.currentThread().setContextClassLoader(sys);<br>        <span class="hljs-keyword">return</span> sys;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们可以很清楚的看到，如果系统属性<code>java.system.class.loader</code>为空，那么就会返回<code>parent</code>。此前<code>parent</code>已通过构造函数被设置为<code>AppClassLoader</code>。</p><p>否则，加载系统属性指向的类并获取带有一个参数的构造方法。随后创建自定义类加载器的实例<code>sys</code>并返回。</p><p>至此，已经完成了系统类加载器的设置。所以说，默认情况下，所有的类都会使用<code>AppClassLoader</code>来加载。</p><h2 id="3-破坏双亲委派模型"><a href="#3-破坏双亲委派模型" class="headerlink" title="3. 破坏双亲委派模型"></a>3. 破坏双亲委派模型</h2><p>虽然双亲委派模型好，但它也不是万能的。到目前为止，已经出现了三次破坏行为。下面来品一哈。</p><h3 id="3-1-第一次破坏"><a href="#3-1-第一次破坏" class="headerlink" title="3.1 第一次破坏"></a>3.1 第一次破坏</h3><p>第一次破坏是由于JDK1.2之前还没有出现双亲委派模型，但是此时已经有了类加载器的概念。那么此时已经有了许多用户自定义的类加载器。那么为了兼容以前的代码，无法再以技术手段避免<code>loadClass()</code>被子类覆盖的可能性。这里所谓的无法避免是什么呢？我们再次来看看双亲委派的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>        <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// First, check if the class has already been loaded</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">long</span> t0 = System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//如果父类不为空，那么就使用父类的加载方法</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//否则使用根加载器加载</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                <span class="hljs-comment">// to find the class.</span><br>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br>                c = findClass(name);<br>                ...<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果此时用户代码还在覆盖<code>loadClass</code>,但是编写出的代码并没有采用双亲委派，那么就会使双亲委派失效。因为双亲委派就是靠<code>loadClass</code>来实现的。所以尽管不能避免之前的状态，但是以后要尽量避免让用户覆盖<code>loadClass</code>。</p><p>所以在JDK1.2之后，在<code>ClassLoader</code>中引入了一个<code>protected</code>方法<code>findClass()</code>。希望引导用户能够覆盖<code>findClass()</code>编写自定义类加载器。这样既不影响双亲委派，又可以按照用户自己的意愿加载类，就像上面源码中的那样，当父类加载失败，那么就会调用<code>findClass()</code>加载。</p><p>所以重写<code>loadClass</code>会破坏双亲模型，而重写<code>findClass</code>则不会，如果需要在多个类加载器中加载同一个<code>Class</code>，则需要使用前者。</p><h3 id="3-2-第二次破坏"><a href="#3-2-第二次破坏" class="headerlink" title="3.2 第二次破坏"></a>3.2 第二次破坏</h3><p>第二次破坏是因为双亲委派这个机制存在缺陷。首先我们需要明白下面这种机制：</p><blockquote><p>假设我们当前代码所处的类为D，如果此时要把一个从未解析的符号解析成类或接口C。如果C不是数组类型，那么<strong>jvm会使用加载D的类加载器来加载C</strong>。</p></blockquote><p>但是在双亲委派模型中，上层的类加载器是无法指派下层的类加载器来完成加载动作的。一个典型的例子就是JNDI(The Java Naming and Directory Interface)服务。简而言之，JDNI就是java规定一组服务的接口，但是具体的实现由第三方提供，例如数据库的驱动。</p><p>那么这个<strong>破坏</strong>在哪里呢？首先JDNI肯定是由启动类加载器加载至JVM。那么调用具体的实现类时，启动类加载器是不可能将实现类加载进来的，因为这不符合启动类加载器的规定。那么怎么办呢？</p><p>开发人员又设计了一种叫进程上下文类加载器(Thread Context ClassLoader)的东西来完成这个任务。启动类加载器会调用进程上下文类加载器来加载接口的实现类。</p><p>线程上下文类加载器在(默认情况下)由<code>Bootstrap classLoader</code>第一次加载<code>Launcher</code>类时就会被设置为<code>App ClassLoader</code>。当然，我们可以通过<code>setContextClassLoader(ClassLoader cl)</code>和<code>getContextClassLoader()</code>来设置和使用我们自定义的线程上下文类加载器。<strong>在多线程的情况下</strong>，子线程会继承父线程的线程上下文类加载器。</p><h3 id="3-3-第三次破坏"><a href="#3-3-第三次破坏" class="headerlink" title="3.3 第三次破坏"></a>3.3 第三次破坏</h3><p>这次破坏是为了实现java应用的热部署。简单来说就是OSGi机制破坏了双亲委派模型。以下引自《深入理解java虚拟机》：</p><blockquote><p>OSGi实现模块热部署的关键是它自定义的类加载机制的实现，每一个程序模块（OSGi称其为bundle）都有属于自己的类加载器。当需要替换Bundle时，就把Bundle连同类加载器一起替换以实现代码的热替换。</p><p>在OSGi环境下，类加载机制不再是委派双亲的树模型，而是一个<strong>网状</strong>结构。OSGi的类加载顺序中，只有前两个步骤符合双亲委派的原则，即：</p><ol><li>将以java.*开头的类，委派给父类加载器加载</li><li>否则,将委派列表名单内的类，委派给父类加载器加载</li></ol></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文详细介绍了双亲委派模型的类加载机制，解释了什么是“双亲”、什么是“委派”，三个系统自带的类加载器的初始化过程（仅限于JDK1.2-1.8）。以及历史上三次破坏双亲委派模型的事件，引出了SPI。后面我会以数据库加载驱动的案例讲解SPI到底是如何工作的。</p><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>我们在上面的源码中会经常看到<code> AccessController.doPrivileged()</code>这个方法，这又跟java的安全模型相关，谈起来不简单，后面我会专门开一篇来讲解它。</p><p><strong>参考文献</strong></p><p><a href="https://greenhathg.github.io/2019/06/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-Launcher%E7%B1%BB/">https://greenhathg.github.io/2019/06/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-Launcher%E7%B1%BB/</a></p><p><a href="https://juejin.im/post/6844903837472423944">https://juejin.im/post/6844903837472423944</a></p><p><a href="https://segmentfault.com/a/1190000021869536">https://segmentfault.com/a/1190000021869536</a></p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/jvm/">jvm</category>
      
      
      <category domain="https://eripe.me/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/">类加载</category>
      
      
      <comments>https://eripe.me/articles/parents-delegation-model.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java中的类型系统</title>
      <link>https://eripe.me/articles/type-system-of-java.html</link>
      <guid>https://eripe.me/articles/type-system-of-java.html</guid>
      <pubDate>Mon, 14 Jun 2021 11:50:07 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>java的类型系统在1.5之后就变的很复杂了。但是又极其重要因为java中的反射基于此。所以想要深入理解反射还需要简单地学习一下java的类型系统。首先我们简要说明一下在逻辑上java的type分类。然后再在实现层次上简要了解一下java到底是如何实现的。</p><p>首先java是一个强类型语言,其任何一个变量、任何一个表达式都有类型。在Java中,总的分为<del>两类</del>三类(还有一个特殊的<code>null type</code>):</p><ul><li>primitive types:原始类型,分类<code>boolean type</code>和<code>numeric type</code>,后者又可以分为<code>integral types</code>和<code>floating-point types</code>。<ul><li>integral types:包括<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>char</code></li><li>floating-point type:包括<code>float</code>和<code>double</code></li></ul></li><li>reference types:包括<code>class types</code>、<code>interface types</code>、<code>array type</code>以及<code>type virables</code></li><li>special type:<code>null type</code></li></ul><blockquote><p>在java中,对象是类的实例或者是动态创建的数组,<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3">参考文献</a></p></blockquote><p>是的,数组也是一个对象。</p><hr><p><strong>Extension：</strong></p><p>这里额外说一下<code>null type</code>,关键字<code>null</code>不是一个类型而是一个特殊的值,可以简答的认为null指向一个特殊的内存区域。我们不能声明一个为<code>null type</code>的引用,也不能将<code>null type</code>声明为类型参数,例如<code>List&lt;null&gt;</code>(<a href="https://stackoverflow.com/questions/26632104/java-kinds-of-type-and-null-reference">参考</a>)。但是<code>null</code>却可以强转为任何类型的引用,转换结果为目标类型的空引用,<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.2">参考</a>。</p><blockquote><p>A value of the null type (the null reference is the only such value) may be assigned to any reference type, resulting in a null reference of that type.</p></blockquote><p>最后,<code>null type</code>不是一个引用类型。</p><hr><h3 id="Reference-Types"><a href="#Reference-Types" class="headerlink" title="Reference Types"></a>Reference Types</h3><p>下面的一段代码使用了四种引用类型(摘自<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3">jse8规范</a>):</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">int</span>[] metrics;<br>    T variables;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Move</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">int</span> deltax, <span class="hljs-keyword">int</span> deltay)</span></span>; &#125;<br></code></pre></div></td></tr></table></figure><p>其中,<code>Point</code>是一个<code>class type</code>(翻译成类类型好难受…),<code>int[]</code>是一个<code>array type</code>,<code>Move</code>是一个<code>interface type</code>,<code>T</code>是一个<code>type variable</code>。前三种都很好理解,最后一个<code>type variable</code>值得一提。</p><p>在jse8规范中,<code>type variable</code>被定义为一个唯一的符号在类、接口、方法、构造函数中作为一个type。所以这个<code>type variable</code>只能在上面四个地方使用。引入<code>type variable</code>的原因是因为在泛型类、泛型接口、泛型构造函数、泛型方法中定义了类型参数。</p><p>所以,很好理解,<code>type variable</code>就是泛型中<code>&lt;T&gt;</code>中的T。注意,<code>type</code></p><p><code>Type</code>接口是java中type信息的顶级接口。主要有五种type,分别是:</p><ul><li><code>raw types</code>:原始类型,使用对应类型的Class对象表示</li><li><code>primitive types</code>:基本类型,使用对应原始类型的Class对象表示</li><li><code>parameterized types</code>:参数类型,基于接口<code>ParameterizedTypes</code>,对应实现类为<code>ParameterizedTypesImpl</code></li><li><code>array types</code>:泛型数组类型,基于接口<code>GenericArrayType</code>,对应实现类为<code>GenericArrayTypeImpl</code></li><li><code>type variables</code>:类型变量,基于接口<code>TypeVariable</code>,对应实现类为<code>TypeVariableImpl</code></li><li><code>WildcardType</code>:通配符类型,基于接口<code>WildcardType</code>,对应实现类为<code>WildcardTypeImpl</code></li></ul><p>其中<code>ParameterizedTypes</code>、<code>GenericArrayType</code>、<code>TypeVariable</code>、<code>WildcardType</code>这四个接口是<code>Type</code>接口的子接口。继承图如下所示:</p><p><img src="images/Type.png" alt="Type继承图"></p><p>可以看到,<code>Class</code>类是<code>Type</code>接口的子类。下面来一一解释一下四种子接口的含义。</p><h2 id="1-ParameterizedType"><a href="#1-ParameterizedType" class="headerlink" title="1. ParameterizedType"></a>1. ParameterizedType</h2><p><code>ParameterizedType</code>翻译过来就是参数化类型,emm。应该就是将类型参数化,这是引入泛型(Generic)的必然结果。例如我们常用的<code>List&lt;Integer&gt;</code>,这一个完整的带<code>&lt;&gt;</code>的类型就叫做参数化类型。下面解释了raw type于parameterized type之间的关系。</p><ul><li>genric type:<code>List&lt;T&gt;</code></li><li>parameterized type:<code>List&lt;Integer&gt;</code></li><li>raw type:<code>List</code></li><li>type parameter:<code>Integer</code></li></ul><p><strong>有如下常用方法</strong>:</p><ul><li><code>Type getRawType()</code>: 返回承载该泛型信息的对象, 如上面那个Map&lt;String, String&gt;承载范型信息的对象是Map</li><li><code>Type[] getActualTypeArguments()</code>: 返回实际泛型类型列表, 如上面那个Map&lt;String, String&gt;实际范型列表中有两个元素, 都是String</li><li><code>Type getOwnerType()</code>: 返回当前成员的属主,例如<code>Map.Entry</code>属于<code>Map</code></li></ul><p>以具体的参数化类型, 如<code>Map&lt;String, String&gt;</code>为例:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestType</span> </span>&#123;<br>    Map&lt;String, String&gt; map;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Field f = TestType.class.getDeclaredField(<span class="hljs-string">&quot;map&quot;</span>);<br>        System.out.println(f.getGenericType());                               <span class="hljs-comment">// java.util.Map&lt;java.lang.String, java.lang.String&gt;</span><br>        System.out.println(f.getGenericType() <span class="hljs-keyword">instanceof</span> ParameterizedType);  <span class="hljs-comment">// true</span><br>        ParameterizedType pType = (ParameterizedType) f.getGenericType();<br>        System.out.println(pType.getRawType());                               <span class="hljs-comment">// interface java.util.Map</span><br>        <span class="hljs-keyword">for</span> (Type type : pType.getActualTypeArguments()) &#123;<br>            System.out.println(type);                                         <span class="hljs-comment">// 打印两遍: class java.lang.String</span><br>        &#125;<br>        System.out.println(pType.getOwnerType());                             <span class="hljs-comment">// null</span><br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="2-TypeVariable"><a href="#2-TypeVariable" class="headerlink" title="2. TypeVariable"></a>2. TypeVariable</h2><p>类型变量, 范型信息在编译时会被转换为一个特定的类型, 而TypeVariable就是用来反映在JVM编译该泛型前的信息.</p><p><strong>常用方法:</strong></p><ul><li><code>Type[] getBounds()</code>: 获取类型变量的上边界, 若未明确声明上边界则默认为Object</li><li><code>D getGenericDeclaration()</code>: 获取声明该类型变量实体,其中<code>D</code>是泛型类型的声明,也就是所在的类全限定名</li><li><code>String getName()</code>: 获取在源码中定义时的名字</li></ul><p>注意:<br>类型变量在定义的时候只能使用extends进行(多)边界限定, 不能用super;为什么边界是一个数组? 因为类型变量可以通过&amp;进行多个上边界限定，因此上边界有多个</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestType</span> &lt;<span class="hljs-title">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span> &amp; <span class="hljs-title">Serializable</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br>    K key;<br>    V value;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获取字段的类型</span><br>        Field fk = TestType.class.getDeclaredField(<span class="hljs-string">&quot;key&quot;</span>);<br>        Field fv = TestType.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>);<br>        Assert.that(fk.getGenericType() <span class="hljs-keyword">instanceof</span> TypeVariable, <span class="hljs-string">&quot;必须为TypeVariable类型&quot;</span>);<br>        Assert.that(fv.getGenericType() <span class="hljs-keyword">instanceof</span> TypeVariable, <span class="hljs-string">&quot;必须为TypeVariable类型&quot;</span>);<br>        TypeVariable keyType = (TypeVariable)fk.getGenericType();<br>        TypeVariable valueType = (TypeVariable)fv.getGenericType();<br>        <span class="hljs-comment">// getName 方法</span><br>        System.out.println(keyType.getName());                 <span class="hljs-comment">// K</span><br>        System.out.println(valueType.getName());               <span class="hljs-comment">// V</span><br>        <span class="hljs-comment">// getGenericDeclaration 方法</span><br>        System.out.println(keyType.getGenericDeclaration());   <span class="hljs-comment">// class com.test.TestType</span><br>        System.out.println(valueType.getGenericDeclaration()); <span class="hljs-comment">// class com.test.TestType</span><br>        <span class="hljs-comment">// getBounds 方法</span><br>        System.out.println(<span class="hljs-string">&quot;K 的上界:&quot;</span>);                        <span class="hljs-comment">// 有两个</span><br>        <span class="hljs-keyword">for</span> (Type type : keyType.getBounds()) &#123;                <span class="hljs-comment">// interface java.lang.Comparable</span><br>            System.out.println(type);                          <span class="hljs-comment">// interface java.io.Serializable</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;V 的上界:&quot;</span>);                        <span class="hljs-comment">// 没明确声明上界的, 默认上界是 Object</span><br>        <span class="hljs-keyword">for</span> (Type type : valueType.getBounds()) &#123;              <span class="hljs-comment">// class java.lang.Object</span><br>            System.out.println(type);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-GenericArrayType"><a href="#3-GenericArrayType" class="headerlink" title="3. GenericArrayType"></a>3. GenericArrayType</h2><p>我们仍然记得,不能创建泛型数组,那么这个<code>GenericArrayType</code>是啥意思?</p><p>虽然不能泛型数组,但是能够创建泛型数组引用啊,<code>T[] nums=null</code>是合法的,见下方代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestType</span> &lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Method method = Test.class.getDeclaredMethods()[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// public void com.test.Test.show(java.util.List[],java.lang.Object[],java.util.List,java.lang.String[],int[])</span><br>        System.out.println(method);<br>        Type[] types = method.getGenericParameterTypes();  <span class="hljs-comment">// 这是 Method 中的方法</span><br>        <span class="hljs-keyword">for</span> (Type type : types) &#123;<br>            System.out.println(type <span class="hljs-keyword">instanceof</span> GenericArrayType);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(List&lt;String&gt;[] pTypeArray, T[] vTypeArray, List&lt;String&gt; list, String[] strings, <span class="hljs-keyword">int</span>[] ints)</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>声明一个泛型数组引用还是没有问题的,运行结果如下:</p><ul><li>第一个参数List<String>[]的组成元素List<String>是ParameterizedType类型, 打印结果为true</li><li>第二个参数T[]的组成元素T是TypeVariable类型, 打印结果为true</li><li>第三个参数List<String>不是数组, 打印结果为false</li><li>第四个参数String[]的组成元素String是普通对象, 没有范型, 打印结果为false</li><li>第五个参数int[] pTypeArray的组成元素int是原生类型, 也没有范型, 打印结果为false</li></ul><p>所以数组元素是<code>ParameterizedType</code>或<code>TypeVariable</code>的数组类型才是<code>GenericArrayType</code>。</p><h2 id="4-WildcardType"><a href="#4-WildcardType" class="headerlink" title="4. WildcardType"></a>4. WildcardType</h2><p>该接口表示通配符泛型, 比如? extends Number 和 ? super Integer 它有如下方法:</p><ul><li>Type[] getUpperBounds(): 获取范型变量的上界</li><li>Type[] getLowerBounds(): 获取范型变量的下界<br>注意:</li></ul><p>现阶段通配符只接受一个上边界或下边界, 返回数组是为了以后的扩展, 实际上现在返回的数组的大小是1</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestType</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;? extends Number&gt; a;  <span class="hljs-comment">// // a没有下界, 取下界会抛出ArrayIndexOutOfBoundsException</span><br>    <span class="hljs-keyword">private</span> List&lt;? <span class="hljs-keyword">super</span> String&gt; b;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Field fieldA = TestType.class.getDeclaredField(<span class="hljs-string">&quot;a&quot;</span>);<br>        Field fieldB = TestType.class.getDeclaredField(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-comment">// 先拿到范型类型</span><br>        Assert.that(fieldA.getGenericType() <span class="hljs-keyword">instanceof</span> ParameterizedType, <span class="hljs-string">&quot;&quot;</span>);<br>        Assert.that(fieldB.getGenericType() <span class="hljs-keyword">instanceof</span> ParameterizedType, <span class="hljs-string">&quot;&quot;</span>);<br>        ParameterizedType pTypeA = (ParameterizedType) fieldA.getGenericType();<br>        ParameterizedType pTypeB = (ParameterizedType) fieldB.getGenericType();<br>        <span class="hljs-comment">// 再从范型里拿到通配符类型</span><br>        Assert.that(pTypeA.getActualTypeArguments()[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> WildcardType, <span class="hljs-string">&quot;&quot;</span>);<br>        Assert.that(pTypeB.getActualTypeArguments()[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> WildcardType, <span class="hljs-string">&quot;&quot;</span>);<br>        WildcardType wTypeA = (WildcardType) pTypeA.getActualTypeArguments()[<span class="hljs-number">0</span>];<br>        WildcardType wTypeB = (WildcardType) pTypeB.getActualTypeArguments()[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 方法测试</span><br>        System.out.println(wTypeA.getUpperBounds()[<span class="hljs-number">0</span>]);   <span class="hljs-comment">// class java.lang.Number</span><br>        System.out.println(wTypeB.getLowerBounds()[<span class="hljs-number">0</span>]);   <span class="hljs-comment">// class java.lang.String</span><br>        <span class="hljs-comment">// 看看通配符类型到底是什么, 打印结果为: ? extends java.lang.Number</span><br>        System.out.println(wTypeA);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>转载自<a href="http://loveshisong.cn/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2016-02-16-Type%E8%AF%A6%E8%A7%A3.html">Java中的Type详解</a>。</p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E5%8F%8D%E5%B0%84/">反射</category>
      
      
      <category domain="https://eripe.me/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">基本概念</category>
      
      <category domain="https://eripe.me/tags/%E7%B1%BB%E5%9E%8B/">类型</category>
      
      
      <comments>https://eripe.me/articles/type-system-of-java.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>通过MySQL驱动的加载学习SPI机制</title>
      <link>https://eripe.me/articles/SPI-service-mechanism.html</link>
      <guid>https://eripe.me/articles/SPI-service-mechanism.html</guid>
      <pubDate>Mon, 14 Jun 2021 11:50:07 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言-什么是SPI&quot;&gt;&lt;a href=&quot;#前言-什么是SPI&quot; class=&quot;headerlink&quot; title=&quot;前言 什么是SPI&quot;&gt;&lt;/a&gt;前言</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言-什么是SPI"><a href="#前言-什么是SPI" class="headerlink" title="前言 什么是SPI"></a>前言 什么是SPI</h2><p>SPI机制（Service Provider Interface)简而言之，就是java规定了一组服务的接口，但是没有具体的实现类。那么具体的实现类肯定由不同的厂商实现，那么客户在使用时是仅依赖于接口的。<strong>SPI的具体实现是靠<code>ServiceLoader</code>完成的。</strong><br>在讲解双亲委派模型时，我们知道，SPI接口是通过<code>bootstrap ClassLoader</code>加载至jvm中的。而具体的驱动实现类是通过线程上下文类加载器加载至jvm中的。下面我们就通过加载数据库驱动的例子来了解SPI的实现原理。</p><h2 id="1-获得数据库连接实例的方式"><a href="#1-获得数据库连接实例的方式" class="headerlink" title="1. 获得数据库连接实例的方式"></a>1. 获得数据库连接实例的方式</h2><p>在JDBC4.0之前，还没有引入SPI，一般需要使用<code>Class.forName()</code>注册驱动，所以加载驱动的代码一般是如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Class.forName(<span class="hljs-string">&quot;xxxx&quot;</span>);<br>Connection c=DriverManager.getConnection(<span class="hljs-string">&quot;url&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>在JDBC4.0之后，我们只需要使用<code>DriverManager.getConnection(url)</code>就可以获得连接对象。这是因为在<code>getConnection()</code>内部会自己调用<code>Class.forName()</code>，这里包含了一层嵌套关系。而<code>DriverManager</code>又是由<code>Bootstrap ClassLoader</code>加载的，根据符号解析的规定，<code>DriverManager</code>内部的符号如果需要解析为类或接口，则会调用<code>DriverManager</code>的加载器。但是问题是<code>DriverManager</code>只会加载核心库。根据双亲委派模型，父类的请求无法派给子类，所以这时候就采用了线程上下文类加载器。<strong>而在JDBC4.0之前没有这层嵌套关系。</strong></p><p>下面我们来看看到底是如何获得驱动的。在初次使用<code>DriverManager</code>时，首先会执行静态代码块中<code>loadInitialDrivers()</code>函数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    loadInitialDrivers();<br>    println(<span class="hljs-string">&quot;JDBC DriverManager initialized&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>初始化函数如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadInitialDrivers</span><span class="hljs-params">()</span> </span>&#123;<br>    String drivers;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//查看是否设置了系统属性jdbc.drivers</span><br>        drivers = AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> System.getProperty(<span class="hljs-string">&quot;jdbc.drivers&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        drivers = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//使用ServiceLoader加载驱动</span><br>    AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);<br>            <br>            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">while</span>(driversIterator.hasNext()) &#123;<br>                    driversIterator.next();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;<br>            <span class="hljs-comment">// Do nothing</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;);<br><br>    println(<span class="hljs-string">&quot;DriverManager.initialize: jdbc.drivers = &quot;</span> + drivers);<br><br>    <span class="hljs-keyword">if</span> (drivers == <span class="hljs-keyword">null</span> || drivers.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//如果设置了系统属性jdbc.drivers,</span><br>    <span class="hljs-comment">//那么如果SPI已经成功加载了驱动，下面的代码还是会重复注册驱动</span><br>    String[] driversList = drivers.split(<span class="hljs-string">&quot;:&quot;</span>);<br>    println(<span class="hljs-string">&quot;number of Drivers:&quot;</span> + driversList.length);<br>    <span class="hljs-keyword">for</span> (String aDriver : driversList) &#123;<br>        ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，<code>DriverManager</code>的初始化分分为两个版本：</p><ul><li>设置系统属性<code>jdbc.drivers</code>属性</li><li>使用``ServiceLoader`加载，如果驱动以service provider的形式出现</li></ul><h2 id="2-SPI加载数据库驱动的原理"><a href="#2-SPI加载数据库驱动的原理" class="headerlink" title="2. SPI加载数据库驱动的原理"></a>2. SPI加载数据库驱动的原理</h2><h3 id="2-1-获取ServiceLoader对象"><a href="#2-1-获取ServiceLoader对象" class="headerlink" title="2.1 获取ServiceLoader对象"></a>2.1 获取ServiceLoader对象</h3><p>使用SPI初始化代码时首先使用<code>ServiceLoader</code>的静态方法<code>load</code>加载SPI<code>Driver</code>的class文件。源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-function">ServiceLoader&lt;S&gt; <span class="hljs-title">load</span><span class="hljs-params">(Class&lt;S&gt; service)</span> </span>&#123;<br>    ClassLoader cl = Thread.currentThread().getContextClassLoader();<br>    <span class="hljs-keyword">return</span> ServiceLoader.load(service, cl);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code> ServiceLoader.load(service, cl)</code>又会通过私有构造方法返回<code>ServiceLoader</code>对象，在私有构造方法内部调用了<code>reload()</code>方法，源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reload</span><span class="hljs-params">()</span> </span>&#123;<br>    providers.clear();<br>    lookupIterator = <span class="hljs-keyword">new</span> LazyIterator(service, loader);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先清空<code>providers</code>，这里的<code>providers</code>是一个<code>LinkedHashMap</code>，用来保存已经加载过服务实现类的实例。随后生成了<code>lazyIterator</code>对象，这个懒加载器是<code>ServiceLoader</code>的核心，它完成了查找实现类、加载实现类的动作。</p><p>那么这里的<strong>懒</strong>到底是指什么？我的理解是在程序启动之初，服务实现类并没有被加载至jvm中<strong>直到我们使用时</strong>。所以这里的懒就是在程序启动到我们使用之前的这一段时间内，不需要也没有加载服务实现类，懒就是懒在这个阶段。那非懒应该就是指在程序一启动就会加载所有的服务实现类。</p><h3 id="2-2-使用ServiceLoader对象迭代器遍历实现类容器"><a href="#2-2-使用ServiceLoader对象迭代器遍历实现类容器" class="headerlink" title="2.2 使用ServiceLoader对象迭代器遍历实现类容器"></a>2.2 使用ServiceLoader对象迭代器遍历实现类容器</h3><p>在成功获取ServiceLoader对象<code>loadedDrivers</code>后，会继续获取<code>loadedDrivers</code>的内部迭代器：</p><blockquote><p>Iterator<Driver> driversIterator = loadedDrivers.iterator();</p></blockquote><p>然后<code>DriverManager</code>会使用这个迭代器遍历ServiceLoader内部用来存储服务实现类对象的容器。具体的驱动注册就在遍历容器的时候完成。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-keyword">while</span>(driversIterator.hasNext()) &#123;<br>        driversIterator.next();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们来看看<code>ServiceLoader</code>内部迭代器的<code>hasNext()</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;S&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Iterator&lt;S&gt;() &#123;<br><br>        Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders<br>            = providers.entrySet().iterator();<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (knownProviders.hasNext())<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">return</span> lookupIterator.hasNext();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> S <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (knownProviders.hasNext())<br>                <span class="hljs-keyword">return</span> knownProviders.next().getValue();<br>            <span class="hljs-keyword">return</span> lookupIterator.next();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>hasNext()</code>首先调用内部容器<code>providers</code>自身的迭代器。失败后才会调用懒迭代器类<code>LazyIterator</code>的<code>hasNext()</code>，其具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyIterator</span></span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">S</span>&gt;</span><br><span class="hljs-class"></span>&#123;<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//无论执行if还是else，都会最终执行hasNextService</span><br>        <span class="hljs-keyword">if</span> (acc == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> hasNextService();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            PrivilegedAction&lt;Boolean&gt; action = <span class="hljs-keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;<br>                <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> hasNextService(); &#125;<br>            &#125;;<br>            <span class="hljs-keyword">return</span> AccessController.doPrivileged(action, acc);<br>        &#125;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在调用<code>LazyIteraotr</code>的<code>hasNext()</code>方法后，内部会调用<code>hashNextService()</code>:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNextService</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nextName != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (configs == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <br>            String fullName = PREFIX + service.getName();<br>            <span class="hljs-keyword">if</span> (loader == <span class="hljs-keyword">null</span>)<br>                configs = ClassLoader.getSystemResources(fullName);<br>            <span class="hljs-keyword">else</span><br>                configs = loader.getResources(fullName);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException x) &#123;<br>            fail(service, <span class="hljs-string">&quot;Error locating configuration files&quot;</span>, x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> ((pending == <span class="hljs-keyword">null</span>) || !pending.hasNext()) &#123;<br>        <span class="hljs-keyword">if</span> (!configs.hasMoreElements()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        pending = parse(service, configs.nextElement());<br>    &#125;<br>    nextName = pending.next();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们看到该方法内部有一个常量字符串<code>PREFIX</code>，其值为:</p><blockquote><p>private static final String PREFIX = “META-INF/services/“;</p></blockquote><p>这是因为java规定，所谓为SPI提供实现的厂商必须在jar包提供目录<code>META-INF/services/</code>，目录内的文件存放当前服务实现类的入口类名，文件名文当前服务接口的全限定名。以MySQL为例，其jar包内容如下：</p><p><img src="images/mysql-SPI.PNG" alt="mysql-SPI"></p><p>其中<code>java.sql.Driver</code>就是java数据库服务接口的全限定名，其内容如下：</p><p><img src="images/mysql-content.PNG" alt="mysql-content"></p><p><code>com.mysql.cj.jdbc.Driver</code>就是具体实现类的全限定名。<code>hasNextService</code>的目标就是把具体实现类的全限定名找到。找的方法就是找到文件：<code>META-INF/services/+service.name</code>。其中<code>service</code>的名字是java规定好的。例如加载数据库时的<code>service</code>就对应<code>Driver</code>类。</p><p>在找到具体实现类的名字后，下一步当然是要把它加载进来了。调用<code>ServiceLoader</code>迭代器的<code>next()</code>方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (acc == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> hasNextService();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        PrivilegedAction&lt;Boolean&gt; action = <span class="hljs-keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> hasNextService(); &#125;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> AccessController.doPrivileged(action, acc);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> S <span class="hljs-title">nextService</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!hasNextService())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>    String cn = nextName;<br>    nextName = <span class="hljs-keyword">null</span>;<br>    Class&lt;?&gt; c = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        c = Class.forName(cn, <span class="hljs-keyword">false</span>, loader);<br>    &#125;<br>    ...<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        S p = service.cast(c.newInstance());<br>        providers.put(cn, p);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>具体的加载由<code>Class.forName()</code>完成，注意，其中传入的loader是线程上下文类加载器。在将具体实现类加载进jvm后，会实例化一个实现类对象，即调用<code>c.newInstance()</code>。在实例化的过程完成了驱动的注册。我们来看看mysql实现类的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Driver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NonRegisteringDriver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">sql</span>.<span class="hljs-title">Driver</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Driver</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            DriverManager.registerDriver(<span class="hljs-keyword">new</span> Driver());<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException var1) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Can&#x27;t register driver!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>非常简单，一旦进行实例化，就会执行静态构造代码块，mysql实现的<code>Driver</code>会主动向<code>DriverManger</code>提出注册请求。至此，已经完成了数据库驱动的一次注册过程。</p><h3 id="2-3-获得数据库连接对象"><a href="#2-3-获得数据库连接对象" class="headerlink" title="2.3 获得数据库连接对象"></a>2.3 获得数据库连接对象</h3><p><code>DriverManager</code>会遍历所有已经注册过的驱动，如果能成功连接目标数据库，那么就返回当前连接对象，否则继续遍历剩下的Driver实例直至结束。下面是遍历驱动的核心代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;<br>    <span class="hljs-comment">// If the caller does not have permission to load the driver then</span><br>    <span class="hljs-comment">// skip it.</span><br>    <span class="hljs-keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            println(<span class="hljs-string">&quot;    trying &quot;</span> + aDriver.driver.getClass().getName());<br>            Connection con = aDriver.driver.connect(url, info);<br>            <span class="hljs-keyword">if</span> (con != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// Success!</span><br>                println(<span class="hljs-string">&quot;getConnection returning &quot;</span> + aDriver.driver.getClass().getName());<br>                <span class="hljs-keyword">return</span> (con);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException ex) &#123;<br>            <span class="hljs-keyword">if</span> (reason == <span class="hljs-keyword">null</span>) &#123;<br>                reason = ex;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        println(<span class="hljs-string">&quot;    skipping: &quot;</span> + aDriver.getClass().getName());<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，如果在一次尝试连接中抛出异常，那么就不会尝试后续的数据库驱动，这还是有点小bug的。</p><h3 id="2-4-存在的问题"><a href="#2-4-存在的问题" class="headerlink" title="2.4 存在的问题"></a>2.4 存在的问题</h3><p><strong>A. ServiceLoader的providers有什么用？</strong></p><p>可以看到，在<code>DriverMangaer</code>初次完成注册后，并没有使用过缓存<code>providers</code>。但是这仅仅是<code>DriverManager</code>的问题，并不能说明缓存没有用。如果我们此时再次遍历当前<code>loadedDrivers</code>，那么就不会再次使用<code>Class.forName()</code>加载，而是会通过内部缓存获得具体的实现类对象。</p><p><strong>B. 如果有多个驱动需要注册，那么在成功注册第一个驱动后，<code>knownProviders.hasNext()</code>返回的结果不应该是<code>true</code>吗？</strong></p><p>其实这跟HashMap迭代器的实现有关，在每次调用<code>entrySet().iterator()</code>后，返回的迭代器都是新<code>new</code>出来的，即初始化函数<code>loadInitialDrivers()</code>中的<code>driversIterator</code>永远都是<code>providers</code>为空时生成的迭代器。所以尽管成功了加载了一个驱动，<code>knownProviders.hasNext()</code>的结果依然是<code>false</code>，依旧会调用懒迭代器<code>lookupIterator</code>的<code>hasNext()</code>方法。</p><h2 id="3-传统的驱动加载方式"><a href="#3-传统的驱动加载方式" class="headerlink" title="3. 传统的驱动加载方式"></a>3. 传统的驱动加载方式</h2><p>传统的加载是通过<code>Class.forName()</code>完成的，而该方法会默认初始化目标类，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; forName(String className)<br>            <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    Class&lt;?&gt; caller = Reflection.getCallerClass();<br>    <span class="hljs-keyword">return</span> forName0(className, <span class="hljs-keyword">true</span>, ClassLoader.getClassLoader(caller), caller);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>一旦完成了实现类的初始化，数据库驱动会自己向<code>DriverManager</code>完成注册。SPI仅仅替代我们写了<code>Class.forName</code>这句话。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>SPI的核心<code>ServiceLoader</code>类，而该类的核心又是内部实现的<code>LazyIterator</code>。在实现SPI时，规定实现库的jar包中必须在<code>META-INF/services/</code>目录下存放以目标SPI命名的文件，其中的内容就是厂商具体实现类的全限定名。</p><p>但是SPI仍然是有缺点的：</p><ul><li>对于某一项服务，会加载所有的实现类，但是其中有一些我们并不需要</li><li>会存在并发问题</li></ul>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E7%B1%BB%E5%8A%A0%E8%BD%BD/">类加载</category>
      
      
      <category domain="https://eripe.me/tags/SPI%E6%9C%BA%E5%88%B6/">SPI机制</category>
      
      <category domain="https://eripe.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD/">数据库驱动加载</category>
      
      
      <comments>https://eripe.me/articles/SPI-service-mechanism.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>关于泛型的常见问题</title>
      <link>https://eripe.me/articles/Frequently-asked-questions-about-generics.html</link>
      <guid>https://eripe.me/articles/Frequently-asked-questions-about-generics.html</guid>
      <pubDate>Mon, 14 Jun 2021 11:50:07 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里罗列一些关于泛型的常见问题,并给出解答。其中本篇大多数问题来自<a href="http://www.angelikalanger.com/GenericsFAQ/FAQSections/ParameterizedTypes.html">Java Generics FAQs - Generic And Parameterized Types</a>,我这里仅翻译一些我认为比较容易糊涂的问题。</p><p>当然,在解答这些问题时,我们需要牢记一个概念,通配符<code>?</code>表示的是不知道是什么类型,而不是任意类型。</p><ul><li>泛型类型:<code>class test&lt;T&gt;&#123;&#125;</code></li><li>具体参数类型:<code>class test&lt;String&gt; t1=null;</code></li><li>泛型参数类型:<code>test&lt;?&gt; t2=null;</code></li></ul><h2 id="1-使用通配符时经常出现的capture-XXX-of-到底什么意思"><a href="#1-使用通配符时经常出现的capture-XXX-of-到底什么意思" class="headerlink" title="1. 使用通配符时经常出现的capture#XXX of ? 到底什么意思?"></a>1. 使用通配符时经常出现的capture#XXX of ? 到底什么意思?</h2><p>在使用通配符时,我们很有可能会遇到类似<code>capture#337 of ?</code>这样莫名奇妙的错误。其中<code>capture</code>是捕获的意思,捕获的是通配符<code>?</code>,那么<code>#337</code>又代表着什么?这一切都要从捕获转化(Capture Conversion)开始说起。</p><p>让我们思考一个问题,如果我们定义定义一个泛型类C如下(类似于List容器)如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> &lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span>&gt;</span>&#123;<br>    ...<br>    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T)</span></span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">C&lt;?&gt; c</span>=<span class="hljs-keyword">new</span> C&lt;Integer&gt;()<br></code></pre></div></td></tr></table></figure><p>那么通过<code>c</code>调用对象方法时,方法的签名是什么样的?像下面这样?(编译时期泛型还是存在的)</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> &lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span>&gt;</span>&#123;<br>    ...<br>    ? get();<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(?)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这显然是毫无意义的,但是我们知道实例化类时一定会使用一个具体的类型X:&lt; Number( <strong>:&lt;</strong> 表示前者继承于后者),尽管我们不知道这个X到底是什么类型的。这并不重要。那么被具体类型X实例化的类C长下面这样:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&lt;<span class="hljs-title">X</span>&gt;</span>&#123;<span class="hljs-comment">//X:&lt;Number</span><br>    ...<br>    <span class="hljs-function">X <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(X)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用一个具有名字的类型比使用通配符<code>?</code>容易多了。所以编译器也是这么做的。只不过编译器并不会使用<code>X</code>,而是随机使用一个数字,例如<code>#337</code>表示上面这个通配符。所以才会有了这句<code>capture#337 of ?</code>。即编译将遇到这个统配符<code>?</code>分配了一个名字叫做<code>#337</code>。</p><p>当一个<code>value</code>的类型是通配符类型,编译器会使用类型变量替换这个<code>value</code>种存在的通配符<code>?</code>(类型变量中的数字按序增长),这种操作名为<code>capture conversion</code>,通过这个操作,编译器只需要处理带有具体类型的对象。</p><p>对于上面的例子,<code>get()</code>方法返回一个<code>X</code>类型的引用,其中<code>X:&lt;Number</code>,那么我们就可以执行下述操作:</p><blockquote><p>Number n= c.get();//c为类C的实例,get方法返回的是Number类型</p></blockquote><p>但是我们却不能向c中添加元素。</p><blockquote><p>c.add(number)//add方法接受的参数为类型为capture#1 of ?</p></blockquote><p>因为add方法接受的参数类型为x(编译器的名字可能为capture#1 of ?),而容器c中的引用至少都为Number类型,因为容器内的元素类型都有一个限制:<code>? extends Number</code>,所以编译器出于安全,将容器内的引用推断为<code>Number</code>类型肯定是不会错的。<br>那么一个存储<code>Number</code>类型的容器,能接受一个类型为<code>capture#1 of ?</code>的值吗?不知道,因为后者的类型编译器无法推断,所以为了保险起见,直接会产生编译错误。</p><p>只要有表达式产生了<code>wild type</code>的<strong>value</strong>(The compiler applies capture conversion on every expression that yields a value in wild type),<code>capture conversion</code>操作就存在。并且会为每个通配符<code>?</code>分配一个唯一ID。以下面代码为例:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;? extends Number&gt; foo(List&lt;? extends Number&gt; numberList)<br>&#123;<br>#<span class="hljs-number">1</span>  <span class="hljs-keyword">for</span>(Number number : numberList)<br>#<span class="hljs-number">2</span>      <span class="hljs-keyword">assert</span> numberList.contains(number);<br>#<span class="hljs-number">3</span>  numberList = numberList;<br>#<span class="hljs-number">4</span>  <span class="hljs-keyword">return</span> numberList;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面代码有四个地方都存在<code>wild type</code>的变量,我们一个一个来分析。</p><p>对于<code>#1</code>处的<code>numberList</code>,其类型为<code>List &lt;? extends Number&gt;</code>,那么会将这处的<code>numberList</code>转换为<code>List&lt;X1&gt;</code>类型,<code>List&lt;X1&gt;</code>是<code>Iterable&lt;X1&gt;</code>的子类,所以可以使用for循环遍历,number的类型是<code>X1</code>,又因为<code>X1:&lt;Number</code>,所以其可以向上转型为<code>Number</code></p><p>对于<code>#2</code>处的<code>numberList</code>,编译器会将其类型转换为<code>List&lt;X2&gt;</code>类型,其中的<code>contains</code>方法是<code>List&lt;X2&gt;</code>类型下的<code>contains</code>方法,所以该方法接受一个<code>X2</code>类型的参数</p><p>对于<code>#3</code>处的右<code>numberList</code>,编译器会将其类型转换为<code>List&lt;X3&gt;</code>,但是！！！对于左边的<code>numberList</code>,因为其是一个variable,而不是一个value,所以编译器不会对其类型进行转换,还是<code>List&lt;? extends Number&gt;</code>,将<code>List&lt;X3&gt;</code>类型赋值给<code>List&lt;? extends Number&gt;</code>类型是合法的,因为<code>X3:&lt;Number</code>。<br><strong>那么是否可以认为左侧的都是variable,而右侧的是value???</strong> 或者是否可以这样理解:右边的变量<code>numberList</code>把它的value赋值给了左侧的<code>numberList</code>,而这个value是<code>wild type</code>？或者说用的时候实际上使用的实际上是variable的value?</p><p>对于<code>#4</code>处的<code>numberList</code>,编译器同样会转换为<code>List&lt;X4&gt;</code>后返回。</p><p>上面的转换规则非常重要,我们再来看一个难一点的例子。现在有一个map,类型为<code>Map&lt;?,?&gt; map</code>,那么如果进行如下操作是合法的:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(Entry&lt;?,?&gt; entry : map.entrySet())<br></code></pre></div></td></tr></table></figure><p>因为<code>map</code>会被转型为<code>Map&lt;X1,X2&gt;</code>类型,那么返回的entrySet就是<code>Set&lt;Entry&lt;X1,X2&gt;&gt;</code>,因为<code>X1&lt;:?</code>,<code>X2&lt;:?</code>,所以将<code>Entry&lt;X1,X2&gt;</code>类型赋值给<code>Entry&lt;?,?&gt;</code>类型是合理的。但是下面的操作就非法了</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Set&lt;Entry&lt;?,?&gt;&gt; entrySet = map.entrySet(); <span class="hljs-comment">// compile error</span><br></code></pre></div></td></tr></table></figure><p>很简单,错误原因是因为泛型不是协变的,<code>Set&lt;Entry&lt;X1,X2&gt;&gt;</code>不是<code>Set&lt;Entry&lt;?,?&gt;&gt;</code>的子类。比较笨拙的办法是在定义一个<code>wild type</code>,如下所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Set&lt;? extends Entry&lt;?,?&gt;&gt; entrySet=map.entrySet();<br></code></pre></div></td></tr></table></figure><p>其实还有一个比较取巧的办法,通过名为<code>capture helper</code>的操作来解决这个问题。</p><h3 id="1-1-Capture-Helper"><a href="#1-1-Capture-Helper" class="headerlink" title="1.1 Capture Helper"></a>1.1 Capture Helper</h3><p>因为编译器对于<code>wild type</code>的取名都是任意的,并且对我们是不可见的,所以我们在源码中无法引用,以下面的代码为例:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(List&lt;? extends Number&gt; numberList)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// numberList.add( numberList.get(0) ); // compile error,因为左numberList接受的是X2类型,而又numberList接受的是X1类型</span><br><br>    <span class="hljs-comment">//假设下面的代码存在,我们将传进来的numberList转型为List&lt;X&gt;类型,那么该方法所有使用numberList的地方,其类型是List&lt;X&gt;</span><br>    <span class="hljs-comment">//而不是见一个numberList换一个类型</span><br>    List&lt;X&gt; list = numberList;  <span class="hljs-comment">// *imaginary* code</span><br><br>    X number = list.get(<span class="hljs-number">0</span>);     <span class="hljs-comment">// get() returns X</span><br>    list.add(number);           <span class="hljs-comment">// add() accepts X</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>既然人为定义<code>wild type</code>的类型,可行,那么我把类型<code>X</code>定义出来不久好了?如下面代码所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">&lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar2</span><span class="hljs-params">(List&lt;T&gt; list)</span></span><br><span class="hljs-function"></span>&#123;<br>    T number = list.get(<span class="hljs-number">0</span>);<br>    list.add(number);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后我们就可以调用<code>bar(numberList)</code>解决上面每个<code>numberList</code>类型不一样的问题。方法<code>bar2</code>就叫做<code>capture helper</code>。</p><p>那么<code>capture helper</code>的出现有什么意义呢?<br>答案是为了兼容老代码,因为1.5之前的代码没有泛型,如果使用泛型的代码想要接受没有泛型的容器,就得实现<code>capture helper</code>(当然不局限于容器,这里容器比较典型)</p><p><strong>参考文献:</strong></p><ol><li><p><a href="http://bayou.io/draft/Capturing_Wildcards.html#Capture_Everywhere">Capturing Wildcards</a></p></li><li><p><a href="http://bayou.io/draft/Wildcard_Case_Studies.html#Map&lt;?,?&gt;_Entry_Set">Wildcard Case Studies</a></p></li></ol><h2 id="2-lt-extends-E-gt-与-lt-T-extends-E-gt-有什么区别"><a href="#2-lt-extends-E-gt-与-lt-T-extends-E-gt-有什么区别" class="headerlink" title="2. &lt;? extends E&gt;与&lt;T extends E&gt;有什么区别?"></a>2. &lt;? extends E&gt;与&lt;T extends E&gt;有什么区别?</h2><p>这是容易搞混的一点,首先<code>T</code>叫做类型变量(type variable),<code>?</code>叫做通配符(wildcard)。</p><ol><li><p>类型变量不能使用<code>super</code>,即类型变量不能有上界,例如<code>T super E</code>,这样是非法的。至于为什么非法可以看下一个问题。但是通配符<code>?</code>却可以有上界或者下界。</p></li><li><p>类型变量可以有多个限制,例如<code>T extends A &amp; B</code>,但是通配符<strong>至多</strong>有一个界限。</p></li><li><p>通配符不能表示一个类型变量,所以通配符不能用来定义<code>generic type</code> ,类型变量可以用来定义<code>generic type</code></p></li></ol><p><strong>参考文献:</strong></p><ol><li><a href="https://stackoverflow.com/questions/18384897/what-is-difference-between-extends-object-and-e-extends-object">What is difference between &lt;? extends Object&gt; and <E extends Object>?</a></li></ol><h2 id="3-lt-T-super-E-gt-为什么是非法的"><a href="#3-lt-T-super-E-gt-为什么是非法的" class="headerlink" title="3. &lt;T super E&gt;为什么是非法的?"></a>3. &lt;T super E&gt;为什么是非法的?</h2><p>因为Object所有引用类型的父类。<T super E>并不会按照我们的想法工作。例如我们定义了一个容器<code>ArrayList&lt;Integer&gt; list</code>,思考下面的代码是否意义:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//add方法是list的对象方法</span><br><span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">super</span> Integer&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T)</span></span>&#123;<br>    list.add(T);<br>&#125;<br><br>ArrayList&lt;Integer&gt; list=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<span class="hljs-comment">//正常,没有任何问题</span><br>lsit.add(<span class="hljs-string">&quot;aaa&quot;</span>);<span class="hljs-comment">//我们的本意是这句不该通过编译,但是却通过了</span><br></code></pre></div></td></tr></table></figure><p><code>add</code>方法的本意是接受类型是<code>Integer</code>的参数,可以是<code>Object</code>、<code>Number</code>、<code>Integer</code>,不应该接受<code>String</code>类型。</p><p>但是<code>Object</code>也是<code>String</code>的父类。很有可能给<code>add</code>传入的参数静态类型是<code>Object</code>,动态类型是<code>String</code>。虽然放进去是没有问题,但是如果把这个<code>String</code>类型的元素取出来,会出现<code>castException</code>,因为<code>String</code>根本不可能转换为<code>Integer</code>。</p><p><strong>参考文献:</strong></p><ol><li><a href="https://stackoverflow.com/questions/2800369/bounding-generics-with-super-keyword">Bounding generics with ‘super’ keyword</a></li></ol><h2 id="4-为什么定义类型参数时不能使用通配符’-’"><a href="#4-为什么定义类型参数时不能使用通配符’-’" class="headerlink" title="4. 为什么定义类型参数时不能使用通配符’?’?"></a>4. 为什么定义类型参数时不能使用通配符’?’?</h2><p>因为通配符<code>?</code>只是用来定义<code>wild type</code>的一个语法成分,它没有任何语义,<strong>它不能表示任何类型</strong>。想象一下,如果下面的代码是合法的:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>&lt;?&gt;</span>&#123;<br>    ? get(<span class="hljs-keyword">int</span> index)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(? elem)</span></span>&#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在前面曾经说过,由于<code>capture conversion</code>的原因,编译器会把每一个类型是<code>wild type</code>的value中的通配符<code>?</code>赋一个名字,例如像下面这样:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">X1</span>&gt;</span>&#123;<br>    <span class="hljs-function">X2 <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> inedx)</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(X3 elem)</span></span>&#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么我们在实例化List的时候,像<code>List&lt;String&gt;</code>这样?那么<code>get</code>的返回值类型又是什么?这样就违背了我们使用<code>?</code>定义泛型类的初衷。我们的本意是<code>List</code>接受一个不知道是什么类型的类型参数(unkown type),并且想要<code>get</code>的返回值类型也是同一个<code>unknown type</code>。但是这很显然不可能。</p><p><strong>所以通配符<code>?</code>就不能用来定义一个类型变量(type variable),它只能用在类型声明的地方</strong>,例如声明方法的形参类型,声明一个变量。因为 <strong>?不是一个有效的变量名,不是一个有效的标识符</strong>:</p><blockquote><p>You can’t name a generic parameter as ?, because ? is not a valid identifier - a valid name of a variable.<br>You have to give a generic parameter a valid java name so you can refer to it in the implementation.</p></blockquote><p>下面是通配符常用的地方:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;?&gt; list;<span class="hljs-comment">//ok,声明变量类型</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(List&lt;? extends Number&gt; list)</span></span>;<span class="hljs-comment">//ok,声明参数类型</span><br></code></pre></div></td></tr></table></figure><p>那么所谓的定义一个泛型类型是什么?就像下面这样:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">    List MyList&lt;T&gt;&#123;<span class="hljs-comment">//定义了一个泛型类型MyList&lt;T&gt;,T是类型变量</span><br><br>    <span class="hljs-keyword">public</span> &lt;V&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(V num,T test)</span></span>&#123;&#125;<span class="hljs-comment">//定义了一个类型变量V</span><br>    <span class="hljs-keyword">public</span> &lt;?&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//compile error</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>并且统配符<code>?</code>只能用来填充类型变量。所谓的填充是什么意思,比如我们定义了一个方法接受<code>MyList&lt;T&gt;</code>泛型的方法,那么我们就可以用<code>?</code>填充这个T。那么填充在哪?</p><ul><li>声明方法的参数</li><li>声明变量</li></ul><p>如下所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//定义方法时声明参数,使用?填充T</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(MyList&lt;?&gt; myList)</span></span>&#123;&#125;<br><span class="hljs-comment">//或者加个界限</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(MyList&lt;? extends Number&gt; myList)</span></span>&#123;&#125;<br><span class="hljs-comment">//定义了一个MyList&lt;T&gt;的变量,使用?填充T</span><br>MyList&lt;?&gt; myList;<span class="hljs-comment">//</span><br></code></pre></div></td></tr></table></figure><p><strong>参考文献:</strong></p><ol><li><a href="https://stackoverflow.com/questions/24740590/java-generic-wildcard?rq=1">java Generic wildcard “?”</a></li><li><a href="https://blog.csdn.net/harvic880925/article/details/49883589">夯实JAVA基本之一——泛型详解(2)：高级进阶</a></li></ol><h2 id="5-有没有不能使用泛型的地方"><a href="#5-有没有不能使用泛型的地方" class="headerlink" title="5. 有没有不能使用泛型的地方?"></a>5. 有没有不能使用泛型的地方?</h2><p>几乎所有类型都可以拥有类型参数,但除了一下几种类型:</p><ul><li>枚举类型:因为枚举类型不能有类型参数,所以枚举类中的值都是静态类型的,但是又因为<strong>类型参数不能用于任何静态的上下文环境</strong>,所以在枚举类中使用泛型是没有任何意义的</li><li>匿名内部类:它可以继承一个参数化类型的类或者接口,但它本身不能是，因为<strong>匿名内部泛型类没有任何意义</strong>。因为匿名内部类没有名字,所以在声明时就没有地方提供类型参数</li><li>异常类:一个泛型类不能间接或者直接继承自<code>Throwable</code>接口,因为异常处理机制是一种运行时机制,但是在运行时泛型已经被擦出了。所以对于同一个泛型类型但是类型参数不同的两个参数化类型来说,虚拟机并不能区分它们,所以异常泛型类也是无意义的。</li></ul><h2 id="6-能不能强转成参数化类型"><a href="#6-能不能强转成参数化类型" class="headerlink" title="6.能不能强转成参数化类型?"></a>6.能不能强转成参数化类型?</h2><p>可以,但是这种操作是类型不安全的,且会产生”unchecked”的编译警告。</p><p>因为一个变量的类型分为静态类型与动态类型。一个类型转换操作也分为两个部分:</p><ul><li>编译时期的静态类型检查</li><li>运行十七的动态类型检查</li></ul><p>静态时期的类型检查去除了一些显而易见的错误,例如讲<code>String</code>转换成<code>Date</code>。而动态类型检查使用了动态类型进行检查。如果动态类型不是目标类型或者不是目标类型的子类(也就是所谓的向下转型),那么就会产生<code>ClassCastException</code>。</p><p>但是并不是所有类型转换都会动态类型检查。基本类型之间的转换仅会进行静态类型检查。并且向上转型也只会进行静态类型检查,向上转型不写也没关系,因为编译器会帮你做这件事。</p><p><strong>需要动态检查</strong>的类型转换潜在是类型不安全的,尤其是当目标类型为一个参数化类型。在运行时参数化类型的类型信息不在存在,虚拟机不能区分两个是同一个泛型,但是采用不同的类型参数实例化出的参数化类型,所以在这种情况下,本不该通过动态检查的类型转换却通过了,这不是我们希望看到的。例如下面的代码,将<code>Object</code>转换为<code>List&lt;String&gt;</code>,但是却没有抛出<code>ClassCastException</code>.</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br>  List&lt;Date&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Date&gt;();<br>  ...<br>  m2(list);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">(Object arg)</span> </span>&#123;<br>  ...<br>  List&lt;String&gt; list = (List&lt;String&gt;) arg;    <span class="hljs-comment">// unchecked warning</span><br>  ...<br>  m3(list);<br>  ...<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">(List&lt;String&gt; list)</span> </span>&#123;<br>  ...<br>  String s = list.get(<span class="hljs-number">0</span>);      <span class="hljs-comment">// ClassCastException</span><br>  ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意上面抛出异常的位置,不是在我们进行类型转换的位置,而是在我们提取元素的时候。这种没有在正确地方抛出的异常是我们非常不愿意看到的。所以为了引起我们对这种潜在的类型不安全的转换注意,编译器产生了”unchecked”警告在遇到可疑的转换时。</p><p>所以,<strong>编译器在每一处目标类型是参数化类型并且是向下转型的地方,都会产生一个unchecked警告</strong>。</p><h2 id="7-泛型中哪里会出现的”unchecked”警告"><a href="#7-泛型中哪里会出现的”unchecked”警告" class="headerlink" title="7.泛型中哪里会出现的”unchecked”警告?"></a>7.泛型中哪里会出现的”unchecked”警告?</h2><ol><li><p>首先就是上面一个问题所说的:向下转型为参数化类型的地方。</p></li><li><p>如果方法的参数类型没有因为类型擦除而改变,那么调用这个方法就是类型安全的</p></li><li><p>如果字段的类型因为类型擦除而改变,那么对该字段赋值就会产生”unchecked”,但是读取该字段的值却不会产生任何问题</p></li></ol><h2 id="8-unbound-wildcard-parameterized-type和raw-type有什么区别"><a href="#8-unbound-wildcard-parameterized-type和raw-type有什么区别" class="headerlink" title="8. unbound wildcard parameterized type和raw type有什么区别?"></a>8. unbound wildcard parameterized type和raw type有什么区别?</h2><p>其实这二者没有太大区别,二者都可以被视作是任何参数化类型的超级类,并且二者都是<code>reifiable types</code>。所以这两种类型可以作为数组的元素类型(注意是unbound wildcard而不是wildcard)。但是编译器对<code>unbound wildcard parameterized type</code>更严格。对于同样的操作,如果<code>raw type</code>产生了<code>unchecked</code>警告,那么<code>unbound wildcard parameterized type</code>则会产生编译错误。</p><h2 id="9-泛型真的不能使用instance-of吗"><a href="#9-泛型真的不能使用instance-of吗" class="headerlink" title="9. 泛型真的不能使用instance of吗?"></a>9. 泛型真的不能使用instance of吗?</h2><p>大部分都不行,只有无界通配符可以,因为只有<code>reifiable type</code>能够使用<code>instance of</code>,<code>reifiable types</code>包括且只包括:</p><ul><li><p>It refers to a non-generic class or interface type declaration.</p></li><li><p>It is a parameterized type in which all type arguments are <strong>unbounded</strong> wildcards (§4.5.1).</p></li><li><p>It is a raw type (§4.8).</p></li><li><p>It is a primitive type (§4.2).</p></li><li><p>It is an array type (§10.1) whose element type is reifiable.</p></li><li><p>It is a nested type where, for each type T separated by a “.”, T itself is reifiable.</p></li></ul><h2 id="10-能创建数组元素是具体参数化类型的数组吗"><a href="#10-能创建数组元素是具体参数化类型的数组吗" class="headerlink" title="10. 能创建数组元素是具体参数化类型的数组吗?"></a>10. 能创建数组元素是具体参数化类型的数组吗?</h2><p>所谓的具体参数化类型就是类型参数是一个具体的参数,例如<code>String</code>、<code>Integer</code>等等。对于这个问题的答案是不能,因为是类型不安全的。</p><p>因为插入操作会逃过数组的动态类型检查,见如下代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>  Pair&lt;Integer,Integer&gt;[] intPairArr = <span class="hljs-keyword">new</span> Pair&lt;Integer,Integer&gt;[<span class="hljs-number">10</span>] ; <span class="hljs-comment">// error</span><br>  addElements(intPairArr); <br>  Pair&lt;Integer,Integer&gt; pair = intPairArr[<span class="hljs-number">1</span>];<br>  Integer i = pair.getFirst();<br>  pair.setSecond(i);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addElements</span><span class="hljs-params">( Object[] objArr)</span> </span>&#123;<br>  objArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair&lt;Integer,Integer&gt;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>  objArr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Pair&lt;String,String&gt;(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);      <span class="hljs-comment">// should fail with ArrayStoreException,但是因为在运行时泛型已经不存在了</span><br>                                                  <span class="hljs-comment">//  逃过了数组插入时的类型动态检查</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="11-能创建数组元素类型是通配符参数化类型的数组吗"><a href="#11-能创建数组元素类型是通配符参数化类型的数组吗" class="headerlink" title="11. 能创建数组元素类型是通配符参数化类型的数组吗?"></a>11. 能创建数组元素类型是通配符参数化类型的数组吗?</h2><p>无界通配符可以,有界通配符不行。因为有界通配符的插入操作也可以逃过数组插入时的动态类型检查,而无界通配符不会。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//非法操作</span><br>Object[] numPairArr = <span class="hljs-keyword">new</span> Pair&lt;? extends Number,? extends Number&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">// illegal</span><br>numPairArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair&lt;Long,Long&gt;(<span class="hljs-number">0L</span>,<span class="hljs-number">0L</span>);     <span class="hljs-comment">// fine</span><br><span class="hljs-comment">//注意,下面这句逃过了数组的动态类型检查</span><br>numPairArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair&lt;String,String&gt;(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// should fail, but would succeed</span><br><br><span class="hljs-comment">//合法操作</span><br>Object[] pairArr = <span class="hljs-keyword">new</span> Pair&lt;?,?&gt;[<span class="hljs-number">10</span>] ;        <span class="hljs-comment">// fine</span><br>pairArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair &lt;Long,Long&gt;(<span class="hljs-number">0L</span>,<span class="hljs-number">0L</span>);     <span class="hljs-comment">// fine</span><br>pairArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair &lt;String,String&gt;(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// fine </span><br>pairArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> ArrayList &lt;String&gt;();        <span class="hljs-comment">// fails with ArrayStoreException</span><br></code></pre></div></td></tr></table></figure><h2 id="12-能创建数组元素是有界通配符参数化类型的数组引用吗"><a href="#12-能创建数组元素是有界通配符参数化类型的数组引用吗" class="headerlink" title="12. 能创建数组元素是有界通配符参数化类型的数组引用吗?"></a>12. 能创建数组元素是有界通配符参数化类型的数组引用吗?</h2><p>可以,但没必要。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//创建了数组元素类型是有界通配符类型的数组</span><br><br>Pair&lt;? extends Number,? extends Number&gt;[] arr = <span class="hljs-keyword">null</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">Double</span>,<span class="hljs-title">Double</span>&gt; </span>&#123; ... &#125;<br>Pair&lt;? extends Number,? extends Number&gt;[] arr = <span class="hljs-keyword">new</span> Point[<span class="hljs-number">2</span>];<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Point(-<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>);  <span class="hljs-comment">// fine</span><br><span class="hljs-comment">//虽然能通过静态类型检查,但是无法通过数组的动态类型检查</span><br>arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Pair&lt;Number,Number&gt;(-<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>); <span class="hljs-comment">// fine (causes ArrayStoreException)</span><br>arr[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Pair&lt;Integer,Integer&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// fine (causes ArrayStoreException)</span><br></code></pre></div></td></tr></table></figure><h2 id="13-通配符参数化类型不能干嘛"><a href="#13-通配符参数化类型不能干嘛" class="headerlink" title="13.通配符参数化类型不能干嘛?"></a>13.通配符参数化类型不能干嘛?</h2><p>不能做父类。见如下代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span> &lt;?&gt; </span>&#123; <span class="hljs-comment">// error</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">( ??? arg)</span> </span>&#123; ... &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>编译器无法知道<code>comapreTo</code>方法到底接受的是什么类型的参数,很奇怪。而且,如前面所说,因为有<code>capture conversion</code>操作,这样的定义是没有任何意义的。</p><h2 id="15-具体化参数类型不能做什么"><a href="#15-具体化参数类型不能做什么" class="headerlink" title="15. 具体化参数类型不能做什么?"></a>15. 具体化参数类型不能做什么?</h2><p>具体化参数类型(concrete parameterized type)就是使用具体类型实例化泛型类型的类型。那么它不能做:</p><ol><li>使用<code>instance of</code></li><li>不能创建数组</li><li>不能用于异常处理(泛型都不行)</li></ol><h2 id="14-泛型不能做什么"><a href="#14-泛型不能做什么" class="headerlink" title="14. 泛型不能做什么?"></a>14. 泛型不能做什么?</h2><ol><li>不能在静态字段中使用类型参数(type paramemter):<strong>因为type parameter不适用于静态上下文环境</strong>,所以泛型不能适用于静态泛型字段,例如<code>static T member</code>、<code>static List&lt;T&gt; list</code></li><li>不用如此使用：<code>obj instanceof T</code>，因为类型擦除的原因</li></ol><p><strong>参考文献:</strong></p><p>若非特殊标注,问题引自<a href="http://www.angelikalanger.com/GenericsFAQ/FAQSections/ParameterizedTypes.html#FAQ001">Java Generics FAQs - Generic And Parameterized Types</a></p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E5%9F%BA%E7%A1%80/">基础</category>
      
      
      <category domain="https://eripe.me/tags/%E6%B3%9B%E5%9E%8B/">泛型</category>
      
      
      <comments>https://eripe.me/articles/Frequently-asked-questions-about-generics.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java的泛型</title>
      <link>https://eripe.me/articles/the-generic-of-java.html</link>
      <guid>https://eripe.me/articles/the-generic-of-java.html</guid>
      <pubDate>Mon, 14 Jun 2021 11:50:07 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>这篇文章是在研究java的Type体系顺带扯出的概念,泛型的使用要说简单也很简单,要说难也可以说难。本文将由浅入深,带你学习java中的”泛型”。</p></blockquote><h2 id="1-泛型的基本概念"><a href="#1-泛型的基本概念" class="headerlink" title="1. 泛型的基本概念"></a>1. 泛型的基本概念</h2><p>泛型的概念始于java1.5,所以在1.5之前所有使用java的地方都没有泛型的影子,那么为了保持向后兼容,java中的泛型被设计成了伪泛型,仅仅存在于编译时期,在实际生成的字节码文件中是没有泛型的,这一动作叫做泛型的<strong>擦除</strong>。</p><p>泛型的基本格式为:<code>class Perosn&lt;T&gt;</code>,其中定义在<code>&lt;&gt;</code>的变量称为<code>type variable</code>,这一概念是随着泛型而出生的,并且也跟java的Type子系统息息相关。在jse8文档中,声明<code>type variable</code>允许用在四个地方,但是并不限制<code>type variable</code>的使用个数。允许的四个地方分别是:</p><ul><li>泛型类</li><li>泛型接口</li><li>泛型方法</li><li>泛型构造函数</li></ul><p>其中泛型构造函数的使用可以归档在泛型方法一类中。</p><p>注意:</p><blockquote><p>使用泛型构造方法并不要求类是泛型类</p></blockquote><p>更新(2020-08-14 20:18:36):</p><p>还有一些概念,了解后可以更好的帮助我们了解泛型:</p><ul><li>泛型类型(generic type):是一个带着类型参数的类型,即类似于<code>class Person&lt;T&gt;</code></li><li>参数化类型(parameterized type):即使用具体的类型实参去实例化泛型类型的类型,例如使用类型<code>String</code>去实例化泛型类型<code>class Person&lt;T&gt;</code>,所得的参数类型为<code>class Person&lt;String&gt;</code></li></ul><h3 id="1-1-泛型使用的简单示例"><a href="#1-1-泛型使用的简单示例" class="headerlink" title="1.1 泛型使用的简单示例"></a>1.1 泛型使用的简单示例</h3><p><strong>泛型类与泛型接口:</strong></p><p>泛型类和泛型接口的声明比较简单,仅需要在类名或者接口名后面使用<code>&lt;&gt;</code>声明<code>type variable</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//泛型类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T name;<br>    <span class="hljs-keyword">private</span> E age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T name,E id)</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.getClass().getSimpleName());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(T name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(E age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//泛型接口</span><br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">People</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>泛型方法:</strong></p><p>泛型方法又分为普通的泛型方法、静态泛型方法、泛型构造方法。泛型方法的声明麻烦一点,泛型方法需要在权限修饰后面定义所要使用的<code>type variable</code>。</p><p>下面是一组使用泛型方法和泛型类的代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> generic;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> T name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(T name,<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>        <span class="hljs-keyword">this</span>.age=age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(T name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">V</span>&gt;</span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span>&lt;T&gt; V <span class="hljs-title">getInfo</span><span class="hljs-params">(People&lt;T&gt; p1, People&lt;T&gt; p2, V sum)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;p1:&quot;</span>+p1.getName()+<span class="hljs-string">&quot; &quot;</span>+p1.getAge());<br>        System.out.println(<span class="hljs-string">&quot;p2:&quot;</span>+p2.getName()+<span class="hljs-string">&quot; &quot;</span>+p2.getAge());<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        People&lt;String&gt; p1=<span class="hljs-keyword">new</span> People&lt;&gt;(<span class="hljs-string">&quot;Bob&quot;</span>,<span class="hljs-number">23</span>);<br>        People&lt;String&gt; p2=<span class="hljs-keyword">new</span> People&lt;&gt;(<span class="hljs-string">&quot;Lee&quot;</span>,<span class="hljs-number">20</span>);<br>        Test&lt;Integer&gt; t=<span class="hljs-keyword">new</span> Test&lt;&gt;();<br>        Object result= t.&lt;String&gt;getInfo(p1,p2,<span class="hljs-number">23</span>);<br>        <span class="hljs-comment">//Object result=t.getInfo(p1,p2,23);</span><br><br>        System.out.println(<span class="hljs-string">&quot;result is an instance of Integer:&quot;</span>+result <span class="hljs-keyword">instanceof</span> Integer);<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">p1:Bob <span class="hljs-number">23</span><br>p2:Lee <span class="hljs-number">20</span><br>result is an instance of Integer:<span class="hljs-keyword">true</span><br></code></pre></div></td></tr></table></figure><p>其中泛型方法签名为:<code>public&lt;T&gt; V getInfo(People&lt;T&gt; p1, People&lt;T&gt; p2, V sum)</code>,<code>T</code>是这个泛型方法<code>getInfo</code>指定的类型变量,而<code>V</code>则是泛型类指定的类型变量。在调用泛型方法时,可以在<code>.</code>和方法名之间明确指定泛型方法的具体类型,或者让编译器自己推断。</p><p>其实上面这个泛型方法有个明显的缺点,就是返回值的类型也是一个泛型,这就要求调用者必须判断返回值的具体类型,因为接口。那么可能有人会问了,那<code>ArrayList</code>的源码中也有很多返回泛型的例子,他们写的也差劲?例如:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    rangeCheck(index);<br>    <span class="hljs-keyword">return</span> elementData(index);<br>&#125;<br><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-function">E <span class="hljs-title">elementData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (E) elementData[index];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样写是因为库编写者已经确定容器中存储的元素的类型就是<code>E</code>,强制转换成<code>E</code>并不会出错,并且调用者也知道返回的类型到底是什么。而且因为方法的返回值是泛型<code>E</code>,编译器会在调用者部分的字节码中自动插入一段强制转换代码将元素类型转为为<code>E</code>。这是由于类型擦除导致的,这会在<strong>后文</strong>详细解释。</p><p>静态泛型方法与常规的泛型方法唯一区别就是<strong>静态泛型方法中不能使用泛型类的类型变量</strong>,例如在<code>people</code>中声明一个方法:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;M&gt; calc(M year,M mouth)&#123;...&#125;<br></code></pre></div></td></tr></table></figure><p><code>calc</code>中不能使用泛型类<code>People</code>中的类型变量<code>T</code>。</p><p><strong>泛型构造方法:</strong></p><p>最后泛型构造方法又可以分为两种:类本身就是泛型类,类不是泛型类。下面是一个简单的例子:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//所在类不是泛型类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span></span>&#123;<br>    <span class="hljs-keyword">public</span> &lt;T &amp; Comparable&lt;T&gt;&gt; People(T age)&#123;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//所在类是泛型类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中<code>&lt;T &amp; Comparable&lt;T&gt;&gt;</code>的含义是要求<code>T</code>已经实现了Comparable接口。这部分细节可以查看jse8关于<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.4">type variable</a>的详细规范。</p><h2 id="2-泛型通配符"><a href="#2-泛型通配符" class="headerlink" title="2. 泛型通配符"></a>2. 泛型通配符</h2><p>在了解泛型通配符之前,我们需要知道一些基本术语:协变、逆变、不变,这一部分引自<a href="https://zhuanlan.zhihu.com/p/31137677">仔细说说Java中的泛型</a>。</p><p>逆变与协变用来描述类型转换（type transformation）后的继承关系，其定义：如果A、B表示类型，f(X)表示类型转换，≤表示继承关系(比如,A≤B表示A继承于b),那么这里有三个关系</p><blockquote><ol><li>当A≤B时有f(B)≤f(A)成立，那么说f(X)是逆变（contravariant）的</li><li>当A≤B时有f(A)≤f(B)成立，那么说f(X)是协变(covariant)的</li><li>当上两者都不成立的时候，那么说f(X)是不变（invariant)的</li></ol></blockquote><p>在java中,<strong>数组是支持协变的</strong>,例如下面这句代码可以通过编译,但会产生运行时错误:</p><blockquote><p>Number[] test=new Integer[];</p></blockquote><p><code>Integer</code>是<code>Number</code>的子类,同时变成数组,<code>Integer[]</code>还是<code>Number[]</code>的子类。</p><hr><p><strong>Extension One:在java中数组为什么要设计成协变的?</strong></p><p>答案来源于:<a href="https://www.zhihu.com/question/21394322">java中，数组为什么要设计为协变？</a>,我在这里补充一些我的理解。</p><p>在java1.5之前,java是不支持泛型的,因为没时间做。但是又需要泛型的特性,所以就把数组设计成协变的了。例如在比较数组时调用的是<code>Arrays.equals</code>方法,其底层调用的是<code>Object.equals</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object[] a, Object[] a2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a==a2)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> (a==<span class="hljs-keyword">null</span> || a2==<span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">int</span> length = a.length;<br>    <span class="hljs-keyword">if</span> (a2.length != length)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;length; i++) &#123;<br>        Object o1 = a[i];<br>        Object o2 = a2[i];<br>        <span class="hljs-keyword">if</span> (!(o1==<span class="hljs-keyword">null</span> ? o2==<span class="hljs-keyword">null</span> : o1.equals(o2)))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>如果</strong>数组是不支持协变的,那么比较<code>B</code>时得重写<code>equals</code>的代码,比较<code>A</code>时又得重写一份<code>equals</code>的代码,因为<code>A[]</code>不能赋值给<code>Object[]</code>,代码重写非常严重,违背了代码复用的宗旨。所以将数组设计成协变的,使得<code>A[]</code>能够赋值为<code>Object[]</code>,从而调用对象的<code>equals()</code>方法时,由于多态的原因,实际上调用的<code>A</code>的<code>equals</code>方法。实现了代码复用。</p><p>那么数组设计成协变会产生大问题吗?答案是不会,因为数组记得它到底保持的是什么类型,这会在<strong>编译时</strong>严格检查数据类型。而泛型协变有问题也只会在运行时出现，延后了问题出现的时间。违背了java是严格类型确定的编程语言。</p><p>但是<strong>并不支持</strong>泛型数组,因为数组能记得它存储的元素类型的前提是在创建时就严格确定了其存储的元素类型(之所以能记住这是靠虚拟机实现的,Array由虚拟机来实现)。</p><p><strong>Extension Two:java中为什么不支持泛型数组?</strong></p><p>参考自<a href="https://www.zhihu.com/question/20928981/answer/117521433">java为什么不支持泛型数组？</a></p><p>java明确规定了数组的元素类型必须是可靠的.</p><blockquote><p>It is a compile-time error if the component type of the array being initialized is not reifiable</p></blockquote><p>其中<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.7">Reifiable Types</a>包括且只包括:</p><ul><li><p>It refers to a non-generic class or interface type declaration.</p></li><li><p>It is a parameterized type in which all type arguments are <strong>unbounded</strong> wildcards (§4.5.1).</p></li><li><p>It is a raw type (§4.8).</p></li><li><p>It is a primitive type (§4.2).</p></li><li><p>It is an array type (§10.1) whose element type is reifiable.</p></li><li><p>It is a nested type where, for each type T separated by a “.”, T itself is reifiable.</p></li></ul><p>下面是每个<code>Reifiable Type</code>的示例:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">E</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&lt;<span class="hljs-title">X</span>&gt;</span>&#123;&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;&#125;<br><br><span class="hljs-comment">//It refers to a non-generic class or interface type declaration.</span><br><span class="hljs-comment">//是一个分泛型的类或接口的引用</span><br>A ref;<br>E ref;<br><span class="hljs-comment">//It is a parameterized type in which all type arguments are **unbounded** wildcards</span><br><span class="hljs-comment">//是一个参数化类型,但是所有的类型参数都是无界通配符</span><br>B&lt;?&gt; ref;<br><span class="hljs-comment">//raw type</span><br>List ref;<br><span class="hljs-comment">//primitive type</span><br><span class="hljs-keyword">int</span> ref;<br><span class="hljs-comment">//array type,并且元素类型都要求是可靠的</span><br><span class="hljs-keyword">int</span>[] ref;<br><span class="hljs-comment">//嵌套类型,要求类型参数参数都是可靠的</span><br>B&lt;?&gt;.C&lt;?&gt; ref;<br>B&lt;A&gt;.C&lt;A&gt; ref;<br><br></code></pre></div></td></tr></table></figure><p>所以想要数组支持泛型的唯一办法就是:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//本意</span><br>ArrayList&lt;String&gt; ref=<span class="hljs-keyword">new</span> ArrayList&lt;String&gt;[];<span class="hljs-comment">//complie-error</span><br><span class="hljs-comment">//正确写法</span><br>ArrayList&lt;String&gt; ref=(ArrayList&lt;String&gt;[])<span class="hljs-keyword">new</span> ArrayList[];<span class="hljs-comment">//cast</span><br></code></pre></div></td></tr></table></figure><p>注:</p><blockquote><p>上述所有言论基于java1.8,似乎在java10中已经开始支持泛型数组,但并未考证</p></blockquote><hr><p>回到正题,java中的泛型是不变的。如果泛型是协变的,思考如下代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ArrayList&lt;Number&gt; ref=<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><br>ref.add(<span class="hljs-number">2.3f</span>);<span class="hljs-comment">//cast</span><br></code></pre></div></td></tr></table></figure><p>在我们眼里,<code>ref</code>是一个存储<code>Number</code>的容器,那么就可以往里面存储<code>Double</code>、<code>Float</code>、<code>Integer</code>。取元素的时候到底转换成什么类型?程序不知道,程序员也不知道。并且很可能会产生运行时错误。既然这么,干脆就在编译期将这类错误禁止就完事了,但是仍然可以通过一些操作实现协变的逻辑。</p><p>对于泛型不支持逆变,是因为父类的引用赋值给子类就非常危险,所以当然不支持,而且也不可能实现。</p><h3 id="使用协变"><a href="#使用协变" class="headerlink" title="使用协变"></a>使用协变</h3><p>有些时候我们确实需要使用协变这一功能。比如我们有一组类<code>Dog``Cat``Pig</code>,需要对这些类实现一个通用的喂食功能,见如下代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> generic;<br><br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>&#123;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">super</span>.getName()+<span class="hljs-string">&quot; eat shit.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cat</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">super</span>.getName()+<span class="hljs-string">&quot; eat air.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CovariantTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">feed</span><span class="hljs-params">(List&lt;Animal&gt; animalList)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(animalList==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(Animal elem:animalList)&#123;<br>            elem.eat();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;Dog&gt; dogs=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        dogs.add(<span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;peter&quot;</span>));<br>        dogs.add(<span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;tom&quot;</span>));<br><br>        ArrayList&lt;Cat&gt; cats=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        cats.add(<span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;lili&quot;</span>));<br>        cats.add(<span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;candy&quot;</span>));<br>        feed(dogs);<span class="hljs-comment">//complie-error</span><br>        feed(cats);<span class="hljs-comment">//complie-error</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面调用<code>feed</code>的代码是无法通过编译的,因为<code>feed</code>接受的是<code>List&lt;Animal&gt;</code>,而提供的是<code>ArrayList&lt;Dog&gt;</code>,这是因为泛型不支持协变。那么这个需求是确确实实存在的,怎么办?</p><p>这时候通配符<code>?</code>该上场了,泛型的作用是限制泛型的类型,提供类似协变的功能。</p><blockquote><p>通配符?表示我们不知道是什么类型,而不是任意类型!!!</p></blockquote><p>注意这里插一句,带有通配符的类型变量(type variable)叫做<code>wild type</code>(不知道是否官方,但是我看到别人这么叫了,而且这种叫法也不错,我就采用了)。但是通配符<code>?</code>是<strong>没有任何语义</strong>的,它不能代表任何一种类型,仅仅为了定义<code>wild type</code>的一个语法组成部分。所以定义类似<code>ArrayList&lt;?&gt;()</code>的对象就是错的,因为没有任何意义。</p><p>通配符是可以加边界来限制类型变量的类型的,通配符<code>?</code>边界分为以下三种:</p><ul><li>有上界的通配符:例如<code>? super Animal</code>,意思是这个泛型只能是<code>Animal</code>或者<code>Animal</code>的父类</li><li>有下界的通配符:例如<code>? extends Animal</code>,意思是这个泛型只能是<code>Animal</code>或者<code>Animal</code>的子类</li><li>无界的通配符:<code>?</code>,泛型是可以任意类型</li></ul><p>那么为了实现上面的需求,应将<code>feed</code>的签名改正为<code>public static void feed(List&lt;? extends Animal&gt; animalList)</code>,现在编译运行:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">peter eat shit.<br>tom eat shit.<br>lili eat air.<br>candy eat air.<br></code></pre></div></td></tr></table></figure><p>成功实现了我们的需求。</p><h3 id="存下取上原则"><a href="#存下取上原则" class="headerlink" title="存下取上原则"></a>存下取上原则</h3><p>该原则取自<a href="https://www.cnblogs.com/Xieyang-blog/p/9215934.html">Java中泛型区别以及泛型擦除详解</a>。</p><p><strong>A. 上界通配符:</strong><br>但是在使用了泛型通配符的地方,想要对容器增删元素就没有那么简单了。就拿上面的<code>List&lt;? extends Animal&gt; animals</code>做例子。传进来的参数有可能是<code>List&lt;Dog&gt;</code>,也有可能是<code>List&lt;Cat&gt;</code>,假设我们能够向<code>animals</code>中存储新元素,那么当我们取出我们存入的新元素时,它到底是什么类型的?编译器不知道。但是我们读取容器中的内容是没问题的,因为里面的元素至少是一个<code>Animals</code>,使用<code>Animals</code>的引用调用<code>Animals</code>的方法是没有任何问题的。这里就体现了<strong>存下取上</strong>的原则。</p><p>对于上界通配符<code>? extends Animal</code>,泛型的上界是<code>Animal</code>,没有下界,那就是<code>null</code>。所以所谓存下取上就是存储的时候按照泛型下界的类型存储,这里就是<code>null</code>,取出的时候按照泛型上界的类型取出,这里就是<code>Animal</code>。注意有一点原文没有说清楚:</p><blockquote><p>储存的元素类型<strong>至多</strong>是下界类型,取出时的元素类型<strong>至少</strong>是上界类型</p></blockquote><p>下面的图片很好的解释了这个原则:</p><p><img src="images/upper-bound.drawio.svg" alt="upper-bound"></p><p>所以如果容器中,存在有<strong>上界通配符</strong>的泛型:对其写入的元素是很鸡肋的,相当于这个容器是<strong>只读</strong>的。</p><p><strong>B. 下界通配符:</strong></p><p>相应的,上界通配符实现的简单意义上的只写功能。例如<code>List&lt;? super Husky&gt; animals</code>,其中<code>husky</code>是<code>Dog</code>的子类,这里能存入的元素类型至多是<code>Husky</code>类型,没有上界,那么就是<code>Object</code>。</p><p>我们可以在<code>animals</code>中存储任意的<code>animals</code>子类对象(就像<code>List&lt;Dog&gt;</code>中存储的都是<code>Dog</code>类型的引用,但是可以在<code>List</code>中存储任意的<code>Dog</code>子类)。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Husky</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Dog</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Husky</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    List&lt;Dog&gt; list=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    insert(list);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> Dog&gt; set)</span></span>&#123;<br>    <span class="hljs-comment">//成功添加</span><br>    set.add(<span class="hljs-keyword">new</span> Husky(<span class="hljs-string">&quot;husky&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;success&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="images/lower-bound.drawio.svg" alt="lower-bound"></p><p>当然类似的,这里只能读取<code>Object</code>类型的对象,也很鸡肋。</p><p>所以如果容器中存在有下界通配符的泛型,那么该容器在非严格意义上是<strong>只写</strong>的。</p><p>这里的存下取上原则也叫做<code>PECS</code>原则,即<code>producer-extends,consumer super</code>。以容器的视角来说,当容器作为作为生产者,往外提供元素时,就使用<code>extends</code>;当容器作为消费者,需要存储元素时,就使用<code>super</code>。</p><p>在<code>Collections.copy</code>方法中,就是用PESC原则:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//src为生产者,dest为消费者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>注意:<strong>如果</strong>同时有读写的要求呢?</strong></p><blockquote><p>就不需要使用泛型了。</p></blockquote><p><strong>C. 无界通配符:</strong></p><p>对于无界通配符<code>?</code>,它对应的下界为<code>null</code>,对应的上界为<code>Object</code>。</p><h3 id="3-泛型的擦除"><a href="#3-泛型的擦除" class="headerlink" title="3. 泛型的擦除"></a>3. 泛型的擦除</h3><p>在最开始曾说到java的泛型是<strong>伪泛型</strong>,仅仅保持在编译层面。在生成字节码文件时会对泛型擦除,将参数类型(parameterized types)转为原始类型(raw types)。所谓的参数类型就是类似于<code>class Person&lt;T&gt;</code>这种,而将它转换为原始类型就是<code>class Pseron</code>。在这种机制下，java中的多态就比较奇妙了。</p><h4 id="3-1-泛型下的多态"><a href="#3-1-泛型下的多态" class="headerlink" title="3.1 泛型下的多态"></a>3.1 泛型下的多态</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> generic;<br><span class="hljs-comment">//定义泛型类Person</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    T name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(T name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student s=<span class="hljs-keyword">new</span> Student();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Student类继承Person</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>Student</code>类继承了<code>Pseron</code>类,并且指定了父类的类型实参为<code>String</code>。那么父类的定义应该如下所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然而java中的泛型都是假泛型,泛型在编译期被擦除后,因为类型变量<code>T</code>没有上界,所以编译会把T推断为<code>Object</code>类型。所以真正的代码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    Object name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(Object name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>所以按道理,<code>Student</code>类中的<code>String</code>类型也应该变成<code>Object</code>类型,这样一来,不是全乱套了?所以java为了解决这个问题,发明了一种桥方法的机制。</p><p>可以看到,<code>Student</code>类中的<code>getName</code>和<code>setName</code>和<code>Person</code>类中的<code>getName</code>和<code>setName</code>参数类型根本就不一样,所以这根本就不是重载。但是代码又可以编译通过并且实现多态的特性。奇怪的事情发生了。我们看看<code>Studnet</code>编译后的字节码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// access flags 0x1</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span>Ljava/lang/String</span>;<br>   L0<br>    LINENUMBER <span class="hljs-number">22</span> L0<br>    ALOAD <span class="hljs-number">0</span><br>    GETFIELD generic/Student.stuName : Ljava/lang/String;<br>    ARETURN<br>   L1<br>    LOCALVARIABLE <span class="hljs-keyword">this</span> Lgeneric/Student; L0 L1 <span class="hljs-number">0</span><br>    MAXSTACK = <span class="hljs-number">1</span><br>    MAXLOCALS = <span class="hljs-number">1</span><br><br>  <span class="hljs-comment">// access flags 0x1</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">setName</span><span class="hljs-params">(Ljava/lang/String;)</span>V</span><br><span class="hljs-function">   L0</span><br><span class="hljs-function">    LINENUMBER 27 L0</span><br><span class="hljs-function">    ALOAD 0</span><br><span class="hljs-function">    ALOAD 1</span><br><span class="hljs-function">    PUTFIELD generic/Student.stuName : Ljava/lang/String</span>;<br>   L1<br>    LINENUMBER <span class="hljs-number">28</span> L1<br>    RETURN<br>   L2<br>    LOCALVARIABLE <span class="hljs-keyword">this</span> Lgeneric/Student; L0 L2 <span class="hljs-number">0</span><br>    LOCALVARIABLE name Ljava/lang/String; L0 L2 <span class="hljs-number">1</span><br>    MAXSTACK = <span class="hljs-number">2</span><br>    MAXLOCALS = <span class="hljs-number">2</span><br><br>  <span class="hljs-comment">// access flags 0x1041</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> synthetic bridge <span class="hljs-title">setName</span><span class="hljs-params">(Ljava/lang/Object;)</span>V</span><br><span class="hljs-function">   L0</span><br><span class="hljs-function">    LINENUMBER 18 L0</span><br><span class="hljs-function">    ALOAD 0</span><br><span class="hljs-function">    ALOAD 1</span><br><span class="hljs-function">    CHECKCAST java/lang/String</span><br><span class="hljs-function">    INVOKEVIRTUAL generic/Student.<span class="hljs-title">setName</span> <span class="hljs-params">(Ljava/lang/String;)</span>V</span><br><span class="hljs-function">    RETURN</span><br><span class="hljs-function">   L1</span><br><span class="hljs-function">    LOCALVARIABLE <span class="hljs-keyword">this</span> Lgeneric/Student</span>; L0 L1 <span class="hljs-number">0</span><br>    MAXSTACK = <span class="hljs-number">2</span><br>    MAXLOCALS = <span class="hljs-number">2</span><br><br>  <span class="hljs-comment">// access flags 0x1041</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> synthetic bridge <span class="hljs-title">getName</span><span class="hljs-params">()</span>Ljava/lang/Object</span>;<br>   L0<br>    LINENUMBER <span class="hljs-number">18</span> L0<br>    ALOAD <span class="hljs-number">0</span><br>    INVOKEVIRTUAL generic/Student.getName ()Ljava/lang/String;<br>    ARETURN<br>   L1<br>    LOCALVARIABLE <span class="hljs-keyword">this</span> Lgeneric/Student; L0 L1 <span class="hljs-number">0</span><br>    MAXSTACK = <span class="hljs-number">1</span><br>    MAXLOCALS = <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>有两个<code>setName</code>,两个<code>getName</code>可以看到其中有一组<code>setName</code>和<code>getName</code>前面有修饰符<code>synthetic</code>和<code>bridge</code>。<code>synthetic</code>表示这是系统自动生成的,而<code>bridge</code>表示这是一个桥方法。</p><p>所以其实桥方法才真正是<code>override</code>了<code>Person</code>类中的两个方法。而桥方法又去调用了我们自定义的<code>setName</code>与<code>getName</code>完成了多态。</p><h4 id="3-2-泛型下的继承"><a href="#3-2-泛型下的继承" class="headerlink" title="3.2 泛型下的继承"></a>3.2 泛型下的继承</h4><p>普通的继承关系并没有类型的困扰。但是一旦给类上了泛型,那么就有点复杂了。大体分为四种情况:</p><ol><li>子类直接指定了父类的类型参数</li><li>子类继承了父类的类型参数</li><li>父类擦除了类型参数,子类没有擦除</li><li>子类与父类都擦出了类型参数</li></ol><p>下面我们一一解释以下,还是以上面的<code>Person</code>类作为例子:</p><p><strong>子类直接制定了父类的类型参数</strong>:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    E name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(E name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这种情况,父类的类型参数已经被制定了,所以子类中从父类继承而来的东西也是被指定的类型,例如<code>String</code>。如果子类新加了类型参数<code>T</code>,那么这个<code>T</code>和父类没有任何关系。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;<br>    T age;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>子类继承了父类的类型参数</strong>:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>    T age;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(E name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么在子类中从父类继承而来的东西,类型还是<code>E</code>,类型参数<code>T</code>与父类没有任何关系。</p><p><strong>父类进行了泛型擦除而子类没有:</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    T age;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(Object name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这个例子中,由于<code>Person</code>类中的类型参数<code>E</code>没有上限,因为编译器只能把<code>E</code>推断为Object最为安全。如果类型参数<code>E</code>有上限,例如<code>E extends Number</code>,那么编译器就会将<code>E</code>推断为<code>Number</code>。上面代码中的<code>Object</code>就会全部换成<code>Number</code>了。</p><p><strong>子类与父类都进行了泛型擦除:</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>     age;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(E name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>子类与父类都进行了擦除这么说并不准确,因为根本就没有定义子类的类型参数…规则和父类擦除而子类不擦除的规则一样。要看父类的类型参数有没有上限,因为编译器的推断类型是不一样的。</p><p><strong>那么为什么不能父类不擦除,而子类不擦除呢？</strong></p><p>因为继承泛型类时,子类必须对父类中的类型参数进行初始化,当然父类擦除或者由子类指定都可以。所以子类擦除而父类不擦除,父类中的类型参数由谁来初始化?</p><h4 id="3-3-泛型下的类型获取"><a href="#3-3-泛型下的类型获取" class="headerlink" title="3.3 泛型下的类型获取"></a>3.3 泛型下的类型获取</h4><p>上面曾说到，Java中的泛型是伪泛型，在编译时会被擦除为<code>Object</code>类型的，但是为什么又能够在运行时获取的泛型的真实类型呢？</p><p>首先我们需要知道一个逻辑：<strong>泛型擦除并不代表JVM不知道类型信息</strong>。对于泛型类，JVM可以从Class文件中的<code>Signature</code>属性来获取泛型类的<strong>声明</strong>类型，而不是实际类型。假设有代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">action</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    T a;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T a)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.a=a;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    action&lt;Integer&gt; test=<span class="hljs-keyword">new</span> action&lt;&gt;();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在运行时我们可以获取引用<code>test</code>中的泛型类型，而不能获得<code>test.a</code>的泛型类。因为<code>test.a</code>在运行时会被泛化为<code>object</code>类型，无法通过class文件获取类型。但是对于<code>test</code>来说，因为在编译的时候编译器会将<code>test</code>泛型的声明类型作为<code>Signature</code>属性保存在<code>action</code>类的class文件中，所以我们可以通过<code>action.class</code>获取它的泛型声明类型。</p><p><strong>参考文献</strong></p><ol><li><a href="https://www.itzhai.com/articles/exploring-the-nature-of-java-generics.html">深入探索Java泛型的本质 | 泛型</a></li><li><a href="https://www.zhihu.com/question/346911525">Java中的泛型会被类型擦除，那为什么在运行期仍然可以使用反射获取到具体的泛型类型？</a></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://zhuanlan.zhihu.com/p/31137677">仔细说说Java中的泛型</a></p></li><li><p><a href="https://www.cnblogs.com/wuqinglong/p/9456193.html">Java泛型类型擦除以及类型擦除带来的问题</a></p></li><li><p><a href="https://developer.aliyun.com/article/313280">java泛型学习（2）</a></p></li><li><p><a href="https://segmentfault.com/q/1010000007925818">java 如何继承泛型</a></p></li><li><p><a href="https://blog.csdn.net/ShierJun/article/details/51253870">泛型继承的几种写法</a></p></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E5%8F%8D%E5%B0%84/">反射</category>
      
      
      <category domain="https://eripe.me/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">基本概念</category>
      
      <category domain="https://eripe.me/tags/%E6%B3%9B%E5%9E%8B/">泛型</category>
      
      
      <comments>https://eripe.me/articles/the-generic-of-java.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>类的加载机制</title>
      <link>https://eripe.me/articles/class-loading-mechanism.html</link>
      <guid>https://eripe.me/articles/class-loading-mechanism.html</guid>
      <pubDate>Mon, 14 Jun 2021 11:50:07 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;1-类初始化的时机&quot;&gt;&lt;a href=&quot;#1-类初始化的时机&quot; class=&quot;headerlink&quot; title=&quot;1. 类初始化的时机&quot;&gt;&lt;/a&gt;1.</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="1-类初始化的时机"><a href="#1-类初始化的时机" class="headerlink" title="1. 类初始化的时机"></a>1. 类初始化的时机</h1><p>当复习类加载时机时，我给自己抛出了一个问题：这里的时机只说明了<strong>类</strong>的初始化，那么对于接口呢？接口什么时候会被初始化呢？</p><p>仔细回顾《深入理解Java虚拟机》，才发现，作者给出的是会触发<strong>类型</strong>初始化的六种时机，而不是<strong>类</strong>初始化。这里类型可能是指类或者接口。ok，那么我的问题迎刃而解了。接口初始化的时机同样遵循以下六种场景。</p><hr><p>在Java中，只有主动引用才会触发<del>类</del>类型加载动作。所谓的主动引用指<strong>只</strong>包括以下六种情况（除了下面这六种情况，其余的引用都称为被动引用）：</p><ol><li>遇到new、getstatic、setstatic或者invokestatic这4个字节码指令时，如果<strong>类型</strong>没有进行过初始化，那么需要先触发其初始化阶段。对应的java代码场景为：<ul><li>new一个关键字或者一个实例化对象时</li><li>读取或设置一个<strong>类型</strong>的静态字段时(final修饰、已在编译期把结果放入常量池的除外)</li><li>调用一个<strong>类行</strong>的静态方法时</li></ul></li><li>使用java.lang.reflect包的方法对<strong>类型</strong>进行反射调用的时候，如果类型没进行初始化，需要先触发其初始化。</li><li>当初始化一个<strong>类</strong>时，如果其父类还未进行初始化，会先触发其父类的初始化；当一个接口在初始化时。并不要求其父接口全部完成了初始化。只有真正使用到了父接口时（例如使用接口中定义的常量）才会对父接口进行初始化</li><li>当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的类)，虚拟机会先初始化这个类。</li><li>当使用JDK 1.7等动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li><li>当一个接口定义了JDK8新加入的默认方法时，如果这个接口的实现类发生了初始化，那么接口需要在其之前被初始化</li></ol><p><strong>注意：</strong><br>对于静态字段或者静态方法，只会对定义了这些内容的类执行类加载动作。我们通过下面的代码来理解这句话的真正含义：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">staticTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       subTest.m1();<br>    <span class="hljs-comment">// System.out.println(subTest.a);</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">subTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;load subclass subTest&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;load class Test&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;method m1&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>执行结果为：</p><blockquote><p>load class Test<br>method m1</p></blockquote><p>虽然通过子类名称调用父类的静态方法，但是jvm仍然只会加载真正定义了静态方法<code>m1</code>的类<code>Test</code>。这是一个特殊情况。</p><hr><p>update：2021-01-18 00:27:01</p><p>我又给自己提出了一个问题：当一个类被初始化时，它实现的接口是什么时候被加载的？这种情况不符合上面所述的六种场景啊。</p><p>经过我的思考，我发现我进入了一个误区。上面所述的六种场景只是声明类或接口被初始化的时机，而不是加载的时机。</p><p>初始化一定要求类或者接口被加载，但是反之则不一定，加载了类或接口，不一定需要初始化。所以我猜测，当是一个实现类在解析接口引用时，只是加载了接口，而没有初始化接口。不然类怎么实现验证步骤？</p><h1 id="2-类加载的七个步骤"><a href="#2-类加载的七个步骤" class="headerlink" title="2. 类加载的七个步骤"></a>2. 类加载的七个步骤</h1><p>将类的Class文件加载至jvm中一般会经历七个步骤：加载、验证、准备、解析、初始化、使用、卸载。但是注意：<strong>这七个步骤并不是完全串行的</strong>。有可能在一个步骤的执行中开启另外一个步骤，而不是等待当前步骤执行完毕。</p><p>并且其中的验证、准备、解析合在一起叫做“连接”。这不就是cpp编译过程的符号链接的步骤嘛，搞的这么花里胡哨的。</p><p>并且其中的初始化是指类的初始化，而不是对象的初始化。类的初始化是指：</p><ul><li>静态字段的初始化</li><li>静态代码的执行</li></ul><p>并且类的初始化只会在类加载的时候执行一次。下面我们就来看看这七个步骤。</p><h2 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1 加载"></a>2.1 加载</h2><p>这个加载是指整个类加载过程中的第一个步骤，而且是整个类加载过程中我们可以实实在在用代码控制的部分。该步骤分为三小步：</p><ol><li>通过类的全限定名获取类的二进制字节流</li><li>将二进制字节流表示的静态存储结构转化<strong>方法区</strong>为运行时存储结构</li><li>生成Class对象，作为方法区各种类型数据的访问接口</li></ol><p>其中通过类的权限名获取类的二进制字节流就是我们能够控制的部分，虚拟机规范只规定了我们要获取字节流，而没有规定从哪里获取字节流。可以从Class文件中获取、静态的jar包中获取、网络中获取，或者动态的在内存中生成，也就是所谓的动态代理技术，这完全都可以自定义实现。<strong>并且获取字节流这个动作就是通过我们自定义的类加载器来实现。</strong></p><p>但是有一个特殊情况，就是数组类的加载不是我们可以控制的，但是数组中的元素类却又是我们可以控制的。因为<strong>数组类的并不是由类加载器加载，而是由jvm在内存中直接构造的。</strong></p><hr><p>这里的数组类可以看作数组的wrapper，即数组的包装类，由jvm动态生成，数组类提供了一些数组的属性，并且数组的访问也通过该类实现。</p><blockquote><p>java访问数组的安全性比c++高很大程度是因为该类包装了数组的访问操作。</p></blockquote><hr><h3 id="2-1-1-数组类的加载机制"><a href="#2-1-1-数组类的加载机制" class="headerlink" title="2.1.1 数组类的加载机制"></a>2.1.1 数组类的加载机制</h3><ul><li>如果数组的组件类型(即数组去掉一个维度，例如int[4][3],实际的组件类型为int[3],因为二维数组可以看作元素类型是一维数组的一维数组)。那么就递归的采用类加载过程去加载这个组件类型。是类就用类的加载过程，是数组类就用数组类的加载过程。并且该数组会被标识在加载该组件类型的类加载器的类名称空间上，因为这样才能唯一的确定一个类</li><li>如果数组的组件类型不是引用类型，那么该数组会被标识在启动类加载器的类名称空间上</li><li>数组类的可访问性和它组件类型的可访问性一致，如果组件类型不是引用类型，那么数组类的可访问性默认为public</li></ul><h3 id="2-1-2-生成Class对象"><a href="#2-1-2-生成Class对象" class="headerlink" title="2.1.2 生成Class对象"></a>2.1.2 生成Class对象</h3><p>在获得类文件的二进制的字节流后，会被转化为方法区的动态存储结构，这个结构是怎么样的并没有强制规定。但是在转化完成后，会在<strong>堆区</strong>实例化一个代表当前类的Class对象。作为方法区存储结构中的数据的访问接口。</p><p><strong>加载阶段和连接阶段是交叉进行的。</strong></p><h2 id="2-2-验证"><a href="#2-2-验证" class="headerlink" title="2.2 验证"></a>2.2 验证</h2><p>验证显而易见就是验证获取的二进制字节流是否安全，符合虚拟机规范。<strong>因为Class不一定是通过编译生成的</strong>，也确实可以直接在二进制层面拼接。<strong>那么在生成Class对象前不是应该先完成验证步骤？</strong></p><p>验证主要验证四个部分：</p><ol><li>文件格式的验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ol><h3 id="2-2-1-文件格式验证"><a href="#2-2-1-文件格式验证" class="headerlink" title="2.2.1 文件格式验证"></a>2.2.1 文件格式验证</h3><p>文件格式的验证就是验证我们在加载阶段获取到的二进制字节流是否符合<strong>Class文件格式</strong>的规范，只有完成这一步验证，字节流才会转化为方法区的存储结构，并且后续的三个验证步骤是基于方法区的存储结构，而不会直接操作二进制流了。</p><h3 id="2-2-2-元数据验证"><a href="#2-2-2-元数据验证" class="headerlink" title="2.2.2 元数据验证"></a>2.2.2 元数据验证</h3><p>元数据验证是验证方法区存储的字节码是否《java语言规范》的语法要求。所谓的语义包括是否继承了final修饰的类、是否修改了final修饰的字段等等。即验证是否符合java的语法。</p><h3 id="2-2-3-字节码验证"><a href="#2-2-3-字节码验证" class="headerlink" title="2.2.3 字节码验证"></a>2.2.3 字节码验证</h3><p><strong>字节码验证主要是验证代码的语义正确性。</strong>例如将父类对象赋值给子类引用（语法验证会通过，但可能会产生运行时问题）。如果代码没有通过字节码验证，说明代码肯定有错误，但反之则不一定，即使通过了验证，也不能说代码完全正确，有可能产生间接的语义错误。</p><p>但是计算代码是否有语义错误显而易见是一项庞大的工程，放到代码运行之前验证不太好。所以在JDK6之后，java团队将验证语义的操作大部分都转移到了编译期间。编译器会在编译时为代码属性添加<code>StackMapTable</code>属性，这一属性描述了代码是否有语义错误。在字节码验证阶段jvm只需要验证该属性是否符合规范。当然，这并不能做到十全十美。</p><h3 id="2-2-4-符号引用验证"><a href="#2-2-4-符号引用验证" class="headerlink" title="2.2.4 符号引用验证"></a>2.2.4 符号引用验证</h3><p>符号引用验证的目的是为了保证<strong>解析阶段</strong>正常进行。会进行权限检查</p><h3 id="2-2-5-小结"><a href="#2-2-5-小结" class="headerlink" title="2.2.5 小结"></a>2.2.5 小结</h3><p>验证阶段可有可无，并不是强制的，只要能够保证代码是正确的，那么也可以关闭大部分类的验证措施来加速类的加载。</p><h2 id="2-3-准备"><a href="#2-3-准备" class="headerlink" title="2.3 准备"></a>2.3 准备</h2><p>准备阶段是为类的静态变量(而不是实例变量，实例变量会在对象实例化时分配空间)分配内存空间，以及赋予静态变量默认的初值，这里的初值指的是int的默认为0、boolean的默认为false之类的默认值。例如:</p><blockquote><p>public static int value=123;</p></blockquote><p>在准备阶段，value的值为默认值，即为0。在初始化阶段才会被赋值为123。</p><p><strong>无论代码中有没有对静态变量的赋值的操作，都会对变量进行初始化操作，至于赋值的步骤，会在初始化阶段完成!!!</strong></p><p>注意：准备阶段只为静态变量做准备。</p><h2 id="2-4-解析"><a href="#2-4-解析" class="headerlink" title="2.4 解析"></a>2.4 解析</h2><p>解析肯定就是符号的链接过程咯。准备来说就是将常量池中的符号引用替换为直接引用。例如Class文件中的<code>CONSTANT_Class_info</code>、<code>CONSTANT_Fieldref_info</code>、<code>CONSTANT_Method_info</code>等符号引用，存储形式都是常量。</p><blockquote><p>解析过程是把符号链接到正确的内存地址，符号引用变为直接引用，而不是确定符号，后者是编译期做的事，<del>解析这件事已经属于运行期了</del>。准确来说，解析并不是运行期，因为解析阶段还没有真正的开始执行字节码，我的理解时<strong>执行字节码才叫做真正的运行期</strong>。</p></blockquote><p>在解析阶段解析符号的过程被称为<strong>静态解析</strong>，当然能够被静态解析的符号类型有限：</p><ul><li>类或接口</li><li>字段</li><li>一部分方法</li><li>接口方法</li></ul><p>关于方法的解析比较复杂，后文单独开一章进行讲解。</p><h3 id="2-4-1-类或接口的解析"><a href="#2-4-1-类或接口的解析" class="headerlink" title="2.4.1 类或接口的解析"></a>2.4.1 类或接口的解析</h3><p>类或接口的解析有一个核心规则：</p><p>如果当前代码所处的类为D，如果想要把D中一个从未解析过的符号引用N解析为类或接口C，那么则有：</p><ol><li><p>如果c不是一个数组类型，那么会使用<strong>D的类加载器</strong>加载c，其中会将c的全限定名传递给D的类加载器。如果其中又需要加载其他类，那么重复整个解析程序</p></li><li><p>如果c是一个数组类型，并且数组元素是对象类型，那么会重复第一步，<strong>并且由虚拟机生成该数组</strong></p></li><li><p>如果上面两步没有出现问题，那么会检查符号引用的权限，确认D对C具有访问，否则会抛出异常</p></li></ol><h3 id="2-4-2-字段的解析"><a href="#2-4-2-字段的解析" class="headerlink" title="2.4.2 字段的解析"></a>2.4.2 字段的解析</h3><p>首先我们需要找到字段所属的类或接口C，然后：</p><ol><li><p>如果在c中找到了简单名称和描述符都与目标相符的字段，那么会返回字段的直接引用</p></li><li><p>在c实现的接口中，从下往上查找目标</p></li><li><p>在c继承的父类中，从下往上查找目标</p></li><li><p>如果成功获得了直接引用，还会检查是否对目标字段具有访问权限</p></li></ol><p>如果在c的父类或接口中实现了相同字段，虽然按照规则可以成功找到目标字段，但是编译器为了安全，还是会选择拒绝编译。</p><blockquote><p>字段会在解析阶段完全解析好，因为符号引用在编译时期就确定了</p></blockquote><h3 id="2-4-3-接口方法的解析"><a href="#2-4-3-接口方法的解析" class="headerlink" title="2.4.3 接口方法的解析"></a>2.4.3 接口方法的解析</h3><p>首先在接口方法表中解析出当前方法所属的类或接口c，然后：</p><ol><li><p>如果c是一个类，那么抛出IncompatibleClassChangeError</p></li><li><p>否则在接口c中查看目标方法，如果成功，则返回直接引用</p></li><li><p>否则在c继承的接口中查找目标方法，这一步骤有一点值得注意：会一直向上递归查找，直到对java.lang.Object查找完毕，因为接口方法的查找范围<strong>包括Object类中的方法。</strong></p></li><li><p>对查找的直接引用进行权限检查在JDK9之后，因为JDK9之后引入了模块化系统。</p></li></ol><p>如果在继承的多个父接口中查找到了多个目标方法，虽然虚拟机规范规定随意返回一个即可。</p><h2 id="2-5-初始化"><a href="#2-5-初始化" class="headerlink" title="2.5 初始化"></a>2.5 初始化</h2><p>这里的初始化是指对类进行初始化，并且这一阶段可以通过程序控制。</p><p>初始化阶段就是执行类构造器<code>&lt;cinit&gt;()</code>方法的过程。这一方法通过编译器自动生成，生成规则如下：</p><ol><li><p>收集类中所有类变量的赋值动作和静态代码块的语句按<strong>顺序</strong>而合成，如果没有静态变量<strong>赋值</strong>语句和静态代码块，那么并不会生成<code>&lt;cinit&gt;()</code></p></li><li><p>静态代码块只能访问定义在块之前的静态变量，对于块之后定义的静态变量，静态代码块只能赋值，不能访问</p></li><li><p>虚拟机会保证父类的类构造器<code>&lt;cinit&gt;()</code>一定会在子类的<code>&lt;cinit&gt;()</code>执行之前执行，这与实例构造器<code>&lt;init&gt;()</code>一样，会保证父类的实例构造器先于子类执行，并且JVM保证在多线程环境下<code>&lt;cinit&gt;()</code>只会被执行一次</p></li></ol><p>这里怎么保证呢？就是虽然<code>super</code>是在是在子类构造器中调用的，但是<code>super</code>实际是在调用父类的<code>&lt;init&gt;</code>，而子类的<code>&lt;init&gt;</code>根本还没有开始执行，这样保证了父类的<code>&lt;init&gt;</code>一定会在子类的<code>&lt;init&gt;</code>之前完成，例如在下面的代码中：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FieldHashNoPolymorphic</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> money = <span class="hljs-number">1</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Father</span><span class="hljs-params">()</span> </span>&#123;<br>            ...<br>            showMeTheMoney();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMeTheMoney</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am Father, I have $&quot;</span> + money);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> money = <span class="hljs-number">3</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Son</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">//虽然super在Son的构造方法中，但是实际上Son的&lt;init&gt;还没有开始执行</span><br>            <span class="hljs-keyword">super</span>();<br>            ...<br>            showMeTheMoney();<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMeTheMoney</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am Son, I have $&quot;</span> + <span class="hljs-keyword">this</span>.money);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Father guy = <span class="hljs-keyword">new</span> Son();<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在执行<code>super</code>的时候，<code>Son</code>类的<code>&lt;init&gt;</code>方法还没有开始调用，所以<code>Son</code>类的<code>money</code>字段仍然为0。那么<code>&lt;init&gt;</code>由哪些部分组成呢？与<code>&lt;cinit&gt;</code>类似，也是由三部分组成：</p><ol><li>成员变量显式赋值代码</li><li>非静态代码块中的代码</li><li>构造器中的代码</li></ol><p>其中1、2部分按照出现的顺序排列，3永远排在最后执行。</p><h3 id="2-5-1-接口的初始化"><a href="#2-5-1-接口的初始化" class="headerlink" title="2.5.1 接口的初始化"></a>2.5.1 接口的初始化</h3><p>对于接口来说，并没有强制要求父接口的<code>&lt;cinit&gt;()</code>一定要在子接口<code>&lt;cinit&gt;()</code>之前执行。只有当父接口中定义的变量被使用时，才会执行父接口的<code>&lt;cinit&gt;()</code>方法。并且接口的实现类初始化时也不会执行接口的<code>&lt;cinit&gt;()</code>方法。</p><h1 id="3-类方法的解析"><a href="#3-类方法的解析" class="headerlink" title="3. 类方法的解析"></a>3. 类方法的解析</h1><p>方法的总体来说可以分为两个部分：</p><ul><li>能够在解析阶段完成解析的方法</li><li>只能在运行时完成解析的方法</li></ul><p>那么如何区分它们呢？这与具体的方法调用的字节码指令有关，在java中，有五条字节码与方法调用有关：</p><ul><li>invokestatic:调用静态方法</li><li>invokespecial：用于调用特殊的实例方法，包括实例初始化方法（<init>()方法）、私有方法、父类方法（<strong>最近的一个父类</strong>）</li><li>invokevirtual：用于调用对象的实例方法</li><li>invokeinferface：用于调用接口方法</li><li>invokedynamic：用于运行时动态解析出调用点限定符所引用的方法</li></ul><p>我们可以根据这五条调用方法的指令来判定当前方法能否在类加载过程中的解析阶段完成符号链接。值得注意的是<strong>前四条的方法调用逻辑</strong>是完全固化在虚拟机内的，而最后一条指令的调用指派完全由程序员指定。</p><h2 id="3-1-类加载阶段的方法符号解析"><a href="#3-1-类加载阶段的方法符号解析" class="headerlink" title="3.1 类加载阶段的方法符号解析"></a>3.1 类加载阶段的方法符号解析</h2><p>只要是通过<code>invokestatic</code>、<code>incokespecial</code>调用的或者被<code>final</code>修饰的方法，就能在类加载阶段中的解析步骤时将符号引用转换为目标方法的直接引用。总计分为五种方法：</p><ul><li>静态方法</li><li>对象的构造方法</li><li>私有方法</li><li>父类方法</li><li>被<code>final</code>修饰的方法</li></ul><p>上述五类方法被称为“非虚方法”，调用的方法的符号引用在编译器就已经完全确定，这类方法的调用称为<strong>解析</strong>。其他的所有方法都为“虚方法”，java中默认方法都是虚方法。</p><h2 id="3-2-运行时的方法符号解析"><a href="#3-2-运行时的方法符号解析" class="headerlink" title="3.2 运行时的方法符号解析"></a>3.2 运行时的方法符号解析</h2><p>除了在3.1小节指出的非虚方法外，其余的方法会在第一次调用时进行链接。这类方法的符号解析有一个特殊的名字，称为<strong>分派</strong>。顾名思义，分派肯定是从多个候选者选择一个。我认为这是与解析最大的不同，因为解析调用的候选方法只有一个。</p><p>分派又可分为静态分派和动态分派。</p><h3 id="3-2-1-静态分派"><a href="#3-2-1-静态分派" class="headerlink" title="3.2.1 静态分派"></a>3.2.1 静态分派</h3><p>所谓的静态分派和上述非虚方法的解析并没有太大差别，都是在编译期确定目标方法的符号引用。值得注意的是：在重载环境下，编译器依赖方法参数的静态类型选择合适的版本。这也侧面说明了重载时只有参数不同才算重载。</p><p>这类依赖静态类型来决定目标方法版本的操作称为静态解析，因为候选者有多个！<strong>静态解析的结果由编译器决定而不是虚拟机。</strong></p><h3 id="3-2-2-动态分派"><a href="#3-2-2-动态分派" class="headerlink" title="3.2.2 动态分派"></a>3.2.2 动态分派</h3><p>静态分派是靠编译器实现的，动态分派是靠<code>invokevirtual</code>执行实现的，<code>invokevirtual</code>的执行步骤如下：</p><ol><li>找到操作数栈顶第一个元素指向的对象的实际类型C</li><li>在类C中查找是否存在描述符和简单名称都符合预期目标的方法，如果存在，那么结束查找</li><li>否则在类C的各个父类中进行查找，直到无法找到抛出异常</li></ol><p>这类依赖变量动态类型来决定调用的方法版本称为动态分派。值得注意的是：字段永远不存在多态，只会存在覆盖的概念。查询字段只会在最近的范围内查找。下面的代码很好地解释了动态分派与同名字段覆盖：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FieldHashNoPolymorphic</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> money = <span class="hljs-number">1</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Father</span><span class="hljs-params">()</span> </span>&#123;<br>            money = <span class="hljs-number">2</span>;<br>            System.out.println(<span class="hljs-keyword">this</span>.money+<span class="hljs-string">&quot;---&quot;</span>+<span class="hljs-keyword">this</span>);<br>            showMeTheMoney();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMeTheMoney</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am Father, I have $&quot;</span> + money);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> money = <span class="hljs-number">3</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Son</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//这个this实际上是不能被传递的，这里只是示意</span><br>            System.out.println(<span class="hljs-keyword">this</span>);<br>            money = <span class="hljs-number">4</span>;<br>            showMeTheMoney();<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMeTheMoney</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am Son, I have $&quot;</span> + money);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Father guy = <span class="hljs-keyword">new</span> Son();<br>        <span class="hljs-comment">// 通过静态类型访问到了父类中的money，输出2</span><br>        System.out.println(<span class="hljs-string">&quot;This guy has $&quot;</span> + guy.money);<br>        <span class="hljs-comment">// 将静态类型强转成Son，访问的就是子类中的money，输出4</span><br>        System.out.println(<span class="hljs-string">&quot;This guy has $&quot;</span> + ((Son) guy).money);<br>    &#125;<br>&#125;<br># 输出如下<br><span class="hljs-number">2</span>---jvm.FieldHashNoPolymorphic$Son@6ed3ef1<br>I am Son, I have $<span class="hljs-number">0</span><br>jvm.FieldHashNoPolymorphic$Son@6ed3ef1<br>I am Son, I have $<span class="hljs-number">4</span><br>This guy has $<span class="hljs-number">2</span><br>This guy has $<span class="hljs-number">4</span><br><br></code></pre></div></td></tr></table></figure><p>在第一次执行中，为什么会调用<code>Son</code>类的<code>showTheMoney()</code>?因为在调用方法时，会将方法接收者（也就是caller）的引用传递进去，调用父类构造函数的代码是<code>super(this)</code>，这里的<code>this</code>代表<code>Son</code>类的对象。所以在执行下面代码时：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Father</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.money = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">this</span>.showMeTheMoney();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>虽然这里的<code>this</code>指向的是子类<code>Son</code>对象，但是我们想想，<code>Son</code>对象肯定会包含了父类<code>Father</code>的数据啊，所以这两个<code>this</code>显示地是同一个地址没毛病。</p><p>但是<code>sout(this.money)==2</code>就说明这里使用的<code>money</code>属性是父类的，因为代码执行处离父类<code>Father</code>最近。而显示的<code>I am Son, I have $0</code>就说明此时使用的是子类<code>Son</code>的<code>money</code>属性，因为此时代码执行处处离<code>Son</code>最近。值为0是因为此时子类<code>Son</code>的<code>money</code>属性还没有初始化，因为父类的构造函数还未执行完毕。</p><p>虽然在Son类型的对象中，内存中会存在两个<code>money</code>,但是Son对象只会使用离他最近的一个，也就是自身类中的<code>money</code>属性，子类的属性会隐藏父类的同名属性。</p><h3 id="3-2-3-单分派与多分派"><a href="#3-2-3-单分派与多分派" class="headerlink" title="3.2.3 单分派与多分派"></a>3.2.3 单分派与多分派</h3><p>决定单分派与多分派的标准是使用的宗量数量。宗量分为两大类：方法的接受者（caller）与方法的参数。采用《深入理解java虚拟机》中的例子作为解释：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dispatch</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QQ</span></span>&#123;&#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_360</span></span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hardChoice</span><span class="hljs-params">(QQ arg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;father choose qq&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hardChoice</span><span class="hljs-params">(_360 arg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;father choose 360&quot;</span>);<br>    &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hardChoice</span><span class="hljs-params">(QQ arg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;son choose qq&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hardChoice</span><span class="hljs-params">(_360 arg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;son chooes 360&quot;</span>);<br>    &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Father father = <span class="hljs-keyword">new</span> Father();<br>    Father son = <span class="hljs-keyword">new</span> Son();<br><br>    father.hardChoice(<span class="hljs-keyword">new</span> _360());<span class="hljs-comment">//father choose 360</span><br>    son.hardChoice(<span class="hljs-keyword">new</span> QQ());<span class="hljs-comment">//son choose qq</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于<code>fahter.hardChoice(new _360())</code>,在编译时期编译器确定调用符号时，可以看出候选者非常多（候选者有哪些，需要列出来）。那么在调用<code>father.hardChoice</code>时发现方法的接收者的静态类型这是<code>Father</code>,这就决定了在<code>Father</code>类中选择。那么接着查看调用方法的参数，发现实参的静态类型为<code>360</code>,那么通过方法调用者和函数实参这两个标准在编译器确定了符号调用，这就代表使用了两个宗量。同理编译<code>son.hardChoice(new QQ())</code>时也会使用两个宗量确定符号引用。</p><p>上述确定的两个符号引用会使用<code>invokevirtual</code>调用。那么在运行时,因为已经在编译器确定了方法签名，但是候选者仍然有两个：</p><ul><li>Father::hardChoice(_360 arg)</li><li>Son::hardChoice(_360 arg)</li></ul><p>因为上述的两个函数调用实际会使用<code>invokeVirtual</code>执行，所以在运行时虚拟机会从上述的两个候选者中选择一个。以<code>father.hardChoice(new _360())</code>为例，方法接收者<code>father</code>的实际类型为<code>Son</code>，所以虚拟机会选择<code>Son</code>类中的方法。可以看出在抉择过程中只用了“方法调用者”这一个参考因素。</p><p>所以到目前为止，<strong>java是一个静态多分派、动态单分派的语言</strong>。那么时候才会进入分派的阶段，也就是使用<code>virtualinvoke</code>指定？</p><p>我认为答案是调用非虚方法时，会进入分派阶段。</p><hr><p><strong>Extension: invokevirtual的执行过程</strong></p><ol><li><code>invokevirtual</code>首先会找到操作数栈的栈顶第一个元素所指向的对象的实际类型，记为C；</li><li>在C自身中进行查找符号和描述相符的方法，如果找到，则需要检查权限</li><li>如果在C自身中未找到，那么会按照继承关系<strong>自下而上</strong>在C的父类中进行查找，如果找到则需要进行权限检查</li><li>如果都为找到，则会抛出<code>AbstractMethodError</code>异常</li></ol><hr><h3 id="3-2-4-分派的具体实现"><a href="#3-2-4-分派的具体实现" class="headerlink" title="3.2.4 分派的具体实现"></a>3.2.4 分派的具体实现</h3><p>在每次调用时才去执行分派效率必定低下，所以jvm选择以虚表(virtual method table)的形式实现分派的过程。虚表和cpp中的虚表概念差不多。这个虚表建立在方法区。对于子类来说，如果没有重写父类的方法，那么子类的虚方法表中，没有被重写的方法的指针和父类同一方法的指针指向同一个函数。</p><blockquote><p>虚表会在类加载阶段完成初始化，在完成连接阶段中的初始化过程后，会完成该类的虚表初始化</p></blockquote><h1 id="4-小测试"><a href="#4-小测试" class="headerlink" title="4. 小测试"></a>4. 小测试</h1><p>根据类加载的规则，下面的代码输出到底是多少？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleTon</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingleTon singleTon = <span class="hljs-keyword">new</span> SingleTon();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count1;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count2 = <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingleTon</span><span class="hljs-params">()</span> </span>&#123;<br>        count1++;<br>        count2++;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleTon <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> singleTon;<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SingleTon singleTon = SingleTon.getInstance();<br>        System.out.println(<span class="hljs-string">&quot;count1=&quot;</span> + singleTon.count1);<br>        System.out.println(<span class="hljs-string">&quot;count2=&quot;</span> + singleTon.count2);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>一个经常出现的错误答案是：</p><blockquote><p>count1=1;<br>count2=1;</p></blockquote><p>但是正确的执行结果为：</p><blockquote><p>count1=1;<br>count2=0;</p></blockquote><p>为什么呢？因为类加载过程中准备阶段是在初始化阶段之前的，虽然在上面的代码中有<code>count2=0</code>，但是准备阶段不关心这个。准备阶段完成后：</p><blockquote><p>count1=0;<br>count2=0;</p></blockquote><p>最后在初始化过程中，编译器生成的<code>&lt;cinit&gt;</code>方法是按照代码书写顺序生成的，例如这个例子中生成的是：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">cinit()&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingleTon singleTon = <span class="hljs-keyword">new</span> SingleTon();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count1;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count2 = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>虽然在执行<code>SingleTon</code>的构造方法时，会执行<code>count2=1</code>的操作，但是注意，<code>&lt;cinit&gt;</code>方法还没有执行完成呢。在<code>&lt;cinit&gt;</code>中最后还是会执行<code>count2=0</code>的操作。</p><p>所以最终的答案是：</p><blockquote><p>count1=1;<br>count2=0;</p></blockquote>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/jvm/">jvm</category>
      
      
      <category domain="https://eripe.me/tags/class-loading/">class loading</category>
      
      
      <comments>https://eripe.me/articles/class-loading-mechanism.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>HashMap源码分析(三)-删除源码</title>
      <link>https://eripe.me/articles/HashMap-analysis-part-three.html</link>
      <guid>https://eripe.me/articles/HashMap-analysis-part-three.html</guid>
      <pubDate>Mon, 14 Jun 2021 11:50:07 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;HashMap的删除操作一般通过&lt;code&gt;remove&lt;/code&gt;完成。在remove方法中,同样存在fast-fail机制,不了解的可以去看看&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>HashMap的删除操作一般通过<code>remove</code>完成。在remove方法中,同样存在fast-fail机制,不了解的可以去看看<a href="../Collection/List/ArrayList-source-code-analysis.md">ArrayList中的fast-fail</a>。通过fast-fail机制检查后,会调用真正的删除方法<code>removeNode</code>,如下面代码所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">removeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key, Object value,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">boolean</span> matchValue, <span class="hljs-keyword">boolean</span> movable)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, index;<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>            <span class="hljs-comment">//通过hash找出一个Node p</span><br>            (p = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>        Node&lt;K,V&gt; node = <span class="hljs-keyword">null</span>, e; K k; V v;<br>        <span class="hljs-comment">//注意,Hash相等不一定是同一个key,因为可能发生hash冲突</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>                <span class="hljs-comment">//如果是同一个对象或者使用equals返回true</span><br>                <span class="hljs-comment">//那么p就是我们要删除的点</span><br>            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            node = p;<br>        <span class="hljs-comment">//在链表中或RB树中查找目标节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = p.next) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key ||<br>                            (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<br>                        node = e;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    p = e;<br>                &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||<br>                                (value != <span class="hljs-keyword">null</span> &amp;&amp; value.equals(v)))) &#123;<br>            <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-comment">//从RB树中删除目标节点</span><br>                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="hljs-keyword">this</span>, tab, movable);<br>            <span class="hljs-comment">//如果目标节点在数组中</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == p)<br>                <span class="hljs-comment">//直接把链表的头部去除</span><br>                tab[index] = node.next;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">//如果此时HashMap仍然是以双向链表存储,那么直接链接后一个节点即可</span><br>                p.next = node.next;<br>            ++modCount;<br>            --size;<br>            afterNodeRemoval(node);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中<code>matchValue</code>表示删除元素时需要value匹配才能删除,<code>movable</code>为<code>false</code>表示当移除元素时不会移动其他节点。在<code>HashMap</code>中<code>matchValue</code>默认为false。在具体阅读源码之前,我们需要了解,<code>HashMap</code>中的链表或者RB树都是hash冲突的元素。<br>所以这个方法的逻辑比较简单:</p><ol><li>首先通过<code>key</code>的hash找出目标桶。</li><li>然后从对应的链表或者RB树找到对应的节点。注意这里对应的节点要求<code>key</code>与<code>value</code>都完全匹配,因为hash冲突。</li><li>如果当前存储形式为RB树,那么调用当前节点的<code>removeTreeNode</code>方法删除自身</li></ol><p>这里需要着重分析的是<code>TreeNode</code>的<code>removeTreeNode</code>方法,该方法非常复杂,需要耐心观看。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeTreeNode</span><span class="hljs-params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-keyword">boolean</span> movable)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> index = (n - <span class="hljs-number">1</span>) &amp; hash;<br>    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;<br>    TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;<br>    <span class="hljs-comment">//删除节点有两种视角,分别是链表视角和红黑树视角</span><br>    <span class="hljs-comment">//能这样操作是因为TreeNode既可以作为红黑树的节点，也可以作为链表节点</span><br>    <span class="hljs-comment">//这里先将hashmap作为链表处理，如果删除完毕节点个数不多于6个,那么直接就将RB树转为链表即可</span><br>    <span class="hljs-comment">//如果想要删除的节点就是根节点</span><br>    <span class="hljs-keyword">if</span> (pred == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-comment">//那么直接使用后继节点补上</span><br>        tab[index] = first = succ;<br>    <span class="hljs-keyword">else</span><br>        pred.next = succ;<br>    <span class="hljs-keyword">if</span> (succ != <span class="hljs-keyword">null</span>)<br>        succ.prev = pred;<br>    <span class="hljs-keyword">if</span> (first == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (root.parent != <span class="hljs-keyword">null</span>)<br>        root = root.root();<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span><br>        || (movable<br>            &amp;&amp; (root.right == <span class="hljs-keyword">null</span><br>                || (rl = root.left) == <span class="hljs-keyword">null</span><br>                || rl.left == <span class="hljs-keyword">null</span>))) &#123;<br>        tab[index] = first.untreeify(map);  <span class="hljs-comment">// too small</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">/******以RB树的视角删除节点************</span><br><span class="hljs-comment">    下面的代码目标是找到替换p的节点replacement然后将p进行真正的删除</span><br><span class="hljs-comment">    */</span><br>        TreeNode&lt;K,V&gt; p = <span class="hljs-keyword">this</span>, pl = left, pr = right, replacement;<br>    <span class="hljs-comment">//如果当前节点的左右子树都不为空</span><br>    <span class="hljs-keyword">if</span> (pl != <span class="hljs-keyword">null</span> &amp;&amp; pr != <span class="hljs-keyword">null</span>) &#123;<br>        TreeNode&lt;K,V&gt; s = pr, sl;<br>        <span class="hljs-comment">//那么就找到右子树的最左节点</span><br>        <span class="hljs-keyword">while</span> ((sl = s.left) != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// find successor</span><br>            s = sl;<br>        <span class="hljs-comment">//交换待删除节点p和p的右子树最左节点的颜色</span><br>        <span class="hljs-keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="hljs-comment">// swap colors</span><br>        <span class="hljs-comment">//此时的s是没有左子树的</span><br>        TreeNode&lt;K,V&gt; sr = s.right;<br>        TreeNode&lt;K,V&gt; pp = p.parent;<br>        <span class="hljs-comment">/***********接下来的操作就是交换s节点和p节点************</span><br><span class="hljs-comment">            * s是p右子树的最左节点</span><br><span class="hljs-comment">            * 总要要设置的就是s和p的left、right、parent三类指针</span><br><span class="hljs-comment">            * pp的left或right指针</span><br><span class="hljs-comment">            * sr的parent指针、pl和pr的parent指针***/</span><br>        <span class="hljs-comment">//如果s是p的右节点,那么就将p设置为s的右节点</span><br>        <span class="hljs-keyword">if</span> (s == pr) &#123; <span class="hljs-comment">// p was s&#x27;s direct parent</span><br>            p.parent = s;<br>            s.right = p;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            TreeNode&lt;K,V&gt; sp = s.parent;<br>            <span class="hljs-comment">//设置p的parent指针,如果s的父节点不为空,将s的父节点设置为p的父节点</span><br>            <span class="hljs-keyword">if</span> ((p.parent = sp) != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (s == sp.left)<br>                    sp.left = p;<br>                <span class="hljs-keyword">else</span><br>                    sp.right = p;<br>            &#125;<br>            <span class="hljs-comment">//设置s的right指针,如果p的右子树不空,那么把p的右子树接到s的右边</span><br>            <span class="hljs-keyword">if</span> ((s.right = pr) != <span class="hljs-keyword">null</span>)<br>                <span class="hljs-comment">//设置pr的parent指针</span><br>                pr.parent = s;<br>        &#125;<br>        <span class="hljs-comment">//设置p的left指针,因为s就是没有左子树的,所以交换后p的left指向null</span><br>        p.left = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//设置p的right指针,将s的右子树接到p的右边</span><br>        <span class="hljs-keyword">if</span> ((p.right = sr) != <span class="hljs-keyword">null</span>)<br>            sr.parent = p;<br>        <span class="hljs-comment">//设置s的left指针,将p的左子树接到s的左边</span><br>        <span class="hljs-keyword">if</span> ((s.left = pl) != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-comment">//设置pl的parent指针</span><br>            pl.parent = s;<br>        <span class="hljs-comment">//设置s的parent指针,设置s的父节点为p的父节点</span><br>        <span class="hljs-keyword">if</span> ((s.parent = pp) == <span class="hljs-keyword">null</span>)<br>            root = s;<br>        <span class="hljs-comment">//设置pp的left指针或者right指针</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == pp.left)<br>            pp.left = s;<br>        <span class="hljs-keyword">else</span><br>            pp.right = s;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">            * sr还是原来s的右子节点,这里并没有产生变化</span><br><span class="hljs-comment">            */</span><br>        <span class="hljs-keyword">if</span> (sr != <span class="hljs-keyword">null</span>)<br>            replacement = sr;<br>        <span class="hljs-keyword">else</span><br>            replacement = p;<br>    &#125;<br>    <span class="hljs-comment">//只有左子树,那么直接使用左子树的根节点替换</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pl != <span class="hljs-keyword">null</span>)<br>        replacement = pl;<br>    <span class="hljs-comment">//只有右子树,那么直接使用右子树的根节点替换</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pr != <span class="hljs-keyword">null</span>)<br>        replacement = pr;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">//当左右子树都为空时,当前节点就是被替换的节点</span><br>        replacement = p;<br>    <span class="hljs-comment">//如果replacement和p不是同一个节点,那么将二者交换</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 这里仅仅是简单的将pp变成replacement的父节点</span><br><span class="hljs-comment">        * 将p的所有指针都置空,方便垃圾回收</span><br><span class="hljs-comment">        */</span><br>    <span class="hljs-keyword">if</span> (replacement != p) &#123;<br>        TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;<br>        <span class="hljs-keyword">if</span> (pp == <span class="hljs-keyword">null</span>)<br>            root = replacement;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == pp.left)<br>            pp.left = replacement;<br>        <span class="hljs-keyword">else</span><br>            pp.right = replacement;<br>        p.left = p.right = p.parent = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-comment">/**如果p是红色,那么可以直接删除红节点</span><br><span class="hljs-comment">        * 否则从replacement开始调整颜色,此时p可以说是已经完全脱离RB树了</span><br><span class="hljs-comment">        */</span><br>        TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);<br>    <span class="hljs-comment">//只有p的左右子树都为空才会走下面的if分支</span><br>    <span class="hljs-keyword">if</span> (replacement == p) &#123;  <span class="hljs-comment">// detach</span><br>        TreeNode&lt;K,V&gt; pp = p.parent;<br>        p.parent = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (pp != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (p == pp.left)<br>                pp.left = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == pp.right)<br>                pp.right = <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (movable)<br>        moveRootToFront(tab, r);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>该方法的<code>this</code>指针就指向当前待删除的节点。在代码中我也写了,该方法删除节点有两种视角,因为<code>TreeNode</code>既可以作为RB树的节点,也可以作为双链表的节点。该方法的思路如下:</p><ol><li>首先以双链表的视角,删除当前节点,如果删除后RB树的节点不多于6个,那么就会执行<code>untreeify</code>方法,将RB树退化为单链表</li><li>当前剩余节点多于6,那么以RB树的视角删除当前节点,这里的核心思想是找到一个节点<code>s</code>替换当前待删除节点<code>p</code>。</li><li>如果节点<code>p</code>是红的,那么直接删除就好,因为删除红节点不会影响平衡性</li><li>如果节点<code>p</code>是黑的,删除节点<code>p</code>后,我们需要从从<code>replacement</code>节点开始调整RB树的颜色,这里的<code>replacement</code>是<code>p</code>的左或者右孩子,或者是<code>s</code>交换前的右孩子,或者是p本身</li></ol><p>经过上述四步,已经完成删除节点操作了,当然其中调整RB树平衡性的方法<code>balanceDeletion</code>是重中之重,但是记下来非常困难,看懂理解就好了。该方法的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 如果能进入到这个函数,那么删除的必是黑节点</span><br><span class="hljs-comment">    * 并且从x开始调整RB树的颜色</span><br><span class="hljs-comment">    * 返回的是RB树的根节点</span><br><span class="hljs-comment">    */</span><br><span class="hljs-keyword">static</span> &lt;K,V&gt; <span class="hljs-function">TreeNode&lt;K,V&gt;  <span class="hljs-title">balanceDeletion</span><span class="hljs-params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123;<br>        <span class="hljs-comment">//如果x是根节点,那么不用调整</span><br>        <span class="hljs-comment">//直接返回root</span><br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span> || x == root)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-comment">//如果x的父节点为空,那么x就是新的父节点</span><br>        <span class="hljs-comment">//直接返回x</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((xp = x.parent) == <span class="hljs-keyword">null</span>) &#123;<br>            x.red = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>        <span class="hljs-comment">//如果x是红节点,因为删除了一个黑节点,需要补上一个黑节点,否则破坏了RB树的完美黑平衡</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.red) &#123;<br>            x.red = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">            * 到这里为止,x必是黑色,因为从x到叶子节点的路径中</span><br><span class="hljs-comment">            * 少了一个黑节点,所有必须想办法把这个黑节点从别的地方补回来</span><br><span class="hljs-comment">            * 我们需要关注的节点就是x</span><br><span class="hljs-comment">            * 下面的代码就是在不断地变换x的指针</span><br><span class="hljs-comment">            * 下面的case1的四种情况图示可以参考:http://jackhuang.online/2019/08/09/red-black-tree%E7%AE%80%E4%BB%8B/</span><br><span class="hljs-comment">            *  case2为镜像分布</span><br><span class="hljs-comment">            */</span><br><br>        <span class="hljs-comment">//case1</span><br>        <span class="hljs-comment">//如果x是其父节点的左孩子</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((xpl = xp.left) == x) &#123;<br>            <span class="hljs-comment">//如果x有右兄弟并且右兄弟是红的,那么就把这个红色移到左边来</span><br>            <span class="hljs-comment">//因为x是xp的左孩子</span><br>            <span class="hljs-comment">//case1-1:</span><br>            <span class="hljs-keyword">if</span> ((xpr = xp.right) != <span class="hljs-keyword">null</span> &amp;&amp; xpr.red) &#123;<br>                xpr.red = <span class="hljs-keyword">false</span>;<br>                xp.red = <span class="hljs-keyword">true</span>;<br>                root = rotateLeft(root, xp);<br>                xpr = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.right;<br>            &#125;<br>            <span class="hljs-comment">//向左旋转后,x没有兄弟,重新设置x为xp</span><br>            <span class="hljs-keyword">if</span> (xpr == <span class="hljs-keyword">null</span>)<br>                x = xp;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">/**到此为止,x必有右兄弟,至于黑红目前还不知道</span><br><span class="hljs-comment">                */</span><br>                TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;<br>                <span class="hljs-comment">//如果右兄弟孩子双全并且都是黑孩子</span><br>                <span class="hljs-comment">//或者有一个孩子并且孩子是黑的</span><br>                <span class="hljs-comment">//case1-2:</span><br>                <span class="hljs-keyword">if</span> ((sr == <span class="hljs-keyword">null</span> || !sr.red) &amp;&amp;<br>                    (sl == <span class="hljs-keyword">null</span> || !sl.red)) &#123;<br>                    xpr.red = <span class="hljs-keyword">true</span>;<br>                    x = xp;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//走到这x的右兄弟必有孩子,因为如果没有孩子不会进入这个else分支</span><br>                    <span class="hljs-comment">//如果有一个孩子,那么该孩子必是红的</span><br>                    <span class="hljs-comment">//如果有两个孩子,必然是一个黑色,一个红色,或者两个都是红色</span><br>                    <span class="hljs-comment">/**</span><br><span class="hljs-comment">                        * 在这我们关注的都是xpr的右孩子</span><br><span class="hljs-comment">                        */</span><br><br><br>                    <span class="hljs-comment">//case1-3:如果xpr没有右孩子或者右孩子是黑的</span><br>                    <span class="hljs-keyword">if</span> (sr == <span class="hljs-keyword">null</span> || !sr.red) &#123;<br>                        <span class="hljs-keyword">if</span> (sl != <span class="hljs-keyword">null</span>)<br>                            sl.red = <span class="hljs-keyword">false</span>;<br>                        xpr.red = <span class="hljs-keyword">true</span>;<br>                        root = rotateRight(root, xpr);<br>                        xpr = (xp = x.parent) == <span class="hljs-keyword">null</span> ?<br>                            <span class="hljs-keyword">null</span> : xp.right;<br>                    &#125;<br>                    <span class="hljs-comment">//走到这,xpr的必有右孩子且右孩子是红的</span><br><br><br>                    <span class="hljs-comment">//case1-4</span><br>                    <span class="hljs-keyword">if</span> (xpr != <span class="hljs-keyword">null</span>) &#123;<br>                        xpr.red = (xp == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">false</span> : xp.red;<br>                        <span class="hljs-keyword">if</span> ((sr = xpr.right) != <span class="hljs-keyword">null</span>)<br>                            sr.red = <span class="hljs-keyword">false</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;<br>                        xp.red = <span class="hljs-keyword">false</span>;<br>                        root = rotateLeft(root, xp);<br>                    &#125;<br>                    x = root;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//case2</span><br>        <span class="hljs-comment">//如果x是其父节点的右孩子,这根上面是镜像的</span><br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// symmetric</span><br>            <span class="hljs-keyword">if</span> (xpl != <span class="hljs-keyword">null</span> &amp;&amp; xpl.red) &#123;<br>                xpl.red = <span class="hljs-keyword">false</span>;<br>                xp.red = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-comment">//与上面相似,这里将红色往右边移,因为x是xp的右节点</span><br>                root = rotateRight(root, xp);<br>                xpl = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.left;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (xpl == <span class="hljs-keyword">null</span>)<br>                x = xp;<br>            <span class="hljs-keyword">else</span> &#123;<br>                TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;<br>                <span class="hljs-keyword">if</span> ((sl == <span class="hljs-keyword">null</span> || !sl.red) &amp;&amp;<br>                    (sr == <span class="hljs-keyword">null</span> || !sr.red)) &#123;<br>                    xpl.red = <span class="hljs-keyword">true</span>;<br>                    x = xp;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (sl == <span class="hljs-keyword">null</span> || !sl.red) &#123;<br>                        <span class="hljs-keyword">if</span> (sr != <span class="hljs-keyword">null</span>)<br>                            sr.red = <span class="hljs-keyword">false</span>;<br>                        xpl.red = <span class="hljs-keyword">true</span>;<br>                        root = rotateLeft(root, xpl);<br>                        xpl = (xp = x.parent) == <span class="hljs-keyword">null</span> ?<br>                            <span class="hljs-keyword">null</span> : xp.left;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (xpl != <span class="hljs-keyword">null</span>) &#123;<br>                        xpl.red = (xp == <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">false</span> : xp.red;<br>                        <span class="hljs-keyword">if</span> ((sl = xpl.left) != <span class="hljs-keyword">null</span>)<br>                            sl.red = <span class="hljs-keyword">false</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;<br>                        xp.red = <span class="hljs-keyword">false</span>;<br>                        root = rotateRight(root, xp);<br>                    &#125;<br>                    x = root;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>在该方法中,<code>x</code>就是我们一直需要关注的节点,主要思想就是从x开始不断地由下向上调整整颗RB树的颜色,其主要逻辑如下:</p><ol><li>如果<code>x</code>没有父节点或者其本身就是root节点,表示并不需要调整什么</li><li>如果<code>x</code>是红节点,那么把<code>x</code>变黑即可,因为原来从根节点到叶节点包含<code>x</code>的这条路径,少了一个黑节点,这里补上的话就没有什么问题了</li><li>如果<code>x</code>是黑节点,那么比较惨,调整操作就比较复杂了,这里分成了两个大case,每个case里面有四种小case,具体见代码注释,并且这四种小case的图解可以<a href="http://jackhuang.online/2019/08/09/red-black-tree%E7%AE%80%E4%BB%8B/">参考</a>,就像图片的作者所说,我也认为这里不要去怀疑这些移动策略的正确性,仅作了解,看懂了即可。</li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</category>
      
      
      <category domain="https://eripe.me/tags/HashMap/">HashMap</category>
      
      
      <comments>https://eripe.me/articles/HashMap-analysis-part-three.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>HashMap源码分析(一)-HashMap中的那些常量</title>
      <link>https://eripe.me/articles/HashMap-analysis-part-one.html</link>
      <guid>https://eripe.me/articles/HashMap-analysis-part-one.html</guid>
      <pubDate>Mon, 14 Jun 2021 11:50:07 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HashMap实现了接口<code>Map</code>、<code>Cloneable</code>、<code>Serializable</code>,后两个都是标记接口,注意HasnMap的<code>clone</code>方法也仅仅是浅复制(shadow copy)。而<code>Map</code>是跟<code>Collection</code>并列的顶级接口。HashMap并且继承抽象类<code>AbstractMap</code>。</p><p>本文将首先简单说说接口<code>Map</code>,因为<code>AbstarctMap</code>作为实现接口<code>Map</code>的骨架,仅实现了一些基本方法,没什么好说的。</p><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br>    ...<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>Map提供了三种方法来遍历自身:</p><ul><li>通过<code>keySet()</code>方法返回Map中所有键组成的Set</li><li>通过<code>values()</code>返回Map中values组成的Collection</li><li>通过<code>entrySet()</code>返回由<code>Map.Entry</code>组成的Set</li></ul><p>前两种都比较常规。值得一提的是第三种方式中的<code>Map.Entry</code>。在<code>Map</code>接口定义了一个内部接口<code>Entry</code>。Entry维护了一组键值对,类似于c++HashMap中的pair结构。这个Entry结构只能通过Map的迭代器获得。并且这些Entry集合<strong>只</strong>在遍历的过程中有效,如果在遍历过程中修改了集合,那么对Entry的操作是未定义的,除非使用Entry定义的<code>setValue()</code>方法。</p><h2 id="1-HashMap中的常量"><a href="#1-HashMap中的常量" class="headerlink" title="1. HashMap中的常量"></a>1. HashMap中的常量</h2><p>HashMap中定义了一些比较重要的常量,如下所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//默认初始容量,必须是2的倍数</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br><br><span class="hljs-comment">//HashMap最大的容量,也就是2^30,因为必须是2的倍数</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br><span class="hljs-comment">//扩容因子,如果当前存储的Entry个数达到容量的75%,那么就进行扩容</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The bin count threshold for using a tree rather than list for a</span><br><span class="hljs-comment"> * bin.  Bins are converted to trees when adding an element to a</span><br><span class="hljs-comment"> * bin with at least this many nodes. The value must be greater</span><br><span class="hljs-comment"> * than 2 and should be at least 8 to mesh with assumptions in</span><br><span class="hljs-comment"> * tree removal about conversion back to plain bins upon</span><br><span class="hljs-comment"> * shrinkage.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//当一条链表上的数据容量达到8时就采用红黑树存储</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The bin count threshold for untreeifying a (split) bin during a</span><br><span class="hljs-comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span><br><span class="hljs-comment"> * most 6 to mesh with shrinkage detection under removal.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//当一条链表上的数据少于等于6个时,就从红黑树转为链表存储一个桶中的数据</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The smallest table capacity for which bins may be treeified.</span><br><span class="hljs-comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span><br><span class="hljs-comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span><br><span class="hljs-comment"> * between resizing and treeification thresholds.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//如果一旦采用红黑树存储,那么HashMap的容量至少为64</span><br><span class="hljs-comment">//当然用红黑树存储一个桶中的数据时,那么就至少是4*TREEIFY_THRESHOLD的容量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;<br></code></pre></div></td></tr></table></figure><p>下面将罗列一些常见的关于HashMap常量的问题。</p><h3 id="1-1-为什么Map的容量都是2的整数幂"><a href="#1-1-为什么Map的容量都是2的整数幂" class="headerlink" title="1.1 为什么Map的容量都是2的整数幂?"></a>1.1 为什么Map的容量都是2的整数幂?</h3><p>有两个理由:</p><ul><li>寻找bucket索引更快</li><li>让扩容方法resize()效率更高，在理想情况下，能够等概率地将一个长链表分为两半，一半在原位置，一半移动到新扩容的地方</li></ul><p>对于第一点,因为在JDK8中,HashMap计算bucket的索引方法如下:</p><blockquote><p>i = (n - 1) &amp; hash == hash % n == (n-1) &amp; (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</p></blockquote><p>tab就是用来存储bucket的数组。n是数组的容量。如果n是2的整数幂,那么<code>(n-1)&amp; hash== hash% n</code>,其中hash是一个32位整数。没错,就是这么神奇。这样计算索引只需移位操作,比取模更快。所以都是2的整数幂。</p><p>对于第二点:每次HashMap扩容都是变为原来的两倍,扩容是一个代价高昂的操作。在扩容时不仅需要复制元素,而且需要更新对应的索引。如果HashMap的容量都是2的整数幂。那么它的索引要么在原来位置,要么偏移了2的整数次幂(<strong>偏移了原始容量的距离</strong>)。</p><p>对于这一点,我们随便设一个hash做验证,令hashcode=0x00008435。未扩容前的容量为2^4=16。那么当前计算出的索引:</p><blockquote><p>0000 0000 0000 0000 1000 0100 0001 0101 -&gt; hash<br>0000 0000 0000 0000 0000 0000 0000 1111 -&gt; n-1</p></blockquote><p>计算出的索引为:0101b &amp; 1111b=101b=5。现在将容量扩张为原来的2倍:</p><blockquote><p>0000 0000 0000 0000 0000 0000 0001 1111 -&gt; n-1</p></blockquote><p>计算出的索引为:11111b &amp; 10101b=10101b=21。索引移动了2的整数幂。再将容量扩充为原来的2倍:</p><blockquote><p>0000 0000 0000 0000 0000 0000 0011 1111 -&gt; n-1</p></blockquote><p>计算出的索引为:111111b &amp; 010101b=10101b=21。索引没有变化。</p><p>从上面的结果可以看出,索引动与不动随机的取决于hashcode某1bit是0还是1。后者是0还是1的概率为0.5。</p><p>将容量扩充为原来的两倍的同时,也公平的将每个桶的容量也扩充为原来的两倍,因为桶中的元素移动于不移动完全是等概率的,取决于hashcode某bit是1还是0。</p><blockquote><p>值得注意的是,JDK1.8中,HashMap扩容不会讲链表倒置,而JDK1.7会</p></blockquote><h3 id="1-2-为什么hash要这么计算"><a href="#1-2-为什么hash要这么计算" class="headerlink" title="1.2 为什么hash要这么计算?"></a>1.2 为什么hash要这么计算?</h3><p>在JDK1.8中,Map计算hashcode采用了新的方法:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-comment">//null的hash为0</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>    <span class="hljs-comment">//这里调用的key的hashCode方法,实际上调用的key的具体实现类,而不是Object的hashCode</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>是将key的hash高16位于低16位进行异或。最后的hash高16位还是原来的高16位,低16位是异或后的结果。为什么要这么做呢?</p><p>简单来说是为了增加hash的随机性。比如两个整数:365(11110101b),165(01110101b)。如果只采用Integer自己实现的hash算法,那么计算出来的hash就是365于165。</p><p>现在进行索引的计算(map容量为16):<code>(n-1) &amp; 16</code>。计算出的结果都为<code>101b</code>,发生了hash碰撞。但是这两个数差别还是蛮大的。所以将对象的原始hash的高16位与低16位异或,这么做也是为了在低16中保留高16位的特性,加大低16位的随机性。</p><p>所以说最终目的就是为了<strong>防止hash碰撞</strong>。JDK1.7的hash算法并不怎么随机,曾经产生了dos攻击。<a href="https://coolshell.cn/articles/6424.html">HASH COLLISION DOS 问题</a></p><p><strong>最后,null的hash为0!</strong></p><h3 id="1-3-为什么HashMap的默认容量为16"><a href="#1-3-为什么HashMap的默认容量为16" class="headerlink" title="1.3 为什么HashMap的默认容量为16?"></a>1.3 为什么HashMap的默认容量为16?</h3><p>既然HashMap的容量必须是2的整数幂,那么为什么不是2,4,或者16,32。emm,这个问题我在网上看到的回答是:</p><blockquote><p>如果是2、4、8之类的,容量太小,容易导致频繁扩容。上文说过,扩容代价很高的。而不设置成32、64等更大的值是因为太大了,用到的概率不大。避免浪费空间。</p></blockquote><p>这个答案还行吧,好像有那么一点道理。</p><h3 id="1-4-为什么桶中节点数到8才采用RB树"><a href="#1-4-为什么桶中节点数到8才采用RB树" class="headerlink" title="1.4 为什么桶中节点数到8才采用RB树?"></a>1.4 为什么桶中节点数到8才采用RB树?</h3><p>答案存在于源码中的开发笔记。这里仅摘抄最重要的部分。</p><blockquote><p>Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use(see TREEIFY_THRESHOLD). And when they become too small (due to removal or resizing) they are converted back to plain bins.  In usages with well-distributed user hashCodes, tree bins are rarely used.  Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution (<a href="http://en.wikipedia.org/wiki/Poisson_distribution">http://en.wikipedia.org/wiki/Poisson_distribution</a>) with a parameter of about 0.5 on average for the default resizing threshold of 0.75, although with a large variance because of resizing granularity.</p></blockquote><p>大致意思是说,采用红黑树的存储所消耗的空间是采用链表存储的两倍。所以仅在链表中数据足够多的情况下会转为红黑树存储,当节点数减少到一定数量,就会再次退化为链表存储。<strong>如果使用足够好的hash算法</strong>,那么计算出的hashcode应该是足够分散的。</p><p>在理想hash下,每个桶中的节点数符合参数为0.5的泊松分布。分布公式为<code>(exp(-0.5) * pow(0.5, k) / * factorial(k))</code>。通过公式的计算,每个桶中各个节点数出现的情况如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-number">0</span>:    <span class="hljs-number">0.60653066</span><br><span class="hljs-number">1</span>:    <span class="hljs-number">0.30326533</span><br><span class="hljs-number">2</span>:    <span class="hljs-number">0.07581633</span><br><span class="hljs-number">3</span>:    <span class="hljs-number">0.01263606</span><br><span class="hljs-number">4</span>:    <span class="hljs-number">0.00157952</span><br><span class="hljs-number">5</span>:    <span class="hljs-number">0.00015795</span><br><span class="hljs-number">6</span>:    <span class="hljs-number">0.00001316</span><br><span class="hljs-number">7</span>:    <span class="hljs-number">0.00000094</span><br><span class="hljs-number">8</span>:    <span class="hljs-number">0.00000006</span><br></code></pre></div></td></tr></table></figure><p>可以看到,一个桶中出现出现8个节点的概率为千万分之六。几乎是不可能出现的情况。当然,回归现实,不可能每次都出现理想hash。所以采用8个节点作为分界点。一个桶中达到8个节点,就转为红黑树存储。</p><p>这里又可以引申出一个问题,<strong>为什么泊松分布的参数要设置为0.5?</strong></p><blockquote><p>emmm,从注释中看,应该也是一个经验值吧。</p></blockquote><h3 id="1-5-为什么桶中节点数减少为6才采用链表"><a href="#1-5-为什么桶中节点数减少为6才采用链表" class="headerlink" title="1.5 为什么桶中节点数减少为6才采用链表?"></a>1.5 为什么桶中节点数减少为6才采用链表?</h3><p>在节点数减少到6时才桶中元素采用RB树转为链表,为什么不是5或者7?</p><p>不设置为5、4、3的原因显而易见,节点太少,用红黑树存储从空间角度上来说不划算,因为是链表存储的2倍。</p><p>那么为什么不设置为7呢?</p><p>因为如果设置为7,那么加一个entry,变为8就要升级红黑树,减一个entry就变为7降级为链表。如果对HashMap频繁的进行增删操作,那么桶的存储方式就得频繁的在红黑树和链表之间转换,这个开销是不可忽视的。所以设为6,有一个缓冲的空间。</p><h3 id="1-6-为什么factor设为0-75"><a href="#1-6-为什么factor设为0-75" class="headerlink" title="1.6 为什么factor设为0.75?"></a>1.6 为什么factor设为0.75?</h3><p>在官方注释中,下面的节选部分解释了为什么<code>load factor</code>是0.75。</p><blockquote><p>As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs.  Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the <tt>HashMap</tt> class, including <tt>get</tt> and <tt>put</tt>).  The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of<br>rehash operations.  If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.</p></blockquote><p>简而言之,0.75是一个经验值,在时间和空间两个方面达到了平衡。<strong>这也就解释为什么不是0.5或是1?</strong></p><p>如果factor是<strong>0.5</strong>,那么就会导致map频繁扩容,代价比较高。而且空间利用率也比较低。但是链表中的内容或者RB树的节点就比较少,提升了查询效率。<strong>是以空间换时间的方式。</strong></p><p>如果factor设置为<strong>1</strong>,虽然空间利用率达到了100%,在使用完才会扩容,一定程度增加了put的时间。并且可能会发生大量的hash碰撞,此时的查询效率是非常低的。<strong>是以时间换空间的方式。</strong></p><p><strong>那么为什么不是0.6或者0.8?</strong></p><p>首先如果<code>load factor</code>为0.75,那么每次<code>load factor * capacity</code>都会得到一个整数。</p><p>其次,在StackOverflow上有一个<a href="https://stackoverflow.com/questions/10901752/what-is-the-significance-of-load-factor-in-hashmap">回答</a>,采用了二项分布的方式计算出了<code>load factor</code>与<code>capacity</code>的最佳比例:</p><p>他首先规定,在完美情况下,在每次插入时所选取的桶应该是一个空桶。泊松分布的极限就是二项分布。在n次插入实验中,每次插入都选取空桶的概率总和应该为0.5。计算公式为:</p><blockquote><p>1/2=P=C(n, 0) * (1/s)^0 * (1 - 1/s)^(n - 0),其中s是桶的数量,n是试验次数</p></blockquote><p>我一直不明白<code>1/s</code>代表的是什么?每次都选取的是非空桶?那么解释不了<code>1/s</code>啊。而且StackOverflow新人还不能评论,可恶啊。</p><p>进行简单变化,在s趋于正无穷时,<code>n/s=load factor</code>趋近于<code>ln(2)</code>。所以他得出load facotr在<code>ln(2)~0.75</code>之间HashMap都能有很出色的表现。</p><p>我对上述回答产生了如下疑问:</p><ol><li>也不一定要求每次插入都必须要求空桶吧?</li><li><code>1/s</code>的数学意义到底代表着什么?</li></ol><h2 id="2-HashMap的属性"><a href="#2-HashMap的属性" class="headerlink" title="2. HashMap的属性"></a>2. HashMap的属性</h2><p>HashMap中的magic number在上面已经分析过,下面是HashMap的一些属性:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The table, initialized on first use, and resized as</span><br><span class="hljs-comment">* necessary. When allocated, length is always a power of two.</span><br><span class="hljs-comment">* (We also tolerate length zero in some operations to allow</span><br><span class="hljs-comment">* bootstrapping mechanics that are currently not needed.)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//用来存储bucket的底层数组,无论是初始化HashMap还是扩容,容量一直都是2的整数幂</span><br><span class="hljs-comment">//当然上面也指出了在某些时候允许长度为0,从而允许一些当前不需要的引导机制????这是啥意思</span><br><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Holds cached entrySet(). Note that AbstractMap fields are used</span><br><span class="hljs-comment">* for keySet() and values().</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The number of key-value mappings contained in this map.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//这是HashMap中实际的Entry数量,不是容量哦</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The number of times this HashMap has been structurally modified</span><br><span class="hljs-comment">* Structural modifications are those that change the number of mappings in</span><br><span class="hljs-comment">* the HashMap or otherwise modify its internal structure (e.g.,</span><br><span class="hljs-comment">* rehash).  This field is used to make iterators on Collection-views of</span><br><span class="hljs-comment">* the HashMap fail-fast.  (See ConcurrentModificationException).</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//modCount曾在分析ArrayList的源码解释过,用于支持fast-fail机制,从而也说明HashMap是线程不安全的</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The next size value at which to resize (capacity * load factor).</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// (The javadoc description is true upon serialization.</span><br><span class="hljs-comment">// Additionally, if the table array has not been allocated, this</span><br><span class="hljs-comment">// field holds the initial array capacity, or zero signifying</span><br><span class="hljs-comment">// DEFAULT_INITIAL_CAPACITY.)</span><br><br><span class="hljs-comment">//注释中的大致意思就是下一次扩容时的容量,如果HashMap还未初始化,那么就存储初始化的容量,或者0(表示默认初始化容量)</span><br><span class="hljs-keyword">int</span> threshold;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The load factor for the hash table.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//HashMap的装载因子,一旦确定,不可更改</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;<br></code></pre></div></td></tr></table></figure><p>更新:2020-08-02 18:57:49</p><p><code>HashMap</code>中的<code>threshold</code>=<code>loadFactor*capacity</code>,并<strong>不是</strong>下一次扩容的容量,当然如果HashMap还未初始化,并且用户指定了初始化容量,那么存储的就是根据用户指定容量计算出的元素数量阈值,否则0就是表示默认值12。       </p><p><code>table</code>数组的元素是Node,这又是什么呢?来一起康康:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>        <span class="hljs-comment">//key的Hash值,是一个32bit的int,不可更改</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;<br>        <span class="hljs-comment">//key,不可更改</span><br>        <span class="hljs-keyword">final</span> K key;<br>        V value;<br>        <span class="hljs-comment">//next指针,因为刚开始就是使用链表存储的Entry的</span><br>        Node&lt;K,V&gt; next;<br>        <span class="hljs-comment">//构造函数</span><br>        <span class="hljs-comment">//注意:没有默认构造函数</span><br>        Node(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-keyword">this</span>.hash = hash;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.value = value;<br>            <span class="hljs-keyword">this</span>.next = next;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span>        </span>&#123; <span class="hljs-keyword">return</span> key; &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span>      </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">&quot;=&quot;</span> + value; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">setValue</span><span class="hljs-params">(V newValue)</span> </span>&#123;<br>            V oldValue = value;<br>            value = newValue;<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Map.Entry) &#123;<br>                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;<br>                <span class="hljs-keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;<br>                    Objects.equals(value, e.getValue()))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>从上面可以看出,Node是在HashMap使用链表存储模式时一组key-value的wrapper类。而<code>Map.Entry</code>是在<code>Map</code>接口中定义的一个内部接口,规定了一些<code>Entry</code>必须实现的方法。基本上就可以说这个<code>Entry</code>就相当于c++中的<code>pair</code>结构。保存一对key-value。<code>Entry</code>的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-function">K <span class="hljs-title">getKey</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">V <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">V <span class="hljs-title">setValue</span><span class="hljs-params">(V value)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K extends Comparable&lt;? <span class="hljs-keyword">super</span> K&gt;, V&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByKey() &#123;<br>        <span class="hljs-keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)<br>            (c1, c2) -&gt; c1.getKey().compareTo(c2.getKey());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V extends Comparable&lt;? <span class="hljs-keyword">super</span> V&gt;&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByValue() &#123;<br>        <span class="hljs-keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)<br>            (c1, c2) -&gt; c1.getValue().compareTo(c2.getValue());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey(Comparator&lt;? <span class="hljs-keyword">super</span> K&gt; cmp) &#123;<br>        Objects.requireNonNull(cmp);<br>        <span class="hljs-keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)<br>            (c1, c2) -&gt; cmp.compare(c1.getKey(), c2.getKey());<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue(Comparator&lt;? <span class="hljs-keyword">super</span> V&gt; cmp) &#123;<br>        Objects.requireNonNull(cmp);<br>        <span class="hljs-keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)<br>            (c1, c2) -&gt; cmp.compare(c1.getValue(), c2.getValue());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在<code>Entry</code>中定义了四个获取比较器的静态方法,对于不熟悉java8新语法的同学来说,静态方法内部的实现可能让人摸不着头脑。</p><p>首先,<code>(c1, c2) -&gt; c1.getKey().compareTo(c2.getKey());</code>其实是lambda表达式,它的一般格式如下:</p><blockquote><p>(type1 arg1,type2 arg2…)-&gt;{ body…}</p></blockquote><p>lambda有<a href="http://blog.oneapm.com/apm-tech/226.html">以下特点</a>:</p><ul><li>一个 Lambda 表达式可以有零个或多个参数</li><li>参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同</li><li>所有参数需包含在圆括号内，参数之间用逗号相隔。例如：(a, b) 或 (String a, int b, float c)<br>空圆括号代表参数集为空。例如：() -&gt; 42</li><li>当只有一个参数，且其类型可推导时，<strong>圆括号</strong>（）可省略。例如：a -&gt; return a*a</li><li>Lambda 表达式的主体可包含零条或多条语句</li><li>如果 Lambda 表达式的主体只有<strong>一条</strong>语句，<strong>花括号</strong>{}可省略。匿名函数的返回类型与该主体表达式一致</li><li>如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</li></ul><p>关于lambda表达式更高级知识可以了解一下函数式语言中的闭包,java中的lambda就是最接近闭包的概念。</p><p>接下来再看看为什么一个lambda表达式能够强转为接口。<code>Comparator</code>是一个函数式接口(<code>@FunctionalInterface</code>)。函数式接口的标准就是其内部只能定义一个抽象方法。在java8中,每个lambda表达式都能隐式的赋值给函数时接口。当然lambda表达式的返回值和参数得和接口中定义的抽象方法一样才行。</p><p>然而我们去实际看<code>Comparator</code>接口源码时,却发现<code>Comparator</code>有两个抽象方法:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(T o1, T o2)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span>;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>竟然和函数式接口的定义不一样?然而答案在<code>FunctionInterface</code>的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html">官方文档</a>中。</p><blockquote><p>If an interface declares an abstract method overriding one of the public methods of java.lang.Object, that also does not count toward the interface’s abstract method count since any implementation of the interface will have an implementation from java.lang.Object or elsewhere.</p></blockquote><p>意思就是说如果函数式接口的抽象方法如果重写自<code>object</code>,那么是不计入函数式接口定义的方法个数中的,因为<code>Object</code>中的方法肯定都会在自身中实现或者override于其他地方。</p><p>最后强转的类型是竟然是<code>(Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</code>,两个类型还能进行与操作?</p><p>其实这也是java8中的新语法,StackOverflow上关于此问题的<a href="https://stackoverflow.com/questions/28509596/java-lambda-expressions-casting-and-comparators">回答</a>如下:</p><blockquote><p>The lambda is initialized with its target type as Comparator and Serializable. Note the return type of method is just Comparator, but because Serializable is also inscribed to it while initialization, it can always be serialized even though this message is lost in method signature.</p></blockquote><p>简而言之就是lambda表达式的初始化的目标类型是<code>Comparator</code>和<code>Serializable</code>。但是最后的<strong>返回类型</strong>却只是<code>Comparator</code>,但是<code>Serializable</code>类型已经在表达式初始化时注册(inscribe)过了。所以尽管在函数签名中丢失了该信息,但是返回值是一定总是可以初始化的。</p><p>ok,经过上述的简单科普,相信返回比较器的代码实现已经不是问题了。上述所有的点都是java8的新语法,包括在接口中定义<code>default</code>方法和<code>static</code>方法。</p><h2 id="3-HashMap的构造方法"><a href="#3-HashMap的构造方法" class="headerlink" title="3. HashMap的构造方法"></a>3. HashMap的构造方法</h2><p><code>HashMap</code>总共有4个构造方法,除了<code>HashMap(Map&lt;? extends K, ? extends V&gt; m)</code>以外,其他3个构造函数都是仅仅设置装载因子<code>load factor</code>,在这三个构造函数中,除了默认构造函数,<del>另外两个都会设置初始容量</del>。</p><p><del>这里传入的初始容量仅仅是为了设置threshold,而不是设置初始容量</del>,这里再次收回所说的话,虽然表面上看仅仅是将传入容量修正为最近的2的整数幂,并赋值给threshold。</p><p><strong>但是在第一次put元素时</strong>,会将刚才设置好的threshold赋值给table的新容量,也就实现的指定HashMap的容量的操作。但是这三个构造都不会进行table内存的分配,<strong>只会在第一次put时调用resize()进行分配</strong>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +<br>                                           initialCapacity);<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                           loadFactor);<br>    <span class="hljs-keyword">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br><br><span class="hljs-comment">//默认构造函数不会设置threshold</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span><br>&#125;<br><br><span class="hljs-comment">//会在putEntries中设置threshold    </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>    putMapEntries(m, <span class="hljs-keyword">false</span>);<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>在第四个使用<code>Map</code>对象构造HashMap的构造函数中,其调用了<code>putMapEntries(Map,boolean)</code>方法,这个函数值得一提,因为其第二个参数的意义会在后面用到:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Implements Map.putAll and Map constructor.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> m the map</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> evict false when initially constructing this map, else</span><br><span class="hljs-comment">     * true (relayed to method afterNodeInsertion).</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putMapEntries</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m, <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> s = m.size();<br>        <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (table == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// pre-size</span><br>                <span class="hljs-comment">//下面的操作是在计算完全存储m中的元素需要的capacity,注意不是threshold</span><br>                <br>                <span class="hljs-comment">//下面的加1.0F是为在计算出的loadFactor为小数时向上取整</span><br>                <span class="hljs-keyword">float</span> ft = ((<span class="hljs-keyword">float</span>)s / loadFactor) + <span class="hljs-number">1.0F</span>;<br>                <span class="hljs-keyword">int</span> t = ((ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY) ?<br>                         (<span class="hljs-keyword">int</span>)ft : MAXIMUM_CAPACITY);<br>                <span class="hljs-comment">//查看所需的capacity是否比当前HashMap的扩容阈值还大,比阈值还大的情况下,不可能存储下m的所有元素,即使当前HashMap为空</span><br>                <span class="hljs-comment">//那么就需要更新当前HashMap的阈值</span><br>                <span class="hljs-keyword">if</span> (t &gt; threshold)<br>                    threshold = tableSizeFor(t);<br>            &#125;<br>            <span class="hljs-comment">//当调用HashMap的putAll方法时,会再次调用该方法执行到下面的else if </span><br>            <span class="hljs-comment">//这里的resize相当于一次预判,如果m的元素个数比当前hashmap的元素个数阈值threshold还高的话</span><br>            <span class="hljs-comment">//那么即使当前HashMap为空,也无法存储m的所有元素,所以必须扩容</span><br>            <span class="hljs-comment">//当然即使s&lt;=threshold,当前HashMap还是有可能存储不下,这会在putVal内部进行扩容</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &gt; threshold)<br>                resize();<br>            <span class="hljs-keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;<br>                K key = e.getKey();<br>                V value = e.getValue();<br>                putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, evict);<br>            &#125;<br>        &#125;<br>    &#125; <br></code></pre></div></td></tr></table></figure><p>在<code>else if</code>中的扩容操作体现了HashMap的扩容懒汉模式,仅仅在已经确定没有足够空间存储的情况中才会进行扩容操作,因为扩容操作的代价太高了。</p><p><strong>evict参数:</strong></p><p>如果当前<code>HashMap</code>的table还未进行分配,那么就会将参数<code>evict</code>设置为false,表示当前正处于构造模式。这个单词本身的意思具有驱逐的意思,主要应用于<code>LinkedHashMap</code>构造<code>LRU</code>时使用。与<code>HashMap</code>中的意义不同。</p><p>最后代码中经常使用<code>tableSizeFor(int)</code>方法就是把用户输入的容量调整到最近的2的整数幂。其代码与<code>ArrayQueue</code>的调整方式基本一致。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACIT      Y : n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>唯一与<code>ArrayQueue</code>不同的时,当把容量调整到离cap最近的2的整数幂-1时:</p><ul><li>如果已经溢出,那么会将容量设为1</li><li>如果此时的容量小于<code>2^31</code>但是大于<code>2^30</code>,那么就将容量修正为<code>2^30</code></li><li>否则最新容量就是最近的2的整数幂。</li></ul><p><a href="https://stackoverflow.com/questions/857420/what-are-the-reasons-why-map-getobject-key-is-not-fully-generic">为什么HashMap的get方法没有写成泛型？</a></p><h2 id="0x3-JDK1-8与JDK1-7的HashMap异同"><a href="#0x3-JDK1-8与JDK1-7的HashMap异同" class="headerlink" title="0x3 JDK1.8与JDK1.7的HashMap异同"></a>0x3 JDK1.8与JDK1.7的HashMap异同</h2><ol><li><p>实现方式不同,在JDK1.7中,HashMap采用数组+链表的方式实现,1.8则采用数组+链表+红黑树实现。</p></li><li><p>扩容与插入顺序不同,1.7在链表中扩容是需要时再扩,也就是在插入时发现实在没办法插入再进行扩容,然后重新完成插入操作。我认为这很正常,没地方放再扩容不是正常逻辑?<br>JDK1.8中是先把节点放入map中,最后再决定是否要调用<code>resize</code>,我认为这是因为1.8中链表和RB树会进行相互转换。如果先进行扩容,那么本来需要进行树化的链表由于扩容被迫拆为两条小链表,可能会浪费空间。例如链表为7个,插入后为8个需要进行树化,但是先扩容导致该链表的长度减为4,又不需要树化了。</p></li><li><p>链表的插入顺序不同,1.7中是采用头插法,1.8中采用尾插法。</p></li></ol><h2 id="0x4-JDK1-7的HashMap中存在的问题"><a href="#0x4-JDK1-7的HashMap中存在的问题" class="headerlink" title="0x4 JDK1.7的HashMap中存在的问题"></a>0x4 JDK1.7的HashMap中存在的问题</h2><ol><li>死循环问题,因为1.7中采用头插法,在多线程环境下进行扩容操作时(resize过后在调用transfor时可能会出现问题)可能会形成循环链表,导致在进行get操作时陷入死循环。这种情况出现在原hashmap中有:3-&gt;5-&gt;7,扩容后的hashmap分割为：5-&gt;3和7，这时可能会产生死循环</li></ol><p>对于1.7hashmap的transform方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Entry[] newTable)</span> </span>&#123;<br>    Entry[] src = table;<br>    <span class="hljs-keyword">int</span> newCapacity = newTable.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; src.length; j++) &#123;<br>        Entry&lt;K,V&gt; e = src[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            src[j] = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">do</span> &#123;<br>                Entry&lt;K,V&gt; next = e.next;<br>                <span class="hljs-keyword">int</span> i = indexFor(e.hash, newCapacity);<br>                <span class="hljs-comment">//如果线程1在这就被挂起，那么当前这个do...while循环本身就不会结束</span><br>                e.next = newTable[i];<br><br>                <span class="hljs-comment">//死循环产生点</span><br>                <span class="hljs-comment">//线程1正准备执行下面一句时被挂起，才会出现get时死循环</span><br>                newTable[i] = e;<br>                <br>                e = next;<br>            &#125; <span class="hljs-keyword">while</span> (e != <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="2"><li>数据丢失问题,同样是因为头插法,原始链表的末尾数据可能会产生丢失问题。</li></ol><p>这种情况出现在原hashmap中有:3-&gt;5-&gt;7,扩容后的hashmap分割为：7-&gt;3和5，这时可能会丢失数据3。详情见：<a href="https://www.cnblogs.com/bendandedaima/p/13259284.html">HashMap为什么线程不安全（死循环+数据丢失过程分析）</a></p><h2 id="0x5-JDK1-8的HashMap中存在的问题"><a href="#0x5-JDK1-8的HashMap中存在的问题" class="headerlink" title="0x5 JDK1.8的HashMap中存在的问题"></a>0x5 JDK1.8的HashMap中存在的问题</h2><p>仍然会出现死循环以及数据丢失的问题。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">....<br><span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>    tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>...<br></code></pre></div></td></tr></table></figure><p>上述是<code>putVal</code>中的部分代码,在多线程环境下,如果线程1已经通过if检查但是被迫放弃cpu,而线程2因为hash相同已经完成了插入操作,线程1重新获取cpu,此时再进行插入就会覆盖线程2插入的线程。</p><p>数据丢失问题是多线程环境下必然产生的问题。而1.8下的死循环原因却不相同,在对链表进行树化(<code>treeify</code>)或者调整树平衡(<code>balanceInsertion</code>)时仍然会产生死循环问题。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://runzhuoli.me/2018/09/20/why-hashmap-size-power-of-2.html">为什么容量都是2的整数幂</a></p></li><li><p><a href="https://albenw.github.io/posts/df45eaf1/">关于HashMap的一些理解</a></p></li><li><p><a href="https://blog.csdn.net/reliveIT/article/details/82960063?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param">HashMap defaultLoadFactor = 0.75和泊松分布没有关系</a></p></li><li><p><a href="https://juejin.im/post/5d5d25e9f265da03f66dc517">HashMap面试必问的6个点，你知道几个</a></p></li><li><p><a href="https://www.cnblogs.com/liang1101/p/12728936.html">1.7与1.8HashMap的异同</a></p></li><li><p><a href="https://stackoverflow.com/questions/10901752/what-is-the-significance-of-load-factor-in-hashmap">1.8散列因子为0.75的可能原因</a></p></li><li><p><a href="https://www.cnblogs.com/xrq730/p/5037299.html">1.7中HashMap存在的问题</a></p></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</category>
      
      
      <category domain="https://eripe.me/tags/HashMap/">HashMap</category>
      
      
      <comments>https://eripe.me/articles/HashMap-analysis-part-one.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>HashMap源码分析(二)-插入源码</title>
      <link>https://eripe.me/articles/HashMap-analysis-part-two.html</link>
      <guid>https://eripe.me/articles/HashMap-analysis-part-two.html</guid>
      <pubDate>Mon, 14 Jun 2021 11:50:07 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;HashMap中最常用的就是&lt;code&gt;put(key,value)&lt;/code&gt;函数与&lt;code&gt;remove&lt;/code&gt;函数,而且这些函数还会包含RB树与list的相互转换,比较复杂。值得</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>HashMap中最常用的就是<code>put(key,value)</code>函数与<code>remove</code>函数,而且这些函数还会包含RB树与list的相互转换,比较复杂。值得认真推敲。</p><h2 id="1-put方法"><a href="#1-put方法" class="headerlink" title="1. put方法"></a>1. put方法</h2><p>下面JDk1.8中,HashMap的<code>put</code>源码。其又在内部调用了<code>putVal</code>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>...<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)</code>有四个参数,其中前两个参数都好理解。第三个参数<code>onlyIfAbsent</code>为一个标志位:</p><ul><li>如果为false,表示对于相同key的value会进行覆盖</li><li>为true则不会进行覆盖</li></ul><p><strong>在<code>HashMap</code>默认对相同key的value进行覆盖。</strong> 最后一个参数<code>evict</code>已在介绍<code>putEntries</code>方法时介绍过。在<code>HashMap</code>表示是否处于创建模式,<strong>默认为false</strong>。</p><p>在深入分析<code>putVal</code>方法之前,需要先了解一下<code>resize()</code>方法,下面是其源码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Initializes or doubles table size.  If null, allocates in</span><br><span class="hljs-comment">    * accord with initial capacity target held in field threshold.</span><br><span class="hljs-comment">    * Otherwise, because we are using power-of-two expansion, the</span><br><span class="hljs-comment">    * elements from each bin must either stay at same index, or move</span><br><span class="hljs-comment">    * with a power of two offset in the new table.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> the table</span><br><span class="hljs-comment">    */</span><br><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-keyword">int</span> oldThr = threshold;<br>    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//如果HashMap不为空,已经是存储过元素了才会不为空</span><br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//如果当前容量已经超过最大容量了,已经没办法扩大了,那么就只会更新存储个数的阈值,只能利用剩下的25%空间</span><br>        <span class="hljs-comment">//无需进行复制</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">//这就是常规的对容量进行扩充一倍的操作</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                    <span class="hljs-comment">//如果原始容量太小,那么threshold就会在后面进行自动计算</span><br>                    <span class="hljs-comment">//比如原始容量为4,原始threshold为3,但是newThr通过原始threshold左移一位也能正确</span><br>                    <span class="hljs-comment">//得出答案啊,为啥还要多此一举?</span><br>                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-comment">//仅仅是调用了能够设置初始容量的构造函数,但是还未put值</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;<br>    <span class="hljs-comment">//如果当前HashMap的table还未分配,也就是调用默认的无参构造函数</span><br>    <span class="hljs-comment">//此时threshold=0,就是分配默认大小的table</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//新的容量就是默认的初始化容量为16</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        <span class="hljs-comment">//设置新的threshold,新的threshold就是12</span><br>        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-comment">//执行下面if语句只会有两种情况发生,一种就是调用能够设置初始容量的构造函数但还未put元素</span><br>    <span class="hljs-comment">//另外一种就是当前HashMap已经有元素,但是当前容量小于默认容量,也就是小于16</span><br>    <span class="hljs-comment">//因为如果调用默认构造函数,那么threshold在上面已经分配</span><br>    <span class="hljs-comment">//如果HashMap中已经有元素,也会直接设置好</span><br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//通过用户的指定的容量进行threshold的计算</span><br>        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?<br>                    (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];<br>    table = newTab;<br>    <span class="hljs-comment">//已经设置好新的容量与新的threshold,如果原始HashMap不为空,那么就进行元素的复制</span><br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//逐个拷贝</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)<br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    <span class="hljs-comment">//如果是使用红黑树存储的,那么就把一棵树分裂成两颗树?这留着后面再分析</span><br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                    <span class="hljs-comment">//HashMap会把一个完整的链表分成高低两个链表,每个链表的具体个数取决元素hash的某一bit是否为1,概率各为50%,高表示当前使用的bit位为1,低表示bit位为0</span><br>                    <span class="hljs-comment">//所以理想情况下分成两个长度相等的链表</span><br><br>                    <span class="hljs-comment">//低链表的头尾</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<br>                    <span class="hljs-comment">//高链表的头尾</span><br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        <span class="hljs-comment">//尾插法</span><br>                        next = e.next;<br>                        <span class="hljs-comment">//低链表,如果当前使用的bit为0,那么就使用尾插法加入到链表中</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">//这里为什么需要判断非null呢?因为有可能运气不好,元素全部聚集到low链表或high链表中</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;<br>                        loTail.next = <span class="hljs-keyword">null</span>;<br>                        <span class="hljs-comment">//如果是low链表,那么索引就会保持原位置不动</span><br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-keyword">null</span>;<br>                        <span class="hljs-comment">//如果是high表,那么索引就会偏移原来的容量的长度</span><br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-putVal方法"><a href="#2-putVal方法" class="headerlink" title="2. putVal方法"></a>2. putVal方法</h2><p>老规矩,先把代码粘上来:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Implements Map.put and related methods.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> hash hash for key</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> key the key</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> value the value to put</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> evict if false, the table is in creation mode.</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> previous value, or null if none</span><br><span class="hljs-comment">    */</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;<br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>        <span class="hljs-comment">//前文说过,(n-1)&amp;hash等价于hash%n,不同hash的key不可能取到同一个下标</span><br>        <span class="hljs-comment">//如果还没有创建过节点,那么创建新节点放到对应桶中即可</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">//目标bucket已经有元素了,那么会有两种情况:</span><br>    <span class="hljs-comment">//要么是替换key对应的value,要么就是加入一个新节点    </span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">//这里总是首先判断目标bucket中第一个元素是否和key是用一个元素,p就是第一个元素</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k)))) <span class="hljs-comment">//@Fisrt Question</span><br>            <span class="hljs-comment">//把bucket中的第一个元素赋值给e</span><br>            e = p;<br>        <span class="hljs-comment">//如果目标bucket已经使用RB tree存储了,那么就调用TreeNode的putTreeVal方法存入新节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">//走到这里,说明bucket还是使用链表存储</span><br>        <span class="hljs-comment">//那么需要判断是加入新节点还是替换value</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">//链表已经遍历完了,还是没有找到相同的对象,说明用户的目的是插入新节点</span><br>                    <br>                    <span class="hljs-comment">//注意,Hash冲突的在这里也会执行插入,导致一条链表过长</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">//因为是从p.next开始遍历的,所以在插入第七个元素时,进行树化</span><br>                    <span class="hljs-comment">//从0开始计算，0表示第一个节点，所以如果原来本身就有8个节点，那么则会调用treeifyBin</span><br>                    <span class="hljs-comment">//但是只有table的长度达到64时，才会进行树化</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//与上面的@First Question一样,判断我们当前处理的链表节点与key是否为同一个对象</span><br>                <span class="hljs-comment">//如果是,说明用户的目的是替换value,而不是插入</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果用户目的是替换元素,那么额e就是找出来的对象,否则如果是插入新节点e就会为null</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            V oldValue = e.value;<br>            <span class="hljs-comment">//onlyIfAbsent为false允许替换元素,如果不允许替换元素,那么就看看原始value是否为null</span><br>            <span class="hljs-comment">//如果为null,那么即使onlyAbsence为true也能替换</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<span class="hljs-comment">//@second question</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//为了实现fast-fail机制</span><br>    ++modCount;<br>    <span class="hljs-comment">//如果插入后元素个数超出了存储阈值,那么就会调用resize扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>不难理解的代码都写在注释中了,这里写写比较难以理解的地方。</p><p>@First Question:为什么要这么写?</p><p>首先,<code>if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</code>这一句是在判断插入的key与bucket中的第一个key是否为同一个对象,在HashMap中判断两个对象是否为同一个需要hash相同并且对象相同。所以用<code>&amp;&amp;</code>把hash是否相同与对象是否相同的两个条件连接起来没什么问题。并且判断hash比后面的判断要快,所以把判断hash写在前面。但是判断两个对象是否相同为什么要使用<code>(key != null &amp;&amp; key.equals(k)))</code>?</p><p>因为对于引用类型,<code>==</code>比较的是对象地址。所以如果两个对象地址都相同,那么肯定是同一个对象。后面的条件是为了满足有些重写了<code>equals</code>与<code>hashCode</code>方法的类需要把逻辑上相同的两个对象认为是同一个对象。</p><p>@Second Question:<code>afterNodeAccess</code>有什么用?</p><p>追踪其实现代码,发现其其实是空函数:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// Callbacks to allow LinkedHashMap post-actions</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeInsertion</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeRemoval</span><span class="hljs-params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;<br></code></pre></div></td></tr></table></figure><p>注释里写的是给<code>LinkedHashMap</code>用作回调函数,不知道为什么HashMap里也使用这个,我们可以override这些函数,在完成插入、替换或者移除节点这些动作后执行一些通用的操作。</p><blockquote><p>Attention!!!<br>能存储在一个链表或者一颗红黑树中的,都是hash冲突的key-value,我到今天才发现!!!惭愧！！！</p></blockquote><h3 id="2-1-treeifyBin"><a href="#2-1-treeifyBin" class="headerlink" title="2.1 treeifyBin"></a>2.1 treeifyBin</h3><p><code>putVal</code>中还有一个非常重要的方法,就是<code>treeifyBin</code>,该方法将链表转化为一颗RB tree,实现代码如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Replaces all linked nodes in bin at index for given hash unless</span><br><span class="hljs-comment">    * table is too small, in which case resizes instead.</span><br><span class="hljs-comment">    */</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> hash)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, index; Node&lt;K,V&gt; e;<br>    <span class="hljs-comment">//如果tab的长度小于64,那么就会扩容,而不是树化</span><br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>        resize();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//hd是头节点,tl指向尾节点</span><br>        TreeNode&lt;K,V&gt; hd = <span class="hljs-keyword">null</span>, tl = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">//Node节点转换为TreeNode双链表</span><br>            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-keyword">null</span>);<br>            <span class="hljs-comment">//设置头节点</span><br>            <span class="hljs-keyword">if</span> (tl == <span class="hljs-keyword">null</span>)<br>                hd = p;<br>            <span class="hljs-comment">//尾插法</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                p.prev = tl;<br>                tl.next = p;<br>            &#125;<br>            tl = p;<br>        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">//因为TreeNode是Node的子列,所以将tab[index]替换成RB树的头节点</span><br>        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-keyword">null</span>)<br>            hd.treeify(tab);<br>    &#125;<br><br>    <span class="hljs-comment">// For treeifyBin</span><br>    <span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">replacementTreeNode</span><span class="hljs-params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看出,<code>treeifyBin</code>仅仅是将目标bucket的由<code>Node</code>组成的双向链表转化为由<code>TreeNode</code>组成的双向链表,具体的树化还得看双向链表的头节点<code>hd</code>的方法<code>treeify</code>。</p><h3 id="2-2-TreeNode"><a href="#2-2-TreeNode" class="headerlink" title="2.2 TreeNode"></a>2.2 TreeNode</h3><p>在深入了解<code>treeify</code>之前,我们还需要简单了解一下<code>TreeNode</code>的结构。<code>TreeNode</code>继承于<code>LinkedHashMap.Entry</code>,而<code>LinkedHashMap.Entry</code>又继承于<code>HashMap.Node</code>,最后<code>HashMap.Node</code>继承于<code>Map.Entry</code>。这一串继承下来,<code>TreeNode</code>的变量总共有11个。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    TreeNode&lt;K,V&gt; parent;  <span class="hljs-comment">// red-black tree links</span><br>    TreeNode&lt;K,V&gt; left;<br>    TreeNode&lt;K,V&gt; right;<br>    TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>    <span class="hljs-keyword">boolean</span> red;<br>    TreeNode(<span class="hljs-keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-keyword">super</span>(hash, key, val, next);<br>    &#125;<br>    ...<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>.<span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    Entry&lt;K,V&gt; before, after;<br>    Entry(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-keyword">super</span>(hash, key, value, next);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    V value;<br>    Node&lt;K,V&gt; next;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面是<code>TreeNode</code>的<code>treeify</code>方法,该方法就是将一个双向链表转化为红黑树,树化肯定要从根节点开始树化嘛。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Forms tree of the nodes linked from this node.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeify</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;<br>    TreeNode&lt;K,V&gt; root = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="hljs-keyword">this</span>, next; x != <span class="hljs-keyword">null</span>; x = next) &#123;<br>        <span class="hljs-comment">//x.next的运行时类型为TreeNode,但是静态类型为Node,所以需要强制转换</span><br>        next = (TreeNode&lt;K,V&gt;)x.next;<br>        x.left = x.right = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//还没有设置RB树的根节点,设置一哈</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            x.parent = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-comment">//根节点必为黑</span><br>            x.red = <span class="hljs-keyword">false</span>;<br>            root = x;<br>        &#125;<br>        <span class="hljs-comment">//开始放置新的树节点</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//x就是当前要放入的节点</span><br>            K k = x.key;<br>            <span class="hljs-keyword">int</span> h = x.hash;<br>            Class&lt;?&gt; kc = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;<br>                <span class="hljs-keyword">int</span> dir, ph;<br>                K pk = p.key;<br>                <span class="hljs-comment">//@First-Q</span><br>                <span class="hljs-comment">//为什么要比较hash的大小</span><br>                <span class="hljs-keyword">if</span> ((ph = p.hash) &gt; h)<br>                    dir = -<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ph &lt; h)<br>                    dir = <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//hash相等</span><br>                <span class="hljs-comment">//如果没有实现Comparable接口,那没法比了,只能调用tieBreakOrder强行比较</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((kc == <span class="hljs-keyword">null</span> &amp;&amp;(kc = comparableClassFor(k)) == <span class="hljs-keyword">null</span>) ||<br>                            <span class="hljs-comment">//实现了Comparable接口,但是二者compare的结果还是相等的</span><br>                            (dir = compareComparables(kc, k, pk)) == <span class="hljs-number">0</span>)<br>                    <span class="hljs-comment">//强行比较</span><br>                    dir = tieBreakOrder(k, pk);<br><br>                TreeNode&lt;K,V&gt; xp = p;<br>                <span class="hljs-comment">//dir&lt;=0就插入到左子树中,否则插入到右子树中,并且如果目标方向的子节点为空,才会进行插入</span><br>                <span class="hljs-comment">//否则继续向下遍历</span><br>                <span class="hljs-keyword">if</span> ((p = (dir &lt;= <span class="hljs-number">0</span>) ? p.left : p.right) == <span class="hljs-keyword">null</span>) &#123;<br>                    x.parent = xp;<br>                    <span class="hljs-keyword">if</span> (dir &lt;= <span class="hljs-number">0</span>)<br>                        xp.left = x;<br>                    <span class="hljs-keyword">else</span><br>                        xp.right = x;<br>                    <span class="hljs-comment">//平衡颜色</span><br>                    root = balanceInsertion(root, x);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//对树进行平衡调整,从根节点开始调整</span><br>    moveRootToFront(tab, root);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么其中<code>comaprableClassFor</code>是干嘛的呢?康康它的源码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Returns x&#x27;s Class if it is of the form &quot;class C implements</span><br><span class="hljs-comment">    * Comparable&lt;C&gt;&quot;, else null.</span><br><span class="hljs-comment">    */</span><br><span class="hljs-keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;<br>    <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> Comparable) &#123;<span class="hljs-comment">//如果对象x实现了Comparable接口</span><br>        Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;<br>        <span class="hljs-keyword">if</span> ((c = x.getClass()) == String.class) <span class="hljs-comment">// bypass checks</span><br>            <span class="hljs-keyword">return</span> c;<br>        <span class="hljs-comment">//ts是一个Type类型的数组</span><br>        <span class="hljs-comment">//getGenericInterfaces返回的是c直接实现的接口</span><br>        <span class="hljs-keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ts.length; ++i) &#123;<br>                <span class="hljs-comment">//如果t是一个参数化类型并且原始类型是Comparable,并且t的泛型类型中参数个数只有1个,并且参数是x.getClass()</span><br>                <span class="hljs-comment">//那么就返回x的Class对象,否则返回null</span><br>                <span class="hljs-keyword">if</span> (((t = ts[i]) <span class="hljs-keyword">instanceof</span> ParameterizedType) &amp;&amp;<br>                    ((p = (ParameterizedType)t).getRawType() ==<br>                        Comparable.class) &amp;&amp;<br>                    (as = p.getActualTypeArguments()) != <span class="hljs-keyword">null</span> &amp;&amp;<br>                    as.length == <span class="hljs-number">1</span> &amp;&amp; as[<span class="hljs-number">0</span>] == c) <span class="hljs-comment">// type arg is c</span><br>                    <span class="hljs-keyword">return</span> c;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>该方法其中就是判断类<code>c</code>是否实现了接口<code>Comparable&lt;c&gt;</code>,如果实现了,就返回<code>c</code>的<code>Class</code>对象,否则返回null。那么<code>compareComparables</code>是干嘛的?顺便康康其源码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Returns k.compareTo(x) if x matches kc (k&#x27;s screened comparable</span><br><span class="hljs-comment">    * class), else 0.</span><br><span class="hljs-comment">    */</span><br><span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span> <span class="hljs-comment">// for cast to Comparable</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareComparables</span><span class="hljs-params">(Class&lt;?&gt; kc, Object k, Object x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (x == <span class="hljs-keyword">null</span> || x.getClass() != kc ? <span class="hljs-number">0</span> :<br>            ((Comparable)k).compareTo(x));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先会比较待插入键<code>y</code>的<code>Class</code>文件<code>kc</code>与树中的节点<code>x</code>的<code>Class</code>文件是否相同,这一句就要求了如果<code>y</code>和<code>x</code>必须是同一类型,否则即使<code>y</code>实现了<code>Comaprable</code>接口也不能比较,因为我们不知道<code>x</code>是否实现了<code>Comparable</code>接口。</p><p>如果是同一类型,那么就是<code>comparaTo</code>方法比较这两个键的大小。注意这里还是有可能相等的,还是无法决定这两个键谁大谁小。那么当然还有最后一招,就是方法<code>tieBreakOrder</code>,这个方法必须抉择处待插入的节点和数中的某个节点到底谁大。那么它怎么比的?还是看源码咯。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Tie-breaking utility for ordering insertions when equal</span><br><span class="hljs-comment">* hashCodes and non-comparable. We don&#x27;t require a total</span><br><span class="hljs-comment">* order, just a consistent insertion rule to maintain</span><br><span class="hljs-comment">* equivalence across rebalancings. Tie-breaking further than</span><br><span class="hljs-comment">* necessary simplifies testing a bit.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tieBreakOrder</span><span class="hljs-params">(Object a, Object b)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> d;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-keyword">null</span> || b == <span class="hljs-keyword">null</span> ||<br>        (d = a.getClass().getName().<br>            compareTo(b.getClass().getName())) == <span class="hljs-number">0</span>)<br>        d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?<br>                -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先判断<code>a</code>或者<code>b</code>的名字谁长,名字短的排在前面。如果名字长度相等,那么计算<code>a</code>和<code>b</code>的hashCode,hash相等的话,<code>a</code>排在前面。那么<code>identityHashCode</code>是怎么计算的?</p><p>该方法就是返回对象<code>a</code>或<code>b</code>的默认hashcode,无论<code>a</code>或者<code>b</code>是否override了<code>hashCode</code>方法。<code>null</code>的<code>hashCode</code>为0。</p><p>经过上述最多三次的抉择,终于能决定待插入节点<code>x</code>和树中的节点谁大谁小了。那么抉择出来了,就可以在树中插入节点<code>x</code>了吗?当然不行,上面的代码仅仅是比较大小而已,真正插入时需要在RB树中找到一个合适的叶节点。下面的代码就是寻找合适的叶节点:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//下文中的x是待插入节点</span><br><span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;<br>    <span class="hljs-keyword">int</span> dir, ph;<br>    K pk = p.key;<br>    <span class="hljs-comment">//@First-Q</span><br>    <span class="hljs-comment">//为什么要比较hash的大小</span><br>    <span class="hljs-keyword">if</span> ((ph = p.hash) &gt; h)<br>        dir = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ph &lt; h)<br>        dir = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//hash相等</span><br>    <span class="hljs-comment">//如果没有实现Comparable接口,那没法比了,只能调用tieBreakOrder强行比较</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((kc == <span class="hljs-keyword">null</span> &amp;&amp;(kc = comparableClassFor(k)) == <span class="hljs-keyword">null</span>) ||<br>                <span class="hljs-comment">//实现了Comparable接口,但是二者compare的结果还是相等的</span><br>                (dir = compareComparables(kc, k, pk)) == <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">//强行比较</span><br>        dir = tieBreakOrder(k, pk);<br><br>    TreeNode&lt;K,V&gt; xp = p;<br>    <span class="hljs-comment">//dir&lt;=0就插入到左子树中,否则插入到右子树中,并且如果目标方向的子节点为空,这才是真正的插入点</span><br>    <span class="hljs-comment">//否则继续向下遍历寻找合适的位置 </span><br>    <span class="hljs-keyword">if</span> ((p = (dir &lt;= <span class="hljs-number">0</span>) ? p.left : p.right) == <span class="hljs-keyword">null</span>) &#123;<br>        x.parent = xp;<br>        <span class="hljs-keyword">if</span> (dir &lt;= <span class="hljs-number">0</span>)<br>            xp.left = x;<br>        <span class="hljs-keyword">else</span><br>            xp.right = x;<br>        <span class="hljs-comment">//平衡颜色</span><br>        root = balanceInsertion(root, x);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在找到插入位置并完成插入后,需要调用<code>balanceInsertion</code>平衡节点之间的颜色。这个函数是红黑树的调整的核心操作。我把注释都写在了代码中:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;K,V&gt; <span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">balanceInsertion</span><span class="hljs-params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;<br><br>    <span class="hljs-comment">//注意在JDK8中,红黑树是左右倾都存在的</span><br>    <span class="hljs-comment">//要从插入的节点x开始逐级向上调整</span><br>    <span class="hljs-comment">//插入的节点一定是红色,而且可能插在x的左侧或者右侧</span><br>    x.red = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;<br>        <span class="hljs-comment">//如果x没有父节点,那么根本不用调整</span><br>        <span class="hljs-comment">//将x的颜色设为黑色返回即可,因为x此时就是根节点</span><br>        <span class="hljs-keyword">if</span> ((xp = x.parent) == <span class="hljs-keyword">null</span>) &#123;<br>            x.red = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>        <span class="hljs-comment">//如果x的父节点xp是黑的,这时可以直接返回,因为在xp左侧插入一个红节点不影响RB的完美平衡</span><br>        <span class="hljs-comment">//或者xp是红色的,但是xp没有父节点,那么可以直接返回?</span><br>        <span class="hljs-comment">//查了一下,xp是红色但是没有父节点的情况不会出现,这样是为了给xpp赋值</span><br>        <span class="hljs-comment">//综上,如果xp是黑色,就直接返回root,因为不影响平衡性</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-comment">//只要上面的else if没返回,那么xp必是红节点,而且xpp必然存在</span><br>        <span class="hljs-comment">//因为xp为红但是xp为根节点的情况不存在</span><br>        <span class="hljs-comment">//不然这里的if判断可能会产生null</span><br>        <span class="hljs-keyword">if</span> (xp == (xppl = xpp.left)) &#123;<br>            <span class="hljs-comment">//走到这,xp就必定是左红节点，如果xpp有右子节点并且xppr为红</span><br>            <span class="hljs-comment">//此时我们就需要把xppl和xppr的红色向上传递?为什么,因为插入的x节点必是红节点,不允许连续子节点和父节点都是红节点</span><br>            <span class="hljs-comment">//这里进行向上传递红色的操作</span><br>            <span class="hljs-keyword">if</span> ((xppr = xpp.right) != <span class="hljs-keyword">null</span> &amp;&amp; xppr.red) &#123;<br>                xppr.red = <span class="hljs-keyword">false</span>;<br>                xp.red = <span class="hljs-keyword">false</span>;<br>                xpp.red = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-comment">//将xpp赋值给x是因为xpp的所有子节点已经调整好了</span><br>                <span class="hljs-comment">//这就相当于递归回溯调整颜色的过程,调整完颜色后直接从新的x节点开始继续开始下一轮循环</span><br>                x = xpp;<br>            &#125;<br><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//如果xpp有右子节点但是为黑</span><br>                <span class="hljs-comment">//或者xpp根本就没有右子节点</span><br>                <span class="hljs-comment">//总之这时已经出现了x和xp两个连续的左红节点,要么都是左红节点,或者x是右红,xp是左红</span><br><br>                <span class="hljs-keyword">if</span> (x == xp.right) &#123;<br>                    <span class="hljs-comment">//如果x是右红,那么就要先以xp为轴点进行左旋,形成x和xp都是左红的局面</span><br>                    <span class="hljs-comment">//注意,这里不是把xp赋值给x后把x传进去,而是传进去xp,顺便把xp赋值给x</span><br>                    root = rotateLeft(root, x = xp);<br>                    <span class="hljs-comment">//这里左旋x就会成为新的xp</span><br>                    <span class="hljs-comment">//这里xp=x.parent也可能是进行赋值操作?</span><br>                    <span class="hljs-comment">//xpp也是赋值操作?</span><br>                    xpp = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.parent;<br>                &#125;<br>                <span class="hljs-comment">//走到这,x和xp就一定都是左红,这里要以xpp为轴点进行右旋</span><br>                <span class="hljs-comment">//这里为毛需要判空?xp不是一定存在?</span><br>                <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">//注意,这里xp一定是红色,那么xpp必然是黑色</span><br>                    <span class="hljs-comment">//旋转后,xp会成为新的xpp,这里是将xpp的颜色赋值给xp</span><br>                    xp.red = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">if</span> (xpp != <span class="hljs-keyword">null</span>) &#123;<br>                        <span class="hljs-comment">//将xp的颜色赋值给xpp,因为xp原来是红色</span><br>                        xpp.red = <span class="hljs-keyword">true</span>;<br>                        <span class="hljs-comment">//右旋,可能会产生新的root节点</span><br>                        root = rotateRight(root, xpp);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//跟上面的插入情况差不多</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//走到这,xp必是右红节点</span><br>            <span class="hljs-comment">//将红色向上传递</span><br>            <span class="hljs-keyword">if</span> (xppl != <span class="hljs-keyword">null</span> &amp;&amp; xppl.red) &#123;<br>                xppl.red = <span class="hljs-keyword">false</span>;<br>                xp.red = <span class="hljs-keyword">false</span>;<br>                xpp.red = <span class="hljs-keyword">true</span>;<br>                x = xpp;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//如果x是左红节点</span><br>                <span class="hljs-keyword">if</span> (x == xp.left) &#123;<br>                    <span class="hljs-comment">//那么就需要以xp为轴点,向右旋,也就是把xp和x安排到一条直线上,也就是像下面这样</span><br>                    <span class="hljs-comment">//    xpp(xpp不一定有)           xpp</span><br>                    <span class="hljs-comment">//      \                         \</span><br>                    <span class="hljs-comment">//       xp  ----&gt;                 xp</span><br>                    <span class="hljs-comment">//       /                          \</span><br>                    <span class="hljs-comment">//      x                            x</span><br>                    root = rotateRight(root, x = xp);<br>                    xpp = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.parent;<br>                &#125;<br>                <span class="hljs-comment">//xp是必然存在的,xpp也是必然存在的,步知道为什么会有这两个判断</span><br>                <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;<br>                    xp.red = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">if</span> (xpp != <span class="hljs-keyword">null</span>) &#123;<br>                        xpp.red = <span class="hljs-keyword">true</span>;<br><br>                        <span class="hljs-comment">//   xpp                xp</span><br>                        <span class="hljs-comment">//    \               /  \</span><br>                        <span class="hljs-comment">//     xp -------&gt;   xpp  x</span><br>                        <span class="hljs-comment">//     \</span><br>                        <span class="hljs-comment">//      x</span><br>                        root = rotateLeft(root, xpp);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</category>
      
      
      <category domain="https://eripe.me/tags/HashMap/">HashMap</category>
      
      
      <comments>https://eripe.me/articles/HashMap-analysis-part-two.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>红黑树入门</title>
      <link>https://eripe.me/articles/red-black-tree.html</link>
      <guid>https://eripe.me/articles/red-black-tree.html</guid>
      <pubDate>Mon, 14 Jun 2021 11:50:07 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;本篇将带你一步一步了解红黑树，当然大部分内容来源于算法(第4版)一书，我仅仅对一点内容总结了自己的心得。&lt;/p&gt;
&lt;p&gt;在谈谈红黑树之前，我们先来回顾一下二叉排序树(balanced sort</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>本篇将带你一步一步了解红黑树，当然大部分内容来源于算法(第4版)一书，我仅仅对一点内容总结了自己的心得。</p><p>在谈谈红黑树之前，我们先来回顾一下二叉排序树(balanced sort tree),因为红黑树是从BST的概念演化而来的。BST的定义很简单，对于一个节点来说，左树的所有节点的值都小于当前节点的值，右树所有节点的值都大于当前节点的值。但是在最坏情况下BST的高度会达到O(N),效率太差。</p><p>我们在这里引入一个抽象的2-3树，所谓的2就是指节点只有两个指针指向子树，相应的3指的是节点中有三个指针指向子树，当然3节点中就会包含2个key。</p><p>2-3保证了一点性质：<strong>所有的空节点到达根节点的路径都是一样长的</strong>,这条性质保证了查找的复杂度在O(logN)的水平。</p><h2 id="1-2-3树的插入"><a href="#1-2-3树的插入" class="headerlink" title="1. 2-3树的插入"></a>1. 2-3树的插入</h2><p>2-3树的插入还是比较复杂的，分为插入位置在2节点还是3节点。</p><h3 id="1-1-2节点位置插入"><a href="#1-1-2节点位置插入" class="headerlink" title="1.1 2节点位置插入"></a>1.1 2节点位置插入</h3><p>2节点位置的插入比较简单，首先我们需要查找目标应该在的位置，如果查找结束于一个2节点，那么直接将目标插入结束的节点即可，下图演示了在2-3树中插入key为N的节点(按照字典序)。</p><p><img src="../images/red-black-tree/red-black-tree.drawio.svg" alt="2节点中插入新节点"></p><h3 id="1-2-3节点位置插入"><a href="#1-2-3节点位置插入" class="headerlink" title="1.2 3节点位置插入"></a>1.2 3节点位置插入</h3><p>3节点位置的插入比较复杂，分为一下三种情况：</p><ul><li>没有父节点的3节点</li><li>父节点为2节点的3节点</li><li>父节点为3节点的3节点</li></ul><p><strong>没有父节点的3节点:</strong></p><p>如果没有父节点，那么在3节点中再加入一个新值的话3节点就会升级为4节点，这在2-3树中是不允许的，采取的办法是为4节点构造一个父节点，将4节点降级为3节点，那么构造的父节点的值是多少？应该是4节点中3个值的中间数，如下图所示：</p><p><img src="../images/red-black-tree/insert-node-to-three.drawio.svg" alt="3节点位置插入-1"></p><p><strong>父节点为2节点的3节点:</strong></p><p>思路是一样的，只不过这里不再需要人为构造父节点了，只需要把4节点中三个数中的中间位置数向上传递就行了，并且将当前节点分割为两个2节点，这样父节点就会由2节点升级为3节点。如下图所示：</p><p><img src="../images/red-black-tree/insert-node-to-three-II.drawio.svg" alt="3节点位置插入-2"></p><p><strong>父节点为3节点的3节点</strong></p><p>操作与上面完全相同，有一点要记住：<strong>如果3节点是通过4节点降级得到的，那么就必须把这个3节点分割为两个2节点</strong>。因为如果不分割，退化后的3节点是不符合规则的。</p><p>经过上面讲解，可以发现有如下规律：</p><ul><li>在插入节点，不管当前位置是2节点还是3节点，我们先把值加入到这个节点中，然后再慢慢调整</li><li>如果3节点是通过4节点降级得到的，那么必须要把这个3节点分割为两个2节点</li></ul><h2 id="2-左倾红黑树"><a href="#2-左倾红黑树" class="headerlink" title="2. 左倾红黑树"></a>2. 左倾红黑树</h2><p>虽然2-3树的理解非常方便，但是代码实现起来比较困难，所以就产生了红黑树等价代替2-3树。但是红黑树都是2节点，怎么保存3节点呢？很简单，就是通过所谓的红或者黑来代替3节点。</p><p>我们通过红链接或者黑链接来表示2-3树。<strong>红链接将两个2节点连接起来构成3节点，黑链接就是普通的链接</strong>。那么这个链接是如何表示？这个颜色到底保存在哪？有如下规定：</p><p>如果a是b的子节点，且二者之间的链接是红色的，那么这个红色的信息保存在a中(也就是子节点)，也就是一个节点的颜色等于指向该节点的链接的颜色。</p><p>那么红黑树的官方定义是什么？</p><p><del>红黑树就是满足以下定义的二叉查找树</del>满足下面定义的仅仅是左倾红黑树:</p><ul><li>根节点总是黑色的</li><li>红链接均为左连接</li><li>没有任何一个节点同时和两条红链接相连</li><li>该树是完美黑色平衡的，就是所有空节点到达根节点所经历的黑链接数量是相同的，也不难理解，因为红链接的两个节点实际在一层，因为表示的是3节点</li></ul><hr><p><strong>Extensions:</strong></p><p>红黑树有很多种,左倾、右倾、或者左右倾等等,我一直以为左倾红黑树就是全部的红黑树,实际上只是因为它简单,算法第4版才会选择它进行讲解。实际上只要满足以下定义的都是红黑树:</p><ul><li>每一个节点不是红就是黑</li><li>根节点必是黑色</li><li>所有叶子节点(最底层的空节点)都是黑色</li><li>红节点的两个直接子节点必须都是黑色（换言之也就是不能同时有两个红节点相连）</li><li>从任意一个节点到到它的最底层子空节点所经过的黑节点个数都是一样的,也就是RB树是完美黑平衡的,注意,这个空节点只能是所选定的节点的子节点,而不能是它兄弟节点的空子节点。也就是任意空节点到达根节点经过的黑节点个数是相同的</li></ul><hr><p>我们如果将红黑树的红链接画平，那么就是一颗2-3树。如下图所示:</p><p><img src="../images/red-black-tree/rb-tree-and-2-3-tree.drawio.svg" alt="红黑树与2-3树的转换"></p><p>那么为了保证左倾红黑树的3条性质，我们还需要熟悉以下几项操作。</p><p><strong>保证红链接均为左链接:</strong></p><p>为了保证以上性质，我们可以采用旋转的操作：</p><p><img src="../images/red-black-tree/rb-tree-left-rotate.drawio.svg" alt="左旋操作"></p><figure class="highlight java"><figcaption><span>"左旋操作"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//返回旋转后的根节点</span><br><span class="hljs-function">Node <span class="hljs-title">rotateLeft</span><span class="hljs-params">(Node h)</span></span>&#123;<br>    Node x=h.right;<br>    h.right=x.left;<br>    x.left=h;<br>    <span class="hljs-comment">//把原来h节点的颜色赋给新的头节点</span><br>    x.color=h.color;<br>    h.color=red;<br>    x.size=h.size;<br>    h.size=<span class="hljs-number">1</span>+size(h.left)+size(h.right);<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>右旋代码是非常类似的。</p><figure class="highlight java"><figcaption><span>"右旋操作"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">Node <span class="hljs-title">rotateRight</span><span class="hljs-params">(Node h)</span></span>&#123;<br>    Node x=h.left;<br>    h.left=x.right;<br>    x.color=h.color;<br>    h.color=red;<br>    x.size=h.size;<br>    h.size=size(h.left)+size(h.right)+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>保证不会出现两条连续的红链接</strong></p><p>这个性质的实现也是通过旋转来实现的,额外的操作是可能需要进行颜色转换，因为可能出现4节点降级为两个2节点。我们需要遵守以下三条准则：</p><ul><li>如果当前节点的左子链接是黑色而右子链接为红色，那么进行对当前节点左旋</li><li>如果当前节点的左子链接是红色的，并且左子链接的左子链接也是红色的，那么将当前节点进行右旋</li><li>如果左右链接都是红色的，那么进行颜色颜色转换，将红链接向上传递。</li></ul><p>前两条规则如下图所示:</p><div align=center><img src="../images/red-black-tree/part-I.png"/></div><p>最后一条规则如下所示:</p><div align=center><img src="../images/red-black-tree/part-II.png"/></div><p>对于第一条规则我认为没有必须要求左子链接为黑色，因为不可能产生三条连续的红链接，因为都是在树底插入，在插入之前就不可能产生两条连续的红色链接，所以插入后最多产生两条连续的红链接。</p><h3 id="2-1-红黑树的插入操作"><a href="#2-1-红黑树的插入操作" class="headerlink" title="2.1 红黑树的插入操作"></a>2.1 红黑树的插入操作</h3><p>红黑树插入新节点时插入的是<strong>红节点</strong>,至于保持平衡那需要在插入之后修正。下面是红黑树的插入节点的代码,与普通的BST差别不是很大,最后需要在回溯修正节点的颜色时遵循上面规则：</p><figure class="highlight java"><figcaption><span>"红黑树插入代码"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">put</span><span class="hljs-params">(Node x,Key key,Value val)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Node(key,val,RED,<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">int</span> cmp=key.compareTo(x.key);<br>        <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>)&#123;<br>            x.left=put(x.left,key,val);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp&gt;<span class="hljs-number">0</span>)&#123;<br>            x.right=put(x.right,key,val);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            x.val=val;<br>        &#125;<br>        <span class="hljs-comment">//修正红黑树的颜色</span><br>        <span class="hljs-comment">//感觉第二个条件也不一定需要吧，只是减少了旋转的次数,如果加了左子树为黑的条件，则不会进行下一行的旋转，因为可以直接进行颜色转换</span><br>        <span class="hljs-comment">//如果删去左子树为黑的条件，那么会多余执行一次下一行的转换，再进行颜色转换，本来可以直接转的，上面做了多余一步的操作</span><br>        <br>        <span class="hljs-comment">//对于左倾红黑树，必须先左转，将红节点调整到右边</span><br>        <span class="hljs-comment">//然后再右转，最后再进行颜色传递</span><br>        <span class="hljs-keyword">if</span>(isRed(x.right)&amp;&amp; !isRed(x.left))&#123;<br>            x=rotateLeft(x);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(isRed(x.left) &amp;&amp; isRed(x.left.left))&#123;<br>            x=rotateRight(x);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(isRed(x.left) &amp;&amp; isRed(x.right))&#123;<br>            flipColor(x);<br>        &#125;<br>        x.size=size(x.left)+size(x.right)+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="2-2-红黑树的删除操作"><a href="#2-2-红黑树的删除操作" class="headerlink" title="2.2 红黑树的删除操作"></a>2.2 红黑树的删除操作</h3><p>红黑树的删除比插入还复杂些,因为红黑树是完美黑节点平衡的,所以在删除时我们就不能删除黑节点,只能删除红节点。但是如果我们想要删除的值就是黑的,怎么办？办法就是把它变红。简单来说就是不断变换颜色。直到我们的目标删除节点为红色时。</p><p>待删除的节点分两种：一种是在底部，没有子节点，像这样的节点，把它转换成红色的删除就好。另外一种就是有后继节点，为了保持树的有序性，我们采取跟BST的一样的操作，把待删除节点的后继节点找到，然后将待删除节点替换为后继节点。</p><p>总的来说：</p><ul><li>我们只能删除红节点</li><li>并且待删除节点不能是个2-节点，因为直接将2-节点删除会破坏平衡性</li></ul><p>所以在我们向下寻找待删除节点的时候，我们就必须保证当前处理的节点不是2-节点。</p><p><strong>删除最小值:</strong></p><p>这里以删除最小值为例,与BST的删除操作类似，采用递归删除。我们在每一轮递归调用时，都需要将当前节点的左子节点调整为非2-节点。如果处理节点为2-节点,这就需要:</p><ul><li>从当前的父节点(当前节点)借一个</li></ul><p><img src="../images/red-black-tree/borrow-from-parent.png" alt="borrow-from-father"></p><ul><li>或者当前节点的左子节点的兄弟节点借一个</li></ul><p><img src="../images/red-black-tree/borrow-from-bro-min.png" alt="borrow-from-bro"></p><p>步骤如下：我们首先从父节点借一个，这里所谓的借一个是将父节点的颜色变黑，两个子节点的颜色变红，也就是改造为4节点，然后我们再看左子节点的兄弟是否为非2-节点。如果是，那么就从兄弟借，把从父节点借的再还回去。然后我们进入下一轮递归调用，这样继续处理左子节点。保证了路径上的每个节点都不是2-节点,<strong>把红链接一层一层传递下去</strong>。最后删除最底层的红节点,然后再层层回溯修复节点颜色。</p><figure class="highlight java"><figcaption><span>"删除最小值"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//删除操作的大小修正都在balance中了</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteMin</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//为啥要进行这步操作，仅仅是为了假装根节点为3-节点吗？？？</span><br>        <span class="hljs-comment">//做这步操作可能是因为flipColor的写法</span><br>        <span class="hljs-comment">//因为flipColor的操作是把当前节点和两个子节点的颜色取反，如果不把根节点的颜色设红，后面的子节点没法借</span><br>        <span class="hljs-keyword">if</span>(!isRed(root.left)&amp;&amp;!isRed(root.right))&#123;<br>            root.color=RED;<br>        &#125;<br><br>        root=deleteMin(root);<br>        <span class="hljs-comment">//恢复根节点的颜色</span><br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-keyword">null</span>)&#123;<br>            root.color=BLACK;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//能够进入这个函数的当前节点一定不是2节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">deleteMin</span><span class="hljs-params">(Node h)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(h.left==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//判断当前节点的左子节点是否为3节点</span><br>        <span class="hljs-keyword">if</span>(!isRed(h.left) &amp;&amp; !isRed(h.left.left))&#123;<br>            <span class="hljs-comment">//左子节点为黑，且它的子节点为黑，表示左子节点是一个2-节点，需要借</span><br>            <span class="hljs-comment">//moveRedLeft就是调整红链接一直往左边走</span><br>            h=moveRedLeft(h);<br>        &#125;<br>        h.left=deleteMin(h.left);<br>        <span class="hljs-comment">//因为前面借节点的时候，有可能只是从父节点借了一个，</span><br>        <span class="hljs-comment">// 这样就会导致存在right-leaning的红链接，需要修正</span><br>        <span class="hljs-keyword">return</span> balance(h);<br>    &#125;<br></code></pre></div></td></tr></table></figure><p><strong>删除最大值:</strong></p><p>删除最大值类似，唯一一点不同的是，我们需要把当前节点的左子节点的红链接先翻转到右边,道理很简单。删除最小值不用这么做是因为红黑树的红链接本身就在左侧。删除最大值就是要把红链接一层一层的向底层传递直到不能传递。并且如果不把红链接翻转到右侧，右树底下的节点如果为2-节点时，他没有办法向上借了。</p><figure class="highlight java"><figcaption><span>"删除最大值"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteMax</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!isRed(root.left)&amp;&amp; !isRed(root.right))&#123;<br>            root.color=RED;<br>        &#125;<br>        root=deleteMax(root);<br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-keyword">null</span>)&#123;<br>            root.color=BLACK;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">deleteMax</span><span class="hljs-params">(Node h)</span></span>&#123;<br>        <span class="hljs-comment">//如果左链接是红色，那么就需要翻转到右边，不然右子节点下面的节点没法向它们的父节点借了</span><br>        <span class="hljs-keyword">if</span>(isRed(h.left))&#123;<br>            h=rotateRight(h);<br>        &#125;<br>        <br>        <span class="hljs-comment">//具体的删除操作，直接置空</span><br>        <span class="hljs-keyword">if</span>(h.right==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!isRed(h.right) &amp;&amp; !isRed(h.right.left))&#123;<br>            h=moveRedRight(h);<br>        &#125;<br>        h.right=deleteMax(h.right);<br>        <span class="hljs-keyword">return</span> balance(h);<br>    &#125;<br><br></code></pre></div></td></tr></table></figure><p><strong>删除任意值:</strong></p><p>删除任意值就是删除最小值与最大值的组合操作。如果想要删除的值比当前节点的值小，那么就向左继续寻找，与删除最小值类似，如果不小于当前节点的值，那么就往右走，类似于删除最大值。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Key key)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!isRed(root.left) &amp;&amp; !isRed(root.right))&#123;<br>            root.color=RED;<br>        &#125;<br>        root=delete(root,key);<br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-keyword">null</span>) &#123;<br>            root.color = BLACK;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">delete</span><span class="hljs-params">(Node h,Key key)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> cmp=key.compareTo(h.key);<br>        <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(!isRed(h.left) &amp;&amp; !isRed(h.left.left))&#123;<br>                h=moveRedLeft(h);<br>            &#125;<br>            h.left=delete(h.left,key);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//把红链接转到右边,因为原来的红链接都是左斜的，如果最大键在3-节点中，删除会导致树的不平衡,就是把红链接往右边传递</span><br>            <span class="hljs-keyword">if</span>(isRed(h.left))&#123;<br>                h=rotateRight(h);<br>            &#125;<br>            <span class="hljs-comment">//目标节点在底部</span><br>            <span class="hljs-comment">//这里只看右子节点是因为如果右子节点不为空，就说明我们找当前节点的后继节点来替换，</span><br>            <span class="hljs-comment">//如果为空，又因为当前节点必不是2-节点，所以可以放心删除</span><br>            <span class="hljs-keyword">if</span>(h.key.compareTo(key)==<span class="hljs-number">0</span> &amp;&amp; h.right==<span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>            <span class="hljs-comment">//走到这里有两种情况，要么我们需要找后继节点替换，要么目标节点在当前节点的右边</span><br>            <span class="hljs-comment">//总之都需要向右边的子节点走，所以必须提前右子节点为非2-节点</span><br>            <span class="hljs-comment">//保证要删除的值所在节点必须不能是2-节点,</span><br>            <span class="hljs-keyword">if</span>(!isRed(h.right) &amp;&amp; !isRed(h.right.left))&#123;<br>                h=moveRedRight(h);<br>            &#125;<br>            <span class="hljs-comment">//如果删除的节点不是在底部，那么就拿后继节点替换</span><br>            <span class="hljs-keyword">if</span>(key.compareTo(h.key)==<span class="hljs-number">0</span>)&#123;<br>                h.val=get(root,min(h.right).key);<br>                h.key=min(h.right).key;<br>                h.right=deleteMin(h.right);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//否则继续向右边走</span><br>                h.right=delete(h.right,key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//balance中会调整节点大小</span><br>        <span class="hljs-keyword">return</span> balance(h);<br>    &#125;<br></code></pre></div></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>普林斯顿原始论文与代码:</p><p>(<a href="https://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf">https://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf</a>)</p><p>(<a href="https://algs4.cs.princeton.edu/33balanced/RedBlackBST.java.html">https://algs4.cs.princeton.edu/33balanced/RedBlackBST.java.html</a>)</p><p>他人博客笔记:</p><p>(<a href="https://deserts.io/red-black-tree-deletion/">https://deserts.io/red-black-tree-deletion/</a>)</p><p>(<a href="https://www.jianshu.com/p/41f092a42ec1">https://www.jianshu.com/p/41f092a42ec1</a>)</p><p>(<a href="https://www.jianshu.com/p/48331a5a11f4">https://www.jianshu.com/p/48331a5a11f4</a>)</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>完整代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> tools;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LLRBTImpl</span>&lt;<span class="hljs-title">Key</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Key</span>&gt;,<span class="hljs-title">Value</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> RED =<span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> BLACK =<span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span></span>&#123;<br>        Key key;<br>        Value val;<br>        Node left;<br>        Node right;<br>        <span class="hljs-keyword">boolean</span> color;<br>        <span class="hljs-keyword">int</span> size;<br>        Node(Key key,Value val,<span class="hljs-keyword">boolean</span> color,<span class="hljs-keyword">int</span> size)&#123;<br>            <span class="hljs-keyword">this</span>.key=key;<br>            <span class="hljs-keyword">this</span>.val=val;<br>            <span class="hljs-keyword">this</span>.color=color;<br>            <span class="hljs-keyword">this</span>.size=size;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> Node root;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">(Node x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x.size;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRed</span><span class="hljs-params">(Node x)</span></span>&#123;<br>        <span class="hljs-comment">//因为有可能需要判断不存在的叶子节点的颜色</span><br>        <span class="hljs-keyword">if</span>(x==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> BLACK;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x.color== RED;<br>    &#125;<br>    <span class="hljs-comment">//左旋x的右节点必然是红色的，返回的是旋转的根节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">rotateLeft</span><span class="hljs-params">(Node h)</span></span>&#123;<br>        Node x=h.right;<br>        h.right=x.left;<br>        x.left=h;<br>        x.color=h.color;<br>        h.color=RED;<br>        x.size=h.size;<br>        h.size=size(h.left)+size(h.right)+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">rotateRight</span><span class="hljs-params">(Node h)</span></span>&#123;<br>        Node x=h.left;<br>        h.left=x.right;<br>        x.right=h;<br>        x.color=h.color;<br>        h.color=RED;<br>        x.size=h.size;<br>        h.size=size(h.left)+size(h.right)+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flipColor</span><span class="hljs-params">(Node x)</span></span>&#123;<br>        x.left.color=!x.left.color;<br>        x.right.color=!x.right.color;<br>        x.color=!x.color;<br>    &#125;<br>    <span class="hljs-comment">//返回的是插入节点后红黑树新的根节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Key key,Value val)</span></span>&#123;<br>        root=put(root,key,val);<br>        root.color=BLACK;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">put</span><span class="hljs-params">(Node x,Key key,Value val)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Node(key,val,RED,<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">int</span> cmp=key.compareTo(x.key);<br>        <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>)&#123;<br>            x.left=put(x.left,key,val);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp&gt;<span class="hljs-number">0</span>)&#123;<br>            x.right=put(x.right,key,val);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            x.val=val;<br>        &#125;<br>        <span class="hljs-comment">//修正红黑树的颜色</span><br>        <span class="hljs-comment">//感觉第二个条件也不一定需要吧，只是减少了旋转的次数</span><br>        <span class="hljs-keyword">if</span>(isRed(x.right)&amp;&amp; !isRed(x.left))&#123;<br>            x=rotateLeft(x);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(isRed(x.left) &amp;&amp; isRed(x.left.left))&#123;<br>            x=rotateRight(x);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(isRed(x.left) &amp;&amp; isRed(x.right))&#123;<br>            flipColor(x);<br>        &#125;<br>        x.size=size(x.left)+size(x.right)+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br><br>    <span class="hljs-comment">//删除操作的大小修正都在balance中了</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteMin</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//为啥要进行这步操作，仅仅是为了假装根节点为3-节点吗？？？</span><br>        <span class="hljs-comment">//做这步操作可能是因为flipColor的写法</span><br>        <span class="hljs-comment">//因为flipColor的操作是把当前节点和两个子节点的颜色取反，如果不把根节点的颜色设红，后面的子节点没法借</span><br>        <span class="hljs-keyword">if</span>(!isRed(root.left)&amp;&amp;!isRed(root.right))&#123;<br>            root.color=RED;<br>        &#125;<br><br>        root=deleteMin(root);<br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-keyword">null</span>)&#123;<br>            root.color=BLACK;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//能够进入这个函数的当前节点一定不是2节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">deleteMin</span><span class="hljs-params">(Node h)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(h.left==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//判断当前节点的左子节点是否为3节点</span><br>        <span class="hljs-keyword">if</span>(!isRed(h.left) &amp;&amp; !isRed(h.left.left))&#123;<br>            <span class="hljs-comment">//左子节点为黑，且它的子节点为黑，表示左子节点是一个2-节点，需要借</span><br>            h=moveRedLeft(h);<br>        &#125;<br>        h.left=deleteMin(h.left);<br>        <span class="hljs-comment">//因为前面借节点的时候，有可能只是从父节点借了一个，</span><br>        <span class="hljs-comment">// 这样就会导致存在right-leaning的红链接，需要修正</span><br>        <span class="hljs-keyword">return</span> balance(h);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteMax</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!isRed(root.left)&amp;&amp; !isRed(root.right))&#123;<br>            root.color=RED;<br>        &#125;<br>        root=deleteMax(root);<br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-keyword">null</span>)&#123;<br>            root.color=BLACK;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">deleteMax</span><span class="hljs-params">(Node h)</span></span>&#123;<br>        <span class="hljs-comment">//如果左链接是红色，那么就需要翻转到右边，不然右子节点下面的节点没法向它们的父节点借了</span><br>        <span class="hljs-keyword">if</span>(isRed(h.left))&#123;<br>            h=rotateRight(h);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(h.right==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!isRed(h.right) &amp;&amp; !isRed(h.right.left))&#123;<br>            h=moveRedRight(h);<br>        &#125;<br>        h.right=deleteMax(h.right);<br>        <span class="hljs-keyword">return</span> balance(h);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Key key)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!isRed(root.left) &amp;&amp; !isRed(root.right))&#123;<br>            root.color=RED;<br>        &#125;<br>        root=delete(root,key);<br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-keyword">null</span>) &#123;<br>            root.color = BLACK;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">delete</span><span class="hljs-params">(Node h,Key key)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> cmp=key.compareTo(h.key);<br>        <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(!isRed(h.left) &amp;&amp; !isRed(h.left.left))&#123;<br>                h=moveRedLeft(h);<br>            &#125;<br>            h.left=delete(h.left,key);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//把红链接转到右边,因为原来的红链接都是左斜的，如果最大键在3-节点中，删除会导致树的不平衡</span><br>            <span class="hljs-keyword">if</span>(isRed(h.left))&#123;<br>                h=rotateRight(h);<br>            &#125;<br>            <span class="hljs-comment">//目标节点在底部</span><br>            <span class="hljs-keyword">if</span>(h.key.compareTo(key)==<span class="hljs-number">0</span> &amp;&amp; h.right==<span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>            <span class="hljs-comment">//保证要删除的值所在节点必须不能是2-节点,</span><br>            <span class="hljs-keyword">if</span>(!isRed(h.right) &amp;&amp; !isRed(h.right.left))&#123;<br>                h=moveRedRight(h);<br>            &#125;<br>            <span class="hljs-comment">//如果删除的节点不是在底部，那么就拿后继节点替换</span><br>            <span class="hljs-keyword">if</span>(key.compareTo(h.key)==<span class="hljs-number">0</span>)&#123;<br>                h.val=get(root,min(h.right).key);<br>                h.key=min(h.right).key;<br>                h.right=deleteMin(h.right);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                h.right=delete(h.right,key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//balance中会调整节点大小</span><br>        <span class="hljs-keyword">return</span> balance(h);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">min</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> min(root);<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">min</span><span class="hljs-params">(Node h)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(h.left==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> h;<br>        &#125;<br>        <span class="hljs-keyword">return</span> min(h.left);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Value <span class="hljs-title">get</span><span class="hljs-params">(Key key)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> get(root,key);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Value <span class="hljs-title">get</span><span class="hljs-params">(Node h,Key key)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(h==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> cmp=key.compareTo(h.key);<br>        <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> get(h.left,key);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> get(h.right,key);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> h.val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//经过一系列反转，头节点必然发生变化，必须返回新的头节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">balance</span><span class="hljs-params">(Node x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(isRed(x.right))&#123;<br>            x=rotateLeft(x);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(isRed(x.left) &amp;&amp; isRed(x.left.left))&#123;<br>            x=rotateRight(x);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(isRed(x.left) &amp;&amp; isRed(x.right))&#123;<br>            flipColor(x);<br>        &#125;<br>        x.size=size(x.left)+size(x.right)+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-comment">//因为删除的节点必须是红节点，所以就必须把红节点往左侧移动</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">moveRedLeft</span><span class="hljs-params">(Node h)</span></span>&#123;<br>        delFlipColor(h);<br>        <span class="hljs-comment">//兄弟节点不是2-节点，可以借</span><br>        <span class="hljs-keyword">if</span>(isRed(h.right.left))&#123;<br>            h.right=rotateRight(h.right);<br>            h=rotateLeft(h);<br>            delFlipColor(h);<br>        &#125;<br>        <span class="hljs-comment">//经过上述一系列反转，头节点早就变化了</span><br>        <span class="hljs-keyword">return</span> h;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">moveRedRight</span><span class="hljs-params">(Node h)</span></span>&#123;<br>        delFlipColor(h);<br>        <span class="hljs-keyword">if</span>(isRed(h.left.left))&#123;<br>            h=rotateRight(h);<br>            delFlipColor(h);<br>        &#125;<br>        <span class="hljs-keyword">return</span> h;<br>    &#125;<br><br>    <span class="hljs-comment">//每调用一次就反转一遍当前节点及左右子节点的颜色</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delFlipColor</span><span class="hljs-params">(Node h)</span></span>&#123;<br>        h.color=!h.color;<br>        h.left.color=!h.left.color;<br>        h.right.color=!h.right.color;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>红黑树删除节点<br><a href="http://jackhuang.online/2019/08/09/red-black-tree%E7%AE%80%E4%BB%8B/">http://jackhuang.online/2019/08/09/red-black-tree%E7%AE%80%E4%BB%8B/</a></p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/java%E9%9B%86%E5%90%88/">java集合</category>
      
      
      <category domain="https://eripe.me/tags/%E7%BA%A2%E9%BB%91%E6%A0%91-map/">红黑树,map</category>
      
      
      <comments>https://eripe.me/articles/red-black-tree.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LinkedList源码分析</title>
      <link>https://eripe.me/articles/LinkedList-source-code-analysis.html</link>
      <guid>https://eripe.me/articles/LinkedList-source-code-analysis.html</guid>
      <pubDate>Mon, 14 Jun 2021 11:50:07 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;&lt;code&gt;LinkedList&lt;/code&gt;弥补了&lt;code&gt;ArrayList&lt;/code&gt;插入元素慢的缺点,当然也带了查找元素慢的缺点。&lt;code&gt;LinkedList&lt;/code&gt;同时实</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p><code>LinkedList</code>弥补了<code>ArrayList</code>插入元素慢的缺点,当然也带了查找元素慢的缺点。<code>LinkedList</code>同时实现了<code>List</code>和<code>Queue</code>接口,其底层采用双向链表实现。当然<code>LinkedList</code>也有一个父类<code>AbstractSequentialList</code>用于实现一般的方法。下面是<code>LinkedList</code>的继承图:</p><p><img src="images/LinkedList-hierarchy.png" alt="LinkedList-hierarchy"></p><p>可以看到<code>LinkedList</code>实现了<code>Cloneable</code>、<code>Serializable</code>接口,当然也是其<code>clone()</code>实现的也是shadow copy(浅拷贝)。并且<code>LinkedList</code>支持序列化。</p><h2 id="0x0-LinkedList的属性"><a href="#0x0-LinkedList的属性" class="headerlink" title="0x0 LinkedList的属性"></a>0x0 LinkedList的属性</h2><p><code>LinkedList</code>的属性非常简单,就三个:</p><ul><li>链表长度</li><li>链表头指针</li><li>链表尾指针</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//双向链表的头指针</span><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<br>    <span class="hljs-comment">//双向链表的尾指针</span><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br><br>    <span class="hljs-comment">//链表的节点定义</span><br>    <span class="hljs-comment">//非常简单,前向和后向指针,再加一个数据项</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>        E item;<br>        Node&lt;E&gt; next;<br>        Node&lt;E&gt; prev;<br><br>        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>            <span class="hljs-keyword">this</span>.item = element;<br>            <span class="hljs-keyword">this</span>.next = next;<br>            <span class="hljs-keyword">this</span>.prev = prev;<br>        &#125;<br>    &#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="0x1-LinkedList的构造方法"><a href="#0x1-LinkedList的构造方法" class="headerlink" title="0x1 LinkedList的构造方法"></a>0x1 LinkedList的构造方法</h2><p><code>LinkedList</code>的构造方法就两,一个是不带参的构造方法,另一个是使用集合初始化的构造函数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>();<br>    <span class="hljs-comment">//addAll函数应该跟ArrayList差不多</span><br>    addAll(c);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="0x2-LinkedList的重要方法"><a href="#0x2-LinkedList的重要方法" class="headerlink" title="0x2 LinkedList的重要方法"></a>0x2 LinkedList的重要方法</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>因为<code>LinkedList</code>同时实现了<code>List</code>和<code>Queue</code>接口,势必有一大堆<code>addXXX</code>、<code>offerXXX</code>、<code>removeXXX</code>、<code>pollXXX</code>方法。实现都非常简单,这里挑一些内部方法看看。</p><p>比如<code>offerLast()</code>方法内部调用<code>linkLast()</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Links e as last element.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(l, e, <span class="hljs-keyword">null</span>);<br>        last = newNode;<br>        <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)<br>            first = newNode;<br>        <span class="hljs-keyword">else</span><br>            l.next = newNode;<br>        size++;<br>        modCount++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkFirst</span><span class="hljs-params">()</span></span>&#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-comment">//在指定节点之前插入</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkBefore</span><span class="hljs-params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;<br>        ...<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>这里的<code>modCount</code>和<code>ArrayList</code>中的<code>modCount</code>差不多,每当对<code>LinkedList</code>做出结构性改变时,就会改变modCount。当然<code>LinkedList</code>也是线程不安全的,也同时实现了fast-fail机制。</p><p>回到主题,<code>linkLast</code>就是把新节点链到双向链表末尾。<code>linkFirst</code>当然同理咯。</p><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>删除头尾的方法也非常简单,没有什么特别值得关注：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//移除头节点</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">unlinkFirst</span><span class="hljs-params">(Node&lt;E&gt; f)</span> </span>&#123;<br>    <span class="hljs-comment">// assert f == first &amp;&amp; f != null;</span><br>    <span class="hljs-keyword">final</span> E element = f.item;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; next = f.next;<br>    f.item = <span class="hljs-keyword">null</span>;<br>    f.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>    first = next;<br>    <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>)<br>        last = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">else</span><br>        next.prev = <span class="hljs-keyword">null</span>;<br>    size--;<br>    modCount++;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br><br><span class="hljs-comment">//移除尾节点</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">unlinkLast</span><span class="hljs-params">(Node&lt;E&gt; l)</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-comment">//指定移除某节点</span><br><span class="hljs-function">E <span class="hljs-title">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> </span>&#123;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>在增和删的方法中我们都看到了,在指定某节点前插入、删除某个指定节点。那么这个指定是怎么获取的?</p><p>当然<code>LinkedList</code>还是贴心的实现了查找某个位置的节点:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-comment">//检查下标是否越界</span><br>    checkElementIndex(index);<br>    <span class="hljs-comment">//获取指定位置的node的value</span><br>    <span class="hljs-keyword">return</span> node(index).item;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkElementIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!isElementIndex(index))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isElementIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; size;<br>&#125;<br><span class="hljs-comment">//可以看出,node只在第一次找位置时使用了一次二分,</span><br><span class="hljs-comment">//然后使用for循环遍历一半元素,是非常慢的</span><br><span class="hljs-function">Node&lt;E&gt; <span class="hljs-title">node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-comment">// assert isElementIndex(index);</span><br><br>    <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>        Node&lt;E&gt; x = first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)<br>            x = x.next;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;E&gt; x = last;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size - <span class="hljs-number">1</span>; i &gt; index; i--)<br>            x = x.prev;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="0x3-小结"><a href="#0x3-小结" class="headerlink" title="0x3 小结"></a>0x3 小结</h2><p>因为之前分析过了<code>ArrayList</code>与<code>ArrayDeque</code>,再来分析<code>LinkedList</code>就比较简单了。</p><ul><li><code>LinkedList</code>虽然插入元素非常快,但是都快在头尾插入。如果在中间插入,就需要找到某一位置的节点,而插入操作又是非常慢的。</li><li>因为<code>LinkedList</code>没有实现<code>RandomAccess</code>接口,所以使用它实现的迭代器或者for-each遍历都比普通的for循环快。并且在遍历时不允许对<code>LinkedList</code>做出结构性改变,除非使用它自己的迭代器来改变。</li><li><code>LinkedList</code>是线程不安全的,支持fast-fail机制</li></ul>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</category>
      
      
      <category domain="https://eripe.me/tags/LinkedList/">LinkedList</category>
      
      
      <comments>https://eripe.me/articles/LinkedList-source-code-analysis.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Queue接口分析</title>
      <link>https://eripe.me/articles/Queue-interface-analysis.html</link>
      <guid>https://eripe.me/articles/Queue-interface-analysis.html</guid>
      <pubDate>Mon, 14 Jun 2021 11:50:07 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;0x1-基本概念&quot;&gt;&lt;a href=&quot;#0x1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;0x1 基本概念&quot;&gt;&lt;/a&gt;0x1</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="0x1-基本概念"><a href="#0x1-基本概念" class="headerlink" title="0x1 基本概念"></a>0x1 基本概念</h2><p><code>Queue</code>接口继承自超级接口<code>Collection</code>,其不仅实现了<code>Coolection</code>中的基本方法,而且额外增加了适用于队列的增、删、差方法。并且对应这三种操作,Queue提供了两套方法,一套在操作失败时抛出异常,另一套在操作失败时返回<code>null</code>,不过在文档中说到:</p><blockquote><p>The latter form of the insert operation is designed specifically for use with capacity-restricted Queue implementations</p></blockquote><p>说是后者是专门为容量有限的队列而设计的,why?这点不是很懂。</p><p>更新:2020-07-23 19:12:32</p><p>现在懂了,如果对于<strong>容量有限</strong>的队列,比如<code>ArrayBlockingQueue</code>,它是继承自抽象类<code>AbstractQueue</code>,如果调用其<code>offer</code>方法(在<code>AbstractQueue</code>中实现),添加元素失败后只会返回true,否则返回false。而调用<code>add</code>的话,如果插入失败,就会抛出状态异常。所以说,offer类方法可用于检查队列是否已满,比add类方法优秀点。但是对于<code>LinkedList</code>、<code>ArrayQueue</code>等带自动扩容属性的队列来说,二者效果差不多,不过offer类可以返回操作是否成功的信息。还是推荐使用offer类。</p><p>两组方法如下图所示:</p><p><img src="images/methods.png" alt="methods"></p><h2 id="0x2-抽象类AbstractQueue"><a href="#0x2-抽象类AbstractQueue" class="headerlink" title="0x2 抽象类AbstractQueue"></a>0x2 抽象类AbstractQueue</h2><p>当然,跟<code>Collection</code>接口差不多,<code>Queue</code>也有一个抽象类用于实现一般的方法:</p><figure class="highlight java"><figcaption><span>"AbstractQueue"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractCollection</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    ...<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>可以看到,因为<code>Queue</code>本身就继承自<code>Clooection</code>,所以<code>AbstractQueue</code>的实现继承自<code>AbstractClloection</code>没有任何异议吧。当然为了实现了Queue的特有方法,也实现了接口<code>Queue</code>。下面简单分析一下<code>offer()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (offer(e))<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Queue full&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>add在内部调用了offer,所以用谁不用我多说了吧。不过一开始我看到写法还是一愣,这<code>offer()</code>方法的实现在哪啊?</p><p>后来一想,抽象类不一定要实现嘛,把这个方法留到子类去实现也行奥。</p><h2 id="0x3-Deque接口"><a href="#0x3-Deque接口" class="headerlink" title="0x3 Deque接口"></a>0x3 Deque接口</h2><p>Deque就是<code>double ended queue</code>,也就是所谓的双端队列,什么是双端队列我就不说了,来看看其规定的抽象方法:</p><figure class="highlight java"><figcaption><span>"Deque"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <br>    <span class="hljs-comment">//双端队列方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(E e)</span></span>;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offerFirst</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offerLast</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">removeLast</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">pollFirst</span><span class="hljs-params">()</span></span>;<br> <br>    <span class="hljs-function">E <span class="hljs-title">pollLast</span><span class="hljs-params">()</span></span>;<br> <br>    <span class="hljs-function">E <span class="hljs-title">getFirst</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">getLast</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">peekFirst</span><span class="hljs-params">()</span></span>;<br> <br>    <span class="hljs-function">E <span class="hljs-title">peekLast</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">removeFirstOccurrence</span><span class="hljs-params">(Object o)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">removeLastOccurrence</span><span class="hljs-params">(Object o)</span></span>;<br><br>    <span class="hljs-comment">// 单向队列方法</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">element</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>;<br><br><br>    <span class="hljs-comment">//栈方法</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//重写Collection的部分方法</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Iterator&lt;E&gt; <span class="hljs-title">descendingIterator</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br><br></code></pre></div></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</category>
      
      
      <category domain="https://eripe.me/tags/Queue/">Queue</category>
      
      
      <comments>https://eripe.me/articles/Queue-interface-analysis.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ArrayList源码分析</title>
      <link>https://eripe.me/articles/ArrayList-source-code-analysis.html</link>
      <guid>https://eripe.me/articles/ArrayList-source-code-analysis.html</guid>
      <pubDate>Mon, 14 Jun 2021 11:50:07 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分析源码初体验，第一次分析个比较简单的集合类ArrayList。我把重点放在了ArrayList实现的接口、继承的类以及几个主要的类方法上。</p><h2 id="0x0-ArrayList继承图"><a href="#0x0-ArrayList继承图" class="headerlink" title="0x0 ArrayList继承图"></a>0x0 ArrayList继承图</h2><p>我们首先来看看ArrayList中的继承图。</p><p><img src="images/arrayList-hierarchy.png" alt="ArrayList继承图"></p><p><code>ArrayList</code>继承自抽象类<code>AbstractList</code>,并且实现了<code>RandomAccess</code>、<code>Cloneable</code>、<code>Seriablizable</code>、<code>List</code>接口。</p><p>这里我首先有了两个疑惑:</p><ul><li>接口与ArrayList之间为什么隔了一个抽象类<code>AbstractList</code>?</li><li>抽象类<code>AbstractList</code>已经实现了<code>List</code>接口，为什么ArrayList又实现了一遍？</li></ul><p>对于<strong>第一个</strong>问题可以从设计模式的角度回答，因为接口<code>List</code>中的抽象方法是非常多的，如果<code>ArrayList</code>直接实现了该接口，那么<code>ArrayList</code>必须实现<code>List</code>中的所有抽象方法，尽管有些方法用不到。那么为了解决这个问题，JDK在接口与实现类中间添加一个抽象类，虽然抽象类不能生成对象，但是也可以实现接口中的抽象方法的，JDK中的AbstractList实现了一些非常非常通用的方法。ArrayList来继承上述的抽象类，这样ArrayList仅需实现AbstractList中没有实现的抽象方法，对于AbstractList已经实现的抽象方法，ArrayList可以自由选择实现与否。</p><p>也就是说抽象类AbstractList给了ArrayList需要实现的抽象方法的选择空间。</p><p>对于<strong>第二个</strong>问题,答案获取有些不那么令人信服，经过网上资料查阅，说是JDK的开发人员人为ArrayList实现List接口可能会对后序的开发有帮助，久而久之，就一直延续下来，造成了现在的局面。</p><p>ok，这两个问题解决了，我们继续向下探索。</p><h2 id="0x1-ArrayList实现的接口"><a href="#0x1-ArrayList实现的接口" class="headerlink" title="0x1 ArrayList实现的接口"></a>0x1 ArrayList实现的接口</h2><p>ArrayList实现了<code>RandomAccess</code>、<code>List</code>、<code>Cloneable</code>、<code>Serializable</code>接口。</p><p><strong>RandomAccess接口:</strong></p><p>这个<code>RandomAccess</code>是一个marker interface(该接口内什么都没有实现，仅仅是作为一个标记接口)。简单来说，实现了该接口的类就一定拥有随机访问的能力。所以我们在遍历一个类的时候，建议我们首先使用<code>instanceOf</code>判断当前类是否为<code>RandomAccess</code>的实现类，如果时，那么采用for循环(普通for循环，而不是增强型for循环，因为增强型内部也是使用迭代器)遍历比采用迭代器的平均性能更好。</p><p><strong>List接口:</strong></p><p>上一小节已经回答了该问题，开发人员的笔误。 :)</p><p><strong>Cloneable接口:</strong></p><p>虽然官方文档没有说明该接口是marker interface,但我感觉作用差不多，实现了该接口的类，那么该类的<code>clone</code>方法就是可用的，允许对象的字段复制。</p><p><strong>Serializable接口:</strong></p><p>作用也相当于一个marker interface，标识实现类是可序列化与反序列化的。</p><h2 id="0x2-ArrayList中的重要属性与方法"><a href="#0x2-ArrayList中的重要属性与方法" class="headerlink" title="0x2 ArrayList中的重要属性与方法"></a>0x2 ArrayList中的重要属性与方法</h2><h3 id="0x2-1-ArrayList的属性"><a href="#0x2-1-ArrayList的属性" class="headerlink" title="0x2-1 ArrayList的属性"></a>0x2-1 ArrayList的属性</h3><p>ArrayList的属性不是很多，但是有一个非常重要的属性<code>modCount</code>，继承自抽象类<code>AbstractList</code>，这个属性保证了fast-fail机制,这会在后面讲解方法的时候提到。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//序列化ID</span><br><span class="hljs-meta">@java</span>.io.Serial<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">8683452581122892189L</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Default initial capacity.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//ArrayList的默认大小为10</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Shared empty array instance used for empty instances.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//这个和下面的区别就是采用无参构造函数时使用这个，大小为0的Object数组</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Shared empty array instance used for default sized empty instances. We</span><br><span class="hljs-comment"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span><br><span class="hljs-comment"> * first element is added.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//下面这个数组是在采用提供大小的构造函数但是提供的参数有误时使用的</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The array buffer into which the elements of the ArrayList are stored.</span><br><span class="hljs-comment"> * The capacity of the ArrayList is the length of this array buffer. Any</span><br><span class="hljs-comment"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="hljs-comment"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">//这个数组是实际存储元素的数组，不知道为什么不是private的啊，按道理来说即使是private也不影响内部类访问啊。</span><br><span class="hljs-comment">//注意这个数组是不参与序列化的</span><br><span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// non-private to simplify nested class access</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The size of the ArrayList (the number of elements it contains).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//List的大小是参与序列化的哦</span><br><br> <span class="hljs-comment">//存储的是数组实际的元素个数,并不是数组的长度</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br></code></pre></div></td></tr></table></figure><h3 id="0x2-2-ArrayList中的重要方法"><a href="#0x2-2-ArrayList中的重要方法" class="headerlink" title="0x2-2 ArrayList中的重要方法"></a>0x2-2 ArrayList中的重要方法</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>ArrayList中的构造方法有三个:</p><ul><li>默认无参构造方法</li><li>初始化容量的构造方法</li><li>使用集合初始化的构造方法</li></ul><p>第一个构造方法没什么好说的,就是使用<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>初始化一个空的Object数组。数组的默认长度为10.</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>第二个构造方法提供了一个容量参数,参数必须&gt;=0,否则会抛出非法参数异常。如果容量大小为0,那么则使用<code>EMPTY_ELEMENTDATA</code>初始化数组,容量为0。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                               initialCapacity);<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>最后一个构造方法使用一个Collection初始化ArrayList,</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>        elementData = c.toArray();<br>        <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br>            <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>                <span class="hljs-comment">//如果c.toArray返回的不是Object数组,那么则需要使用数组工具类的copy方法一个一个复制元素</span><br>                elementData = Arrays.copyOf(elementData, size, Object[].class);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// replace with empty array.</span><br>            <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>这里需要提一嘴Arrays中的<code>copyOf</code>方法,其中的一个小问题困扰了我很长时间,下面是Arrays中其中一个的<code>copyOf</code>的源码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="hljs-keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    T[] copy = ((Object)newType == (Object)Object[].class) ?<br>            (T[]) <span class="hljs-keyword">new</span> Object[newLength] :<br>            (T[]) Array.newInstance(newType.getComponentType(), newLength);<br>    System.out.println((Object)newType.toString());<br>    System.arraycopy(original, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>,<br>                        Math.min(original.length, newLength));<br>    <span class="hljs-keyword">return</span> copy;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我一直不理解为什么需要加上<code>((Object)newType == (Object)Object[].class)</code>这一句判断，在stackoverflow上看到了一个<a href="https://stackoverflow.com/questions/29494800/do-not-understand-the-source-code-of-arrays-copyof">答案</a>,回答说这句话的目的就是检查<code>newType</code>是否持有一个<code>Object[]</code>类型的引用,可是这里的newType只有非基本类型的Class对象传进来才能编译成功,否则就会出现无法推断泛型的准确类型???</p><p>我好像又懂了,虽然代码里写的是强转Object,但是在运行时<code>==</code>比较的是等号两边指的是否为同一个对象,并不是说,我们在代码里把它转成Object了,在运行时两边比较的就是Object。</p><p>所以<code>((Object)newType == (Object)Object[].class)</code>之所以要进行强转,是因为由于泛型的原型，两边本身就不是同一个type,所以使用<code>==</code>比较编译根本就无法通过(所以说<code>==</code>的两侧必须是同一个类型编译才能通过?)。</p><p>ok,第二个困惑我的原因就很搞笑了,我原来调试的时候这句代码的执行结果一直是true,尽管我传进来的是<code>Integer[].class</code>,这我就纳了闷了,我就寻思那这句代码不是废话?既然只能传对象的Class,那不是恒成立,后来再调试的偶然瞬间发现,在调试copyOf的时候,调用这个api的函数根本就不是我写的,怪不得一直Object,不管传进来的是什么…这个错误着实搞笑,后来我直接从用户代码step into,嗯，结果对了，上述这句代码的结果为false,舒服了。</p><p>最后说说为什么要有这句代码,是因为直接new比采用newInstance快,因为newInstance使用了反射,<a href="https://stackoverflow.com/questions/29494800/do-not-understand-the-source-code-of-arrays-copyof">参考：</a></p><blockquote><p>new Object[…] creates an array the normal way, of a type that is statically known. Remember, the code has just checked that T[] is Object[].</p></blockquote><blockquote><p>Array.newInstance(…) uses reflection to dynamically create an array of the Class type passed in.</p></blockquote><p><code>copyOf</code>方法是会构建一个新的数组来存放元素的拷贝,当然需要说明:<strong>copyOf是浅拷贝!!!</strong></p><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>ArrayList的add方法挺多的，我将按照我的使用频率依次讲解。</p><p>首先是<code>add (E e)</code>方法:</p><figure class="highlight java"><figcaption><span>"add(E e)"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        modCount++;<br>        add(e, elementData, size);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>该方法首先将modCount加1,因为add方法使ArrayList发生了结构性改变,这会在后面说到,方法内部又调用了add的重载函数,</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e, Object[] elementData, <span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s == elementData.length)<br>        elementData = grow();<br>    elementData[s] = e;<br>    size = s + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先判断ArrayList的属性<code>size</code>是否达到了<code>elementData</code>的长度,这说明<code>size</code>属性并不是实时更新,size是数组实际存储的元素个数，应该会在elemeData扩张的时候更新。如果已经没有空间存放新元素了,就调用<code>grow</code>函数。其又会调用grow的带参重载函数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//此时size==elementData.length</span><br><span class="hljs-keyword">private</span> Object[] grow() &#123;<br>    <span class="hljs-keyword">return</span> grow(size + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//minCapacity是我们能够允许的最小的新的数组空间,也就是多一个</span><br><span class="hljs-keyword">private</span> Object[] grow(<span class="hljs-keyword">int</span> minCapacity) &#123;<br>    <span class="hljs-keyword">int</span> oldCapacity = elementData.length;<br>    <span class="hljs-comment">//如果数组中已经存在元素或者并不是调用默认构造函数创建对象</span><br>    <span class="hljs-comment">//那么我们可能会扩充至原始的1.5倍,为什么用可能,需要看具体的获取大小的函数</span><br>    <span class="hljs-keyword">if</span> (oldCapacity &gt; <span class="hljs-number">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        <span class="hljs-keyword">int</span> newCapacity = ArraysSupport.newLength(oldCapacity,<br>                minCapacity - oldCapacity, <span class="hljs-comment">/* minimum growth */</span><br>                oldCapacity &gt;&gt; <span class="hljs-number">1</span>           <span class="hljs-comment">/* preferred growth */</span>);<br>        <span class="hljs-keyword">return</span> elementData = Arrays.copyOf(elementData, newCapacity);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//否则如果我们原始大小为0,那么就扩充为10个长度</span><br>        <span class="hljs-keyword">return</span> elementData = <span class="hljs-keyword">new</span> Object[Math.max(DEFAULT_CAPACITY, minCapacity)];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>获取数组新容量的函数如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">newLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span> oldLength, <span class="hljs-keyword">int</span> minGrowth, <span class="hljs-keyword">int</span> prefGrowth)</span> </span>&#123;<br>        <span class="hljs-comment">// assert oldLength &gt;= 0</span><br>        <span class="hljs-comment">// assert minGrowth &gt; 0</span><br><br>        <span class="hljs-comment">//在最小增长大小和最适应增当大小之间选一个,并加上原来的大小,不出意外就是扩充为原来的1.5倍</span><br>        <span class="hljs-keyword">int</span> newLength = Math.max(minGrowth, prefGrowth) + oldLength;<br>        <span class="hljs-comment">//如果计算出的新大小没有超过MAX_ARRAY_LENGTH=Integer.MAX_VALUE-8</span><br>        <span class="hljs-comment">//那么就返回新计算出的大小</span><br>        <span class="hljs-comment">//否则就继续扩充,最大扩容至Integer.MAX_VALUE</span><br>        <span class="hljs-keyword">if</span> (newLength - MAX_ARRAY_LENGTH &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> newLength;<br>        &#125;<br>        <span class="hljs-keyword">return</span> hugeLength(oldLength, minGrowth);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span> oldLength, <span class="hljs-keyword">int</span> minGrowth)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> minLength = oldLength + minGrowth;<br>        <span class="hljs-keyword">if</span> (minLength &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError(<span class="hljs-string">&quot;Required array length too large&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (minLength &lt;= MAX_ARRAY_LENGTH) &#123;<br>            <span class="hljs-keyword">return</span> MAX_ARRAY_LENGTH;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Integer.MAX_VALUE;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>上面的ArrayList源码是JDK14的,和JDK8还是有点区别的,不过差别不大,都是将容量扩充到原来的1.5倍，而size只是简单的记录数组中元素的数量。</p><h4 id="toArray方法"><a href="#toArray方法" class="headerlink" title="toArray方法"></a>toArray方法</h4><p>还有一个我经常使用的方法<code>toArray</code>,这下顺便看到了真面目,如果使用无参的<code>toArray</code>,那么因为调用的是copyOf,返回了原始数组的浅拷贝副本,<del>也是Object数组</del>。该方法不一定会返回Object[]。<br>因为子类对象是可以使用父类引用保持的。具体类型取决于list中的数据类型。如下 代码所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object[] toArray() &#123;<br>    <span class="hljs-keyword">return</span> Arrays.copyOf(elementData, size);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="hljs-keyword">int</span> newLength) &#123;<br>    <span class="hljs-comment">//这里的original就是elementData</span><br>    <span class="hljs-keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果使用的是带参的<code>toArray</code>,那么参数就是我们想要该函数返回的数组类型,比如<code>toArray(new Integer[0])</code>,这里的数组长度无所谓了,反正都会创建一个数组,还有这个传入数组的类型,应该必须是非基本类型,不然又会出现类型无法推导的错误。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object[] toArray() &#123;<br>        <span class="hljs-keyword">return</span> Arrays.copyOf(elementData, size);<br>    &#125;<br><br><span class="hljs-keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;<br>        <span class="hljs-keyword">if</span> (a.length &lt; size)<br>            <span class="hljs-comment">// Make a new array of a&#x27;s runtime type, but my contents:</span><br>            <span class="hljs-keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());<br>        System.arraycopy(elementData, <span class="hljs-number">0</span>, a, <span class="hljs-number">0</span>, size);<br>        <span class="hljs-keyword">if</span> (a.length &gt; size)<br>            a[size] = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="0x3-ArrayList中的迭代器"><a href="#0x3-ArrayList中的迭代器" class="headerlink" title="0x3 ArrayList中的迭代器"></a>0x3 ArrayList中的迭代器</h2><p>为什么要讲迭代器呢?因为我想讲讲不能在使用迭代器遍历list时删除元素的原因。<code>AbstractList</code>中有一个叫做<code>modCount</code>的属性,在初次构建list对象时初始化为0。</p><blockquote><p>protected transient int modCount = 0;</p></blockquote><p>在我们对list做出结构性改变时,modCount也会改变。所谓的结构性改变是指list中元素个数发生了变化。</p><figure class="highlight java"><figcaption><span>"JDK8"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//add函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-comment">//每次增加元素时都需要确保仍然有空间保存元素</span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    <span class="hljs-comment">//添加元素时modCount加1</span><br>    modCount++;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br><br><span class="hljs-comment">//remove函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    rangeCheck(index);<br>    <span class="hljs-comment">//list元素减少时,modCount加1</span><br>    modCount++;<br>    E oldValue = elementData(index);<br><br>    <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                         numMoved);<br>    elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br><br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到只要对list做增删操作,那么就会使modCount发生改变。ok,那我们接下来看看ArrayList内部类实现的迭代器。</p><figure class="highlight java"><figcaption><span>"ArrayList内部实现的迭代器"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">int</span> cursor;       <span class="hljs-comment">// index of next element to return</span><br>    <span class="hljs-keyword">int</span> lastRet = -<span class="hljs-number">1</span>; <span class="hljs-comment">// index of last element returned; -1 if no such</span><br>    <span class="hljs-comment">//使用modCount初始化expectedModCount</span><br>    <span class="hljs-keyword">int</span> expectedModCount = modCount;<br><br>    Itr() &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cursor != size;<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        checkForComodification();<br>        <span class="hljs-keyword">int</span> i = cursor;<br>        <span class="hljs-keyword">if</span> (i &gt;= size)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>        Object[] elementData = ArrayList.<span class="hljs-keyword">this</span>.elementData;<br>        <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>        cursor = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>    &#125;<br><br>    <span class="hljs-comment">//检查expectedModCount的值是否发生改变</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkForComodification</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>    &#125;<br>...<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到,在使用迭代器的<code>next()</code>时,代码会首先检查modCount是否发生改变,那么在什么情况下modCount会发生改变?就是我们在自己额外调用例如<code>add()</code>、<code>remove()</code>改变list元素个数的方法时会改变modCount,所以如果在使用迭代器遍历的时候如果改变list的元素个数时,会抛出ConcurrentModificationException。<strong>这就是所谓的fail-fast</strong>。</p><p>如果在多线程环境下,其他线程有可能在当前线程遍历的同时对list做出结构性改变,所以ArrayList不是线程安全的。也会抛出同样的异常。</p><p>在使用迭代器遍历时,注意如果我们仅仅是改变元素的内容,而不改变元素个数的操作是允许的。ok,问题提出来了,那么如何再使用迭代器遍历的时候增删元素?</p><p>当然是调用迭代器的自己的<code>remove</code>方法了奥。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//这个单向迭代器只能删除当前获取的元素</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();<br>    checkForComodification();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//在检查完modCount之后,再调用remove方法</span><br>        ArrayList.<span class="hljs-keyword">this</span>.remove(lastRet);<br>        cursor = lastRet;<br>        lastRet = -<span class="hljs-number">1</span>;<br>        expectedModCount = modCount;<br>    &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面是一个使用的小栗子👀</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testRemove</span><span class="hljs-params">()</span></span>&#123;<br>    ArrayList&lt;Integer&gt; t=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    t.add(<span class="hljs-number">1</span>);<br>    t.add(<span class="hljs-number">2</span>);<br>    t.add(<span class="hljs-number">3</span>);<br>    Iterator&lt;Integer&gt; it=t.iterator();<br>    <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>        <span class="hljs-keyword">if</span>(it.next()==<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-comment">//</span><br>            it.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="0x4-小结"><a href="#0x4-小结" class="headerlink" title="0x4 小结"></a>0x4 小结</h2><p>关于ArrayList的源码就分析到这里了,后续如果有什么没想到的应该会补充的奥。👼</p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</category>
      
      
      <category domain="https://eripe.me/tags/ArrayList/">ArrayList</category>
      
      
      <comments>https://eripe.me/articles/ArrayList-source-code-analysis.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ArrayQueue与ArrayDeque源码分析</title>
      <link>https://eripe.me/articles/ArrayQueue-and-ArrayDeque-analysis.html</link>
      <guid>https://eripe.me/articles/ArrayQueue-and-ArrayDeque-analysis.html</guid>
      <pubDate>Mon, 14 Jun 2021 11:50:07 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里将<code>ArrayQueue</code>与<code>ArrayDeque</code>放在一起分析是因为二者都是基于数组实现的队列。</p><h2 id="0x0-小试牛刀-ArrayQueue源码分析"><a href="#0x0-小试牛刀-ArrayQueue源码分析" class="headerlink" title="0x0 小试牛刀-ArrayQueue源码分析"></a>0x0 小试牛刀-ArrayQueue源码分析</h2><p>在进入主题之前我们思考一个问题,如果我们用数组实现一个传统的FIFO队列,是有可能出现数组未满,但是队列已满的假象的。这是因为我们在不断弹出元素的同时,队列的头指针就会不断朝着队列尾部的方向移动,那么头指针之前的空间就被浪费了,而采用链表实现的队列就不会出现这种情况。</p><p>为了解决上述的问题,我们采用循环数组的方式实现单项队列。所谓的循环数组,就是逻辑上数组的头和尾是连接在一起的,我们维护一个头指针和一个尾指针。那么为了我们能够知道什么时候数组被填充满了,我们需要使用额外的一个元素空间来标记队列是否真的满了。如果队列真的满了,那么头指针和尾指针就会重合。否则头指针和尾指针之间至少会有一个元素的空闲空间大小,如下图所示:</p><p><img src="images/circular-queue.drawio.svg" alt="循环队列示意图"></p><p>接下来进入主题,简要分析以下它的源码。</p><p>下面是<code>ArrayQueue</code>的构造函数:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayQueue</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br>    <span class="hljs-keyword">private</span> T[] queue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> head;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tail;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.capacity = capacity + <span class="hljs-number">1</span>;<span class="hljs-comment">//把额外用作标记的空间加上</span><br>        <span class="hljs-keyword">this</span>.queue = newArray(capacity + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">this</span>.head = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.tail = <span class="hljs-number">0</span>;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到,<code>ArrayQueue</code>是通过数组<code>queue</code>保存内容的。其中维持了两个指针<code>head</code>和<code>tail</code>。capacity表示队列的容量。在构造函数中,可以看到会对<code>capacity</code>加1,这是为什么?还记得上面说过的循环队列需要使用的额外的一个元素空间来标记队列是否满了?没错,这个加1就是把那个额外空间加上了。</p><p>接下来看看它的<code>add</code>函数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(T o)</span> </span>&#123;<br>    queue[tail] = o;<br>    <span class="hljs-keyword">int</span> newtail = (tail + <span class="hljs-number">1</span>) % capacity;<br>    <span class="hljs-keyword">if</span> (newtail == head)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">&quot;Queue full&quot;</span>);<br>    tail = newtail;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <span class="hljs-comment">// we did add something</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>ArrayQueue</code>因为是单项队列,所以只能从队尾进元素,然后tail指针取模向后移动一个。很可惜,<code>add</code>方法并不会自动扩容,在队列满后,会抛出指针异常,但是我们可以手动调用<code>resize()</code>方法进行扩容,很麻烦。所以没人用是正常的。接下来看看<code>resize()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newcapacity)</span> </span>&#123;<br>    <span class="hljs-comment">//获取当前队列内的元素个数</span><br>    <span class="hljs-keyword">int</span> size = size();<br>    <span class="hljs-keyword">if</span> (newcapacity &lt; size)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">&quot;Resizing would lose data&quot;</span>);<br>    <span class="hljs-comment">//仍然需要把标记空间加上</span><br>    newcapacity++;<br>    <span class="hljs-keyword">if</span> (newcapacity == <span class="hljs-keyword">this</span>.capacity)<br>        <span class="hljs-keyword">return</span>;<br>    T[] newqueue = newArray(newcapacity);<br>    <span class="hljs-comment">//将原始队列中的元素复制到新队列中,从新队列的0位置开始复制</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>        newqueue[i] = get(i);<br>    <span class="hljs-keyword">this</span>.capacity = newcapacity;<br>    <span class="hljs-keyword">this</span>.queue = newqueue;<br>    <span class="hljs-keyword">this</span>.head = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">this</span>.tail = size;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Can&#x27;t use % here because it&#x27;s not mod: -3 % 2 is -1, not +1.</span><br>    <span class="hljs-comment">//在java中负数取模的结果符号与被取模的数符号相同</span><br>    <span class="hljs-keyword">int</span> diff = tail - head;<br>    <span class="hljs-keyword">if</span> (diff &lt; <span class="hljs-number">0</span>)<br>        diff += capacity;<br>    <span class="hljs-keyword">return</span> diff;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> size = size();<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= size) &#123;<br>        <span class="hljs-keyword">final</span> String msg = <span class="hljs-string">&quot;Index &quot;</span> + i + <span class="hljs-string">&quot;, queue size &quot;</span> + size;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(msg);<br>    &#125;<br>    <span class="hljs-comment">//加上偏移量head,就能准确定位老队列中的元素了</span><br>    <span class="hljs-keyword">int</span> index = (head + i) % capacity;<br>    <span class="hljs-keyword">return</span> queue[index];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>单项队列<code>ArrayQueue</code>的源码还是比较简单的,下面才是这篇文章的核心。</p><h2 id="0x1-主菜-ArrayDeque源码分析"><a href="#0x1-主菜-ArrayDeque源码分析" class="headerlink" title="0x1  主菜-ArrayDeque源码分析"></a>0x1  主菜-ArrayDeque源码分析</h2><h3 id="0x1-1-重要字段与构造函数"><a href="#0x1-1-重要字段与构造函数" class="headerlink" title="0x1-1 重要字段与构造函数"></a>0x1-1 重要字段与构造函数</h3><p>双向队列<code>ArraDeque</code>底层也是数组实现的,当然与<code>ArrayQueue</code>一样,采用循环数组。下面是<code>ArrayDeque</code>的字段与构造方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayDeque</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractCollection</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">                           <span class="hljs-keyword">implements</span> <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span></span><br><span class="hljs-class"></span>&#123;<br><br>     <span class="hljs-comment">//底层采用object类型数组保存元素,双向队列的容量就是该数组的长度,并且总是2的倍数</span><br>     <span class="hljs-comment">//数组永远都不会填满,并且没有用于储存队列元素的数组元素都必定为null</span><br>    <span class="hljs-keyword">transient</span> Object[] elements; <span class="hljs-comment">// non-private to simplify nested class access</span><br><br>    <span class="hljs-comment">//双端队列的头指针,只有队列中没有存储元素时head才会与tail相遇</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> head;<br><br>    <span class="hljs-comment">//双端队列的尾指针,指向下一个元素的存储位置</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> tail;<br><br>    <span class="hljs-comment">//默认最小容量为8</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_INITIAL_CAPACITY = <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">//无参构造方法</span><br>    <span class="hljs-comment">//队列为空,那么就将队列扩充为16</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayDeque</span><span class="hljs-params">()</span> </span>&#123;<br>        elements = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">16</span>];<br>    &#125;<br><br>    <span class="hljs-comment">//指定初始容量的构造方法,但是都会把容量升级为最小的2的倍数</span><br>    <span class="hljs-comment">//allocateElements用于升级容量至最小的2的倍数,这将在后面详解</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayDeque</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numElements)</span> </span>&#123;<br>        allocateElements(numElements);<br>    &#125;<br><br>    <span class="hljs-comment">//使用一个集合初始化队列,但是还是首先会把容量扩充至最最近的2的倍数,</span><br>    <span class="hljs-comment">//然后再将原集合中的左右元素拷贝至队列中</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayDeque</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>        allocateElements(c.size());<br>        addAll(c);<br>    &#125;<br><br></code></pre></div></td></tr></table></figure><p>可以看到,最重要的就是扩充容量函数<code>allocateElements</code>,这个函数比较复杂,有点难理解。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//该函数内部调用了calculateSize计算新的容量(计算最近的2的倍数)</span><br><span class="hljs-comment">//然后分配数组</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">allocateElements</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numElements)</span> </span>&#123;<br>    elements = <span class="hljs-keyword">new</span> Object[calculateSize(numElements)];<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numElements)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> initialCapacity = MIN_INITIAL_CAPACITY;<br>    <span class="hljs-comment">// Find the best power of two to hold elements.</span><br>    <span class="hljs-comment">// Tests &quot;&lt;=&quot; because arrays aren&#x27;t kept full即可.</span><br>    <span class="hljs-comment">//如果目标容量还小于规定的最小容量8,那么直接返回即可</span><br>    <span class="hljs-keyword">if</span> (numElements &gt;= initialCapacity) &#123;<br>        initialCapacity = numElements;<br>        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="hljs-number">1</span>);<br>        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="hljs-number">2</span>);<br>        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="hljs-number">4</span>);<br>        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="hljs-number">8</span>);<br>        initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>        initialCapacity++;<br><br>        <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)   <span class="hljs-comment">// Too many elements, must back off</span><br>            initialCapacity &gt;&gt;&gt;= <span class="hljs-number">1</span>;<span class="hljs-comment">// Good luck allocating 2 ^ 30 elements</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> initialCapacity;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到<code>calculateSize()</code>的代码很魔性,很有必要好好解释一哈。以下面32bit的数(作为初始容量newElements)为例:</p><blockquote><p>0000 0010 1101 0011 0000 0000 0000 0000</p></blockquote><p><strong>目标数据</strong>为离newElements最近的2的整数:</p><blockquote><p>0000 0100 0000 0000 0000 0000 0000 0000</p></blockquote><p>操作步骤如下:</p><ol><li>先执行<code>initialCapacity |= (initialCapacity &gt;&gt;&gt;  1)</code>,即将<code>initialCapacity</code>无符号向右移动1位:</li></ol><blockquote><p>0000 0001 0110 1001 1000 0000 0000 0000</p></blockquote><p>然后与自身进行或操作更新<code>initialCapacity</code>,这样就保证了左边第1位和第2位都为1。</p><blockquote><p>0000 0011 1111 1011 1000 0000 0000 0000</p></blockquote><ol start="2"><li>再执行<code>initialCapacity |= (initialCapacity &gt;&gt;&gt;  2)</code>,将<code>initialCapacity</code>无符号向右移动2位:</li></ol><blockquote><p>0000 0000 1111 1110 1110 0000 0000 0000</p></blockquote><p>然后与自身进行或操作更新<code>initialCapacity</code>,这样就保证了从左侧第一个1开始,后四位都是1。</p><blockquote><p>0000 0011 1111 1111 1110 0000 0000 0000</p></blockquote><ol start="3"><li>执行<code>initialCapacity |= (initialCapacity &gt;&gt;&gt;  4)</code>,将<code>initialCapacity</code>无符号向右移动4位:</li></ol><blockquote><p>0000 0000 0011 1111 1111 1110 0000 0000</p></blockquote><p>然后与自身进行或操作更新<code>initialCapacity</code>,这样就保证了从左侧第一个1开始,后八位都是1。</p><blockquote><p>0000 0011 1111 1111 1111 1110 0000 0000</p></blockquote><ol start="4"><li>执行<code>initialCapacity |= (initialCapacity &gt;&gt;&gt;  8)</code>,将<code>initialCapacity</code>无符号向右移动8位:</li></ol><blockquote><p>0000 0000 0000 0011 1111 1111 1111 1110</p></blockquote><p>然后与自身进行或操作更新<code>initialCapacity</code>,这样就保证了从左侧第一个1开始,后十六位都是1。</p><blockquote><p>0000 0011 1111 1111 1111 1111 1111 1110</p></blockquote><ol start="5"><li>执行<code>initialCapacity |= (initialCapacity &gt;&gt;&gt;  16)</code>,将<code>initialCapacity</code>无符号向右移动16位:</li></ol><blockquote><p>0000 0000 0000 0000 0000 0011 1111 1111 </p></blockquote><p>然后与自身进行或操作更新<code>initialCapacity</code>,这样就保证了从左侧第一个1开始,后三十二位都是1(当然最右边会有些bit丢失,但是这并没有关系。)</p><blockquote><p>0000 0011 1111 1111 1111 1111 1111 1111</p></blockquote><p>6.最后将自身加1,就得到了目标数据:</p><blockquote><p>0000 0100 0000 0000 0000 0000 0000 0000</p></blockquote><p>是离<code>0000 0010 1101 0011 0000 0000 0000 0000</code>最近的2的整数倍容量。我只能说,这段代码是真的妙,太妙了。</p><p>然后如果传进来的目标容易第31为1,那么求得的新容量第32位就会变为1,变成了负数2^31,所以还需要处理以下,如果新容量发生溢出,那么就将2^32向右移一位,返回<br>2^30,这已经是<code>ArrayDeque</code>的极限容量。</p><h3 id="0x1-2-ArrayDeque的增删查"><a href="#0x1-2-ArrayDeque的增删查" class="headerlink" title="0x1-2 ArrayDeque的增删查"></a>0x1-2 ArrayDeque的增删查</h3><p>对于<code>ArrayDeque</code>的增删查方法也值得我们关注,下面我们先来看看add方法。</p><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><p><code>ArrayDeque</code>是直接继承<code>AbstractCllecetion</code>的,所以并没由在add中调用offer类方法。相反,在add类中调用了offer类。在<code>ArrayDeque</code>中,add类和offer类并没有差别。因为<code>ArrayDeque</code>会自动扩容,永远也不会出现插入失败的情况。这里就以add类的方法为例,代码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>        elements[head = (head - <span class="hljs-number">1</span>) &amp; (elements.length - <span class="hljs-number">1</span>)] = e;<br>        <span class="hljs-keyword">if</span> (head == tail)<br>            doubleCapacity();<br>    &#125;<br><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>        elements[tail] = e;<br>        <span class="hljs-keyword">if</span> ( (tail = (tail + <span class="hljs-number">1</span>) &amp; (elements.length - <span class="hljs-number">1</span>)) == head)<br>            doubleCapacity();<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offerFirst</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        addFirst(e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offerLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        addLast(e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p><code>addFirst()</code>首先会判断元素是否为<code>null</code>,<code>ArrayDeque</code>中是允许存在null元素的,但是不允许我们存储<code>null</code>。注意下面真正进行存储的代码:</p><blockquote><p>elements[head = (head - 1) &amp; (elements.length - 1)] = e;</p></blockquote><p>这里首先会将head减1,为什么要减呢?因为我们是采用循环数组存储的,如果当前head指向0,调用<code>addFirst</code>是将元素往头部存的,自然需要将head往前移动。指针移动如下图所示:</p><p><img src="images/ArrayDeque-ciecular.drawio.svg" alt="指针移动"></p><p>但是减1有可能会将head变为负数。所以需要与<code>elements.length - 1</code>进行与操作。这里举个例子好理解:</p><p>以32位计算机为例,如果当前我们的队列容量为<code>128</code>,也就是<code>1 0000 0000</code>，减1后会变为<code>1111 1111</code>:</p><ul><li><p>如果head移动后为负数:假设为-1,也就是<code>1000,...,000 0000</code>(最高位符号位为1,中间有许多1就不写了),与<code>1111 1111</code>相与,那么结果就还是127,刚好是队列中的最后一个位置。</p></li><li><p>如果head减1后仍为正数:那么就是对head取模,结果仍然是head,非常巧妙。</p></li></ul><p>最后,如果再添加新元素完成后,队列容量已满(头指针head与尾指针tail相遇),那么就调用<code>doubleCapacity</code>使容量翻倍。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doubleCapacity</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">assert</span> head == tail;<br>    <span class="hljs-keyword">int</span> p = head;<br>    <span class="hljs-keyword">int</span> n = elements.length;<br>    <span class="hljs-comment">//r就是尾指针到数组最后一个位置之间的元素数量</span><br>    <span class="hljs-keyword">int</span> r = n - p; <span class="hljs-comment">// number of elements to the right of p</span><br>    <span class="hljs-keyword">int</span> newCapacity = n &lt;&lt; <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//容量无法扩充,已到达2^31,抛出状态异常</span><br>    <span class="hljs-keyword">if</span> (newCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Sorry, deque too big&quot;</span>);<br>    <span class="hljs-comment">//否则就申请新数组并将元素拷贝至此</span><br>    Object[] a = <span class="hljs-keyword">new</span> Object[newCapacity];<br>    <br>    System.arraycopy(elements, p, a, <span class="hljs-number">0</span>, r);<br>    <span class="hljs-comment">//最后一位为长度</span><br>    System.arraycopy(elements, <span class="hljs-number">0</span>, a, r, p);<br>    elements = a;<br>    head = <span class="hljs-number">0</span>;<br>    tail = n;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里仍然以下图为例(队列容量为8):</p><p><img src="images/ArrayDeque-double-cap.drawio.svg" alt="double-cap"></p><p>首先从新队列的头开始复制r个元素,然后接着再r后面复制p个元素,完成扩容。</p><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>从下面的代码可以得知:remove系列在底层是调用了poll系列的方法,所以还是直接调用remove系列方法方便。调用poll系列是如果队列为空时则返回null,否则返回弹出的元素。没有什么特别的。查头尾元素也非常普通,这里就不单列出来了。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span> </span>&#123;<br>    E x = pollFirst();<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">removeLast</span><span class="hljs-params">()</span> </span>&#123;<br>    E x = pollLast();<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">pollFirst</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h = head;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    E result = (E) elements[h];<br>    <span class="hljs-comment">// Element is null if deque empty</span><br>    <span class="hljs-comment">//如果队列为空,那么还是可以查到null的</span><br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    elements[h] = <span class="hljs-keyword">null</span>;     <span class="hljs-comment">// Must null out slot</span><br>    head = (h + <span class="hljs-number">1</span>) &amp; (elements.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">pollLast</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> t = (tail - <span class="hljs-number">1</span>) &amp; (elements.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    E result = (E) elements[t];<br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    elements[t] = <span class="hljs-keyword">null</span>;<br>    tail = t;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="occurrence方法"><a href="#occurrence方法" class="headerlink" title="occurrence方法"></a>occurrence方法</h3><p>occurrence系列有两个方法,<code>removeFirstOccurrence</code>是删除第一次出现的指定元素,对应的<code>removeLastOccurrence</code>就是删除最后一次出现的元素。具体的删除操作由<code>delete</code>完成,为了在删除时移动最少的元素,所以<code>delete</code>还是有点小复杂。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeFirstOccurrence</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">int</span> mask = elements.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> i = head;<br>    Object x;<br>    <span class="hljs-keyword">while</span> ( (x = elements[i]) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (o.equals(x)) &#123;<br>            delete(i);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//从head开始,往tail方向遍历</span><br>        i = (i + <span class="hljs-number">1</span>) &amp; mask;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeLastOccurrence</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">int</span> mask = elements.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> i = (tail - <span class="hljs-number">1</span>) &amp; mask;<br>    Object x;<br>    <span class="hljs-keyword">while</span> ( (x = elements[i]) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (o.equals(x)) &#123;<br>            delete(i);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//从tail开始,往head方向遍历</span><br>        i = (i - <span class="hljs-number">1</span>) &amp; mask;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面是delete的源码,为了实现最小次数的移动还真是费心了,具体的解释见注释吧。其中检查函数的作用就是检查还能不能在原数组中进行了移动数据的操作。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//如果是移动i后面的那部分数据,就返回true</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    checkInvariants();<br>    <span class="hljs-keyword">final</span> Object[] elements = <span class="hljs-keyword">this</span>.elements;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mask = elements.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> h = head;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> t = tail;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> front = (i - h) &amp; mask;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> back  = (t - i) &amp; mask;<br><br>    <span class="hljs-comment">// Invariant: head &lt;= i &lt; tail mod circularity</span><br>    <span class="hljs-keyword">if</span> (front &gt;= ((t - h) &amp; mask))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br><br>    <span class="hljs-comment">//下面这么复杂完全是为了减少移动次数</span><br>    <span class="hljs-comment">//如果前半段少于后半段数据,那么就移动前半段</span><br>    <span class="hljs-keyword">if</span> (front &lt; back) &#123;<br>        <span class="hljs-comment">//此时h和i之间并没有跨越下标0</span><br>        <span class="hljs-keyword">if</span> (h &lt;= i) &#123;<br>            System.arraycopy(elements, h, elements, h + <span class="hljs-number">1</span>, front);<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// Wrap around</span><br>        <span class="hljs-comment">//h和i之间跨域了下标0</span><br>            <span class="hljs-comment">//先将下标0~i之间的元素从0~i-1移动至1~i</span><br>            System.arraycopy(elements, <span class="hljs-number">0</span>, elements, <span class="hljs-number">1</span>, i);<br>            <span class="hljs-comment">//把数组中的最后一个元素拷贝至数组下标0位置</span><br>            elements[<span class="hljs-number">0</span>] = elements[mask];<br>            <span class="hljs-comment">//把数组中h~mask-1移动至h+1~mask</span><br>            System.arraycopy(elements, h, elements, h + <span class="hljs-number">1</span>, mask - h);<br>        &#125;<br>        elements[h] = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//更新head</span><br>        head = (h + <span class="hljs-number">1</span>) &amp; mask;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//后半段数据少于前半段,那么就移动后半段,并返回true</span><br>        <span class="hljs-keyword">if</span> (i &lt; t) &#123; <span class="hljs-comment">// Copy the null tail as well</span><br>            System.arraycopy(elements, i + <span class="hljs-number">1</span>, elements, i, back);<br>            tail = t - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// Wrap around</span><br>            System.arraycopy(elements, i + <span class="hljs-number">1</span>, elements, i, mask - i);<br>            elements[mask] = elements[<span class="hljs-number">0</span>];<br>            System.arraycopy(elements, <span class="hljs-number">1</span>, elements, <span class="hljs-number">0</span>, t);<br>            tail = (t - <span class="hljs-number">1</span>) &amp; mask;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//就是检查有没有移动数据的空间</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkInvariants</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">assert</span> elements[tail] == <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">assert</span> head == tail ? elements[head] == <span class="hljs-keyword">null</span> :<br>        (elements[head] != <span class="hljs-keyword">null</span> &amp;&amp;<br>         elements[(tail - <span class="hljs-number">1</span>) &amp; (elements.length - <span class="hljs-number">1</span>)] != <span class="hljs-keyword">null</span>);<br>    <span class="hljs-keyword">assert</span> elements[(head - <span class="hljs-number">1</span>) &amp; (elements.length - <span class="hljs-number">1</span>)] == <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="0x3-课后总结"><a href="#0x3-课后总结" class="headerlink" title="0x3 课后总结"></a>0x3 课后总结</h2><p>ArrayDeque采用数组实现循环队列,容量始终是2次幂。在单线程中:</p><ul><li>作为栈,比<code>Stack</code>快,因为不需要保证线程安全</li><li>作为队列比LinkedList快,因为不需要构造节点</li></ul><p>不过一般没啥人用吧,就当为分析LinkedList提前开路了。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.jianshu.com/p/1c1c3f24762e">https://www.jianshu.com/p/1c1c3f24762e</a></p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</category>
      
      
      <category domain="https://eripe.me/tags/Queue/">Queue</category>
      
      <category domain="https://eripe.me/tags/ArrayQueue/">ArrayQueue</category>
      
      <category domain="https://eripe.me/tags/ArrayDeque/">ArrayDeque</category>
      
      
      <comments>https://eripe.me/articles/ArrayQueue-and-ArrayDeque-analysis.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>volatile关键字</title>
      <link>https://eripe.me/articles/volatile-keyword.html</link>
      <guid>https://eripe.me/articles/volatile-keyword.html</guid>
      <pubDate>Mon, 14 Jun 2021 11:50:07 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;1-volatile是什么&quot;&gt;&lt;a href=&quot;#1-volatile是什么&quot; class=&quot;headerlink&quot; title=&quot;1. volatile是什么&quot;&gt;&lt;/a&gt;1.</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1-volatile是什么"><a href="#1-volatile是什么" class="headerlink" title="1. volatile是什么"></a>1. volatile是什么</h2><p>volatile被称为轻量级的<code>synchronzied</code>，它保证了内存的可见性、指令的有序性。我们通过经典的懒汉单例模式看看这个关键字的作用。</p><figure class="highlight java"><figcaption><span>"线程不安全"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DraconianSingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DraconianSingleton instance;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  DraconianSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>            synchronzied(<span class="hljs-keyword">this</span>)&#123;<br>                <span class="hljs-keyword">if</span>(instance==<span class="hljs-keyword">null</span>)&#123;<br>                    instance = <span class="hljs-keyword">new</span> DraconianSingleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>虽然使用了双锁，但是上述代码仍然是线程不安全的，因为<code>new DraconianSingleton()</code>并不是原子操作。这句代码的正常操作是：</p><ol><li>分配内存空间</li><li>初始化对象</li><li>将对象地址赋给引用instance</li></ol><p>但是因为操作2和操作3之间没有数据依赖，编译器有理由将这两条指令进行重排。重拍后的操作为：</p><ol><li>分配内存空间</li><li>将对象地址赋给引用instance</li><li>初始化对象</li></ol><p>重排后的指令在单线程环境下执行是没有问题的。但是在多线程环境下，如果thread1获得锁并且在执行了第二步之后，<code>instance != null</code>,但是对象并没有完成初始化。此时如果thread1时间片到期，切换到thread2。thread2调用<code>getInstace()</code>后获得的是一个部分初始化的对象，此时thread2在使用这个对象时很可能会出现意外的错误。</p><p>但是使用<code>volatile</code>修饰<code>instance</code>后，就能够禁止上述的重排现象发生，从而变成线程安全。</p><figure class="highlight java"><figcaption><span>"线程安全"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DraconianSingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> DraconianSingleton instance;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  DraconianSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>            synchronzied(<span class="hljs-keyword">this</span>)&#123;<br>                <span class="hljs-keyword">if</span>(instance==<span class="hljs-keyword">null</span>)&#123;<br>                    instance = <span class="hljs-keyword">new</span> DraconianSingleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-volatile做了什么"><a href="#2-volatile做了什么" class="headerlink" title="2.volatile做了什么"></a>2.volatile做了什么</h2><p>volatile能够禁止上述指令重排的原因是因为它在volatile write操作之前插入了内存屏障，禁止volatile write操作之前任何的read/write操作重排序到volatile write之后。在执行<code>new DraconianSingleton()</code>时，构造函数(构造函数可以会执行写操作，例如写变量的初值)肯定会执行write操作，所以构造函数的write操作一定不会被重排序到volatile write操作之后，从而保证了只会在实例化对象完成后才会<code>instance</code>赋值。</p><p>网上许多文章都说volatile会执行上述的操作禁止指令重排，但是几乎没有人说它为什么这么做。我尝试使用如下代码解释一下我的理解：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">volatile</span> b;<br>write()&#123; <span class="hljs-comment">//thread 1</span><br>    a=<span class="hljs-number">1</span>; <span class="hljs-comment">//opreation 1</span><br>    <span class="hljs-comment">//StoreStore memory barrier</span><br>    b=<span class="hljs-number">2</span>; <span class="hljs-comment">//opreation 2</span><br>    <span class="hljs-comment">//StoreLoad memory barrier</span><br>&#125;<br><br>read()&#123; <span class="hljs-comment">//thread 2</span><br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">2</span>)&#123; <span class="hljs-comment">//opreation 3</span><br>        sout(a);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>根据happens before的程序次序原则，o1 hb o2，那么JMM保证o1的执行结果必须被o2看到。我们可以延伸一下，volatile write之前所有的动作结果都应该在volatile write执行时被看到。所以为了实现这个效果，JMM会在volatile write之前插入StoreStore、StoreLoad内存屏障（这是最笨、最稳妥的办法，具体实现时肯定会有相应的优化。<br>根据happens before的volatile变量规则，o2 hb o3，JMM保证o2（volatile写）的执行结果必须被o3（volatile读）看到。为了实现这个效果，需要借助StoreLoad内存屏障的力量。</p><p><strong>所以volatile做这些工作都是为了实现happens before relation</strong>。内存屏障只是volatile实现happens before的<strong>技术手段</strong>。并且volatile并不会刷新内存，那不是它的责任，刷新内存是内存屏障的作用。</p><hr><p><strong>对于volatile的一些小疑问：</strong></p><p><strong>Q1：对于volatile write(A) hb volatile read(B)，是不是只有A先比B发生，JMM才会使用内存屏障达到B一定能够看到A的效果（即实现 A hb B）。也就是说，如果A没有比B先发生，JMM就不会使用内存屏障实现A hb B了？</strong></p><p>很明显这个表述是有问题的，但是我一直不知道如何否定这个逻辑。经过几天的思考，我给出我的理解：<br>对于volatile write(A) hb volatile read(B)，JMM不管A与B谁先发生，它只管使用内存屏障达到：如果A发生，B就能看到结果的效果（换言之，JMM按照理想情况，A先发生B后发生的情形插入内存屏障）。这样就会有：</p><ul><li>如果A比B先发生，那么就能实现A hb B的效果</li><li>如果B比A先发生，那么虽然插入了内存屏障，但是也没有产生什么负面效果</li></ul><p><strong>Q2：volatile真的禁止重排序了吗？</strong></p><p>我认为volatile并没有这么做，volatile它只是借助内存屏障禁止volatile write之前的任何read/write重排序到volatile write之后，至于那些read/write操作到底如何重排序，volatile并不care</p><hr><h2 id="3-volatile如何使用"><a href="#3-volatile如何使用" class="headerlink" title="3. volatile如何使用"></a>3. volatile如何使用</h2><p>首先我们需要知道volatile只有read/write操作具有原子性，剩余的基于volatile的算数运算并没有原子性。例如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clac</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>        <span class="hljs-keyword">new</span> Thread()&#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">1000</span>;j++)<br>                    j++;<br>            &#125;;<br>        &#125;.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述<code>j++</code>并不具有原子性。想象以下多线程的场景：</p><p><code>j</code>默认初始化为0。首先thread读取到<code>j=0</code>，然后进行<code>+1</code>操作，但是在将1赋给<code>j</code>之前，时间片用完，所以此时并没有volatile write操作。切换到thread2，thread2读取到的<code>j</code>仍然为0，并且完成了<code>+1</code>的动作。这样在thread2完成之后，其他所有的线程读取到的<code>j</code>肯定都为<code>1</code>。但是thread1此时不需要读取<code>j</code>了，它只会完成最后一步的volatile write动作。出现了线程安全问题。所以说volatile只有read/write操作具有原子性。</p><p>上面出现问题的原因是什么呢？</p><blockquote><p>多个线程都能够修改同一个volatile的值，并且目标修改值依赖volatile变量的前一个值</p></blockquote><p>所以为了避免上述缺陷，volatile的理想使用场景是：</p><ol><li><p>可以有多个线程修改volatile变量，但是修改后的值不应该依赖volatile变量之前的值</p></li><li><p>volatile变量不需要与其他变量构成约束条件（我理解的约束条件是导致控制流发生改变的条件）</p></li></ol><p>规则1很好理解，对于规则2的理解见如下代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//代码摘自：http://kael-aiur.com/java/java%E4%B8%ADvolatile%E5%85%B3%E9%94%AE%E5%AD%97.html</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberRange</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> lower, upper;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLower</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> lower; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getUpper</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> upper; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLower</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123; <br>        <span class="hljs-keyword">if</span> (value &gt; upper) <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(...);<br>        lower = value;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUpper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123; <br>        <span class="hljs-keyword">if</span> (value &lt; lower) <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(...);<br>        upper = value;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在上面的代码中，如果lower与upper初始化为(0,5)。两个线程分别调用<code>setLower</code>和<code>setUpper</code>，将（lower,upper）设置为（4，3），例如调用<code>setLower</code>通过if检查后，让出cpu，<code>setUpper</code>通过if检查后，继续执行，就能够成功将区间设置为（4，3）。这样的区间是没有意义的，之所以会出现这样的错误是因为约束条件为<code>value&gt;upper</code>，<code>volatile</code>与<code>value</code>共同参与了不变约束。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://stackoverflow.com/questions/11639746/what-is-the-point-of-making-the-singleton-instance-volatile-while-using-double-l/11640026#11640026">What is the point of making the singleton instance volatile while using double lock?</a></p></li><li><p><a href="https://stackoverflow.com/questions/51647337/java-volatile-reordering-prevention-scope">Java volatile reordering prevention scope</a></p></li><li><p><a href="https://blog.csdn.net/xdzhouxin/article/details/81236356">volatile为什么不能保证原子性</a></p></li><li><p><a href="https://developpaper.com/memory-barrier-and-its-application-in-jvm-2/">Memory barrier and its application in – JVM (2)</a></p></li><li><p><a href="https://stackoverflow.com/questions/45151763/analyzing-of-x86-output-generated-by-jit-in-the-context-of-volatile">Analyzing of x86 output generated by JIT in the context of volatile</a></p></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">多线程基础</category>
      
      
      <category domain="https://eripe.me/tags/volatile/">volatile</category>
      
      
      <comments>https://eripe.me/articles/volatile-keyword.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>多线程为什么会不安全</title>
      <link>https://eripe.me/articles/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%B8%8D%E5%AE%89%E5%85%A8.html</link>
      <guid>https://eripe.me/articles/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%B8%8D%E5%AE%89%E5%85%A8.html</guid>
      <pubDate>Mon, 14 Jun 2021 11:50:07 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;在聊多线程为什么不安全之前，需要说一哈学习多线程编程的路线。多线程说到底就是为了提高效率，而这个效率的提高是有安全风险的，这也是多线程为啥这么难的原因。而编写一个多线程的程序可以分为三个部分：分</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>在聊多线程为什么不安全之前，需要说一哈学习多线程编程的路线。多线程说到底就是为了提高效率，而这个效率的提高是有安全风险的，这也是多线程为啥这么难的原因。而编写一个多线程的程序可以分为三个部分：分工、同步、互斥。</p><p>分工更偏向于<strong>设计</strong>，这里是提高性能的关键。相当于项目经理分配任务。与现实世界非常相似, <strong>不过是一个线程执行完了一个任务，如何通知执行后续任务的线程开工而已。</strong> 这里多说一句，计算机里的这个模型那个模型我认为都是为了更好的模拟现实世界。</p><p>而同步是偏向于<strong>实现</strong>，同步就是为了线程之间的更好的有序协作，这与现实世界的分工合作并无不同。线程之间的协作问题都可以认为时：当某个线程不满足条件时，需要怎么样，满足条件了，又怎么样。<strong>在Java并发编程领域，解决协作问题的核心技术是管程</strong>。</p><p>而互斥则是为了<strong>安全</strong>。线程不安全是因为线程之间执行的顺序是不确定的，导致不确定的因素有三点：可见性问题、有序性问题和原子性问题。java引入了JMM(内存模型，一组规则)解决前两个问题，这还不够。还需要解决互斥问题，所谓的互斥就是指<strong>同一时刻，只能有一个线程访问共享变量</strong>。解决互斥的关键还是锁。</p><p>下面贴出一张大佬总结并发学习的思路：</p><p><img src="images/learn-route.png" alt="并发学习架构"></p><p>ok,我们开始进入正题：并发安全的三大问题是：可见性问题、原子性问题、有序性问题。在普通的计算机模型中，cpu通常采用三级缓存，之后才是内存，所以如果有多个核心，它们的一二级缓存是不共享的，但是它们对变量的操作都会在缓存里进行，显而易见，各个核心在自己缓存里的操作是隔离的，别人看不到的，这也就是所谓的可见性问题。</p><p>那么在java中，因为有JMM，堆是共享的，每个线程都有自己的逻辑工作内存，当然这个工作内存也是互不可见的。这就与上面的缓存问题是等价的。那么如果我们想在java中解决可见性，就需要对共享变量加上volatile关键字，注意，<strong>volatile只保证可见性与有序性，不保证原子性</strong>。volatile的工作原理时如果一个线程对共享变量做了改变，那么就会将改变强制刷新到堆中，同理如果有另外的线程想要操作共享变量，只能强制从堆中读取最新的数据。这里还有一点需要注意：<strong>JMM规定，线程的操作只能在自己的工作内存中完成</strong>。</p><p>原子性没啥好解释的。</p><p>有序性就是汇编指令的执行顺序不定，但是保证结果是一样的。</p><p>下面是一个存在线程安全的单例模式：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> Singleton instance;<br>  <span class="hljs-function"><span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)<br>          instance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>问题在于 <code>new Singlrton()</code>的指令重排问题。可能的步骤是先分配内存，然后设置地址引用，最后初始化。如果线程A在设置完地址引用后，时间到了，此时不会释放锁。如果线程B此时才进入第一个if判断，因为已经设置过引用了，会直接返回。此时的对象还未创建后，会出现非法引用的错误。</p><p>在评论区看到一个正确的解答：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySingleton</span> </span>&#123;<br><br>    <span class="hljs-comment">//内部类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySingletonHandler</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> MySingleton instance = <span class="hljs-keyword">new</span> MySingleton();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">MySingleton</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> MySingletonHandler.instance;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><a href="https://blog.csdn.net/mnb65482/article/details/80458571">静态内部类实现的单例模式为什么是线程安全的</a></p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</category>
      
      
      <category domain="https://eripe.me/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">基本概念</category>
      
      
      <comments>https://eripe.me/articles/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%B8%8D%E5%AE%89%E5%85%A8.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ThreadLocal源码解析</title>
      <link>https://eripe.me/articles/threadlocal-analysis.html</link>
      <guid>https://eripe.me/articles/threadlocal-analysis.html</guid>
      <pubDate>Mon, 14 Jun 2021 11:50:07 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;顾名思义，&lt;code&gt;ThreadLocal&lt;/code&gt;就是基于线程粒度的私有变量，跟我们以往认知中基于函数、类粒度的私有变量不同。而且&lt;code&gt;ThreadLocal&lt;/code&gt;的使用频</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>顾名思义，<code>ThreadLocal</code>就是基于线程粒度的私有变量，跟我们以往认知中基于函数、类粒度的私有变量不同。而且<code>ThreadLocal</code>的使用频率非常高，但是如若使用不当，则可能会发生内存泄漏，所以好好研究一下其实现原理是非常有必要的。内容分为三个部分：<code>ThreadLocalMap</code>是什么，<code>ThreadLocal</code>是如何插入变量的，<code>ThreadLocal</code>是如何删除变量的。</p><h2 id="ThreadLocalMap是什么"><a href="#ThreadLocalMap是什么" class="headerlink" title="ThreadLocalMap是什么"></a><code>ThreadLocalMap</code>是什么</h2><p>在<code>ThreadLocal</code>中，其自己实现了一个名为<code>ThreadLocalMap</code>的静态类，从名字就可以看出，其功能类似于map，用于维护形如&lt;key=<code>ThreadLocal</code>弱引用，value=’Corresponding value’&gt;的键值对，但是它没有用在<code>ThreadLocal</code>中，反而<code>Thread</code>类中维护了一个<code>ThreadLocalMap</code>对象，我认为这是理解<code>ThreadLocal</code>的关键。<code>ThreadLocal</code>中维护的<code>ThreadLocalMap</code>如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    ...<br>    <br>    <span class="hljs-comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="hljs-comment">     * by the ThreadLocal class. */</span><br>    <span class="hljs-comment">// 因为ThreadLocal和Thread处于同一个包，可以直接使用</span><br>    ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * InheritableThreadLocal values pertaining to this thread. This map is</span><br><span class="hljs-comment">     * maintained by the InheritableThreadLocal class.</span><br><span class="hljs-comment">     */</span><br>    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="hljs-keyword">null</span>;<br>    ...<br></code></pre></div></td></tr></table></figure><p><code>ThreadLocal</code>不像网上大部分文章说的，在<code>ThreadLocal</code>中维护了一个HashMap，key为ThreadID，value为对应值。而是通过<code>Thread</code>中的<code>ThreadLocalMap</code>维护多个<code>ThreadLocal</code>对象，每个<code>ThreadLocal</code>对象维护其自己对应的值。</p><p>如果有多个<code>ThreadLocal</code>对象作用于同一个线程A，那么这些<code>ThreadLocal</code>共享线程A的<code>ThreadLocalMap</code>，或者同一个<code>ThreadLocal</code>对象B同时作用于多个线程，例如线程C、D。那么在C、D的<code>ThreadLocalMap</code>会维护两组key相同但值不同的键值对，例如&lt;key=B.hashcode,value=C.value&gt;，&lt;key=B.hashcode,value=D.value&gt;，不会相互干扰。所以<code>ThreadLocalMap</code>才是<code>ThreadLocal</code>的关键，那么<code>ThreadLocalMap</code>到底是如何实现的？先来看看其部分实现源码：</p><figure class="highlight java"><figcaption><span>"ThreadLocalMap"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* ThreadLocalMap is a customized hash map suitable only for</span><br><span class="hljs-comment">* maintaining thread local values. No operations are exported</span><br><span class="hljs-comment">* outside of the ThreadLocal class. The class is package private to</span><br><span class="hljs-comment">* allow declaration of fields in class Thread.  To help deal with</span><br><span class="hljs-comment">* very large and long-lived usages, the hash table entries use</span><br><span class="hljs-comment">* WeakReferences for keys. However, since reference queues are not</span><br><span class="hljs-comment">* used, stale entries are guaranteed to be removed only when</span><br><span class="hljs-comment">* the table starts running out of space.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//静态内部类是可以实例化的哦</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalMap</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;<br>        <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>        Object value;<br><br>        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>            <span class="hljs-keyword">super</span>(k);<br>            value = v;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * TThreadLocalMap的初始容量，必须是2的指数倍</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INITIAL_CAPACITY = <span class="hljs-number">16</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 用于存放Entry的table，长度必须是2的指数倍</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> Entry[] table;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * table的初始大小</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 下一次扩容的阈值</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> threshold; <span class="hljs-comment">// Default to 0</span><br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>跟HashMap类似，ThreadLocalMap也是通过静态内部类<code>Entry</code>来维护键值对，其中key为<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>，value为具体的值。这里存在一个问题：为何使用要使用弱引用？用意何在？这个问题先留着，后续再讨论。从上面的代码我们可以看出，<code>ThreadLocalMap</code>通过数组<code>table</code>来维护插入的键值对，并且同样的，数组大小必须是2的次方，这里的理由与hashMap容量必须是2的整数幂一样。</p><h2 id="ThreadLocal的插入操作"><a href="#ThreadLocal的插入操作" class="headerlink" title="ThreadLocal的插入操作"></a>ThreadLocal的插入操作</h2><p>我们一般使用<code>ThreadLocal</code>的<code>set(T)</code>方法进行插入操作：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    Thread t = Thread.currentThread();<br>    <span class="hljs-comment">//首先获取当前线程内部的ThreadLocalMap</span><br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-comment">// 如果map为空，说明当前线程中的ThreadLocalMap还未创建</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)<br>        map.set(<span class="hljs-keyword">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;<br><br><span class="hljs-comment">//getMap的实现原理也非常简单，直接返回线程的内部变量</span><br><span class="hljs-function">ThreadLocalMap <span class="hljs-title">getMap</span><span class="hljs-params">(Thread t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从上面代码我们能够得知：往<code>ThreadLocal</code>中插入元素的第一步就是获取当前线程内部的<code>ThreadLocalMap</code>。如果map已经存在，则直接调用<code>set(ThreadLocal&lt;?&gt;, Object)</code>存储值。否则调用<code>createMap(Thread, Object)</code>创建map并存储。我们先来分析<code>createMap</code>:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>&#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>createMap</code>的逻辑很简单，就是调用<code>ThreadLocalMap</code>的构造函数生成对象后，赋值给当前线程的<code>threadLocals</code>变量。</p><figure class="highlight java"><figcaption><span>"constructor method"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br>ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>    table = <span class="hljs-keyword">new</span> Entry[INITIAL_CAPACITY];<br>    <span class="hljs-keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//我们先分析前两句，注释的部分先不看</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    table[i] = new Entry(firstKey, firstValue);</span><br><span class="hljs-comment">    size = 1;</span><br><span class="hljs-comment">    setThreshold(INITIAL_CAPACITY);</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这个构造函数，会首先初始化table，然后利用当前<code>Threadlocal</code>对象的hash值计算索引。首先这句代码就会产生两个问题：<code>ThreadLocal</code>对象的hash值是如何产生的？索引计算为何使用<code>&amp;</code>运算符？</p><h3 id="ThreadLocal的hash值计算原理"><a href="#ThreadLocal的hash值计算原理" class="headerlink" title="ThreadLocal的hash值计算原理"></a>ThreadLocal的hash值计算原理</h3><p>对于第一个问题，首先我们需要知道，<code>ThreadLocal</code>对象的hash值是在<code>new</code>的时候就构造好了。hash值构造方法如下所示：</p><figure class="highlight java"><figcaption><span>"ThreadLocal哈希码生成部分"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocal</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    ...<br>    <br>    <span class="hljs-comment">//每次生成ThreadLocal对象时会自动调用nextHashCode</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threadLocalHashCode = nextHashCode();<br><br>    <span class="hljs-comment">//静态变量，第一次加载该类时threadLocalHashCode会被初始化为0</span><br>    <span class="hljs-comment">//随后每生成一个ThreadLocal对象，nextHashCode的值都为上一个ThreadLocal对象的HashCode</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicInteger nextHashCode =<br>        <span class="hljs-keyword">new</span> AtomicInteger();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The difference between successively generated hash codes - turns</span><br><span class="hljs-comment">     * implicit sequential thread-local IDs into near-optimally spread</span><br><span class="hljs-comment">     * multiplicative hash values for power-of-two-sized tables.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HASH_INCREMENT = <span class="hljs-number">0x61c88647</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextHashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>    &#125;<br>    ...<br></code></pre></div></td></tr></table></figure><p><code>threadLocalHashCode</code>是通过<code>nextHashCode()</code>完成计算的，而在<code>nextHashCode()</code>中，它会将<code>nextHashCode</code>加上<code>HASH_INCREMENT</code>，并返回原始的<code>nextHashCode</code>。<code>nextHashCode</code>是一个静态变量，被所有<code>ThreadLocal</code>对象共享。所以每当有新的<code>ThreadLocal</code>对象生成时，就会使用上一个<code>ThreadLocal</code>改变的<code>nextHashCode</code>。至于为什么<code>nextHashCode</code>的增量<code>HASH_INCREMENT</code>是魔数<code>0x61c88647</code>，理由是计算出的hash值足够离散，能够均匀地分布在<code>table</code>数组中。</p><p>对于第二个问题：使用<code>&amp;</code>计算索引是因为如果n是2的整数次幂，那么则有<code>hash % n == (n-1)&amp; hash</code>，这样做是为了加速运算。</p><p>了解了如何计算<code>ThreadLocal</code>对象的hash值后，我们的视角回到<code>ThreadLocalMap</code>的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    table = new Entry[INITIAL_CAPACITY];</span><br><span class="hljs-comment">    int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="hljs-comment">    */</span><br>    table[i] = <span class="hljs-keyword">new</span> Entry(firstKey, firstValue);<br>    size = <span class="hljs-number">1</span>;<br>    setThreshold(INITIAL_CAPACITY);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在<code>table</code>中安置好新加入的entry后，则会调用<code>setThreshold</code>设置扩容阈值，阈值大小为<code>table</code>容量的<strong>2/3</strong>，而不是HashMap的3/4。</p><h3 id="set-方法原理"><a href="#set-方法原理" class="headerlink" title="set()方法原理"></a>set()方法原理</h3><p>那么如果线程的<code>ThreadLocalMap</code>已经构造好了，添加元素是怎么样一个过程呢？来看看私有的<code>set(ThreadLocal&lt;?&gt;, Object)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;<br>    <span class="hljs-comment">// 我们不像get()那样使用哈希值快速查找Entry</span><br>    <span class="hljs-comment">// 因为使用set()创建新条目和替换现有条目至少是一样普遍的</span><br>    <span class="hljs-comment">// 在这种情况下，使用哈希值失败的可能性通常会更高</span><br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    <span class="hljs-comment">// 计算ThreadLocal对象的索引</span><br>    <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 遍历table，这里一定会找到一个Entry==null的索引</span><br>    <span class="hljs-comment">// 因为有提前扩容机制，不可能把table填满</span><br>    <span class="hljs-keyword">for</span> (Entry e = tab[i];<br>            e != <span class="hljs-keyword">null</span>;<br>            e = tab[i = nextIndex(i, len)]) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//找到一个失效的Entry</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//stale是陈旧的意思</span><br>            replaceStaleEntry(key, value, i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    tab[i] = <span class="hljs-keyword">new</span> Entry(key, value);<br>    <span class="hljs-keyword">int</span> sz = ++size;<br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在<code>set(ThreadLocal&lt;?&gt;, Object)</code>中，首先会计算当前<code>ThreadLocal</code>对象的索引<code>i</code>，然后使用<code>for</code>循环从<code>i</code>之后遍历<code>table</code>数组，直到找到一个空的位置，for循环调用了<code>nextIndex(int,int)</code>进行变量自增，那么<code>nextIndex</code>做了什么？看看它的实现代码：</p><figure class="highlight java"><figcaption><span>"nextIndex"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ((i + <span class="hljs-number">1</span> &lt; len) ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>含义很简单，就是从索引<code>i</code>开始计算下一个位置，如果已经<code>i</code>已经到达尾部，那么循环到头部开始。所以可以把<code>ThreadLocalMap</code>中的<code>table</code>当作一个环形数组，如下图所示：</p><p><img src="images/circular-ThreadLocalMap.drawio.svg" alt="table"></p><p><code>set(ThreadLocal&lt;?&gt;, Object)</code>的for循环含义很简单：</p><ol><li>如果当前<code>ThreadLocal</code>对象已经在<code>table</code>中，那么就更新其对应的value</li><li>如果找到了一个无效Entry，那么就会从当前Entry开始，调用<code>replaceStaleEntry(ThreadLocal&lt;?&gt;,Object,int)</code></li><li>尝试在table中找到我们的目标Entry，并将目标Entry和无效Entry交换，然后进行一些清除无效Entry的操作。replaceStaleEntry的实现源码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* @param  key the key</span><br><span class="hljs-comment">* @param  value key对应的value</span><br><span class="hljs-comment">* @param  staleSlot 当前Entry的key==null的索引，表示这个Entry是需要被清除的</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">replaceStaleEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-keyword">int</span> staleSlot)</span> </span>&#123;<br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    Entry e;<br>    <br>    <span class="hljs-comment">// slotToExpunge表示的含义是从当前索引值开始清理无效Entry</span><br>    <span class="hljs-comment">// 做法是从staleSlot开始向前，也就histaleSlot的左边，找到最远离staleSlot的，Entry不为空的，但是Entry.weakReference==null的Entry索引</span><br>    <span class="hljs-comment">// 如果在遇到空Entry之前，还未找到失效的Entry，那么slotToExpunge将会等于staleSlot</span><br>    <span class="hljs-keyword">int</span> slotToExpunge = staleSlot;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = prevIndex(staleSlot, len);<br>            (e = tab[i]) != <span class="hljs-keyword">null</span>;<br>            i = prevIndex(i, len))<br>        <span class="hljs-keyword">if</span> (e.get() == <span class="hljs-keyword">null</span>)<br>            slotToExpunge = i;<br><br>    <span class="hljs-comment">//从staleSlot开始向后遍历，直到遇到空Entry为止</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nextIndex(staleSlot, len);<br>            (e = tab[i]) != <span class="hljs-keyword">null</span>;<br>            i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br><br>        <span class="hljs-comment">//如果找到了我们的目标Entry的索引i</span><br>        <span class="hljs-comment">//那么就将索引staleSlot和i表示的Entry相互相互</span><br>        <span class="hljs-comment">//交换之后，索引i表示的Entry就失效了</span><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-comment">//交换Entry</span><br>            tab[i] = tab[staleSlot];<br>            tab[staleSlot] = e;<br><br>            <span class="hljs-comment">//如果在第一个for循环中没有找到失效的Entry，那么下面的if条件就会成立</span><br>            <span class="hljs-comment">//因为i现在表示的失效Entry索引，所以就将slotToExpunge设为i</span><br>            <span class="hljs-keyword">if</span> (slotToExpunge == staleSlot)<br>                slotToExpunge = i;<br>            <span class="hljs-comment">//然后开始使用两种方法清理无效Entry</span><br>            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果还未找到目标Entry，所以尝试找到staleSlot右边最近的失效Entry</span><br>        <span class="hljs-comment">// 因为我们是从staleSlot开始向后遍历，还是有可能遇到Entry.weakReference==null的情况</span><br>        <span class="hljs-comment">// 这个if只可能执行一次，表示staleSlot左边最远没有失效的Entry，只找到了右边最近的失效Entry</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)<br>            slotToExpunge = i;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果在table根本就不存在key</span><br>    <span class="hljs-comment">// 那么直接在当前失效Entry的槽位上新建Entry</span><br>    <span class="hljs-comment">// 在新建之前，会将原来Entry的value设为null，这是为了防止内存泄漏</span><br>    tab[staleSlot].value = <span class="hljs-keyword">null</span>;<br>    tab[staleSlot] = <span class="hljs-keyword">new</span> Entry(key, value);<br><br>    <span class="hljs-comment">// 如果存在失效Entry但是索引不是staleSlot，那么就从slotToExpunge开始清除无效Entry</span><br>    <span class="hljs-keyword">if</span> (slotToExpunge != staleSlot)<br>        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>replaceStaleEntry</code>函数的主要思想就是：</p><ol><li>如果在<code>table</code>中找到了目标Entry的索引<code>i</code>，那么就将我们索引<code>staleSlot</code>和<code>i</code>对应的Entry交换</li><li>如果在<code>table</code>中没有找到目标Entry，那么就直接在索引<code>staleSlot</code>对应的槽位构建新的Entry</li><li>期望在当前<code>staleSlot</code>的最远左边或者最近右边找到一个失效Entry以便最大化清除失效Entry的效果，具体的清除原理我们放到<code>ThreadLocal</code>删除操作一节中讲解。</li></ol><p>现在我们的视角回到<code>set(ThreadLocal&lt;?&gt;, Object)</code>:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;<br>    <span class="hljs-comment">// 我们不像get()那样使用哈希值快速查找Entry</span><br>    <span class="hljs-comment">// 因为使用set()创建新条目和替换现有条目至少是一样普遍的</span><br>    <span class="hljs-comment">// 在这种情况下，使用哈希值失败的可能性通常会更高</span><br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    <span class="hljs-comment">// 计算ThreadLocal对象的索引</span><br>    <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 遍历table，这里一定会找到一个Entry==null的索引</span><br>    <span class="hljs-comment">// 因为有提前扩容机制，不可能把table填满</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    for (Entry e = tab[i];</span><br><span class="hljs-comment">            e != null;</span><br><span class="hljs-comment">            e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="hljs-comment">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        if (k == key) &#123;</span><br><span class="hljs-comment">            e.value = value;</span><br><span class="hljs-comment">            return;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        //找到一个失效的Entry</span><br><span class="hljs-comment">        if (k == null) &#123;</span><br><span class="hljs-comment">            replaceStaleEntry(key, value, i);</span><br><span class="hljs-comment">            return;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br><br>    tab[i] = <span class="hljs-keyword">new</span> Entry(key, value);<br>    <span class="hljs-keyword">int</span> sz = ++size;<br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果在set中在找到空槽位之前没有找到目标Entry或者失效Entry，那么就会直接在空槽位上构建Entry对象。新构建之后第一步需要考虑的就是扩容问题。这个问题由<code>rehash</code>来解决。当然扩容也是有条件的：需要在调用<code>cleanSomeSlots</code>进行一波清理操作后，<code>table</code>内的Entry个数仍然大于扩容阈值才会调用<code>rehash</code>。<code>rehash</code>的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rehash</span><span class="hljs-params">()</span> </span>&#123;<br>    expungeStaleEntries();<br><br>    <span class="hljs-comment">// Use lower threshold for doubling to avoid hysteresis</span><br>    <span class="hljs-keyword">if</span> (size &gt;= threshold - threshold / <span class="hljs-number">4</span>)<br>        resize();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">expungeStaleEntries</span><span class="hljs-params">()</span> </span>&#123;<br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>        Entry e = tab[j];<br>        <span class="hljs-comment">//找到每个失效Entry，并对每个失效Entry调用expungeStaleEntry实施清除操作</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span> &amp;&amp; e.get() == <span class="hljs-keyword">null</span>)<br>            expungeStaleEntry(j);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>rehash</code>内部又会调用<code>expungeStaleEntries()</code>进行一波清理操作，如果<code>table</code>内的<code>Entry</code>数量仍然大于等于<code>table</code>容量得1/2(计算公式：threshold*2/3*capacity*3/4)，才会真正调用调用<code>resize()</code>进行扩容。所以这里有一个小点我们容易忽略：<strong>并不是table中的Entry数量大于等于容量的2/3就会进行扩容，而是在进行两类清除操作之后，Entry数量仍然大于等于容量的1/2，才会进行扩容</strong>。具体扩容的原理就很简单，简单的扩容<strong>两倍</strong>并复制了Entry。</p><h2 id="ThreadLocal的删除操作"><a href="#ThreadLocal的删除操作" class="headerlink" title="ThreadLocal的删除操作"></a>ThreadLocal的删除操作</h2><p>在插入操作的<code>set(ThreadLocal&lt;?&gt;, Object)</code>函数中，我们不止一次提到了两种清除操作:<code>cleanSomeSlots(int,int)</code>和<code>expungeStaleEntry(j)</code>，那么这两种清除操作最大的区别就是前者为<strong>启发式</strong>清除操作，后者为<strong>线性</strong>清除操作，为何这么说？首先来看看<code>cleanSomeSlots(int,int)</code>的实现代码：</p><figure class="highlight java"><figcaption><span>"启发式清除操作"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//参数i表示当前Entry必有效的索引，所以清除要从下一个index开始</span><br><span class="hljs-comment">//参数n表示清除操作的执行次数</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">cleanSomeSlots</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> removed = <span class="hljs-keyword">false</span>;<br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    <span class="hljs-keyword">do</span> &#123;<br>        i = nextIndex(i, len);<br>        Entry e = tab[i];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span> &amp;&amp; e.get() == <span class="hljs-keyword">null</span>) &#123;<br>            n = len;<br>            removed = <span class="hljs-keyword">true</span>;<br>            i = expungeStaleEntry(i);<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> ( (n &gt;&gt;&gt;= <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> removed;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>根据代码<code>n&gt;&gt;&gt;=1</code>可知，<code>cleanSomeSlots</code>总共会执行log2(n)次操作，而每次操作时会尝试找到失效Entry，然后从失效Entry的索引开始，调用<code>expungeStaleEntry</code>进行线程清除操作，来看看其实现源码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 参数staleSlot表示失效Entry的索引</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> staleSlot)</span> </span>&#123;<br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br><br>    <span class="hljs-comment">// 将value置为空，避免内存泄漏</span><br>    tab[staleSlot].value = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 将失效Entry移出</span><br>    tab[staleSlot] = <span class="hljs-keyword">null</span>;<br>    size--;<br><br>    <span class="hljs-comment">// Rehash until we encounter null</span><br>    Entry e;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-comment">//从staleSlot开始遍历table，直到遇到空槽位</span><br>    <span class="hljs-comment">//所以是一个线程清除操作</span><br>    <span class="hljs-keyword">for</span> (i = nextIndex(staleSlot, len);<br>            (e = tab[i]) != <span class="hljs-keyword">null</span>;<br>            i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-comment">//遇到失效Entry，进行移出操作</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span>) &#123;<br>            e.value = <span class="hljs-keyword">null</span>;<br>            tab[i] = <span class="hljs-keyword">null</span>;<br>            size--;<br>        &#125;<br>        <span class="hljs-comment">//遇到正常的Entry，那么就尝试重新计算索引</span><br>        <span class="hljs-comment">//因为在此之前这个Entry是因为哈希冲突才来到当前位置的</span><br>        <span class="hljs-comment">// 这么做的目的是让Entry更接近它的理想位置h</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (h != i) &#123;<br>                tab[i] = <span class="hljs-keyword">null</span>;<br><br>                <br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                * 以下解析摘自参考文章[1]</span><br><span class="hljs-comment">                * 在原代码的这里有句注释值得一提，原注释如下：</span><br><span class="hljs-comment">                *</span><br><span class="hljs-comment">                * Unlike Knuth 6.4 Algorithm R, we must scan until</span><br><span class="hljs-comment">                * null because multiple entries could have been stale.</span><br><span class="hljs-comment">                *</span><br><span class="hljs-comment">                * 这段话提及了Knuth高德纳的著作TAOCP（《计算机程序设计艺术》）的6.4章节（散列）</span><br><span class="hljs-comment">                * 中的R算法。R算法描述了如何从使用线性探测的散列表中删除一个元素。</span><br><span class="hljs-comment">                * R算法维护了一个上次删除元素的index，当在非空连续段中扫到某个entry的哈希值取模后的索引</span><br><span class="hljs-comment">                * 还没有遍历到时，会将该entry挪到index那个位置，并更新当前位置为新的index，</span><br><span class="hljs-comment">                * 继续向后扫描直到遇到空的entry。</span><br><span class="hljs-comment">                *</span><br><span class="hljs-comment">                * ThreadLocalMap因为使用了弱引用，所以其实每个slot的状态有三种也即</span><br><span class="hljs-comment">                * 有效（value未回收），无效（value已回收），空（entry==null）。</span><br><span class="hljs-comment">                * 正是因为ThreadLocalMap的entry有三种状态，所以不能完全套高德纳原书的R算法。</span><br><span class="hljs-comment">                *</span><br><span class="hljs-comment">                * 因为expungeStaleEntry函数在扫描过程中还会对无效slot清理将之转为空slot，</span><br><span class="hljs-comment">                * 如果直接套用R算法，可能会出现具有相同哈希值的entry之间断开（中间有空entry）。</span><br><span class="hljs-comment">                */</span><br>                <span class="hljs-comment">//从h之后线性探测一个空槽位</span><br>                <span class="hljs-keyword">while</span> (tab[h] != <span class="hljs-keyword">null</span>)<br>                    h = nextIndex(h, len);<br>                tab[h] = e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>线性操作的原理比较简单：</p><ol><li>如果遇到了失效Entry，就将其移除</li><li>如果遇到了正常Entry，那么就对其进行冲哈希定位，目的是尽可能地将当前Entry放在它应该在的位置上</li><li>如果遇到了空槽位，那么就直接返回当前空槽位的索引</li></ol><p>在了解了两种清除操作之后，再去看<code>ThreadLocal</code>的移出操作就非常简单了，我们一般都会调用<code>remove</code>进行移出，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 即使没有在ThreadLocal中存入值，也可以调用remove方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>    ThreadLocalMap m = getMap(Thread.currentThread());<br>    <span class="hljs-keyword">if</span> (m != <span class="hljs-keyword">null</span>)<br>        m.remove(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 寻找目标Entry进行移出，并会顺带调用expungeStaleEntry进行线性清除</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;<br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (Entry e = tab[i];<br>            e != <span class="hljs-keyword">null</span>;<br>            e = tab[i = nextIndex(i, len)]) &#123;<br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;<br>            e.clear();<br>            expungeStaleEntry(i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>所以经过以上学习，我们可以总结出：</p><ol><li>启发式清除操作会在<code>set(ThreadLocal&lt;?&gt;, Object)</code>中的两个地方被调用：<ul><li>table中存在目标Entry，那么就从找到的失效Entry开始启发式清除</li><li>table中不存在目标Entry，那么就从新插入的Entry开始启发式清除</li></ul></li><li>线性清除操作出现的地方比较多：<ul><li>在启发式清除中会开始线性清除</li><li>在<code>replaceStaleEntry</code>中，会先进行线性清除，之后进行启发式清除</li></ul></li></ol><h3 id="ThreadLocal中的内存泄漏问题"><a href="#ThreadLocal中的内存泄漏问题" class="headerlink" title="ThreadLocal中的内存泄漏问题"></a>ThreadLocal中的内存泄漏问题</h3><p>在前面我们曾提出了一个问题，为什么要对<code>ThreadLocal</code>使用弱引用，首先我们需要直到什么是弱引用：</p><blockquote><p>使用WeakReference修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收</p></blockquote><p>也就是说，当一个对象只存在弱引用时，无论内存空间是否足够，都会将其回收。那么试想如下一个场景：</p><p>如果对于一个<code>ThreadLocal</code>对象引用<code>a=new ThreadLocal&lt;&gt;()</code>，当我们不再需要这个<code>ThreadLocal</code>对象时，那么就会将<code>a</code>设为null。但是曾经使用过该<code>ThreadLocal</code>对象的线程A内部的<code>ThreadLocalMap</code>仍然持有该<code>ThreadLocal</code>对象的引用，所以如果不使用虚引用，那么否则直到线程A死亡，该<code>ThreadLocal</code>对象都不会被回收。当线程A运行时间特别长时，可能由于<code>ThreadLocal</code>对象无法被回收的问题，可能内存空间会越来越小。</p><p>所以这种类型的内存泄漏已经被大牛们解决了。那么我们常说的ThreadLocal内存泄漏是什么呢？</p><p>不知大家是否还记得<code>Entry</code>的结构，其内部属性<code>value</code>仍然是一个强引用，就会出现key无效但是value有效的<code>Entry</code>对象，导致<code>Entry</code>对象仍然无法会回收。所以虽然在调用<code>set</code>方法时，大概率会将无效<code>Entry</code>对象清除，但这种清除并不是百分百生效的。所以当我们不在需要一个<code>ThreadLocal</code>对象时，最后手动调用<code>remove</code>方法清除无效Entry，防止内存泄漏。</p><h2 id="ThreadLocal的获取操作"><a href="#ThreadLocal的获取操作" class="headerlink" title="ThreadLocal的获取操作"></a>ThreadLocal的获取操作</h2><p>实现获取操作的<code>get()</code>方法很简单，如下所示：</p><figure class="highlight java"><figcaption><span>"get()实现源码"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    Thread t = Thread.currentThread();<br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;<br>        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            T result = (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果没有存入value，那么则会初始化默认value并返回</span><br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="InheritableThreadLocal原理"><a href="#InheritableThreadLocal原理" class="headerlink" title="InheritableThreadLocal原理"></a>InheritableThreadLocal原理</h2><p>除了<code>ThreadLocal</code>，还有一种用于实现父子线程数据共享的<code>ThreadLocal</code>:<code>InheritableThreadLocal</code>，它的具体实现是在Thread类中除了threadLocals外还有一个inheritableThreadLocals对象。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="hljs-comment">     * by the ThreadLocal class. */</span><br>    ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * InheritableThreadLocal values pertaining to this thread. This map is</span><br><span class="hljs-comment">     * maintained by the InheritableThreadLocal class.</span><br><span class="hljs-comment">     */</span><br>    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="hljs-keyword">null</span>;<br></code></pre></div></td></tr></table></figure><p>在线程对象初始化的时候，会调用ThreadLocal的createInheritedMap从父线程的inheritableThreadLocals中把有效的entry都拷过来，做的事情就是以父线程的inheritableThreadLocalMap为数据源，过滤出有效的entry，初始化到自己的inheritableThreadLocalMap中。其中childValue可以被重写。需要注意的地方是InheritableThreadLocal只是在子线程创建的时候会去拷一份父线程的inheritableThreadLocals。如果父线程是在子线程创建后再set某个InheritableThreadLocal对象的值，对子线程是不可见的。</p><h2 id="ThreadLocal的基本使用"><a href="#ThreadLocal的基本使用" class="headerlink" title="ThreadLocal的基本使用"></a>ThreadLocal的基本使用</h2><p>下面是一个在线程中简单使用<code>ThreadLocal</code>的例子：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalExample1</span> </span>&#123;<br><br>    <span class="hljs-comment">// (1) 创建ThreadLocal变量</span><br>    <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; localVariable = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br><br>    <span class="hljs-comment">// (2)print函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str)</span></span>&#123;<br>        <span class="hljs-comment">// 打印当前线程本地内存中localVariable变量的值</span><br>        System.out.println(str + <span class="hljs-string">&quot;:&quot;</span> + localVariable.get());<br>        <span class="hljs-comment">// 2.1 清楚当前线程本地内存变量</span><br><span class="hljs-comment">//        localVariable.remove();</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">// (3) 创建线程one</span><br>        Thread threadOne = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">// 设置threadOne中的本地变量localVariable的值</span><br>                localVariable.set(<span class="hljs-string">&quot;threadOne local variable&quot;</span>);<br>                <span class="hljs-comment">// 调用打印函数</span><br>                print(<span class="hljs-string">&quot;threadOne&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;threadOne remove after&quot;</span> + localVariable.get());<br>            &#125;<br>        &#125;);<br><br><br>        <span class="hljs-comment">// 创建线程two</span><br>        Thread threadTwo = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">// 设置threadTwo线程中的本地线程变量</span><br>                localVariable.set(<span class="hljs-string">&quot;threadTwo local variable&quot;</span>);<br>                <span class="hljs-comment">// 调用打印函数</span><br>                print(<span class="hljs-string">&quot;threadTwo&quot;</span>);<br>                <span class="hljs-comment">// 打印本地线程变量</span><br>                System.out.println(<span class="hljs-string">&quot;threadTwo remove after&quot;</span> + <span class="hljs-string">&quot;:&quot;</span> + localVariable.get());<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// (5)启动线程</span><br>        threadOne.start();<br>        threadTwo.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以如果想要在每个线程都维护一个线程级的变量，那么只需要一个<code>ThreadLocal</code>对象即可，如果想要为一个线程维护多个线程级的私有变量，那么就需要多个<code>ThreadLocal</code>对象。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://www.cnblogs.com/micrari/p/6790229.html">ThreadLocal源码解读</a></li></ol><p>2.<a href="https://segmentfault.com/a/1190000022663697">面试官：小伙子，听说你看过ThreadLocal源码？</a></p><p>3.<a href="https://zhuanlan.zhihu.com/p/88133406">面试官连环炮轰炸的ThreadLocal 吃透源码的每一个细节和设计原理</a></p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">多线程基础</category>
      
      
      <category domain="https://eripe.me/tags/ThreadLocal/">ThreadLocal</category>
      
      
      <comments>https://eripe.me/articles/threadlocal-analysis.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>多线程基础</title>
      <link>https://eripe.me/articles/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.html</link>
      <guid>https://eripe.me/articles/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.html</guid>
      <pubDate>Mon, 14 Jun 2021 11:50:07 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;多进程是为了提高CPU效率，而多线程是为了提高程序使用率？我咋感觉不对啊，多线程通信方便，资源浪费小。并且多线程能不能提高效率得看是什么任务。&lt;/p&gt;
&lt;p&gt;总而言之：&lt;strong&gt;多进程为操</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>多进程是为了提高CPU效率，而多线程是为了提高程序使用率？我咋感觉不对啊，多线程通信方便，资源浪费小。并且多线程能不能提高效率得看是什么任务。</p><p>总而言之：<strong>多进程为操作系统提供了并发的可能，多进程为单个程序提供了并发的能力</strong>。</p><p>简而言之：多线程就是程序内部有多条执行路径，这句话至少我认为是没有错的。</p><p>并且并发是在某一时间段同时发生，<strong>并行</strong>是在某一<strong>时间点</strong>同时发生。不要记混了。所以记住java搞高并发就不会错了。</p><p>在java中，启动一个java程序，也就是启动一个JVM进程，然后进程会自动运行一个<strong>主线程</strong>来调用某个类的main方法。</p><blockquote><p>那么JVM的启动是单线程的还是多线程的？</p></blockquote><p>是多线程的，因为至少会启动一个gc线程和主线程。</p><h3 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h3><p>在java中，实现多线程的方法主要就分为三种，一种是继承Thread类，override它的run方法，第二种就是实现Runnable接口下的run方法。或者实现Callable<V>下的run方法。</p><h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><p>这是第一种实现多线程方式。</p><ol><li>首先我们需要自定义类并继承自Thread类</li><li>重写<code>run()</code>方法：因为<strong>不是类中的所有代码都需要被线程执行</strong>，所以为了区别哪些代码被线程执行，java提供了<code>run()</code>来包含那些需要被线程执行的代码。</li><li>创建对象</li><li>启动线程：如果直接使用<code>run()</code>启动线程，那么就相当直接调用线程，也就是只实现了单线程效果。</li></ol><blockquote><p>run()与start()有什么区别？</p></blockquote><p>run()仅仅是封装了需要执行的代码，直接调用就相当于调用普通方法。而<code>start()</code>是启动了线程，使线程处于就绪状态，然后再由JVM调用线程的<code>run()</code>方法。</p><blockquote><p>如何获取与设置线程的名称？</p></blockquote><p>很简单，调用线程的<code>getName()</code>与<code>setName()</code>即可。或者直接在构造线程对象时设置名称。</p><figure class="highlight java"><figcaption><span>"多线程入门栗子"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-comment">//super.run();</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;++i) &#123;<br>            System.out.println(getName()+<span class="hljs-string">&quot;:&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    MyThread my=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;tom&quot;</span>);<br>    my.start();<br>    MyThread my1=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;bob&quot;</span>);<br>    my1.start();<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>调用自己写的线程子类很容易获取名称。但是如何获取不是我们自定义的线程的名称呢？例如main线程？</p></blockquote><p>很简单，调用Thread类的静态方法：<code>public static Thread currentThread()</code>获得当前线程的引用。然后在调用该线程的<code>getName()</code>即可。在哪个线程里调<code>currentThread()</code>，就是获得了哪个线程的Thread对象引用。</p><h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><ol><li>自定义类实现Runnable接口，<code>Runnable</code>接口只有一个抽象方法<code>run</code>，无法取消</li><li>实现<code>run()</code>方法</li><li>创建MyRunnable对象</li><li>创建Thread对象并将第三步的对象作为参数传进去</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">500</span>;++i) &#123;<br>            System.out.println(Thread.currentThread().getName()+i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    MyRunnable my=<span class="hljs-keyword">new</span> MyRunnable();<br>    Thread t1=<span class="hljs-keyword">new</span> Thread(my,<span class="hljs-string">&quot;tom&quot;</span>);<br>    Thread t2=<span class="hljs-keyword">new</span> Thread(my,<span class="hljs-string">&quot;candy&quot;</span>);<br>    t1.start();<br>    t2.start();<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="实现callable接口"><a href="#实现callable接口" class="headerlink" title="实现callable接口"></a>实现callable接口</h4><p>这种实现多线程的方式必须配合线程池使用。这种方式与实现Runnable接口的区别就是这种方法可以返回一个值。由泛型指定类型。调用<code>submit()</code>后会返回一个Future，可以通过Future的<code>get()</code>方法获得返回值，但是该方法会阻塞当前线程，直到得到结果。下面是一个使用的栗子：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mycallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Mycallable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>        <span class="hljs-keyword">this</span>.num = num;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++) &#123;<br>            sum+=i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    ExecutorService pool=Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>    Future&lt;Integer&gt; f1=pool.submit(<span class="hljs-keyword">new</span> Mycallable(<span class="hljs-number">50</span>));<br>    Future&lt;Integer&gt; f2=pool.submit(<span class="hljs-keyword">new</span> Mycallable(<span class="hljs-number">100</span>));<br>    <span class="hljs-keyword">try</span> &#123;<br>        System.out.println(f1.get()+f2.get());<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-comment">// TODO Auto-generated catch block</span><br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>        <span class="hljs-comment">// TODO Auto-generated catch block</span><br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        pool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面提到了Future，这是个啥？其实它是一个接口，它只有五个非常简单的方法。</p><figure class="highlight java"><figcaption><span>"Future接口"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">cancel</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> mayInterruptIfRunning)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCancelled</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;<br><br>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>cancel()</code>表示<strong>试图</strong>取消当前线程的执行，但注意仅仅是试图，到底能不能取消还不知道，因为当前线程或许已经执行完了，或者已经取消了，或者一些其他不可控的因素。唯一的参数表示是否以中断的方式取消。</p><blockquote><p>所以有时候，为了让任务有能够取消的功能，就使用Callable来代替Runnable。如果为了可取消性而使用 Future但又不提供可用的结果，则可以声明 Future&lt;?&gt;形式类型、并返回 null作为底层任务的结果。<a href="http://concurrent.redspider.group/article/01/2.html">参考</a>。</p></blockquote><p>但是自定义Future接口中的<code>cancel</code>、<code>get</code>方法又非常困难，所以jdk为我们提供了一个Future的实现类<code>FutureTask</code>类。<code>FutureTask</code>实现了<code>RunnableFuture&lt;V&gt;</code>接口，而<code>RunnableFuture&lt;V&gt;</code>又继承了<code>Runnable</code>与<code>Future&lt;V&gt;</code>接口。</p><figure class="highlight java"><figcaption><span>"FutureTask简单使用"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService service= Executors.newCachedThreadPool();<br>        FutureTask&lt;Integer&gt; futureTask=<span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> CreateThread3());<br>        service.submit(futureTask);<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(futureTask.get());<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面使用线程池<code>submit()</code>提交一个FutureTask实例后，并不像提交Callable的实例后，有一个返回值。并且获取返回值的时候是直接通过FutureTask的实例获取。这里的submit原型为<code>submit(Runnable task)</code>，因为FutureTask就是Runnable接口的实现类。提交Callable的函数原型为<code>submit(Callable&lt;V&gt; task)</code>。</p><h4 id="java中实现线程的方式到底有几个？"><a href="#java中实现线程的方式到底有几个？" class="headerlink" title="java中实现线程的方式到底有几个？"></a>java中实现线程的方式到底有几个？</h4><p>这是一个值得思考的问题。上面我们看到定义一个线程的方法主要有三种。</p><p>第一种就是实现<code>Runnable</code>run方法。这种方式是怎么执行我们定义的线程代码的？源码给出了答案：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span>) &#123;<br>            target.run();<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>虚拟机会调用Thread实例的run方法执行线程代码，而在run方法中，又会调用target的<code>run()</code>方法，这个target就是我们传进去的RUnnable实例。</p><p>第二种就是继承Thread类，重写Thread的类的run方法。那么运行时会调用该实例重写的<code>run</code>方法。</p><p>第三种就是实现Callable接口的run方法，然后提交到线程池中。注意线程池中的线程是怎么来的？还是通过new一个Thread来实现的。</p><blockquote><p>无论是 Callable 还是 FutureTask，它们首先和 Runnable 一样，都是一个任务，是需要被执行的，而不是说它们本身就是线程。它们可以放到线程池中执行，如代码所示， submit() 方法把任务放到线程池中，并由线程池创建线程，不管用什么方法，最终都是靠线程来执行的。线程池里的线程还是new Thread创建出来的。</p></blockquote><p>所以说创建线程的方式就一种：<strong>创建一个Thread实例</strong>，而定义线程执行的内容有两种，实现Runnable、Callable等的run方法，或者重写Thread类的run方法。</p><p>那么我们应该选取哪种方式实现线程执行内容?</p><p>实现Runnable比继承Thread更好，理由如下：</p><ol><li>实现Runnable接口可以解决单继承的局限性</li><li>把线程和程序代码更好的分离。也就是如果使用继承Thread的方式实现，如果自定义类中有成员数据，就得创建多个MyThread对象才能实现多线程，数据成员也会出现多次。<br>而采用接口实现，只创建一个MyRunnabe对象就可实现多线程。数据成员只会出现一次。实现了Runnable与Thread类的解耦，Thread类只负责设置一些线程的参数。</li><li>在某些情况下Runnable的效率更好，比如我们需要重复执行一些小而短的程序，不停的创建Thread实例代价太高了，实现一个Runnable丢给线程池执行就好。</li></ol><h3 id="线程组的基本知识"><a href="#线程组的基本知识" class="headerlink" title="线程组的基本知识"></a>线程组的基本知识</h3><p>在java中，运行的线程必然属于某一个线程组，如果没有设置，默认线程组是当前启动新线程的线程所在的线程组，就是线程A启动了线程B，默认B的线程组为A所在的线程组。线程组的属性非常多，比如其他的线程组，当前组里的线程等等。</p><blockquote><p>ThreadGroup管理着它下面的Thread，ThreadGroup是一个标准的向下引用的树状结构，这样设计的原因是防止”上级”线程被”下级”线程引用而无法有效地被GC回收。</p></blockquote><h3 id="线程不安全的经典案例"><a href="#线程不安全的经典案例" class="headerlink" title="线程不安全的经典案例"></a>线程不安全的经典案例</h3><p>下面以电影院买票为例阐述多线程编程时的经典问题：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTickets</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tickets=<span class="hljs-number">10</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-keyword">while</span>(tickets&gt;<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-comment">// TODO Auto-generated catch block</span><br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;正在卖出第： &quot;</span>+(tickets--)+<span class="hljs-string">&quot;张票&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>买票时会出现售出同票或者售出负数票，这是为什么？</p><ol><li><p>首先解释同票的问题：因为<code>--</code>不是一个原子操作，所以有可能窗口1读到的tickets为100，此时时间片结束，窗口2读到的也为100，窗口3同理。由于不是原子性操作，所以可能会出现同票问题。</p></li><li><p>售出负数票是因为线程调度是随意的，没有顺序的。有可能tickets为1，t1、t2、t3三个线程都进入了循环，然后分别依次执行，就会出现负数票问题。</p></li></ol><p>综上，由于不是原子性操作和线程调度随意性。</p><h3 id="解决线程安全"><a href="#解决线程安全" class="headerlink" title="解决线程安全"></a>解决线程安全</h3><p>首先我们需要判断是否会出现线程不安全的问题。有以下几个标准：</p><ol><li>是否为多线程环境</li><li>是否线程间<strong>共享</strong>了数据</li><li>处理共享数据的操作是否为<strong>原子</strong>操作</li></ol><p>综上所述，只要将线程同步了，就可以解决线程安全的问题。那么同步有什么特征吗?</p><ol><li>必须是多线程环境</li><li>多个线程必须使用的同一把锁</li><li>当线程过多时，由于需要判断锁的情况，效率地下</li></ol><p>那么如何实现同步？使用<code>synchronized</code>关键字的方法有三种：</p><ol><li><p>使用同步代码块，并且同步代码块能够解决线程安全的关键在于对象，这个对象就相当于一把锁。锁对象可以是<strong>任意对象</strong>。必须共享同一个对象。</p></li><li><p>使用对象同步方法：锁对象就是<strong>该实例对象</strong>本身，将这个对象都锁住了。</p></li><li><p>使用静态同步方法：锁就是<strong>class对象</strong>本身</p></li></ol><p>显而易见，锁的范围越小越好，所以同步代码块的代价是最低的。</p><p>如果采用实例同步方法：同时有两个不相关的实例同步方法。当某个线程在调用其中一个同步实例方法的时候，其他的线程就无法继续调用另外的一个实例同步方法。因为锁只有一个，就是这个实例本身，导致没有关系的两个方法却不能同时进行。<a href=http://www.tianshouzhi.com/api/tutorials/mutithread/284>哪种同步方法好解析</a>。</p><figure class="highlight java"><figcaption><span>"同步代码块实例"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTickets</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tickets = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">private</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-keyword">synchronized</span> (obj) &#123;<span class="hljs-comment">//同步代码块的对象必须是同一对象</span><br>        <span class="hljs-keyword">while</span> (tickets &gt; <span class="hljs-number">0</span>) &#123;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-comment">// TODO Auto-generated catch block</span><br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在卖出第： &quot;</span> + (tickets--) + <span class="hljs-string">&quot;张票&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><figure class="highlight java"><figcaption><span>"实例同步方法"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTickets</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tickets = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (tickets &gt; <span class="hljs-number">0</span>) &#123;<br>        sell();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tickets &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在卖出第： &quot;</span> + (tickets--) + <span class="hljs-string">&quot;张票&quot;</span>);<br>    &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="解决死锁问题"><a href="#解决死锁问题" class="headerlink" title="解决死锁问题"></a>解决死锁问题</h3><p>死锁问题归根到底就是锁的嵌套问题。下面是一个死锁的栗子：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//公共锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLock</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj1=<span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj2=<span class="hljs-keyword">new</span> Object();<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> flag;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MultiThread</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> flag)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>();<br>    <span class="hljs-keyword">this</span>.flag = flag;<br>&#125;;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-comment">// super.run();</span><br>        <span class="hljs-keyword">if</span>(flag) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-comment">// TODO Auto-generated catch block</span><br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (MyLock.obj1) &#123;<br>                System.out.println(Thread.currentThread().getName()+<br>                        <span class="hljs-string">&quot;get lock obj1&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (MyLock.obj2) &#123;<br>                    System.out.println(Thread.currentThread().getName()+<br>                            <span class="hljs-string">&quot;get lock obj2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (MyLock.obj2) &#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;get lock obj2&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (MyLock.obj1) &#123;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;get lock obj1&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面的代码由于锁的相互嵌套，造成了死锁问题。这是由线程间通信方式不当而造成的。</p><blockquote><p>什么是线程间的通信问题？</p></blockquote><p>就是不同<strong>种类</strong>的线程针对同一资源的操作。</p><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p>场景：</p><ol><li>共同资源：学生对象</li><li>设置学生数据：setThread(生产者)</li><li>获得学生数据： getThread(消费者)</li><li>测试demo</li></ol><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>线程调度有两种模型，分别为：</p><ul><li>分时调度模型：所有线程轮流使用CPU，并且分配的时间片都相同</li><li>抢占式调度模型：优先级高的线程优先获得CPU使用权，并且时间片也会比低级线程的多一些。如果线程优先级相同，则随机选一个。</li></ul><p><strong>java使用抢占式调度模式。</strong></p><p>那么如何设置优先级呢？没有设置优先级之前，在java中所有线程的优先级都为5。线程优先级范围为1-10。注意：</p><blockquote><p>线程优先级高仅仅代表线程获取时间片的几率较高，而不是这个线程最先执行完毕。并且要多次执行才能看出效果。</p></blockquote><p>而且这里设置的优先级也仅仅是建议，到底优不优先还得看操作系统。并且线程一定属于线程组，那么如果线程的优先级高于所在线程组的优先级，会怎么样呢？</p><figure class="highlight java"><figcaption><span>"线程组优先级"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ThreadGroup t=<span class="hljs-keyword">new</span> ThreadGroup(<span class="hljs-string">&quot;t&quot;</span>);<br>    Thread t1= <span class="hljs-keyword">new</span> Thread(t,<span class="hljs-keyword">new</span> CreateThread2(<span class="hljs-string">&quot;tom&quot;</span>));<br>    Thread t2=<span class="hljs-keyword">new</span> Thread(t,<span class="hljs-keyword">new</span> CreateThread2(<span class="hljs-string">&quot;bob&quot;</span>));<br>    t.setMaxPriority(<span class="hljs-number">6</span>);<br>    t1.setPriority(<span class="hljs-number">9</span>);<br>    t2.setPriority(<span class="hljs-number">2</span>);<br>    t1.start();<br>    t2.start();<br>    System.out.println(<span class="hljs-string">&quot;线程组优先级:&quot;</span>+t.getMaxPriority());<br>    System.out.println(<span class="hljs-string">&quot;t1优先级:&quot;</span>+t1.getPriority());<br>    System.out.println(<span class="hljs-string">&quot;t2优先级:&quot;</span>+t2.getPriority());<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>结果如下：</p><blockquote><p>线程组优先级:6<br>t1优先级:6<br>t2优先级:2</p></blockquote><ul><li>设置优先级：<ul><li>setPriority()</li></ul></li><li>获取优先级：<ul><li>getPriority()</li></ul></li></ul><h3 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h3><ul><li><p>线程休眠：<code>public static void sleep(long time)</code>，time表示休眠的毫秒值</p></li><li><p>线程加入：<code>public final void join()</code>,这个方法的作用就是调用该方法的线程先执行完了，其他的线程才能加进来，进入就绪状态。这个join方法有点意思，后序会更新。现在先列一些参考：<a href="https://blog.csdn.net/u013425438/article/details/80205693">参考1</a>,<a href="https://blog.csdn.net/qq_20919883/article/details/100695018">参考2</a><a href="https://www.cnblogs.com/techyc/p/3286678.html">参考3</a></p></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    MyThread my=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;tom&quot;</span>);<br><br>    MyThread my1=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;bob&quot;</span>);<br><br>    MyThread my2=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;candy&quot;</span>);<br>    my.start();<br>    my.join();<br>    my1.start();<br>    my2.start();<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p><del>注意：调用join的位置很重要，必须放在其他线程对象调用<code>start()</code>之前才起作用。</del> 前面这句话完全是在扯淡。在使用join方法，我们需要考虑一个更高的维度，就是当前代码的执行环境。我们可以看到<code>my.join()</code>是在主线程里被调的，虽然调的是<code>MyThread</code>的join方法，但是执行的线程环境是在执行这句代码的线程中。所以这就解释了为什么是<code>my</code>在调用，而阻塞的是<code>main</code>线程，之所以与位置有关，是为主线程被阻塞了，<code>my1.start()</code>、<code>my2.start()</code>还没执行呢，线程当然不会启动。</p><p>这里多说一句，<code>join()</code>方法底层调用的还是<code>wait(0)</code>。</p><ul><li>线程礼让：<code>public static void yield()</code>:暂停当前执行的线程对象，并之情其他线程，让多个线程执行更和谐，但不能保证一人一次。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-comment">//super.run();</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;++i) &#123;<br>            System.out.println(getName()+<span class="hljs-string">&quot;:&quot;</span>+i);<br>            Thread.yield();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>守护线程：简而言之就是守护线程是与其守护的线程的同生死的。被守护的线程死了，守护线程必须得死，但不是立即死。反之则不一定。被守护的线程没死，守护线程可以死。</li></ul><p>那么守护线程到底守护的是谁？是所有的非守护线程，只要还有非守护线程，那么守护线程就会一直工作。</p><p>通过使用成员方法<code>public final void setDaemon()</code>。并且一定要在线程启动前调用。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    MyThread my=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;tom&quot;</span>);<br><br>    MyThread my1=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;bob&quot;</span>);<br><br>    MyThread my2=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;candy&quot;</span>);<br>    my.setDaemon(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//必须在就绪前设为守护线程</span><br>    my1.setDaemon(<span class="hljs-keyword">true</span>);<br>    my2.setDaemon(<span class="hljs-keyword">true</span>);<br>    my.start();<br>    my1.start();<br>    my2.start();<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++) &#123;<br>        System.out.println(Thread.currentThread().getName()+i);<br>    &#125;<br>    <span class="hljs-comment">//System.out.println(my.getPriority());</span><br>    <span class="hljs-comment">//Thread curThread=Thread.currentThread();</span><br>    <span class="hljs-comment">//System.out.println(curThread.getName());</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><ul><li>线程终止：有两种方法，<code>stop()</code>,<code>public void interrupt()</code>。前者已经过时。主要使用后者。后者中断的原理时抛出<code>InterruptedException</code>异常，使用<code>try-catch</code>捕捉后，后续代码仍可执行。</li></ul>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="https://eripe.me/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</category>
      
      
      <comments>https://eripe.me/articles/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
