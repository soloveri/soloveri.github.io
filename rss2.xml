<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>一颗胡杨树</title>
    <link>https://eripe.me/</link>
    
    <image>
      <url>https://eripe.me/img/panda.png</url>
      <title>一颗胡杨树</title>
      <link>https://eripe.me/</link>
    </image>
    
    <atom:link href="https://eripe.me/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>欢迎乘坐八楼的二路公交车</description>
    <pubDate>Mon, 30 Aug 2021 16:38:42 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>反射初体验</title>
      <link>https://eripe.me/articles/%E5%8F%8D%E5%B0%84%E5%88%9D%E4%BD%93%E9%AA%8C.html</link>
      <guid>https://eripe.me/articles/%E5%8F%8D%E5%B0%84%E5%88%9D%E4%BD%93%E9%AA%8C.html</guid>
      <pubDate>Mon, 30 Aug 2021 16:38:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h3 id=&quot;0x0-反射是什么&quot;&gt;&lt;a href=&quot;#0x0-反射是什么&quot; class=&quot;headerlink&quot; title=&quot;0x0 反射是什么&quot;&gt;&lt;/a&gt;0x0</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h3 id="0x0-反射是什么"><a href="#0x0-反射是什么" class="headerlink" title="0x0 反射是什么"></a>0x0 反射是什么</h3><p>反射是java中非常重要的一个概念。简而言之，反射就是在程序<strong>运行时</strong>可以<strong>动态</strong>的获取一个类的对象、执行某个类的方法等等。这里采用<a href="https://stackoverflow.com/questions/4453349/what-is-the-class-object-java-lang-class">overflow</a>上的一个回答。</p><blockquote><p>In order to fully understand the class object, let go back in and understand we get the class object in the first place. You see, every .java file you create, when you compile that .java file, the jvm will creates a .class file, this file contains all the information about the class, namely:</p></blockquote><blockquote><p>Fully qualified name of the class<br>Parent of class<br>Method information<br>Variable fields<br>Constructor<br>Modifier information<br>Constant pool<br>The list you see above is what you typically see in a typical class. Now, up to this point, your .java file and .class file exists on your hard-disk, when you actually need to use the class i.e. executing code in main() method, the jvm will use that .class file in your hard drive and load it into one of 5 memory areas in jvm, which is the method area, immediately after loading the .class file into the method area, the jvm will use that information and a Class object that represents that class that exists in the heap memory area.</p></blockquote><blockquote><p>Here is the top level view,<br>.java –compile–&gt; .class –&gt;when you execute your script–&gt; .class loads into method area –jvm creates class object from method area–&gt; a class object is born</p></blockquote><p>With a class object, you are obtain information such as class name, and method names, everything about the class.</p><p>反射机制是通过一个名为Class对象的概念来实现的。在编译每个.java文件后，都会生成一个对应的.class文件。这个.class文件包含了我们所编写的类的所有信息。比如类的全限定名、属性、方法、修饰符等等。然后当我们需要使用所编写的类时（这里记为target），.class文件会被加载至方法区，并且jvm会在堆区创建一个target类对应的Class对象。然后targt类的所有实例都由这个Class对象来产生。</p><p>注意，对于一个类，jvm只会生成一个对应的Class对象。</p><h3 id="0x1-反射有什么用"><a href="#0x1-反射有什么用" class="headerlink" title="0x1 反射有什么用"></a>0x1 反射有什么用</h3><p>反射最主要的作用的我认为就是提高了对未知应用的扩展能力。</p><p>试想一个场景：</p><p>项目的云服务我们最先使用的是阿里云，然后某天不爽想换成腾讯云，然后又换成什么亚马逊，七牛等等，需求不停的在变。如果我们在代码里写死了业务代码，那么每换一次，就要更新一次代码，烦不烦，你说烦不烦。</p><p>那么这是肯定有人想，写个配置文件，到时候我们在代码里判断到底用的是哪个云服务不就完事了？用什么反射，自找麻烦。</p><p>但是想过没有，我们if判断的条件只能是已知的，如果某天市场上杀出一个新的厂商，怎么办？还是得更新业务代码。得重新编译、重新运行。</p><p>所以为了处理这种未知的状况，就不得不使用使用反射了。我们把类名写在配置文件里，然后利用反射加载对应的类，这样以不变应万变。配置文件变化时只需要重新应用就行了，<strong>无需重新编译代码!!!</strong></p><p>当然，这些服务应该还有统一的接口，不然不可能实现一份代码适配多种情况。</p><h3 id="0x2-反射怎么用"><a href="#0x2-反射怎么用" class="headerlink" title="0x2 反射怎么用"></a>0x2 反射怎么用</h3><h4 id="1-获取反射对象"><a href="#1-获取反射对象" class="headerlink" title="1. 获取反射对象"></a>1. 获取反射对象</h4><p>想使用反射，我们必须得首先获得Class对象，获得Class对象的方法有三种：</p><ul><li>使用Class类的静态方法forName，参数为类的全限定名</li><li>直接使用某个类的class属性</li><li>调用某个对象的getClass()方法</li></ul><figure class="highlight java"><figcaption><span>"获取Class对象的三种方式"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//获取class对象的方法有三种</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getClassObject</span><span class="hljs-params">(Employee employee)</span></span>&#123;<br>        <span class="hljs-comment">//第一种通过全限定名获取</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Class c1=Class.forName(<span class="hljs-string">&quot;ReflectionBase.Employee&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">//第二种通过类的class属性获取</span><br>        Class&lt;ReflectionBase.Employee&gt; c2=Employee.class;<br><br>        <span class="hljs-comment">//第三种通过对象的getClass()方法获取</span><br>        Class&lt;? extends ReflectionBase.Employee&gt; c3=employee.getClass();<br>    &#125;<br></code></pre></div></td></tr></table></figure><h4 id="2-通过Class对象创造实例"><a href="#2-通过Class对象创造实例" class="headerlink" title="2. 通过Class对象创造实例"></a>2. 通过Class对象创造实例</h4><p>主要有两种方法：</p><ul><li>调用Class对象的newInstance()方法。</li><li>通过Class对象获取想要的Constructor，然后通过Constructor生成实例</li></ul><figure class="highlight java"><figcaption><span>"通过反射获取类的实例"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//通过newInstance方法</span><br><span class="hljs-keyword">try</span> &#123;<br>    Employee instance = c2.newInstance();<br>&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>    e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//通过获取Constructor来构造实例</span><br><span class="hljs-comment">//其中的参数填充要根据我们想要的构造函数</span><br><span class="hljs-keyword">try</span> &#123;<br>    Constructor&lt;Employee&gt; constructor = c2.getDeclaredConstructor(String.class, <span class="hljs-keyword">int</span>.class, String.class, <span class="hljs-keyword">int</span>.class, String.class, <span class="hljs-keyword">double</span>.class);<br>    <span class="hljs-comment">//取消访问检查</span><br>    constructor.setAccessible(<span class="hljs-keyword">true</span>);<br>    Employee e = constructor.newInstance(<span class="hljs-string">&quot;bob&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;eng&quot;</span>, <span class="hljs-number">200.2</span>);<br>    e.sayHello();<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，第一种方法只能通过默认无参构造方法构造对象，那么如果我们的类米有无参构造函数怎么办？这也许就是它被放弃的理由吧。</p><p>第二种可以获取任意一个构造函数，无论有参无参、私有公共，不过就是参数必须一一对应。</p><h4 id="3-获取修饰符"><a href="#3-获取修饰符" class="headerlink" title="3. 获取修饰符"></a>3. 获取修饰符</h4><p>修饰符的信息封装在<code>Modifier</code>类中，常见的用法通过<code>getModifiers()</code>返回一个用于描述Field、Method和Constructor的修饰符的整形数值，然后再由Modifier的静态方法<code>toString()</code>转为字符串。</p><p>以及一些常用的判断是否为<code>static</code>字段。</p><h4 id="4-获取类的属性"><a href="#4-获取类的属性" class="headerlink" title="4. 获取类的属性"></a>4. 获取类的属性</h4><p>类的属性都由Filed类管理。常用的方法有：</p><ul><li><code>getFields()</code>,获取该类所有的public属性，但不包括父类的属性。</li><li><code>getDeclaredFields()</code>,获取该类的所有属性，包括私有，但同样不包括父类的属性</li></ul><figure class="highlight java"><figcaption><span>"获取类的所有属性"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">parseFields</span><span class="hljs-params">(Class c)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    StringBuilder sb=<span class="hljs-keyword">new</span> StringBuilder();<br>    Field[] fields = c.getFields();<br><br>    <span class="hljs-keyword">for</span> (Field elem : fields) &#123;<br><br>        sb.append(SPLIT);<br>        <span class="hljs-keyword">int</span> modifiers = elem.getModifiers();<br>        <span class="hljs-keyword">if</span> (Modifier.toString(modifiers).length() &gt; <span class="hljs-number">0</span>) &#123;<br>            sb.append(Modifier.toString(modifiers)).append(SPLIT);<br><br>        &#125;<br>        Class&lt;?&gt; type = elem.getType();<br>        <span class="hljs-keyword">if</span> (type != <span class="hljs-keyword">null</span>) &#123;<br>            sb.append(type.getName()).append(SPLIT);<br>        &#125;<br>        sb.append(elem.getName());<br>        sb.append(<span class="hljs-string">&quot;;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br></code></pre></div></td></tr></table></figure><h4 id="5-获取类的构造方法"><a href="#5-获取类的构造方法" class="headerlink" title="5. 获取类的构造方法"></a>5. 获取类的构造方法</h4><p>同样，类的构造方法也会被封装在<code>Constructor</code>类中。<code>getDeclaredConstructors()</code>可以获取该类的所有构造方法。但是不包含<strong>父类的构造方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">parseConstructor</span><span class="hljs-params">(Class c)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    StringBuilder sb=<span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-comment">//获得该类的所有共有构造方法</span><br>    Constructor[] constructors = c.getConstructors();<br>    <span class="hljs-keyword">for</span>(Constructor elem:constructors)&#123;<br>        sb.append(SPLIT);<br>        <span class="hljs-keyword">int</span> modifiers = elem.getModifiers();<br>        <span class="hljs-keyword">if</span>(Modifier.toString(modifiers).length()&gt;<span class="hljs-number">0</span>)&#123;<br>            sb.append(Modifier.toString(modifiers)).append(SPLIT);<br>        &#125;<br>        sb.append(elem.getName()).append(<span class="hljs-string">&quot;(&quot;</span>);<br>        Class[] types = elem.getParameterTypes();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;types.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>)&#123;<br>                sb.append(<span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>            sb.append(types[i].getName());<br>        &#125;<br>        sb.append(<span class="hljs-string">&quot;);\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br></code></pre></div></td></tr></table></figure><h4 id="6-获取类的所有方法"><a href="#6-获取类的所有方法" class="headerlink" title="6. 获取类的所有方法"></a>6. 获取类的所有方法</h4><p>与上面类似，方法被封装在Method类中，同样，<code>getDeclaredMethod()</code>获取的方法<strong>不包括</strong>父类的方法。<code>getMethods()</code>获取公共的、父类或接口的所有方法。</p><figure class="highlight java"><figcaption><span>"获取类的所有方法"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">parseMethods</span><span class="hljs-params">(Class c)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(c==<span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    StringBuilder sb=<span class="hljs-keyword">new</span> StringBuilder();<br>    Method[] methods = c.getDeclaredMethods();<br>    <span class="hljs-keyword">for</span>(Method elem:methods)&#123;<br>        sb.append(SPLIT);<br>        <span class="hljs-keyword">int</span> modifiers = elem.getModifiers();<br>        <span class="hljs-keyword">if</span>(Modifier.toString(modifiers).length()&gt;<span class="hljs-number">0</span>)&#123;<br>            sb.append(Modifier.toString(modifiers)).append(SPLIT);<br>        &#125;<br>        Class&lt;?&gt; returnType = elem.getReturnType();<br>        sb.append(returnType.getName()).append(SPLIT);<br>        sb.append(elem.getName()).append(<span class="hljs-string">&quot;(&quot;</span>);<br>        Class&lt;?&gt;[] parameterTypes = elem.getParameterTypes();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;parameterTypes.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>)&#123;<br>                sb.append(<span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>            sb.append(parameterTypes[i].getName());<br>        &#125;<br>        sb.append(<span class="hljs-string">&quot;);\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>获取了方法，我们如何使用？非常简单，调用Method类的<code>invoke(Object invoke(Object obj, Object... args)</code> 执行方法，第一个参数执行该方法的对象，如果是static修饰的类方法，则传null即可方法。</p><p>通过获取Method对象时，仍然需要通过准确的参数类型才能找到我们想要的method对象。</p><h4 id="7-解析类的基本信息"><a href="#7-解析类的基本信息" class="headerlink" title="7. 解析类的基本信息"></a>7. 解析类的基本信息</h4><p>有了上面的工具我们就可以通过class文件来解析该类的基本信息了，我们构造两个类，Person和Employee类，后者继承前者：</p><figure class="highlight java"><figcaption><span>"Person类"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> String hobby;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String hobby)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.hobby = hobby;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getHobby</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> hobby;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHobby</span><span class="hljs-params">(String hobby)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.hobby = hobby;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><hr><figure class="highlight java"><figcaption><span>"Employee类"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> employeeId;<br>    <span class="hljs-keyword">protected</span> String title;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String hobby, <span class="hljs-keyword">int</span> employeeId, String title, <span class="hljs-keyword">double</span> salary)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name, age, hobby);<br>        <span class="hljs-keyword">this</span>.employeeId = employeeId;<br>        <span class="hljs-keyword">this</span>.title = title;<br>        <span class="hljs-keyword">this</span>.salary = salary;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;Hello, 我是 %s, 今年 %s 岁, 爱好是%s, 我目前的工作是%s, 月入%s元\n&quot;</span>,<br>                name, age, getHobby(), title, salary));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;My name is %s, 工作中勿扰.&quot;</span>, name));<br><br>    &#125;<br></code></pre></div></td></tr></table></figure><p>构造了上述类，我们就可以通过反射获取该类的字段、构造器、方法等等，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseClass</span><span class="hljs-params">(String className)</span></span>&#123;<br><br>    StringBuilder result=<span class="hljs-keyword">new</span> StringBuilder();<br>    Class c= <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        c = Class.forName(className);<br>        <span class="hljs-keyword">int</span> modifiers = c.getModifiers();<br>        <span class="hljs-comment">//打印类的修饰符</span><br>        result.append(Modifier.toString(modifiers));<br>        result.append(SPLIT);<br>        result.append(c.getName()).append(SPLIT);<br>        Class superclass = c.getSuperclass();<br>        <span class="hljs-keyword">if</span>(superclass!=<span class="hljs-keyword">null</span> &amp;&amp; superclass!=Object.class)&#123;<br>            result.append(<span class="hljs-string">&quot;extends&quot;</span>).append(SPLIT).append(superclass.getName());<br>        &#125;<br>        result.append(<span class="hljs-string">&quot;&#123;\n&quot;</span>);<br>        <span class="hljs-comment">//打印属性</span><br>        result.append(parseFields(c));<br>        <span class="hljs-comment">//打印构造函数</span><br>        result.append(parseConstructor(c));<br>        <span class="hljs-comment">//打印成员方法</span><br>        result.append(parseMethods(c));<br><br>        result.append(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>        System.out.println(result.toString());<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>        e.getMessage();<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ReflectionBase.Employee extends ReflectionBase.Person&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> employeeId;<br>    <span class="hljs-keyword">public</span> java.lang.String name;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="8-解析类的数据"><a href="#8-解析类的数据" class="headerlink" title="8. 解析类的数据"></a>8. 解析类的数据</h4><p>上面的解析是解析类的基本结构，那么如何获取一个对象的具体数据呢？与上面类似，我们将对象的类型分为三种，字符串、数组、普通对象。采用递归的方法解析所有字段。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">parseObject</span><span class="hljs-params">(Object obj)</span></span>&#123;<br><br>    <span class="hljs-keyword">if</span>(obj==<span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    StringBuilder sb=<span class="hljs-keyword">new</span> StringBuilder();<br><br>    Class&lt;?&gt; c = obj.getClass();<br>    <span class="hljs-comment">//判断是否为字符串类</span><br>    <span class="hljs-keyword">if</span>(c==String.class)&#123;<br>        <span class="hljs-keyword">return</span> (String)obj;<br>    &#125;<br>    <span class="hljs-comment">//判断对象是否为数组</span><br>    <span class="hljs-keyword">if</span>(c.isArray())&#123;<br>        sb.append(c.getComponentType()).append(<span class="hljs-string">&quot;[]&#123;\n&quot;</span>);<br>        System.out.println(Array.getLength(obj));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;Array.getLength(obj);i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>)&#123;<br>                sb.append(<span class="hljs-string">&quot;,\n&quot;</span>);<br>            &#125;<br>            sb.append(<span class="hljs-string">&quot;\t&quot;</span>);<br>            Object o = Array.get(obj, i);<br>            <span class="hljs-comment">//数组元素类型为8种普通类型，直接打印即可</span><br>            <span class="hljs-keyword">if</span>(c.getComponentType().isPrimitive())&#123;<br>                sb.append(o.toString());<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//数组元素类型为类，递归解析</span><br>                sb.append(parseObject(o));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.append(<span class="hljs-string">&quot;\n&#125;&quot;</span>).toString();<br>    &#125;<br>    <span class="hljs-comment">//既不是数组，也不是字符串，那就是普通对象</span><br>    <span class="hljs-keyword">while</span>(c!=<span class="hljs-keyword">null</span>)&#123;<br>        sb.append(c.getName());<br>        sb.append(<span class="hljs-string">&quot;[&quot;</span>);<br>        Field[] fields = c.getDeclaredFields();<br>        AccessibleObject.setAccessible(fields,<span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;fields.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!Modifier.isStatic(fields[i].getModifiers())) &#123;<br>                <span class="hljs-keyword">if</span> (!sb.toString().endsWith(<span class="hljs-string">&quot;[&quot;</span>)) &#123;<br>                    sb.append(<span class="hljs-string">&quot;,&quot;</span>);<br>                &#125;<br>                sb.append(fields[i].getName()).append(<span class="hljs-string">&quot;=&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//属性为8种普通类型，直接打印即可</span><br>                    <span class="hljs-keyword">if</span> (fields[i].getType().isPrimitive()) &#123;<br>                        sb.append(fields[i].get(obj));<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">//属性为类，继续递归解析</span><br>                        sb.append(parseObject(fields[i].get(obj)));<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        sb.append(<span class="hljs-string">&quot;]&quot;</span>);<br>        c=c.getSuperclass();<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>测试代码为：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        list.add(i*i);<br>    &#125;<br><br>    System.out.println(ReflectionUtil.parseObject(list).toString());<br><br></code></pre></div></td></tr></table></figure><hr><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">java.util.ArrayList[elementData=<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Object</span>[]</span>&#123;<br>    java.lang.Integer[value=<span class="hljs-number">1</span>]java.lang.Number[]java.lang.Object[],<br>    java.lang.Integer[value=<span class="hljs-number">4</span>]java.lang.Number[]java.lang.Object[],<br>    java.lang.Integer[value=<span class="hljs-number">9</span>]java.lang.Number[]java.lang.Object[],<br>    ,<br>    ,<br>    ,<br>    ,<br>    ,<br>    ,<br>&#125;,size=<span class="hljs-number">3</span>]java.util.AbstractList[modCount=<span class="hljs-number">3</span>]java.util.AbstractCollection[]java.lang.Object[]<br></code></pre></div></td></tr></table></figure><p>这里的空白行是为ArrayList的默认容量为10。</p><p>小结：我们通过Filed类的<code>getType()</code>的方法来获取属性的类型，通过Field类的<code>get(Object o)</code>获取该属性的值，参数为我们当前想要查看的对象。</p><h3 id="0x4-反射机制的优缺点"><a href="#0x4-反射机制的优缺点" class="headerlink" title="0x4 反射机制的优缺点"></a>0x4 反射机制的优缺点</h3><p>优点：</p><ul><li>就是灵活，提高了对未知代码的兼容性</li></ul><p>缺点：</p><ul><li>对性能有影响，反射的性能消耗比不使用的要高很多</li><li>而且打破了安全限制，使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</li><li>破坏了封装性</li></ul><p>所以能不用反射，就不用反射。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&mid=2247483785&idx=1&sn=f696c8c49cb7ecce9818247683482a1c&chksm=e9c2ed84deb564925172b2dd78d307d4dc345fa313d3e44f01e84fa22ac5561b37aec5cbd5b4&scene=0#rd">java反射机制详解</a></p></li><li><p><a href="https://laijianfeng.org/2018/12/Java-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/">动态代理详解</a></p></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E5%8F%8D%E5%B0%84/">反射</category>
      
      
      <category domain="https://eripe.me/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">基本概念</category>
      
      
      <comments>https://eripe.me/articles/%E5%8F%8D%E5%B0%84%E5%88%9D%E4%BD%93%E9%AA%8C.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java的内存布局</title>
      <link>https://eripe.me/articles/java-memory-layout.html</link>
      <guid>https://eripe.me/articles/java-memory-layout.html</guid>
      <pubDate>Mon, 30 Aug 2021 16:38:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>众所周知,java虚拟机的内存布局和传统的内存布局都差不多,都分为栈、堆啥的。准确的来说，jvm的内存分为以下几个部分:</p><ul><li>程序计数器(就是eip)</li><li>堆</li><li>方法区</li><li>本地方法栈</li><li>虚拟机栈</li></ul><p>其中堆和方法区是所有线程锁共享的,而程序计数器、栈肯定都是线程私有的,因为这与程序的正常运行息息相关。</p><p>上述的五个区域都可能产生内存溢出,有的还可能产生内存泄漏(虽然内存由jvm管理,但是并不能保证内存不会泄露奥)。下面我将一一介绍上述四个区域(不包括程序计数器)产生内存溢出的一般情况,当然大部分内容还是来自&lt;&lt;深入理解JVM&gt;&gt;一书,我在这里仅仅做个概括加上自己一点的感想。</p><h2 id="0x1-虚拟机栈"><a href="#0x1-虚拟机栈" class="headerlink" title="0x1 虚拟机栈"></a>0x1 虚拟机栈</h2><p>虚拟机栈跟传统汇编里的栈感觉差不多,只不过这里用所谓的局部变量槽来保存(Slot)。当然栈就是用来存储局部变量和返回地址的，内容肯定和传统栈一样。当然本地方法栈和虚拟机栈在性质上就是一类东西,<strong>仅仅是用途不同而已</strong>。所以就不单独分开说本地方法栈了。</p><p>Tips:</p><blockquote><p>当进入一个方法时,这个方法需要多少个局部变量槽是确定的,局部变量所需的内存在编译时期分配完成,而具体内存是多少个byte是不确定的,因为局部变量槽的实现方式不在JVM规范中。由虚拟机厂商所决定。</p></blockquote><p>上面这个我也是才注意的,不像传统栈可以不停的push,使用的大小完全无法确定。</p><p>进入正题,虚拟机栈可能会发生两种内存错误:</p><ul><li>StackOverFlow</li><li>OutOfMemeory</li></ul><p>StackOverFlow要么是死递归造成的栈空间不够,要么是局部变量太多。感觉后者不太可能发生,因为需要的局部变量太多儿。所以出现StackOverFlow的第一直觉就是死递归。</p><p>第二种出现于允许栈可扩展的虚拟机中。虚拟机之王HotSpot是不支持虚拟机栈扩展的。但是仍然可能出现OOM,当线程申请栈空间失败时。反之申请成功就永远不会出现OOM。</p><h2 id="0x2-堆"><a href="#0x2-堆" class="headerlink" title="0x2 堆"></a>0x2 堆</h2><p>堆是所有线程共享的内存区域,堆中能出现的内存错误当然是OOM辣。在Java中,几乎所有的对象实例都在堆中分配(具体解释来自深入理解JVM:page45)。</p><p>堆的可以被实现为固定的或者可扩展的。hotSpot中堆属于可扩展的。堆的大小可以通过参数<code>-Xms</code>(初始堆的大小)和<code>-Xmx</code>(堆的最大值)来控制。</p><p>当在堆中无法完成对象的分配时,在堆上就会出现OOM。</p><h3 id="0x2-1-方法区"><a href="#0x2-1-方法区" class="headerlink" title="0x2-1 方法区"></a>0x2-1 方法区</h3><p>方法区跟堆一样也是属于所有线程共享的内存区域。其中主要存储由虚拟机加载的类型信息、常量、静态变量、JIT编译后的缓存数据等等。</p><p>在JDK8以前,HotSopt采用了永久代的方法实现了方法区,从而能够像管理堆一样管理方法区。<strong>但是这是一个陋习</strong>。永久代有上限,这就导致在加载过多类后会出现内存溢出。</p><p>所以在JDK7中,oracle已经将方法区中的常量池、静态变量移出了永久代。在JDK8中,在方法区中彻底废除了永久代,通过在本地内存中实现元空间(与J9类似)保存剩余的信息,大部分都是类型信息。</p><p>虚拟机规范对方法区的要求是非常宽松的,比如方法区可以<strong>不执行内存回收</strong>,当然在方法区执行内存回收也是比较麻烦的。</p><p>当在方法区中无法申请到满足要求的内存时,就会出现OOM错误。</p><h3 id="0x2-2-运行时常量池"><a href="#0x2-2-运行时常量池" class="headerlink" title="0x2-2 运行时常量池"></a>0x2-2 运行时常量池</h3><p>运行时常量池本来是属于方法区的东西(注意oralce在JDK7是把常量池移出了永久代,而不是移出了方法区)。在Class文件中有一项信息为常量表,存储的是编译时期的各种常量与符号引用。这部分内容将在类加载完成后存放至方法区的运行时常量池。</p><p>当然常量池的内容不一定得是编译时的常量，也可以在运行时将新常量加入到池中。所以说运行时常量池与Class文件的常量池相比,前者具有动态性。</p><p>运行时常量池既然是方法区的东西,自然也会受到方法区的限制,当无法申请到足够多的内存时,就会出现OOM。</p><h2 id="0x3-直接内存"><a href="#0x3-直接内存" class="headerlink" title="0x3 直接内存"></a>0x3 直接内存</h2><p>直接内存并不是虚拟机规范中定义的内存区域,但是逐渐变得很重要。</p><p>在JDK1.4中,java引入了NIO。注意IO操作可以是要频繁跟本地堆的内容进行交互的。所以在NIO中：</p><blockquote><p>引入了一种基于管道和缓冲区的IO方式,可以直接使用native函数库分配native堆,然后通过一个存储在java堆中的DirectByteBuffer对象作为native堆的引用来操作native堆</p></blockquote><p>上述这种操作就避免了在java堆中和native中频繁的复制数据。</p><p>native堆的分配大小一般都会忽略,导致各个内存区域的大小总和超过了本机主机内存,从而出现OOM。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://medium.com/platform-engineer/understanding-java-memory-model-1d0863f6d973">Understanding Java Memory Model</a></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/jvm/">jvm</category>
      
      
      <category domain="https://eripe.me/tags/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/">内存布局</category>
      
      
      <comments>https://eripe.me/articles/java-memory-layout.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java中的类型系统</title>
      <link>https://eripe.me/articles/type-system-of-java.html</link>
      <guid>https://eripe.me/articles/type-system-of-java.html</guid>
      <pubDate>Mon, 30 Aug 2021 16:38:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>java的类型系统在1.5之后就变的很复杂了。但是又极其重要因为java中的反射基于此。所以想要深入理解反射还需要简单地学习一下java的类型系统。首先我们简要说明一下在逻辑上java的type分类。然后再在实现层次上简要了解一下java到底是如何实现的。</p><p>首先java是一个强类型语言,其任何一个变量、任何一个表达式都有类型。在Java中,总的分为<del>两类</del>三类(还有一个特殊的<code>null type</code>):</p><ul><li>primitive types:原始类型,分类<code>boolean type</code>和<code>numeric type</code>,后者又可以分为<code>integral types</code>和<code>floating-point types</code>。<ul><li>integral types:包括<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>char</code></li><li>floating-point type:包括<code>float</code>和<code>double</code></li></ul></li><li>reference types:包括<code>class types</code>、<code>interface types</code>、<code>array type</code>以及<code>type virables</code></li><li>special type:<code>null type</code></li></ul><blockquote><p>在java中,对象是类的实例或者是动态创建的数组,<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3">参考文献</a></p></blockquote><p>是的,数组也是一个对象。</p><hr><p><strong>Extension：</strong></p><p>这里额外说一下<code>null type</code>,关键字<code>null</code>不是一个类型而是一个特殊的值,可以简答的认为null指向一个特殊的内存区域。我们不能声明一个为<code>null type</code>的引用,也不能将<code>null type</code>声明为类型参数,例如<code>List&lt;null&gt;</code>(<a href="https://stackoverflow.com/questions/26632104/java-kinds-of-type-and-null-reference">参考</a>)。但是<code>null</code>却可以强转为任何类型的引用,转换结果为目标类型的空引用,<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.2">参考</a>。</p><blockquote><p>A value of the null type (the null reference is the only such value) may be assigned to any reference type, resulting in a null reference of that type.</p></blockquote><p>最后,<code>null type</code>不是一个引用类型。</p><hr><h3 id="Reference-Types"><a href="#Reference-Types" class="headerlink" title="Reference Types"></a>Reference Types</h3><p>下面的一段代码使用了四种引用类型(摘自<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3">jse8规范</a>):</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">int</span>[] metrics;<br>    T variables;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Move</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">int</span> deltax, <span class="hljs-keyword">int</span> deltay)</span></span>; &#125;<br></code></pre></div></td></tr></table></figure><p>其中,<code>Point</code>是一个<code>class type</code>(翻译成类类型好难受…),<code>int[]</code>是一个<code>array type</code>,<code>Move</code>是一个<code>interface type</code>,<code>T</code>是一个<code>type variable</code>。前三种都很好理解,最后一个<code>type variable</code>值得一提。</p><p>在jse8规范中,<code>type variable</code>被定义为一个唯一的符号在类、接口、方法、构造函数中作为一个type。所以这个<code>type variable</code>只能在上面四个地方使用。引入<code>type variable</code>的原因是因为在泛型类、泛型接口、泛型构造函数、泛型方法中定义了类型参数。</p><p>所以,很好理解,<code>type variable</code>就是泛型中<code>&lt;T&gt;</code>中的T。注意,<code>type</code></p><p><code>Type</code>接口是java中type信息的顶级接口。主要有五种type,分别是:</p><ul><li><code>raw types</code>:原始类型,使用对应类型的Class对象表示</li><li><code>primitive types</code>:基本类型,使用对应原始类型的Class对象表示</li><li><code>parameterized types</code>:参数类型,基于接口<code>ParameterizedTypes</code>,对应实现类为<code>ParameterizedTypesImpl</code></li><li><code>array types</code>:泛型数组类型,基于接口<code>GenericArrayType</code>,对应实现类为<code>GenericArrayTypeImpl</code></li><li><code>type variables</code>:类型变量,基于接口<code>TypeVariable</code>,对应实现类为<code>TypeVariableImpl</code></li><li><code>WildcardType</code>:通配符类型,基于接口<code>WildcardType</code>,对应实现类为<code>WildcardTypeImpl</code></li></ul><p>其中<code>ParameterizedTypes</code>、<code>GenericArrayType</code>、<code>TypeVariable</code>、<code>WildcardType</code>这四个接口是<code>Type</code>接口的子接口。继承图如下所示:</p><p><img src="images/Type.png" alt="Type继承图"></p><p>可以看到,<code>Class</code>类是<code>Type</code>接口的子类。下面来一一解释一下四种子接口的含义。</p><h2 id="1-ParameterizedType"><a href="#1-ParameterizedType" class="headerlink" title="1. ParameterizedType"></a>1. ParameterizedType</h2><p><code>ParameterizedType</code>翻译过来就是参数化类型,emm。应该就是将类型参数化,这是引入泛型(Generic)的必然结果。例如我们常用的<code>List&lt;Integer&gt;</code>,这一个完整的带<code>&lt;&gt;</code>的类型就叫做参数化类型。下面解释了raw type于parameterized type之间的关系。</p><ul><li>genric type:<code>List&lt;T&gt;</code></li><li>parameterized type:<code>List&lt;Integer&gt;</code></li><li>raw type:<code>List</code></li><li>type parameter:<code>Integer</code></li></ul><p><strong>有如下常用方法</strong>:</p><ul><li><code>Type getRawType()</code>: 返回承载该泛型信息的对象, 如上面那个Map&lt;String, String&gt;承载范型信息的对象是Map</li><li><code>Type[] getActualTypeArguments()</code>: 返回实际泛型类型列表, 如上面那个Map&lt;String, String&gt;实际范型列表中有两个元素, 都是String</li><li><code>Type getOwnerType()</code>: 返回当前成员的属主,例如<code>Map.Entry</code>属于<code>Map</code></li></ul><p>以具体的参数化类型, 如<code>Map&lt;String, String&gt;</code>为例:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestType</span> </span>&#123;<br>    Map&lt;String, String&gt; map;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Field f = TestType.class.getDeclaredField(<span class="hljs-string">&quot;map&quot;</span>);<br>        System.out.println(f.getGenericType());                               <span class="hljs-comment">// java.util.Map&lt;java.lang.String, java.lang.String&gt;</span><br>        System.out.println(f.getGenericType() <span class="hljs-keyword">instanceof</span> ParameterizedType);  <span class="hljs-comment">// true</span><br>        ParameterizedType pType = (ParameterizedType) f.getGenericType();<br>        System.out.println(pType.getRawType());                               <span class="hljs-comment">// interface java.util.Map</span><br>        <span class="hljs-keyword">for</span> (Type type : pType.getActualTypeArguments()) &#123;<br>            System.out.println(type);                                         <span class="hljs-comment">// 打印两遍: class java.lang.String</span><br>        &#125;<br>        System.out.println(pType.getOwnerType());                             <span class="hljs-comment">// null</span><br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="2-TypeVariable"><a href="#2-TypeVariable" class="headerlink" title="2. TypeVariable"></a>2. TypeVariable</h2><p>类型变量, 范型信息在编译时会被转换为一个特定的类型, 而TypeVariable就是用来反映在JVM编译该泛型前的信息.</p><p><strong>常用方法:</strong></p><ul><li><code>Type[] getBounds()</code>: 获取类型变量的上边界, 若未明确声明上边界则默认为Object</li><li><code>D getGenericDeclaration()</code>: 获取声明该类型变量实体,其中<code>D</code>是泛型类型的声明,也就是所在的类全限定名</li><li><code>String getName()</code>: 获取在源码中定义时的名字</li></ul><p>注意:<br>类型变量在定义的时候只能使用extends进行(多)边界限定, 不能用super;为什么边界是一个数组? 因为类型变量可以通过&amp;进行多个上边界限定，因此上边界有多个</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestType</span> &lt;<span class="hljs-title">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span> &amp; <span class="hljs-title">Serializable</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br>    K key;<br>    V value;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获取字段的类型</span><br>        Field fk = TestType.class.getDeclaredField(<span class="hljs-string">&quot;key&quot;</span>);<br>        Field fv = TestType.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>);<br>        Assert.that(fk.getGenericType() <span class="hljs-keyword">instanceof</span> TypeVariable, <span class="hljs-string">&quot;必须为TypeVariable类型&quot;</span>);<br>        Assert.that(fv.getGenericType() <span class="hljs-keyword">instanceof</span> TypeVariable, <span class="hljs-string">&quot;必须为TypeVariable类型&quot;</span>);<br>        TypeVariable keyType = (TypeVariable)fk.getGenericType();<br>        TypeVariable valueType = (TypeVariable)fv.getGenericType();<br>        <span class="hljs-comment">// getName 方法</span><br>        System.out.println(keyType.getName());                 <span class="hljs-comment">// K</span><br>        System.out.println(valueType.getName());               <span class="hljs-comment">// V</span><br>        <span class="hljs-comment">// getGenericDeclaration 方法</span><br>        System.out.println(keyType.getGenericDeclaration());   <span class="hljs-comment">// class com.test.TestType</span><br>        System.out.println(valueType.getGenericDeclaration()); <span class="hljs-comment">// class com.test.TestType</span><br>        <span class="hljs-comment">// getBounds 方法</span><br>        System.out.println(<span class="hljs-string">&quot;K 的上界:&quot;</span>);                        <span class="hljs-comment">// 有两个</span><br>        <span class="hljs-keyword">for</span> (Type type : keyType.getBounds()) &#123;                <span class="hljs-comment">// interface java.lang.Comparable</span><br>            System.out.println(type);                          <span class="hljs-comment">// interface java.io.Serializable</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;V 的上界:&quot;</span>);                        <span class="hljs-comment">// 没明确声明上界的, 默认上界是 Object</span><br>        <span class="hljs-keyword">for</span> (Type type : valueType.getBounds()) &#123;              <span class="hljs-comment">// class java.lang.Object</span><br>            System.out.println(type);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-GenericArrayType"><a href="#3-GenericArrayType" class="headerlink" title="3. GenericArrayType"></a>3. GenericArrayType</h2><p>我们仍然记得,不能创建泛型数组,那么这个<code>GenericArrayType</code>是啥意思?</p><p>虽然不能泛型数组,但是能够创建泛型数组引用啊,<code>T[] nums=null</code>是合法的,见下方代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestType</span> &lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Method method = Test.class.getDeclaredMethods()[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// public void com.test.Test.show(java.util.List[],java.lang.Object[],java.util.List,java.lang.String[],int[])</span><br>        System.out.println(method);<br>        Type[] types = method.getGenericParameterTypes();  <span class="hljs-comment">// 这是 Method 中的方法</span><br>        <span class="hljs-keyword">for</span> (Type type : types) &#123;<br>            System.out.println(type <span class="hljs-keyword">instanceof</span> GenericArrayType);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(List&lt;String&gt;[] pTypeArray, T[] vTypeArray, List&lt;String&gt; list, String[] strings, <span class="hljs-keyword">int</span>[] ints)</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>声明一个泛型数组引用还是没有问题的,运行结果如下:</p><ul><li>第一个参数List<String>[]的组成元素List<String>是ParameterizedType类型, 打印结果为true</li><li>第二个参数T[]的组成元素T是TypeVariable类型, 打印结果为true</li><li>第三个参数List<String>不是数组, 打印结果为false</li><li>第四个参数String[]的组成元素String是普通对象, 没有范型, 打印结果为false</li><li>第五个参数int[] pTypeArray的组成元素int是原生类型, 也没有范型, 打印结果为false</li></ul><p>所以数组元素是<code>ParameterizedType</code>或<code>TypeVariable</code>的数组类型才是<code>GenericArrayType</code>。</p><h2 id="4-WildcardType"><a href="#4-WildcardType" class="headerlink" title="4. WildcardType"></a>4. WildcardType</h2><p>该接口表示通配符泛型, 比如? extends Number 和 ? super Integer 它有如下方法:</p><ul><li>Type[] getUpperBounds(): 获取范型变量的上界</li><li>Type[] getLowerBounds(): 获取范型变量的下界<br>注意:</li></ul><p>现阶段通配符只接受一个上边界或下边界, 返回数组是为了以后的扩展, 实际上现在返回的数组的大小是1</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestType</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;? extends Number&gt; a;  <span class="hljs-comment">// // a没有下界, 取下界会抛出ArrayIndexOutOfBoundsException</span><br>    <span class="hljs-keyword">private</span> List&lt;? <span class="hljs-keyword">super</span> String&gt; b;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Field fieldA = TestType.class.getDeclaredField(<span class="hljs-string">&quot;a&quot;</span>);<br>        Field fieldB = TestType.class.getDeclaredField(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-comment">// 先拿到范型类型</span><br>        Assert.that(fieldA.getGenericType() <span class="hljs-keyword">instanceof</span> ParameterizedType, <span class="hljs-string">&quot;&quot;</span>);<br>        Assert.that(fieldB.getGenericType() <span class="hljs-keyword">instanceof</span> ParameterizedType, <span class="hljs-string">&quot;&quot;</span>);<br>        ParameterizedType pTypeA = (ParameterizedType) fieldA.getGenericType();<br>        ParameterizedType pTypeB = (ParameterizedType) fieldB.getGenericType();<br>        <span class="hljs-comment">// 再从范型里拿到通配符类型</span><br>        Assert.that(pTypeA.getActualTypeArguments()[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> WildcardType, <span class="hljs-string">&quot;&quot;</span>);<br>        Assert.that(pTypeB.getActualTypeArguments()[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> WildcardType, <span class="hljs-string">&quot;&quot;</span>);<br>        WildcardType wTypeA = (WildcardType) pTypeA.getActualTypeArguments()[<span class="hljs-number">0</span>];<br>        WildcardType wTypeB = (WildcardType) pTypeB.getActualTypeArguments()[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 方法测试</span><br>        System.out.println(wTypeA.getUpperBounds()[<span class="hljs-number">0</span>]);   <span class="hljs-comment">// class java.lang.Number</span><br>        System.out.println(wTypeB.getLowerBounds()[<span class="hljs-number">0</span>]);   <span class="hljs-comment">// class java.lang.String</span><br>        <span class="hljs-comment">// 看看通配符类型到底是什么, 打印结果为: ? extends java.lang.Number</span><br>        System.out.println(wTypeA);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>转载自<a href="http://loveshisong.cn/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2016-02-16-Type%E8%AF%A6%E8%A7%A3.html">Java中的Type详解</a>。</p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E5%8F%8D%E5%B0%84/">反射</category>
      
      
      <category domain="https://eripe.me/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">基本概念</category>
      
      <category domain="https://eripe.me/tags/%E7%B1%BB%E5%9E%8B/">类型</category>
      
      
      <comments>https://eripe.me/articles/type-system-of-java.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>通过MySQL驱动的加载学习SPI机制</title>
      <link>https://eripe.me/articles/SPI-service-mechanism.html</link>
      <guid>https://eripe.me/articles/SPI-service-mechanism.html</guid>
      <pubDate>Mon, 30 Aug 2021 16:38:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言-什么是SPI&quot;&gt;&lt;a href=&quot;#前言-什么是SPI&quot; class=&quot;headerlink&quot; title=&quot;前言 什么是SPI&quot;&gt;&lt;/a&gt;前言</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言-什么是SPI"><a href="#前言-什么是SPI" class="headerlink" title="前言 什么是SPI"></a>前言 什么是SPI</h2><p>SPI机制（Service Provider Interface)简而言之，就是java规定了一组服务的接口，但是没有具体的实现类。那么具体的实现类肯定由不同的厂商实现，那么客户在使用时是仅依赖于接口的。<strong>SPI的具体实现是靠<code>ServiceLoader</code>完成的。</strong><br>在讲解双亲委派模型时，我们知道，SPI接口是通过<code>bootstrap ClassLoader</code>加载至jvm中的。而具体的驱动实现类是通过线程上下文类加载器加载至jvm中的。下面我们就通过加载数据库驱动的例子来了解SPI的实现原理。</p><h2 id="1-获得数据库连接实例的方式"><a href="#1-获得数据库连接实例的方式" class="headerlink" title="1. 获得数据库连接实例的方式"></a>1. 获得数据库连接实例的方式</h2><p>在JDBC4.0之前，还没有引入SPI，一般需要使用<code>Class.forName()</code>注册驱动，所以加载驱动的代码一般是如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Class.forName(<span class="hljs-string">&quot;xxxx&quot;</span>);<br>Connection c=DriverManager.getConnection(<span class="hljs-string">&quot;url&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>在JDBC4.0之后，我们只需要使用<code>DriverManager.getConnection(url)</code>就可以获得连接对象。这是因为在<code>getConnection()</code>内部会自己调用<code>Class.forName()</code>，这里包含了一层嵌套关系。而<code>DriverManager</code>又是由<code>Bootstrap ClassLoader</code>加载的，根据符号解析的规定，<code>DriverManager</code>内部的符号如果需要解析为类或接口，则会调用<code>DriverManager</code>的加载器。但是问题是<code>DriverManager</code>只会加载核心库。根据双亲委派模型，父类的请求无法派给子类，所以这时候就采用了线程上下文类加载器。<strong>而在JDBC4.0之前没有这层嵌套关系。</strong></p><p>下面我们来看看到底是如何获得驱动的。在初次使用<code>DriverManager</code>时，首先会执行静态代码块中<code>loadInitialDrivers()</code>函数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    loadInitialDrivers();<br>    println(<span class="hljs-string">&quot;JDBC DriverManager initialized&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>初始化函数如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadInitialDrivers</span><span class="hljs-params">()</span> </span>&#123;<br>    String drivers;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//查看是否设置了系统属性jdbc.drivers</span><br>        drivers = AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> System.getProperty(<span class="hljs-string">&quot;jdbc.drivers&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        drivers = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//使用ServiceLoader加载驱动</span><br>    AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);<br>            <br>            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">while</span>(driversIterator.hasNext()) &#123;<br>                    driversIterator.next();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;<br>            <span class="hljs-comment">// Do nothing</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;);<br><br>    println(<span class="hljs-string">&quot;DriverManager.initialize: jdbc.drivers = &quot;</span> + drivers);<br><br>    <span class="hljs-keyword">if</span> (drivers == <span class="hljs-keyword">null</span> || drivers.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//如果设置了系统属性jdbc.drivers,</span><br>    <span class="hljs-comment">//那么如果SPI已经成功加载了驱动，下面的代码还是会重复注册驱动</span><br>    String[] driversList = drivers.split(<span class="hljs-string">&quot;:&quot;</span>);<br>    println(<span class="hljs-string">&quot;number of Drivers:&quot;</span> + driversList.length);<br>    <span class="hljs-keyword">for</span> (String aDriver : driversList) &#123;<br>        ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，<code>DriverManager</code>的初始化分分为两个版本：</p><ul><li>设置系统属性<code>jdbc.drivers</code>属性</li><li>使用``ServiceLoader`加载，如果驱动以service provider的形式出现</li></ul><h2 id="2-SPI加载数据库驱动的原理"><a href="#2-SPI加载数据库驱动的原理" class="headerlink" title="2. SPI加载数据库驱动的原理"></a>2. SPI加载数据库驱动的原理</h2><h3 id="2-1-获取ServiceLoader对象"><a href="#2-1-获取ServiceLoader对象" class="headerlink" title="2.1 获取ServiceLoader对象"></a>2.1 获取ServiceLoader对象</h3><p>使用SPI初始化代码时首先使用<code>ServiceLoader</code>的静态方法<code>load</code>加载SPI<code>Driver</code>的class文件。源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-function">ServiceLoader&lt;S&gt; <span class="hljs-title">load</span><span class="hljs-params">(Class&lt;S&gt; service)</span> </span>&#123;<br>    ClassLoader cl = Thread.currentThread().getContextClassLoader();<br>    <span class="hljs-keyword">return</span> ServiceLoader.load(service, cl);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code> ServiceLoader.load(service, cl)</code>又会通过私有构造方法返回<code>ServiceLoader</code>对象，在私有构造方法内部调用了<code>reload()</code>方法，源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reload</span><span class="hljs-params">()</span> </span>&#123;<br>    providers.clear();<br>    lookupIterator = <span class="hljs-keyword">new</span> LazyIterator(service, loader);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先清空<code>providers</code>，这里的<code>providers</code>是一个<code>LinkedHashMap</code>，用来保存已经加载过服务实现类的实例。随后生成了<code>lazyIterator</code>对象，这个懒加载器是<code>ServiceLoader</code>的核心，它完成了查找实现类、加载实现类的动作。</p><p>那么这里的<strong>懒</strong>到底是指什么？我的理解是在程序启动之初，服务实现类并没有被加载至jvm中<strong>直到我们使用时</strong>。所以这里的懒就是在程序启动到我们使用之前的这一段时间内，不需要也没有加载服务实现类，懒就是懒在这个阶段。那非懒应该就是指在程序一启动就会加载所有的服务实现类。</p><h3 id="2-2-使用ServiceLoader对象迭代器遍历实现类容器"><a href="#2-2-使用ServiceLoader对象迭代器遍历实现类容器" class="headerlink" title="2.2 使用ServiceLoader对象迭代器遍历实现类容器"></a>2.2 使用ServiceLoader对象迭代器遍历实现类容器</h3><p>在成功获取ServiceLoader对象<code>loadedDrivers</code>后，会继续获取<code>loadedDrivers</code>的内部迭代器：</p><blockquote><p>Iterator<Driver> driversIterator = loadedDrivers.iterator();</p></blockquote><p>然后<code>DriverManager</code>会使用这个迭代器遍历ServiceLoader内部用来存储服务实现类对象的容器。具体的驱动注册就在遍历容器的时候完成。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-keyword">while</span>(driversIterator.hasNext()) &#123;<br>        driversIterator.next();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们来看看<code>ServiceLoader</code>内部迭代器的<code>hasNext()</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;S&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Iterator&lt;S&gt;() &#123;<br><br>        Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders<br>            = providers.entrySet().iterator();<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (knownProviders.hasNext())<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">return</span> lookupIterator.hasNext();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> S <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (knownProviders.hasNext())<br>                <span class="hljs-keyword">return</span> knownProviders.next().getValue();<br>            <span class="hljs-keyword">return</span> lookupIterator.next();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>hasNext()</code>首先调用内部容器<code>providers</code>自身的迭代器。失败后才会调用懒迭代器类<code>LazyIterator</code>的<code>hasNext()</code>，其具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyIterator</span></span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">S</span>&gt;</span><br><span class="hljs-class"></span>&#123;<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//无论执行if还是else，都会最终执行hasNextService</span><br>        <span class="hljs-keyword">if</span> (acc == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> hasNextService();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            PrivilegedAction&lt;Boolean&gt; action = <span class="hljs-keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;<br>                <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> hasNextService(); &#125;<br>            &#125;;<br>            <span class="hljs-keyword">return</span> AccessController.doPrivileged(action, acc);<br>        &#125;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在调用<code>LazyIteraotr</code>的<code>hasNext()</code>方法后，内部会调用<code>hashNextService()</code>:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNextService</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nextName != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (configs == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <br>            String fullName = PREFIX + service.getName();<br>            <span class="hljs-keyword">if</span> (loader == <span class="hljs-keyword">null</span>)<br>                configs = ClassLoader.getSystemResources(fullName);<br>            <span class="hljs-keyword">else</span><br>                configs = loader.getResources(fullName);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException x) &#123;<br>            fail(service, <span class="hljs-string">&quot;Error locating configuration files&quot;</span>, x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> ((pending == <span class="hljs-keyword">null</span>) || !pending.hasNext()) &#123;<br>        <span class="hljs-keyword">if</span> (!configs.hasMoreElements()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        pending = parse(service, configs.nextElement());<br>    &#125;<br>    nextName = pending.next();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们看到该方法内部有一个常量字符串<code>PREFIX</code>，其值为:</p><blockquote><p>private static final String PREFIX = “META-INF/services/“;</p></blockquote><p>这是因为java规定，所谓为SPI提供实现的厂商必须在jar包提供目录<code>META-INF/services/</code>，目录内的文件存放当前服务实现类的入口类名，文件名文当前服务接口的全限定名。以MySQL为例，其jar包内容如下：</p><p><img src="images/mysql-SPI.PNG" alt="mysql-SPI"></p><p>其中<code>java.sql.Driver</code>就是java数据库服务接口的全限定名，其内容如下：</p><p><img src="images/mysql-content.PNG" alt="mysql-content"></p><p><code>com.mysql.cj.jdbc.Driver</code>就是具体实现类的全限定名。<code>hasNextService</code>的目标就是把具体实现类的全限定名找到。找的方法就是找到文件：<code>META-INF/services/+service.name</code>。其中<code>service</code>的名字是java规定好的。例如加载数据库时的<code>service</code>就对应<code>Driver</code>类。</p><p>在找到具体实现类的名字后，下一步当然是要把它加载进来了。调用<code>ServiceLoader</code>迭代器的<code>next()</code>方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (acc == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> hasNextService();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        PrivilegedAction&lt;Boolean&gt; action = <span class="hljs-keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> hasNextService(); &#125;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> AccessController.doPrivileged(action, acc);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> S <span class="hljs-title">nextService</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!hasNextService())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>    String cn = nextName;<br>    nextName = <span class="hljs-keyword">null</span>;<br>    Class&lt;?&gt; c = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        c = Class.forName(cn, <span class="hljs-keyword">false</span>, loader);<br>    &#125;<br>    ...<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        S p = service.cast(c.newInstance());<br>        providers.put(cn, p);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>具体的加载由<code>Class.forName()</code>完成，注意，其中传入的loader是线程上下文类加载器。在将具体实现类加载进jvm后，会实例化一个实现类对象，即调用<code>c.newInstance()</code>。在实例化的过程完成了驱动的注册。我们来看看mysql实现类的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Driver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NonRegisteringDriver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">sql</span>.<span class="hljs-title">Driver</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Driver</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            DriverManager.registerDriver(<span class="hljs-keyword">new</span> Driver());<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException var1) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Can&#x27;t register driver!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>非常简单，一旦进行实例化，就会执行静态构造代码块，mysql实现的<code>Driver</code>会主动向<code>DriverManger</code>提出注册请求。至此，已经完成了数据库驱动的一次注册过程。</p><h3 id="2-3-获得数据库连接对象"><a href="#2-3-获得数据库连接对象" class="headerlink" title="2.3 获得数据库连接对象"></a>2.3 获得数据库连接对象</h3><p><code>DriverManager</code>会遍历所有已经注册过的驱动，如果能成功连接目标数据库，那么就返回当前连接对象，否则继续遍历剩下的Driver实例直至结束。下面是遍历驱动的核心代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;<br>    <span class="hljs-comment">// If the caller does not have permission to load the driver then</span><br>    <span class="hljs-comment">// skip it.</span><br>    <span class="hljs-keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            println(<span class="hljs-string">&quot;    trying &quot;</span> + aDriver.driver.getClass().getName());<br>            Connection con = aDriver.driver.connect(url, info);<br>            <span class="hljs-keyword">if</span> (con != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// Success!</span><br>                println(<span class="hljs-string">&quot;getConnection returning &quot;</span> + aDriver.driver.getClass().getName());<br>                <span class="hljs-keyword">return</span> (con);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException ex) &#123;<br>            <span class="hljs-keyword">if</span> (reason == <span class="hljs-keyword">null</span>) &#123;<br>                reason = ex;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        println(<span class="hljs-string">&quot;    skipping: &quot;</span> + aDriver.getClass().getName());<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，如果在一次尝试连接中抛出异常，那么就不会尝试后续的数据库驱动，这还是有点小bug的。</p><h3 id="2-4-存在的问题"><a href="#2-4-存在的问题" class="headerlink" title="2.4 存在的问题"></a>2.4 存在的问题</h3><p><strong>A. ServiceLoader的providers有什么用？</strong></p><p>可以看到，在<code>DriverMangaer</code>初次完成注册后，并没有使用过缓存<code>providers</code>。但是这仅仅是<code>DriverManager</code>的问题，并不能说明缓存没有用。如果我们此时再次遍历当前<code>loadedDrivers</code>，那么就不会再次使用<code>Class.forName()</code>加载，而是会通过内部缓存获得具体的实现类对象。</p><p><strong>B. 如果有多个驱动需要注册，那么在成功注册第一个驱动后，<code>knownProviders.hasNext()</code>返回的结果不应该是<code>true</code>吗？</strong></p><p>其实这跟HashMap迭代器的实现有关，在每次调用<code>entrySet().iterator()</code>后，返回的迭代器都是新<code>new</code>出来的，即初始化函数<code>loadInitialDrivers()</code>中的<code>driversIterator</code>永远都是<code>providers</code>为空时生成的迭代器。所以尽管成功了加载了一个驱动，<code>knownProviders.hasNext()</code>的结果依然是<code>false</code>，依旧会调用懒迭代器<code>lookupIterator</code>的<code>hasNext()</code>方法。</p><h2 id="3-传统的驱动加载方式"><a href="#3-传统的驱动加载方式" class="headerlink" title="3. 传统的驱动加载方式"></a>3. 传统的驱动加载方式</h2><p>传统的加载是通过<code>Class.forName()</code>完成的，而该方法会默认初始化目标类，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; forName(String className)<br>            <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    Class&lt;?&gt; caller = Reflection.getCallerClass();<br>    <span class="hljs-keyword">return</span> forName0(className, <span class="hljs-keyword">true</span>, ClassLoader.getClassLoader(caller), caller);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>一旦完成了实现类的初始化，数据库驱动会自己向<code>DriverManager</code>完成注册。SPI仅仅替代我们写了<code>Class.forName</code>这句话。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>SPI的核心<code>ServiceLoader</code>类，而该类的核心又是内部实现的<code>LazyIterator</code>。在实现SPI时，规定实现库的jar包中必须在<code>META-INF/services/</code>目录下存放以目标SPI命名的文件，其中的内容就是厂商具体实现类的全限定名。</p><p>但是SPI仍然是有缺点的：</p><ul><li>对于某一项服务，会加载所有的实现类，但是其中有一些我们并不需要</li><li>会存在并发问题</li></ul>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E7%B1%BB%E5%8A%A0%E8%BD%BD/">类加载</category>
      
      
      <category domain="https://eripe.me/tags/SPI%E6%9C%BA%E5%88%B6/">SPI机制</category>
      
      <category domain="https://eripe.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD/">数据库驱动加载</category>
      
      
      <comments>https://eripe.me/articles/SPI-service-mechanism.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java的泛型</title>
      <link>https://eripe.me/articles/the-generic-of-java.html</link>
      <guid>https://eripe.me/articles/the-generic-of-java.html</guid>
      <pubDate>Mon, 30 Aug 2021 16:38:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>这篇文章是在研究java的Type体系顺带扯出的概念,泛型的使用要说简单也很简单,要说难也可以说难。本文将由浅入深,带你学习java中的”泛型”。</p></blockquote><h2 id="1-泛型的基本概念"><a href="#1-泛型的基本概念" class="headerlink" title="1. 泛型的基本概念"></a>1. 泛型的基本概念</h2><p>泛型的概念始于java1.5,所以在1.5之前所有使用java的地方都没有泛型的影子,那么为了保持向后兼容,java中的泛型被设计成了伪泛型,仅仅存在于编译时期,在实际生成的字节码文件中是没有泛型的,这一动作叫做泛型的<strong>擦除</strong>。</p><p>泛型的基本格式为:<code>class Perosn&lt;T&gt;</code>,其中定义在<code>&lt;&gt;</code>的变量称为<code>type variable</code>,这一概念是随着泛型而出生的,并且也跟java的Type子系统息息相关。在jse8文档中,声明<code>type variable</code>允许用在四个地方,但是并不限制<code>type variable</code>的使用个数。允许的四个地方分别是:</p><ul><li>泛型类</li><li>泛型接口</li><li>泛型方法</li><li>泛型构造函数</li></ul><p>其中泛型构造函数的使用可以归档在泛型方法一类中。</p><p>注意:</p><blockquote><p>使用泛型构造方法并不要求类是泛型类</p></blockquote><p>更新(2020-08-14 20:18:36):</p><p>还有一些概念,了解后可以更好的帮助我们了解泛型:</p><ul><li>泛型类型(generic type):是一个带着类型参数的类型,即类似于<code>class Person&lt;T&gt;</code></li><li>参数化类型(parameterized type):即使用具体的类型实参去实例化泛型类型的类型,例如使用类型<code>String</code>去实例化泛型类型<code>class Person&lt;T&gt;</code>,所得的参数类型为<code>class Person&lt;String&gt;</code></li></ul><h3 id="1-1-泛型使用的简单示例"><a href="#1-1-泛型使用的简单示例" class="headerlink" title="1.1 泛型使用的简单示例"></a>1.1 泛型使用的简单示例</h3><p><strong>泛型类与泛型接口:</strong></p><p>泛型类和泛型接口的声明比较简单,仅需要在类名或者接口名后面使用<code>&lt;&gt;</code>声明<code>type variable</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//泛型类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T name;<br>    <span class="hljs-keyword">private</span> E age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T name,E id)</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.getClass().getSimpleName());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(T name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(E age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//泛型接口</span><br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">People</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>泛型方法:</strong></p><p>泛型方法又分为普通的泛型方法、静态泛型方法、泛型构造方法。泛型方法的声明麻烦一点,泛型方法需要在权限修饰后面定义所要使用的<code>type variable</code>。</p><p>下面是一组使用泛型方法和泛型类的代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> generic;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> T name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(T name,<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>        <span class="hljs-keyword">this</span>.age=age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(T name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">V</span>&gt;</span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span>&lt;T&gt; V <span class="hljs-title">getInfo</span><span class="hljs-params">(People&lt;T&gt; p1, People&lt;T&gt; p2, V sum)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;p1:&quot;</span>+p1.getName()+<span class="hljs-string">&quot; &quot;</span>+p1.getAge());<br>        System.out.println(<span class="hljs-string">&quot;p2:&quot;</span>+p2.getName()+<span class="hljs-string">&quot; &quot;</span>+p2.getAge());<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        People&lt;String&gt; p1=<span class="hljs-keyword">new</span> People&lt;&gt;(<span class="hljs-string">&quot;Bob&quot;</span>,<span class="hljs-number">23</span>);<br>        People&lt;String&gt; p2=<span class="hljs-keyword">new</span> People&lt;&gt;(<span class="hljs-string">&quot;Lee&quot;</span>,<span class="hljs-number">20</span>);<br>        Test&lt;Integer&gt; t=<span class="hljs-keyword">new</span> Test&lt;&gt;();<br>        Object result= t.&lt;String&gt;getInfo(p1,p2,<span class="hljs-number">23</span>);<br>        <span class="hljs-comment">//Object result=t.getInfo(p1,p2,23);</span><br><br>        System.out.println(<span class="hljs-string">&quot;result is an instance of Integer:&quot;</span>+result <span class="hljs-keyword">instanceof</span> Integer);<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">p1:Bob <span class="hljs-number">23</span><br>p2:Lee <span class="hljs-number">20</span><br>result is an instance of Integer:<span class="hljs-keyword">true</span><br></code></pre></div></td></tr></table></figure><p>其中泛型方法签名为:<code>public&lt;T&gt; V getInfo(People&lt;T&gt; p1, People&lt;T&gt; p2, V sum)</code>,<code>T</code>是这个泛型方法<code>getInfo</code>指定的类型变量,而<code>V</code>则是泛型类指定的类型变量。在调用泛型方法时,可以在<code>.</code>和方法名之间明确指定泛型方法的具体类型,或者让编译器自己推断。</p><p>其实上面这个泛型方法有个明显的缺点,就是返回值的类型也是一个泛型,这就要求调用者必须判断返回值的具体类型,因为接口。那么可能有人会问了,那<code>ArrayList</code>的源码中也有很多返回泛型的例子,他们写的也差劲?例如:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    rangeCheck(index);<br>    <span class="hljs-keyword">return</span> elementData(index);<br>&#125;<br><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-function">E <span class="hljs-title">elementData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (E) elementData[index];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样写是因为库编写者已经确定容器中存储的元素的类型就是<code>E</code>,强制转换成<code>E</code>并不会出错,并且调用者也知道返回的类型到底是什么。而且因为方法的返回值是泛型<code>E</code>,编译器会在调用者部分的字节码中自动插入一段强制转换代码将元素类型转为为<code>E</code>。这是由于类型擦除导致的,这会在<strong>后文</strong>详细解释。</p><p>静态泛型方法与常规的泛型方法唯一区别就是<strong>静态泛型方法中不能使用泛型类的类型变量</strong>,例如在<code>people</code>中声明一个方法:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;M&gt; calc(M year,M mouth)&#123;...&#125;<br></code></pre></div></td></tr></table></figure><p><code>calc</code>中不能使用泛型类<code>People</code>中的类型变量<code>T</code>。</p><p><strong>泛型构造方法:</strong></p><p>最后泛型构造方法又可以分为两种:类本身就是泛型类,类不是泛型类。下面是一个简单的例子:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//所在类不是泛型类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span></span>&#123;<br>    <span class="hljs-keyword">public</span> &lt;T &amp; Comparable&lt;T&gt;&gt; People(T age)&#123;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//所在类是泛型类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中<code>&lt;T &amp; Comparable&lt;T&gt;&gt;</code>的含义是要求<code>T</code>已经实现了Comparable接口。这部分细节可以查看jse8关于<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.4">type variable</a>的详细规范。</p><h2 id="2-泛型通配符"><a href="#2-泛型通配符" class="headerlink" title="2. 泛型通配符"></a>2. 泛型通配符</h2><p>在了解泛型通配符之前,我们需要知道一些基本术语:协变、逆变、不变,这一部分引自<a href="https://zhuanlan.zhihu.com/p/31137677">仔细说说Java中的泛型</a>。</p><p>逆变与协变用来描述类型转换（type transformation）后的继承关系，其定义：如果A、B表示类型，f(X)表示类型转换，≤表示继承关系(比如,A≤B表示A继承于b),那么这里有三个关系</p><blockquote><ol><li>当A≤B时有f(B)≤f(A)成立，那么说f(X)是逆变（contravariant）的</li><li>当A≤B时有f(A)≤f(B)成立，那么说f(X)是协变(covariant)的</li><li>当上两者都不成立的时候，那么说f(X)是不变（invariant)的</li></ol></blockquote><p>在java中,<strong>数组是支持协变的</strong>,例如下面这句代码可以通过编译,但会产生运行时错误:</p><blockquote><p>Number[] test=new Integer[];</p></blockquote><p><code>Integer</code>是<code>Number</code>的子类,同时变成数组,<code>Integer[]</code>还是<code>Number[]</code>的子类。</p><hr><p><strong>Extension One:在java中数组为什么要设计成协变的?</strong></p><p>答案来源于:<a href="https://www.zhihu.com/question/21394322">java中，数组为什么要设计为协变？</a>,我在这里补充一些我的理解。</p><p>在java1.5之前,java是不支持泛型的,因为没时间做。但是又需要泛型的特性,所以就把数组设计成协变的了。例如在比较数组时调用的是<code>Arrays.equals</code>方法,其底层调用的是<code>Object.equals</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object[] a, Object[] a2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a==a2)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> (a==<span class="hljs-keyword">null</span> || a2==<span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">int</span> length = a.length;<br>    <span class="hljs-keyword">if</span> (a2.length != length)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;length; i++) &#123;<br>        Object o1 = a[i];<br>        Object o2 = a2[i];<br>        <span class="hljs-keyword">if</span> (!(o1==<span class="hljs-keyword">null</span> ? o2==<span class="hljs-keyword">null</span> : o1.equals(o2)))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>如果</strong>数组是不支持协变的,那么比较<code>B</code>时得重写<code>equals</code>的代码,比较<code>A</code>时又得重写一份<code>equals</code>的代码,因为<code>A[]</code>不能赋值给<code>Object[]</code>,代码重写非常严重,违背了代码复用的宗旨。所以将数组设计成协变的,使得<code>A[]</code>能够赋值为<code>Object[]</code>,从而调用对象的<code>equals()</code>方法时,由于多态的原因,实际上调用的<code>A</code>的<code>equals</code>方法。实现了代码复用。</p><p>那么数组设计成协变会产生大问题吗?答案是不会,因为数组记得它到底保持的是什么类型,这会在<strong>编译时</strong>严格检查数据类型。而泛型协变有问题也只会在运行时出现，延后了问题出现的时间。违背了java是严格类型确定的编程语言。</p><p>但是<strong>并不支持</strong>泛型数组,因为数组能记得它存储的元素类型的前提是在创建时就严格确定了其存储的元素类型(之所以能记住这是靠虚拟机实现的,Array由虚拟机来实现)。</p><p><strong>Extension Two:java中为什么不支持泛型数组?</strong></p><p>参考自<a href="https://www.zhihu.com/question/20928981/answer/117521433">java为什么不支持泛型数组？</a></p><p>java明确规定了数组的元素类型必须是可靠的.</p><blockquote><p>It is a compile-time error if the component type of the array being initialized is not reifiable</p></blockquote><p>其中<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.7">Reifiable Types</a>包括且只包括:</p><ul><li><p>It refers to a non-generic class or interface type declaration.</p></li><li><p>It is a parameterized type in which all type arguments are <strong>unbounded</strong> wildcards (§4.5.1).</p></li><li><p>It is a raw type (§4.8).</p></li><li><p>It is a primitive type (§4.2).</p></li><li><p>It is an array type (§10.1) whose element type is reifiable.</p></li><li><p>It is a nested type where, for each type T separated by a “.”, T itself is reifiable.</p></li></ul><p>下面是每个<code>Reifiable Type</code>的示例:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">E</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&lt;<span class="hljs-title">X</span>&gt;</span>&#123;&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;&#125;<br><br><span class="hljs-comment">//It refers to a non-generic class or interface type declaration.</span><br><span class="hljs-comment">//是一个分泛型的类或接口的引用</span><br>A ref;<br>E ref;<br><span class="hljs-comment">//It is a parameterized type in which all type arguments are **unbounded** wildcards</span><br><span class="hljs-comment">//是一个参数化类型,但是所有的类型参数都是无界通配符</span><br>B&lt;?&gt; ref;<br><span class="hljs-comment">//raw type</span><br>List ref;<br><span class="hljs-comment">//primitive type</span><br><span class="hljs-keyword">int</span> ref;<br><span class="hljs-comment">//array type,并且元素类型都要求是可靠的</span><br><span class="hljs-keyword">int</span>[] ref;<br><span class="hljs-comment">//嵌套类型,要求类型参数参数都是可靠的</span><br>B&lt;?&gt;.C&lt;?&gt; ref;<br>B&lt;A&gt;.C&lt;A&gt; ref;<br><br></code></pre></div></td></tr></table></figure><p>所以想要数组支持泛型的唯一办法就是:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//本意</span><br>ArrayList&lt;String&gt; ref=<span class="hljs-keyword">new</span> ArrayList&lt;String&gt;[];<span class="hljs-comment">//complie-error</span><br><span class="hljs-comment">//正确写法</span><br>ArrayList&lt;String&gt; ref=(ArrayList&lt;String&gt;[])<span class="hljs-keyword">new</span> ArrayList[];<span class="hljs-comment">//cast</span><br></code></pre></div></td></tr></table></figure><p>注:</p><blockquote><p>上述所有言论基于java1.8,似乎在java10中已经开始支持泛型数组,但并未考证</p></blockquote><hr><p>回到正题,java中的泛型是不变的。如果泛型是协变的,思考如下代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ArrayList&lt;Number&gt; ref=<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><br>ref.add(<span class="hljs-number">2.3f</span>);<span class="hljs-comment">//cast</span><br></code></pre></div></td></tr></table></figure><p>在我们眼里,<code>ref</code>是一个存储<code>Number</code>的容器,那么就可以往里面存储<code>Double</code>、<code>Float</code>、<code>Integer</code>。取元素的时候到底转换成什么类型?程序不知道,程序员也不知道。并且很可能会产生运行时错误。既然这么,干脆就在编译期将这类错误禁止就完事了,但是仍然可以通过一些操作实现协变的逻辑。</p><p>对于泛型不支持逆变,是因为父类的引用赋值给子类就非常危险,所以当然不支持,而且也不可能实现。</p><h3 id="使用协变"><a href="#使用协变" class="headerlink" title="使用协变"></a>使用协变</h3><p>有些时候我们确实需要使用协变这一功能。比如我们有一组类<code>Dog``Cat``Pig</code>,需要对这些类实现一个通用的喂食功能,见如下代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> generic;<br><br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>&#123;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">super</span>.getName()+<span class="hljs-string">&quot; eat shit.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cat</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">super</span>.getName()+<span class="hljs-string">&quot; eat air.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CovariantTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">feed</span><span class="hljs-params">(List&lt;Animal&gt; animalList)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(animalList==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(Animal elem:animalList)&#123;<br>            elem.eat();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;Dog&gt; dogs=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        dogs.add(<span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;peter&quot;</span>));<br>        dogs.add(<span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;tom&quot;</span>));<br><br>        ArrayList&lt;Cat&gt; cats=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        cats.add(<span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;lili&quot;</span>));<br>        cats.add(<span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;candy&quot;</span>));<br>        feed(dogs);<span class="hljs-comment">//complie-error</span><br>        feed(cats);<span class="hljs-comment">//complie-error</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面调用<code>feed</code>的代码是无法通过编译的,因为<code>feed</code>接受的是<code>List&lt;Animal&gt;</code>,而提供的是<code>ArrayList&lt;Dog&gt;</code>,这是因为泛型不支持协变。那么这个需求是确确实实存在的,怎么办?</p><p>这时候通配符<code>?</code>该上场了,泛型的作用是限制泛型的类型,提供类似协变的功能。</p><blockquote><p>通配符?表示我们不知道是什么类型,而不是任意类型!!!</p></blockquote><p>注意这里插一句,带有通配符的类型变量(type variable)叫做<code>wild type</code>(不知道是否官方,但是我看到别人这么叫了,而且这种叫法也不错,我就采用了)。但是通配符<code>?</code>是<strong>没有任何语义</strong>的,它不能代表任何一种类型,仅仅为了定义<code>wild type</code>的一个语法组成部分。所以定义类似<code>ArrayList&lt;?&gt;()</code>的对象就是错的,因为没有任何意义。</p><p>通配符是可以加边界来限制类型变量的类型的,通配符<code>?</code>边界分为以下三种:</p><ul><li>有上界的通配符:例如<code>? super Animal</code>,意思是这个泛型只能是<code>Animal</code>或者<code>Animal</code>的父类</li><li>有下界的通配符:例如<code>? extends Animal</code>,意思是这个泛型只能是<code>Animal</code>或者<code>Animal</code>的子类</li><li>无界的通配符:<code>?</code>,泛型是可以任意类型</li></ul><p>那么为了实现上面的需求,应将<code>feed</code>的签名改正为<code>public static void feed(List&lt;? extends Animal&gt; animalList)</code>,现在编译运行:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">peter eat shit.<br>tom eat shit.<br>lili eat air.<br>candy eat air.<br></code></pre></div></td></tr></table></figure><p>成功实现了我们的需求。</p><h3 id="存下取上原则"><a href="#存下取上原则" class="headerlink" title="存下取上原则"></a>存下取上原则</h3><p>该原则取自<a href="https://www.cnblogs.com/Xieyang-blog/p/9215934.html">Java中泛型区别以及泛型擦除详解</a>。</p><p><strong>A. 上界通配符:</strong><br>但是在使用了泛型通配符的地方,想要对容器增删元素就没有那么简单了。就拿上面的<code>List&lt;? extends Animal&gt; animals</code>做例子。传进来的参数有可能是<code>List&lt;Dog&gt;</code>,也有可能是<code>List&lt;Cat&gt;</code>,假设我们能够向<code>animals</code>中存储新元素,那么当我们取出我们存入的新元素时,它到底是什么类型的?编译器不知道。但是我们读取容器中的内容是没问题的,因为里面的元素至少是一个<code>Animals</code>,使用<code>Animals</code>的引用调用<code>Animals</code>的方法是没有任何问题的。这里就体现了<strong>存下取上</strong>的原则。</p><p>对于上界通配符<code>? extends Animal</code>,泛型的上界是<code>Animal</code>,没有下界,那就是<code>null</code>。所以所谓存下取上就是存储的时候按照泛型下界的类型存储,这里就是<code>null</code>,取出的时候按照泛型上界的类型取出,这里就是<code>Animal</code>。注意有一点原文没有说清楚:</p><blockquote><p>储存的元素类型<strong>至多</strong>是下界类型,取出时的元素类型<strong>至少</strong>是上界类型</p></blockquote><p>下面的图片很好的解释了这个原则:</p><p><img src="images/upper-bound.drawio.svg" alt="upper-bound"></p><p>所以如果容器中,存在有<strong>上界通配符</strong>的泛型:对其写入的元素是很鸡肋的,相当于这个容器是<strong>只读</strong>的。</p><p><strong>B. 下界通配符:</strong></p><p>相应的,上界通配符实现的简单意义上的只写功能。例如<code>List&lt;? super Husky&gt; animals</code>,其中<code>husky</code>是<code>Dog</code>的子类,这里能存入的元素类型至多是<code>Husky</code>类型,没有上界,那么就是<code>Object</code>。</p><p>我们可以在<code>animals</code>中存储任意的<code>animals</code>子类对象(就像<code>List&lt;Dog&gt;</code>中存储的都是<code>Dog</code>类型的引用,但是可以在<code>List</code>中存储任意的<code>Dog</code>子类)。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Husky</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Dog</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Husky</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    List&lt;Dog&gt; list=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    insert(list);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> Dog&gt; set)</span></span>&#123;<br>    <span class="hljs-comment">//成功添加</span><br>    set.add(<span class="hljs-keyword">new</span> Husky(<span class="hljs-string">&quot;husky&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;success&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="images/lower-bound.drawio.svg" alt="lower-bound"></p><p>当然类似的,这里只能读取<code>Object</code>类型的对象,也很鸡肋。</p><p>所以如果容器中存在有下界通配符的泛型,那么该容器在非严格意义上是<strong>只写</strong>的。</p><p>这里的存下取上原则也叫做<code>PECS</code>原则,即<code>producer-extends,consumer super</code>。以容器的视角来说,当容器作为作为生产者,往外提供元素时,就使用<code>extends</code>;当容器作为消费者,需要存储元素时,就使用<code>super</code>。</p><p>在<code>Collections.copy</code>方法中,就是用PESC原则:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//src为生产者,dest为消费者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>注意:<strong>如果</strong>同时有读写的要求呢?</strong></p><blockquote><p>就不需要使用泛型了。</p></blockquote><p><strong>C. 无界通配符:</strong></p><p>对于无界通配符<code>?</code>,它对应的下界为<code>null</code>,对应的上界为<code>Object</code>。</p><h3 id="3-泛型的擦除"><a href="#3-泛型的擦除" class="headerlink" title="3. 泛型的擦除"></a>3. 泛型的擦除</h3><p>在最开始曾说到java的泛型是<strong>伪泛型</strong>,仅仅保持在编译层面。在生成字节码文件时会对泛型擦除,将参数类型(parameterized types)转为原始类型(raw types)。所谓的参数类型就是类似于<code>class Person&lt;T&gt;</code>这种,而将它转换为原始类型就是<code>class Pseron</code>。在这种机制下，java中的多态就比较奇妙了。</p><h4 id="3-1-泛型下的多态"><a href="#3-1-泛型下的多态" class="headerlink" title="3.1 泛型下的多态"></a>3.1 泛型下的多态</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> generic;<br><span class="hljs-comment">//定义泛型类Person</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    T name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(T name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student s=<span class="hljs-keyword">new</span> Student();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Student类继承Person</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>Student</code>类继承了<code>Pseron</code>类,并且指定了父类的类型实参为<code>String</code>。那么父类的定义应该如下所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然而java中的泛型都是假泛型,泛型在编译期被擦除后,因为类型变量<code>T</code>没有上界,所以编译会把T推断为<code>Object</code>类型。所以真正的代码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    Object name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(Object name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>所以按道理,<code>Student</code>类中的<code>String</code>类型也应该变成<code>Object</code>类型,这样一来,不是全乱套了?所以java为了解决这个问题,发明了一种桥方法的机制。</p><p>可以看到,<code>Student</code>类中的<code>getName</code>和<code>setName</code>和<code>Person</code>类中的<code>getName</code>和<code>setName</code>参数类型根本就不一样,所以这根本就不是重载。但是代码又可以编译通过并且实现多态的特性。奇怪的事情发生了。我们看看<code>Studnet</code>编译后的字节码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// access flags 0x1</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span>Ljava/lang/String</span>;<br>   L0<br>    LINENUMBER <span class="hljs-number">22</span> L0<br>    ALOAD <span class="hljs-number">0</span><br>    GETFIELD generic/Student.stuName : Ljava/lang/String;<br>    ARETURN<br>   L1<br>    LOCALVARIABLE <span class="hljs-keyword">this</span> Lgeneric/Student; L0 L1 <span class="hljs-number">0</span><br>    MAXSTACK = <span class="hljs-number">1</span><br>    MAXLOCALS = <span class="hljs-number">1</span><br><br>  <span class="hljs-comment">// access flags 0x1</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">setName</span><span class="hljs-params">(Ljava/lang/String;)</span>V</span><br><span class="hljs-function">   L0</span><br><span class="hljs-function">    LINENUMBER 27 L0</span><br><span class="hljs-function">    ALOAD 0</span><br><span class="hljs-function">    ALOAD 1</span><br><span class="hljs-function">    PUTFIELD generic/Student.stuName : Ljava/lang/String</span>;<br>   L1<br>    LINENUMBER <span class="hljs-number">28</span> L1<br>    RETURN<br>   L2<br>    LOCALVARIABLE <span class="hljs-keyword">this</span> Lgeneric/Student; L0 L2 <span class="hljs-number">0</span><br>    LOCALVARIABLE name Ljava/lang/String; L0 L2 <span class="hljs-number">1</span><br>    MAXSTACK = <span class="hljs-number">2</span><br>    MAXLOCALS = <span class="hljs-number">2</span><br><br>  <span class="hljs-comment">// access flags 0x1041</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> synthetic bridge <span class="hljs-title">setName</span><span class="hljs-params">(Ljava/lang/Object;)</span>V</span><br><span class="hljs-function">   L0</span><br><span class="hljs-function">    LINENUMBER 18 L0</span><br><span class="hljs-function">    ALOAD 0</span><br><span class="hljs-function">    ALOAD 1</span><br><span class="hljs-function">    CHECKCAST java/lang/String</span><br><span class="hljs-function">    INVOKEVIRTUAL generic/Student.<span class="hljs-title">setName</span> <span class="hljs-params">(Ljava/lang/String;)</span>V</span><br><span class="hljs-function">    RETURN</span><br><span class="hljs-function">   L1</span><br><span class="hljs-function">    LOCALVARIABLE <span class="hljs-keyword">this</span> Lgeneric/Student</span>; L0 L1 <span class="hljs-number">0</span><br>    MAXSTACK = <span class="hljs-number">2</span><br>    MAXLOCALS = <span class="hljs-number">2</span><br><br>  <span class="hljs-comment">// access flags 0x1041</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> synthetic bridge <span class="hljs-title">getName</span><span class="hljs-params">()</span>Ljava/lang/Object</span>;<br>   L0<br>    LINENUMBER <span class="hljs-number">18</span> L0<br>    ALOAD <span class="hljs-number">0</span><br>    INVOKEVIRTUAL generic/Student.getName ()Ljava/lang/String;<br>    ARETURN<br>   L1<br>    LOCALVARIABLE <span class="hljs-keyword">this</span> Lgeneric/Student; L0 L1 <span class="hljs-number">0</span><br>    MAXSTACK = <span class="hljs-number">1</span><br>    MAXLOCALS = <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>有两个<code>setName</code>,两个<code>getName</code>可以看到其中有一组<code>setName</code>和<code>getName</code>前面有修饰符<code>synthetic</code>和<code>bridge</code>。<code>synthetic</code>表示这是系统自动生成的,而<code>bridge</code>表示这是一个桥方法。</p><p>所以其实桥方法才真正是<code>override</code>了<code>Person</code>类中的两个方法。而桥方法又去调用了我们自定义的<code>setName</code>与<code>getName</code>完成了多态。</p><h4 id="3-2-泛型下的继承"><a href="#3-2-泛型下的继承" class="headerlink" title="3.2 泛型下的继承"></a>3.2 泛型下的继承</h4><p>普通的继承关系并没有类型的困扰。但是一旦给类上了泛型,那么就有点复杂了。大体分为四种情况:</p><ol><li>子类直接指定了父类的类型参数</li><li>子类继承了父类的类型参数</li><li>父类擦除了类型参数,子类没有擦除</li><li>子类与父类都擦出了类型参数</li></ol><p>下面我们一一解释以下,还是以上面的<code>Person</code>类作为例子:</p><p><strong>子类直接制定了父类的类型参数</strong>:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    E name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(E name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这种情况,父类的类型参数已经被制定了,所以子类中从父类继承而来的东西也是被指定的类型,例如<code>String</code>。如果子类新加了类型参数<code>T</code>,那么这个<code>T</code>和父类没有任何关系。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;<br>    T age;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>子类继承了父类的类型参数</strong>:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;<br>    T age;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(E name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么在子类中从父类继承而来的东西,类型还是<code>E</code>,类型参数<code>T</code>与父类没有任何关系。</p><p><strong>父类进行了泛型擦除而子类没有:</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    T age;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(Object name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这个例子中,由于<code>Person</code>类中的类型参数<code>E</code>没有上限,因为编译器只能把<code>E</code>推断为Object最为安全。如果类型参数<code>E</code>有上限,例如<code>E extends Number</code>,那么编译器就会将<code>E</code>推断为<code>Number</code>。上面代码中的<code>Object</code>就会全部换成<code>Number</code>了。</p><p><strong>子类与父类都进行了泛型擦除:</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>     age;<br>    String stuName;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> stuName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(E name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.stuName=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(T age)</span></span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>子类与父类都进行了擦除这么说并不准确,因为根本就没有定义子类的类型参数…规则和父类擦除而子类不擦除的规则一样。要看父类的类型参数有没有上限,因为编译器的推断类型是不一样的。</p><p><strong>那么为什么不能父类不擦除,而子类不擦除呢？</strong></p><p>因为继承泛型类时,子类必须对父类中的类型参数进行初始化,当然父类擦除或者由子类指定都可以。所以子类擦除而父类不擦除,父类中的类型参数由谁来初始化?</p><h4 id="3-3-泛型下的类型获取"><a href="#3-3-泛型下的类型获取" class="headerlink" title="3.3 泛型下的类型获取"></a>3.3 泛型下的类型获取</h4><p>上面曾说到，Java中的泛型是伪泛型，在编译时会被擦除为<code>Object</code>类型的，但是为什么又能够在运行时获取的泛型的真实类型呢？</p><p>首先我们需要知道一个逻辑：<strong>泛型擦除并不代表JVM不知道类型信息</strong>。对于泛型类，JVM可以从Class文件中的<code>Signature</code>属性来获取泛型类的<strong>声明</strong>类型，而不是实际类型。假设有代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">action</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    T a;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T a)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.a=a;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    action&lt;Integer&gt; test=<span class="hljs-keyword">new</span> action&lt;&gt;();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在运行时我们可以获取引用<code>test</code>中的泛型类型，而不能获得<code>test.a</code>的泛型类。因为<code>test.a</code>在运行时会被泛化为<code>object</code>类型，无法通过class文件获取类型。但是对于<code>test</code>来说，因为在编译的时候编译器会将<code>test</code>泛型的声明类型作为<code>Signature</code>属性保存在<code>action</code>类的class文件中，所以我们可以通过<code>action.class</code>获取它的泛型声明类型。</p><p><strong>参考文献</strong></p><ol><li><a href="https://www.itzhai.com/articles/exploring-the-nature-of-java-generics.html">深入探索Java泛型的本质 | 泛型</a></li><li><a href="https://www.zhihu.com/question/346911525">Java中的泛型会被类型擦除，那为什么在运行期仍然可以使用反射获取到具体的泛型类型？</a></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://zhuanlan.zhihu.com/p/31137677">仔细说说Java中的泛型</a></p></li><li><p><a href="https://www.cnblogs.com/wuqinglong/p/9456193.html">Java泛型类型擦除以及类型擦除带来的问题</a></p></li><li><p><a href="https://developer.aliyun.com/article/313280">java泛型学习（2）</a></p></li><li><p><a href="https://segmentfault.com/q/1010000007925818">java 如何继承泛型</a></p></li><li><p><a href="https://blog.csdn.net/ShierJun/article/details/51253870">泛型继承的几种写法</a></p></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E5%8F%8D%E5%B0%84/">反射</category>
      
      
      <category domain="https://eripe.me/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">基本概念</category>
      
      <category domain="https://eripe.me/tags/%E6%B3%9B%E5%9E%8B/">泛型</category>
      
      
      <comments>https://eripe.me/articles/the-generic-of-java.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>类的加载机制</title>
      <link>https://eripe.me/articles/class-loading-mechanism.html</link>
      <guid>https://eripe.me/articles/class-loading-mechanism.html</guid>
      <pubDate>Mon, 30 Aug 2021 16:38:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;1-类初始化的时机&quot;&gt;&lt;a href=&quot;#1-类初始化的时机&quot; class=&quot;headerlink&quot; title=&quot;1. 类初始化的时机&quot;&gt;&lt;/a&gt;1.</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="1-类初始化的时机"><a href="#1-类初始化的时机" class="headerlink" title="1. 类初始化的时机"></a>1. 类初始化的时机</h1><p>当复习类加载时机时，我给自己抛出了一个问题：这里的时机只说明了<strong>类</strong>的初始化，那么对于接口呢？接口什么时候会被初始化呢？</p><p>仔细回顾《深入理解Java虚拟机》，才发现，作者给出的是会触发<strong>类型</strong>初始化的六种时机，而不是<strong>类</strong>初始化。这里类型可能是指类或者接口。ok，那么我的问题迎刃而解了。接口初始化的时机同样遵循以下六种场景。</p><hr><p>在Java中，只有主动引用才会触发<del>类</del>类型加载动作。所谓的主动引用指<strong>只</strong>包括以下六种情况（除了下面这六种情况，其余的引用都称为被动引用）：</p><ol><li>遇到new、getstatic、setstatic或者invokestatic这4个字节码指令时，如果<strong>类型</strong>没有进行过初始化，那么需要先触发其初始化阶段。对应的java代码场景为：<ul><li>new一个关键字或者一个实例化对象时</li><li>读取或设置一个<strong>类型</strong>的静态字段时(final修饰、已在编译期把结果放入常量池的除外)</li><li>调用一个<strong>类行</strong>的静态方法时</li></ul></li><li>使用java.lang.reflect包的方法对<strong>类型</strong>进行反射调用的时候，如果类型没进行初始化，需要先触发其初始化。</li><li>当初始化一个<strong>类</strong>时，如果其父类还未进行初始化，会先触发其父类的初始化；当一个接口在初始化时。并不要求其父接口全部完成了初始化。只有真正使用到了父接口时（例如使用接口中定义的常量）才会对父接口进行初始化</li><li>当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的类)，虚拟机会先初始化这个类。</li><li>当使用JDK 1.7等动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li><li>当一个接口定义了JDK8新加入的默认方法时，如果这个接口的实现类发生了初始化，那么接口需要在其之前被初始化</li></ol><p><strong>注意：</strong><br>对于静态字段或者静态方法，只会对定义了这些内容的类执行类加载动作。我们通过下面的代码来理解这句话的真正含义：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">staticTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       subTest.m1();<br>    <span class="hljs-comment">// System.out.println(subTest.a);</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">subTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;load subclass subTest&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;load class Test&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;method m1&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>执行结果为：</p><blockquote><p>load class Test<br>method m1</p></blockquote><p>虽然通过子类名称调用父类的静态方法，但是jvm仍然只会加载真正定义了静态方法<code>m1</code>的类<code>Test</code>。这是一个特殊情况。</p><hr><p>update：2021-01-18 00:27:01</p><p>我又给自己提出了一个问题：当一个类被初始化时，它实现的接口是什么时候被加载的？这种情况不符合上面所述的六种场景啊。</p><p>经过我的思考，我发现我进入了一个误区。上面所述的六种场景只是声明类或接口被初始化的时机，而不是加载的时机。</p><p>初始化一定要求类或者接口被加载，但是反之则不一定，加载了类或接口，不一定需要初始化。所以我猜测，当是一个实现类在解析接口引用时，只是加载了接口，而没有初始化接口。不然类怎么实现验证步骤？</p><h1 id="2-类加载的七个步骤"><a href="#2-类加载的七个步骤" class="headerlink" title="2. 类加载的七个步骤"></a>2. 类加载的七个步骤</h1><p>将类的Class文件加载至jvm中一般会经历七个步骤：加载、验证、准备、解析、初始化、使用、卸载。但是注意：<strong>这七个步骤并不是完全串行的</strong>。有可能在一个步骤的执行中开启另外一个步骤，而不是等待当前步骤执行完毕。</p><p>并且其中的验证、准备、解析合在一起叫做“连接”。这不就是cpp编译过程的符号链接的步骤嘛，搞的这么花里胡哨的。</p><p>并且其中的初始化是指类的初始化，而不是对象的初始化。类的初始化是指：</p><ul><li>静态字段的初始化</li><li>静态代码的执行</li></ul><p>并且类的初始化只会在类加载的时候执行一次。下面我们就来看看这七个步骤。</p><h2 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1 加载"></a>2.1 加载</h2><p>这个加载是指整个类加载过程中的第一个步骤，而且是整个类加载过程中我们可以实实在在用代码控制的部分。该步骤分为三小步：</p><ol><li>通过类的全限定名获取类的二进制字节流</li><li>将二进制字节流表示的静态存储结构转化<strong>方法区</strong>为运行时存储结构</li><li>生成Class对象，作为方法区各种类型数据的访问接口</li></ol><p>其中通过类的权限名获取类的二进制字节流就是我们能够控制的部分，虚拟机规范只规定了我们要获取字节流，而没有规定从哪里获取字节流。可以从Class文件中获取、静态的jar包中获取、网络中获取，或者动态的在内存中生成，也就是所谓的动态代理技术，这完全都可以自定义实现。<strong>并且获取字节流这个动作就是通过我们自定义的类加载器来实现。</strong></p><p>但是有一个特殊情况，就是数组类的加载不是我们可以控制的，但是数组中的元素类却又是我们可以控制的。因为<strong>数组类的并不是由类加载器加载，而是由jvm在内存中直接构造的。</strong></p><hr><p>这里的数组类可以看作数组的wrapper，即数组的包装类，由jvm动态生成，数组类提供了一些数组的属性，并且数组的访问也通过该类实现。</p><blockquote><p>java访问数组的安全性比c++高很大程度是因为该类包装了数组的访问操作。</p></blockquote><hr><h3 id="2-1-1-数组类的加载机制"><a href="#2-1-1-数组类的加载机制" class="headerlink" title="2.1.1 数组类的加载机制"></a>2.1.1 数组类的加载机制</h3><ul><li>如果数组的组件类型(即数组去掉一个维度，例如int[4][3],实际的组件类型为int[3],因为二维数组可以看作元素类型是一维数组的一维数组)。那么就递归的采用类加载过程去加载这个组件类型。是类就用类的加载过程，是数组类就用数组类的加载过程。并且该数组会被标识在加载该组件类型的类加载器的类名称空间上，因为这样才能唯一的确定一个类</li><li>如果数组的组件类型不是引用类型，那么该数组会被标识在启动类加载器的类名称空间上</li><li>数组类的可访问性和它组件类型的可访问性一致，如果组件类型不是引用类型，那么数组类的可访问性默认为public</li></ul><h3 id="2-1-2-生成Class对象"><a href="#2-1-2-生成Class对象" class="headerlink" title="2.1.2 生成Class对象"></a>2.1.2 生成Class对象</h3><p>在获得类文件的二进制的字节流后，会被转化为方法区的动态存储结构，这个结构是怎么样的并没有强制规定。但是在转化完成后，会在<strong>堆区</strong>实例化一个代表当前类的Class对象。作为方法区存储结构中的数据的访问接口。</p><p><strong>加载阶段和连接阶段是交叉进行的。</strong></p><h2 id="2-2-验证"><a href="#2-2-验证" class="headerlink" title="2.2 验证"></a>2.2 验证</h2><p>验证显而易见就是验证获取的二进制字节流是否安全，符合虚拟机规范。<strong>因为Class不一定是通过编译生成的</strong>，也确实可以直接在二进制层面拼接。<strong>那么在生成Class对象前不是应该先完成验证步骤？</strong></p><p>验证主要验证四个部分：</p><ol><li>文件格式的验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ol><h3 id="2-2-1-文件格式验证"><a href="#2-2-1-文件格式验证" class="headerlink" title="2.2.1 文件格式验证"></a>2.2.1 文件格式验证</h3><p>文件格式的验证就是验证我们在加载阶段获取到的二进制字节流是否符合<strong>Class文件格式</strong>的规范，只有完成这一步验证，字节流才会转化为方法区的存储结构，并且后续的三个验证步骤是基于方法区的存储结构，而不会直接操作二进制流了。</p><h3 id="2-2-2-元数据验证"><a href="#2-2-2-元数据验证" class="headerlink" title="2.2.2 元数据验证"></a>2.2.2 元数据验证</h3><p>元数据验证是验证方法区存储的字节码是否《java语言规范》的语法要求。所谓的语义包括是否继承了final修饰的类、是否修改了final修饰的字段等等。即验证是否符合java的语法。</p><h3 id="2-2-3-字节码验证"><a href="#2-2-3-字节码验证" class="headerlink" title="2.2.3 字节码验证"></a>2.2.3 字节码验证</h3><p><strong>字节码验证主要是验证代码的语义正确性。</strong>例如将父类对象赋值给子类引用（语法验证会通过，但可能会产生运行时问题）。如果代码没有通过字节码验证，说明代码肯定有错误，但反之则不一定，即使通过了验证，也不能说代码完全正确，有可能产生间接的语义错误。</p><p>但是计算代码是否有语义错误显而易见是一项庞大的工程，放到代码运行之前验证不太好。所以在JDK6之后，java团队将验证语义的操作大部分都转移到了编译期间。编译器会在编译时为代码属性添加<code>StackMapTable</code>属性，这一属性描述了代码是否有语义错误。在字节码验证阶段jvm只需要验证该属性是否符合规范。当然，这并不能做到十全十美。</p><h3 id="2-2-4-符号引用验证"><a href="#2-2-4-符号引用验证" class="headerlink" title="2.2.4 符号引用验证"></a>2.2.4 符号引用验证</h3><p>符号引用验证的目的是为了保证<strong>解析阶段</strong>正常进行。会进行权限检查</p><h3 id="2-2-5-小结"><a href="#2-2-5-小结" class="headerlink" title="2.2.5 小结"></a>2.2.5 小结</h3><p>验证阶段可有可无，并不是强制的，只要能够保证代码是正确的，那么也可以关闭大部分类的验证措施来加速类的加载。</p><h2 id="2-3-准备"><a href="#2-3-准备" class="headerlink" title="2.3 准备"></a>2.3 准备</h2><p>准备阶段是为类的静态变量(而不是实例变量，实例变量会在对象实例化时分配空间)分配内存空间，以及赋予静态变量默认的初值，这里的初值指的是int的默认为0、boolean的默认为false之类的默认值。例如:</p><blockquote><p>public static int value=123;</p></blockquote><p>在准备阶段，value的值为默认值，即为0。在初始化阶段才会被赋值为123。</p><p><strong>无论代码中有没有对静态变量的赋值的操作，都会对变量进行初始化操作，至于赋值的步骤，会在初始化阶段完成!!!</strong></p><p>注意：准备阶段只为静态变量做准备。</p><h2 id="2-4-解析"><a href="#2-4-解析" class="headerlink" title="2.4 解析"></a>2.4 解析</h2><p>解析肯定就是符号的链接过程咯。准备来说就是将常量池中的符号引用替换为直接引用。例如Class文件中的<code>CONSTANT_Class_info</code>、<code>CONSTANT_Fieldref_info</code>、<code>CONSTANT_Method_info</code>等符号引用，存储形式都是常量。</p><blockquote><p>解析过程是把符号链接到正确的内存地址，符号引用变为直接引用，而不是确定符号，后者是编译期做的事，<del>解析这件事已经属于运行期了</del>。准确来说，解析并不是运行期，因为解析阶段还没有真正的开始执行字节码，我的理解时<strong>执行字节码才叫做真正的运行期</strong>。</p></blockquote><p>在解析阶段解析符号的过程被称为<strong>静态解析</strong>，当然能够被静态解析的符号类型有限：</p><ul><li>类或接口</li><li>字段</li><li>一部分方法</li><li>接口方法</li></ul><p>关于方法的解析比较复杂，后文单独开一章进行讲解。</p><h3 id="2-4-1-类或接口的解析"><a href="#2-4-1-类或接口的解析" class="headerlink" title="2.4.1 类或接口的解析"></a>2.4.1 类或接口的解析</h3><p>类或接口的解析有一个核心规则：</p><p>如果当前代码所处的类为D，如果想要把D中一个从未解析过的符号引用N解析为类或接口C，那么则有：</p><ol><li><p>如果c不是一个数组类型，那么会使用<strong>D的类加载器</strong>加载c，其中会将c的全限定名传递给D的类加载器。如果其中又需要加载其他类，那么重复整个解析程序</p></li><li><p>如果c是一个数组类型，并且数组元素是对象类型，那么会重复第一步，<strong>并且由虚拟机生成该数组</strong></p></li><li><p>如果上面两步没有出现问题，那么会检查符号引用的权限，确认D对C具有访问，否则会抛出异常</p></li></ol><h3 id="2-4-2-字段的解析"><a href="#2-4-2-字段的解析" class="headerlink" title="2.4.2 字段的解析"></a>2.4.2 字段的解析</h3><p>首先我们需要找到字段所属的类或接口C，然后：</p><ol><li><p>如果在c中找到了简单名称和描述符都与目标相符的字段，那么会返回字段的直接引用</p></li><li><p>在c实现的接口中，从下往上查找目标</p></li><li><p>在c继承的父类中，从下往上查找目标</p></li><li><p>如果成功获得了直接引用，还会检查是否对目标字段具有访问权限</p></li></ol><p>如果在c的父类或接口中实现了相同字段，虽然按照规则可以成功找到目标字段，但是编译器为了安全，还是会选择拒绝编译。</p><blockquote><p>字段会在解析阶段完全解析好，因为符号引用在编译时期就确定了</p></blockquote><h3 id="2-4-3-接口方法的解析"><a href="#2-4-3-接口方法的解析" class="headerlink" title="2.4.3 接口方法的解析"></a>2.4.3 接口方法的解析</h3><p>首先在接口方法表中解析出当前方法所属的类或接口c，然后：</p><ol><li><p>如果c是一个类，那么抛出IncompatibleClassChangeError</p></li><li><p>否则在接口c中查看目标方法，如果成功，则返回直接引用</p></li><li><p>否则在c继承的接口中查找目标方法，这一步骤有一点值得注意：会一直向上递归查找，直到对java.lang.Object查找完毕，因为接口方法的查找范围<strong>包括Object类中的方法。</strong></p></li><li><p>对查找的直接引用进行权限检查在JDK9之后，因为JDK9之后引入了模块化系统。</p></li></ol><p>如果在继承的多个父接口中查找到了多个目标方法，虽然虚拟机规范规定随意返回一个即可。</p><h2 id="2-5-初始化"><a href="#2-5-初始化" class="headerlink" title="2.5 初始化"></a>2.5 初始化</h2><p>这里的初始化是指对类进行初始化，并且这一阶段可以通过程序控制。</p><p>初始化阶段就是执行类构造器<code>&lt;cinit&gt;()</code>方法的过程。这一方法通过编译器自动生成，生成规则如下：</p><ol><li><p>收集类中所有类变量的赋值动作和静态代码块的语句按<strong>顺序</strong>而合成，如果没有静态变量<strong>赋值</strong>语句和静态代码块，那么并不会生成<code>&lt;cinit&gt;()</code></p></li><li><p>静态代码块只能访问定义在块之前的静态变量，对于块之后定义的静态变量，静态代码块只能赋值，不能访问</p></li><li><p>虚拟机会保证父类的类构造器<code>&lt;cinit&gt;()</code>一定会在子类的<code>&lt;cinit&gt;()</code>执行之前执行，这与实例构造器<code>&lt;init&gt;()</code>一样，会保证父类的实例构造器先于子类执行，并且JVM保证在多线程环境下<code>&lt;cinit&gt;()</code>只会被执行一次</p></li></ol><p>这里怎么保证呢？就是虽然<code>super</code>是在是在子类构造器中调用的，但是<code>super</code>实际是在调用父类的<code>&lt;init&gt;</code>，而子类的<code>&lt;init&gt;</code>根本还没有开始执行，这样保证了父类的<code>&lt;init&gt;</code>一定会在子类的<code>&lt;init&gt;</code>之前完成，例如在下面的代码中：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FieldHashNoPolymorphic</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> money = <span class="hljs-number">1</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Father</span><span class="hljs-params">()</span> </span>&#123;<br>            ...<br>            showMeTheMoney();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMeTheMoney</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am Father, I have $&quot;</span> + money);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> money = <span class="hljs-number">3</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Son</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">//虽然super在Son的构造方法中，但是实际上Son的&lt;init&gt;还没有开始执行</span><br>            <span class="hljs-keyword">super</span>();<br>            ...<br>            showMeTheMoney();<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMeTheMoney</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am Son, I have $&quot;</span> + <span class="hljs-keyword">this</span>.money);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Father guy = <span class="hljs-keyword">new</span> Son();<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在执行<code>super</code>的时候，<code>Son</code>类的<code>&lt;init&gt;</code>方法还没有开始调用，所以<code>Son</code>类的<code>money</code>字段仍然为0。那么<code>&lt;init&gt;</code>由哪些部分组成呢？与<code>&lt;cinit&gt;</code>类似，也是由三部分组成：</p><ol><li>成员变量显式赋值代码</li><li>非静态代码块中的代码</li><li>构造器中的代码</li></ol><p>其中1、2部分按照出现的顺序排列，3永远排在最后执行。</p><h3 id="2-5-1-接口的初始化"><a href="#2-5-1-接口的初始化" class="headerlink" title="2.5.1 接口的初始化"></a>2.5.1 接口的初始化</h3><p>对于接口来说，并没有强制要求父接口的<code>&lt;cinit&gt;()</code>一定要在子接口<code>&lt;cinit&gt;()</code>之前执行。只有当父接口中定义的变量被使用时，才会执行父接口的<code>&lt;cinit&gt;()</code>方法。并且接口的实现类初始化时也不会执行接口的<code>&lt;cinit&gt;()</code>方法。</p><h1 id="3-类方法的解析"><a href="#3-类方法的解析" class="headerlink" title="3. 类方法的解析"></a>3. 类方法的解析</h1><p>方法的总体来说可以分为两个部分：</p><ul><li>能够在解析阶段完成解析的方法</li><li>只能在运行时完成解析的方法</li></ul><p>那么如何区分它们呢？这与具体的方法调用的字节码指令有关，在java中，有五条字节码与方法调用有关：</p><ul><li>invokestatic:调用静态方法</li><li>invokespecial：用于调用特殊的实例方法，包括实例初始化方法（<init>()方法）、私有方法、父类方法（<strong>最近的一个父类</strong>）</li><li>invokevirtual：用于调用对象的实例方法</li><li>invokeinferface：用于调用接口方法</li><li>invokedynamic：用于运行时动态解析出调用点限定符所引用的方法</li></ul><p>我们可以根据这五条调用方法的指令来判定当前方法能否在类加载过程中的解析阶段完成符号链接。值得注意的是<strong>前四条的方法调用逻辑</strong>是完全固化在虚拟机内的，而最后一条指令的调用指派完全由程序员指定。</p><h2 id="3-1-类加载阶段的方法符号解析"><a href="#3-1-类加载阶段的方法符号解析" class="headerlink" title="3.1 类加载阶段的方法符号解析"></a>3.1 类加载阶段的方法符号解析</h2><p>只要是通过<code>invokestatic</code>、<code>incokespecial</code>调用的或者被<code>final</code>修饰的方法，就能在类加载阶段中的解析步骤时将符号引用转换为目标方法的直接引用。总计分为五种方法：</p><ul><li>静态方法</li><li>对象的构造方法</li><li>私有方法</li><li>父类方法</li><li>被<code>final</code>修饰的方法</li></ul><p>上述五类方法被称为“非虚方法”，调用的方法的符号引用在编译器就已经完全确定，这类方法的调用称为<strong>解析</strong>。其他的所有方法都为“虚方法”，java中默认方法都是虚方法。</p><h2 id="3-2-运行时的方法符号解析"><a href="#3-2-运行时的方法符号解析" class="headerlink" title="3.2 运行时的方法符号解析"></a>3.2 运行时的方法符号解析</h2><p>除了在3.1小节指出的非虚方法外，其余的方法会在第一次调用时进行链接。这类方法的符号解析有一个特殊的名字，称为<strong>分派</strong>。顾名思义，分派肯定是从多个候选者选择一个。我认为这是与解析最大的不同，因为解析调用的候选方法只有一个。</p><p>分派又可分为静态分派和动态分派。</p><h3 id="3-2-1-静态分派"><a href="#3-2-1-静态分派" class="headerlink" title="3.2.1 静态分派"></a>3.2.1 静态分派</h3><p>所谓的静态分派和上述非虚方法的解析并没有太大差别，都是在编译期确定目标方法的符号引用。值得注意的是：在重载环境下，编译器依赖方法参数的静态类型选择合适的版本。这也侧面说明了重载时只有参数不同才算重载。</p><p>这类依赖静态类型来决定目标方法版本的操作称为静态解析，因为候选者有多个！<strong>静态解析的结果由编译器决定而不是虚拟机。</strong></p><h3 id="3-2-2-动态分派"><a href="#3-2-2-动态分派" class="headerlink" title="3.2.2 动态分派"></a>3.2.2 动态分派</h3><p>静态分派是靠编译器实现的，动态分派是靠<code>invokevirtual</code>执行实现的，<code>invokevirtual</code>的执行步骤如下：</p><ol><li>找到操作数栈顶第一个元素指向的对象的实际类型C</li><li>在类C中查找是否存在描述符和简单名称都符合预期目标的方法，如果存在，那么结束查找</li><li>否则在类C的各个父类中进行查找，直到无法找到抛出异常</li></ol><p>这类依赖变量动态类型来决定调用的方法版本称为动态分派。值得注意的是：字段永远不存在多态，只会存在覆盖的概念。查询字段只会在最近的范围内查找。下面的代码很好地解释了动态分派与同名字段覆盖：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FieldHashNoPolymorphic</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> money = <span class="hljs-number">1</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Father</span><span class="hljs-params">()</span> </span>&#123;<br>            money = <span class="hljs-number">2</span>;<br>            System.out.println(<span class="hljs-keyword">this</span>.money+<span class="hljs-string">&quot;---&quot;</span>+<span class="hljs-keyword">this</span>);<br>            showMeTheMoney();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMeTheMoney</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am Father, I have $&quot;</span> + money);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> money = <span class="hljs-number">3</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Son</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//这个this实际上是不能被传递的，这里只是示意</span><br>            System.out.println(<span class="hljs-keyword">this</span>);<br>            money = <span class="hljs-number">4</span>;<br>            showMeTheMoney();<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMeTheMoney</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am Son, I have $&quot;</span> + money);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Father guy = <span class="hljs-keyword">new</span> Son();<br>        <span class="hljs-comment">// 通过静态类型访问到了父类中的money，输出2</span><br>        System.out.println(<span class="hljs-string">&quot;This guy has $&quot;</span> + guy.money);<br>        <span class="hljs-comment">// 将静态类型强转成Son，访问的就是子类中的money，输出4</span><br>        System.out.println(<span class="hljs-string">&quot;This guy has $&quot;</span> + ((Son) guy).money);<br>    &#125;<br>&#125;<br># 输出如下<br><span class="hljs-number">2</span>---jvm.FieldHashNoPolymorphic$Son@6ed3ef1<br>I am Son, I have $<span class="hljs-number">0</span><br>jvm.FieldHashNoPolymorphic$Son@6ed3ef1<br>I am Son, I have $<span class="hljs-number">4</span><br>This guy has $<span class="hljs-number">2</span><br>This guy has $<span class="hljs-number">4</span><br><br></code></pre></div></td></tr></table></figure><p>在第一次执行中，为什么会调用<code>Son</code>类的<code>showTheMoney()</code>?因为在调用方法时，会将方法接收者（也就是caller）的引用传递进去，调用父类构造函数的代码是<code>super(this)</code>，这里的<code>this</code>代表<code>Son</code>类的对象。所以在执行下面代码时：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Father</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.money = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">this</span>.showMeTheMoney();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>虽然这里的<code>this</code>指向的是子类<code>Son</code>对象，但是我们想想，<code>Son</code>对象肯定会包含了父类<code>Father</code>的数据啊，所以这两个<code>this</code>显示地是同一个地址没毛病。</p><p>但是<code>sout(this.money)==2</code>就说明这里使用的<code>money</code>属性是父类的，因为代码执行处离父类<code>Father</code>最近。而显示的<code>I am Son, I have $0</code>就说明此时使用的是子类<code>Son</code>的<code>money</code>属性，因为此时代码执行处处离<code>Son</code>最近。值为0是因为此时子类<code>Son</code>的<code>money</code>属性还没有初始化，因为父类的构造函数还未执行完毕。</p><p>虽然在Son类型的对象中，内存中会存在两个<code>money</code>,但是Son对象只会使用离他最近的一个，也就是自身类中的<code>money</code>属性，子类的属性会隐藏父类的同名属性。</p><h3 id="3-2-3-单分派与多分派"><a href="#3-2-3-单分派与多分派" class="headerlink" title="3.2.3 单分派与多分派"></a>3.2.3 单分派与多分派</h3><p>决定单分派与多分派的标准是使用的宗量数量。宗量分为两大类：方法的接受者（caller）与方法的参数。采用《深入理解java虚拟机》中的例子作为解释：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dispatch</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QQ</span></span>&#123;&#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_360</span></span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hardChoice</span><span class="hljs-params">(QQ arg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;father choose qq&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hardChoice</span><span class="hljs-params">(_360 arg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;father choose 360&quot;</span>);<br>    &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hardChoice</span><span class="hljs-params">(QQ arg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;son choose qq&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hardChoice</span><span class="hljs-params">(_360 arg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;son chooes 360&quot;</span>);<br>    &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Father father = <span class="hljs-keyword">new</span> Father();<br>    Father son = <span class="hljs-keyword">new</span> Son();<br><br>    father.hardChoice(<span class="hljs-keyword">new</span> _360());<span class="hljs-comment">//father choose 360</span><br>    son.hardChoice(<span class="hljs-keyword">new</span> QQ());<span class="hljs-comment">//son choose qq</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于<code>fahter.hardChoice(new _360())</code>,在编译时期编译器确定调用符号时，可以看出候选者非常多（候选者有哪些，需要列出来）。那么在调用<code>father.hardChoice</code>时发现方法的接收者的静态类型这是<code>Father</code>,这就决定了在<code>Father</code>类中选择。那么接着查看调用方法的参数，发现实参的静态类型为<code>360</code>,那么通过方法调用者和函数实参这两个标准在编译器确定了符号调用，这就代表使用了两个宗量。同理编译<code>son.hardChoice(new QQ())</code>时也会使用两个宗量确定符号引用。</p><p>上述确定的两个符号引用会使用<code>invokevirtual</code>调用。那么在运行时,因为已经在编译器确定了方法签名，但是候选者仍然有两个：</p><ul><li>Father::hardChoice(_360 arg)</li><li>Son::hardChoice(_360 arg)</li></ul><p>因为上述的两个函数调用实际会使用<code>invokeVirtual</code>执行，所以在运行时虚拟机会从上述的两个候选者中选择一个。以<code>father.hardChoice(new _360())</code>为例，方法接收者<code>father</code>的实际类型为<code>Son</code>，所以虚拟机会选择<code>Son</code>类中的方法。可以看出在抉择过程中只用了“方法调用者”这一个参考因素。</p><p>所以到目前为止，<strong>java是一个静态多分派、动态单分派的语言</strong>。那么时候才会进入分派的阶段，也就是使用<code>virtualinvoke</code>指定？</p><p>我认为答案是调用非虚方法时，会进入分派阶段。</p><hr><p><strong>Extension: invokevirtual的执行过程</strong></p><ol><li><code>invokevirtual</code>首先会找到操作数栈的栈顶第一个元素所指向的对象的实际类型，记为C；</li><li>在C自身中进行查找符号和描述相符的方法，如果找到，则需要检查权限</li><li>如果在C自身中未找到，那么会按照继承关系<strong>自下而上</strong>在C的父类中进行查找，如果找到则需要进行权限检查</li><li>如果都为找到，则会抛出<code>AbstractMethodError</code>异常</li></ol><hr><h3 id="3-2-4-分派的具体实现"><a href="#3-2-4-分派的具体实现" class="headerlink" title="3.2.4 分派的具体实现"></a>3.2.4 分派的具体实现</h3><p>在每次调用时才去执行分派效率必定低下，所以jvm选择以虚表(virtual method table)的形式实现分派的过程。虚表和cpp中的虚表概念差不多。这个虚表建立在方法区。对于子类来说，如果没有重写父类的方法，那么子类的虚方法表中，没有被重写的方法的指针和父类同一方法的指针指向同一个函数。</p><blockquote><p>虚表会在类加载阶段完成初始化，在完成连接阶段中的初始化过程后，会完成该类的虚表初始化</p></blockquote><h1 id="4-小测试"><a href="#4-小测试" class="headerlink" title="4. 小测试"></a>4. 小测试</h1><p>根据类加载的规则，下面的代码输出到底是多少？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleTon</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingleTon singleTon = <span class="hljs-keyword">new</span> SingleTon();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count1;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count2 = <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingleTon</span><span class="hljs-params">()</span> </span>&#123;<br>        count1++;<br>        count2++;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleTon <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> singleTon;<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SingleTon singleTon = SingleTon.getInstance();<br>        System.out.println(<span class="hljs-string">&quot;count1=&quot;</span> + singleTon.count1);<br>        System.out.println(<span class="hljs-string">&quot;count2=&quot;</span> + singleTon.count2);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>一个经常出现的错误答案是：</p><blockquote><p>count1=1;<br>count2=1;</p></blockquote><p>但是正确的执行结果为：</p><blockquote><p>count1=1;<br>count2=0;</p></blockquote><p>为什么呢？因为类加载过程中准备阶段是在初始化阶段之前的，虽然在上面的代码中有<code>count2=0</code>，但是准备阶段不关心这个。准备阶段完成后：</p><blockquote><p>count1=0;<br>count2=0;</p></blockquote><p>最后在初始化过程中，编译器生成的<code>&lt;cinit&gt;</code>方法是按照代码书写顺序生成的，例如这个例子中生成的是：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">cinit()&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingleTon singleTon = <span class="hljs-keyword">new</span> SingleTon();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count1;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count2 = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>虽然在执行<code>SingleTon</code>的构造方法时，会执行<code>count2=1</code>的操作，但是注意，<code>&lt;cinit&gt;</code>方法还没有执行完成呢。在<code>&lt;cinit&gt;</code>中最后还是会执行<code>count2=0</code>的操作。</p><p>所以最终的答案是：</p><blockquote><p>count1=1;<br>count2=0;</p></blockquote>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/jvm/">jvm</category>
      
      
      <category domain="https://eripe.me/tags/class-loading/">class loading</category>
      
      
      <comments>https://eripe.me/articles/class-loading-mechanism.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>双亲委派模型</title>
      <link>https://eripe.me/articles/parents-delegation-model.html</link>
      <guid>https://eripe.me/articles/parents-delegation-model.html</guid>
      <pubDate>Mon, 30 Aug 2021 16:38:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先在了解双亲委派模型前，我们有必要了解它的英文名字：<code>parents delegation model</code>。其实在具体的模型中，并没有所谓的“双亲”，只有一个逻辑意义上的父类，详情见下文。</p><h2 id="1-类加载器"><a href="#1-类加载器" class="headerlink" title="1. 类加载器"></a>1. 类加载器</h2><p>在《深入理解java虚拟机》一书中写道：</p><blockquote><p>java团队有意将类加载阶段中的“通过一个类的全限定名来获取该类的二进制字节流”这个动作放到java虚拟机外部去实现<br>完成这个动作的代码就称为类加载器，以前不理解放到虚拟机外部是什么意思，现在我的理解是我们能够在编写程序时就能够编写目标类的加载过程，这也就是所谓的在虚拟机外部。这样如此，我们自定义的类加载器就能够处理我们自定义的字节码。</p></blockquote><p>值得一提的是：类加载器与类共同确定了该类在虚拟机中是否唯一。也就是说，在虚拟机要比较两个类是否相同，比较的前提是<strong>待比较的两个类是由同一个类加载器加载到虚拟机中的</strong>，才有比较的意义。</p><p>这里的比较包括：<code>instanceof</code>、Class对象的<code>equals()</code>、<code>isAssignableForm()</code>、<code>isInstance()</code>方法。</p><h2 id="2-双亲委派模型"><a href="#2-双亲委派模型" class="headerlink" title="2. 双亲委派模型"></a>2. 双亲委派模型</h2><p>在了解双亲委派模型前，我们需要知道，jvm中有三类自带的类加载器：</p><ul><li><code>bootstrap class loader</code>，启动类加载器</li><li><code>extension class loader</code>，扩展类加载器</li><li><code>Application class laoder</code>，应用程序类加载器</li></ul><p><strong>启动类加载器</strong><br>启动类加载器由cpp编写，在java代码中无法直接引用。该加载器负责加载java的核心库，包括<code>&lt;JAVA_HOME&gt;/lib/</code>下的库，例如rt.jar、tools.jar；或者由<code>-Xbootclasspath</code>指定的，并且存放在lib目录下的符合规则的库，这里的规则是库的名字由jvm指定，不符合名字要求的即使由参数指定，也不会被加载。</p><p>前面说到，该加载器由cpp编写时，所以在编写代码时如果我们需要使用到该加载器，我们可以用null指代启动类加载器，这一规则由java团队约定。</p><p><strong>扩展类加载器</strong><br>扩展类加载器由java编写，负责加载<code>&lt;JAVA_HOME&gt;/lib/ext/</code>目录下的库，或者由环境变量<code>java.extdirs</code>指定目录下的库。</p><p><strong>应用程序加载器</strong><br>应用程序类加载器通用由java编写，在代码中可以直接引用。该加载器是我们接触最多的加载器了，默认情况下，我们编写的class都由其加载至jvm中。它负责加载由<code>classpath</code>参数指定路径下的类库。</p><blockquote><p>应用程序类加载器由<code>sun.misc.Launcher$AppClassLoader</code>实现。并且应用程序类加载器是ClassLoader中的getSystemClassLoader()方法的返回值</p></blockquote><p>这三个加载器的关系如下所示：</p><p><img src="images/jvmclassloader.jpg" alt="jvm class loader"></p><p>可以看到，<code>BootStrap ClassLoader</code>作为顶层的父类，<code>Extension ClassLoader</code>作为<code>BootStrap ClassLoader</code>的子类，而<code>Application ClassLoader</code>又作为<code>Extension ClassLoader</code>的子类。我们可以看到，这里并没有所谓的双亲，只有单亲，而这么翻译可能是因为第一个翻译的人看到的是parents吧。</p><blockquote><p>这里的父类与子类并不是传统意义上的使用extends保持的继承关系，而是通过内部包含来实现逻辑意义上的继承关系</p></blockquote><p><strong>三类加载器的初始化过程</strong></p><p>下图显示了<code>ExtClassLoader</code>、<code>AppClassLoader</code>、<code>ClassLoader</code>三者真正的继承关系。<br><img src="images/Inheritance.png" alt="继承体系"></p><p><code>ExtClassLoader</code>和<code>AppClassLoader</code>处于平级的关系，那么如何实现所谓的双亲委派？这一切都要靠抽象类<code>ClassLoader</code>中的<code>parent</code>字段来实现，如下图所示：</p><p><img src="images/parents-field.png" alt="parent字段"></p><p>每生成一个新的<code>ClassLoader</code>,都会用父类加载器去初始化它。那么这三个加载器是如何初始化的呢？这一切都起源于<code>Launcher</code>类。 <strong>该类由<code>Bootstrap ClassLoader</code>来加载。</strong> 我们来看看它的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Launcher</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Launcher launcher = <span class="hljs-keyword">new</span> Launcher();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String bootClassPath = System.getProperty(<span class="hljs-string">&quot;sun.boot.class.path&quot;</span>);<br>    <span class="hljs-keyword">private</span> ClassLoader loader;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Launcher <span class="hljs-title">getLauncher</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> launcher;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Launcher</span><span class="hljs-params">()</span> </span>&#123;<br>        Launcher.ExtClassLoader var1;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//初始化ExtClassLoader</span><br>            var1 = Launcher.ExtClassLoader.getExtClassLoader();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException var10) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(<span class="hljs-string">&quot;Could not create extension class loader&quot;</span>, var10);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//初始化loader字段，将其设置为AppClassLoader</span><br>            <span class="hljs-keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException var9) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(<span class="hljs-string">&quot;Could not create application class loader&quot;</span>, var9);<br>        &#125;<br>        <span class="hljs-comment">//设置线程上下文加载器，也就是AppClassLoader</span><br>        Thread.currentThread().setContextClassLoader(<span class="hljs-keyword">this</span>.loader);<br>        ...<br>    &#125;<br>    ...<br></code></pre></div></td></tr></table></figure><p>在<code>Bootstrap ClassLoader</code>把<code>Launcher</code>加载进虚拟机后，<code>Launcher</code>会初始化静态字段<code>Launcher</code>，然后会调用构造方法。在构造方法中，我们目前只需关注三个部分：</p><ol><li><p>使用<code>Launcher.ExtClassLoader.getExtClassLoader()</code>生成扩展类加载器<code>ExtClassLoader</code></p></li><li><p>使用<code>Launcher.AppClassLoader.getAppClassLoader(var1)</code>生成应用类加载器<code>App ClassLoader</code>,其中<code>var1</code>就是第一步生成的扩展类加载器，其用来初始化<code>parent</code>字段</p></li><li><p>使用<code>Thread.currentThread().setContextClassLoader(this.loader)</code>初始化线程上下文加载器，其中<code>loader</code>字段就是第二步生成的应用类加载器</p></li></ol><p>此外我们还需要关注以下<code>App ClassLoader</code>的生成方法，因为其与<code>classpath</code>的设置息息相关。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClassLoader <span class="hljs-title">getAppClassLoader</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ClassLoader var0)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//读取系统属性classpath</span><br>    <span class="hljs-comment">//这里读取的是一个整个字符串，因为在windows上由“;”将多个路径拼接成一个string</span><br>    <span class="hljs-comment">//linux平台使用“:”拼接多个路径组成一个string</span><br>    <span class="hljs-keyword">final</span> String var1 = System.getProperty(<span class="hljs-string">&quot;java.class.path&quot;</span>);<br>    <span class="hljs-comment">//将多个路径抽象为File</span><br>    <span class="hljs-keyword">final</span> File[] var2 = var1 == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> File[<span class="hljs-number">0</span>] : Launcher.getClassPath(var1);<br>    <span class="hljs-keyword">return</span> (ClassLoader)AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Launcher.AppClassLoader&gt;() &#123;<br>        <span class="hljs-keyword">public</span> Launcher.<span class="hljs-function">AppClassLoader <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">//将多个路径转化为URL数组</span><br>            URL[] var1x = var1 == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> URL[<span class="hljs-number">0</span>] : Launcher.pathToURLs(var2);<br>            <span class="hljs-comment">//使用URl路径和Ext ClassLoader生成新的AppClassLoader</span><br>            <span class="hljs-comment">//具体的初始化逻辑见下</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Launcher.AppClassLoader(var1x, var0);<br>        &#125;<br>    &#125;);<br>&#125;<br><br>AppClassLoader(URL[] var1, ClassLoader var2) &#123;<br>    <span class="hljs-comment">//调用父类URLClassLoader的构造函数保存多个classpath路径</span><br>    <span class="hljs-keyword">super</span>(var1, var2, Launcher.factory);<br>    <span class="hljs-keyword">this</span>.ucp.initLookupCache(<span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-comment">//父类URLClassLoader的构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">URLClassLoader</span><span class="hljs-params">(URL[] urls, ClassLoader parent,</span></span><br><span class="hljs-params"><span class="hljs-function">                        URLStreamHandlerFactory factory)</span> </span>&#123;<br>    <span class="hljs-comment">//初始化parent字段</span><br>    <span class="hljs-keyword">super</span>(parent);<br>    ...<br>    <span class="hljs-comment">//实际使用ucp字符保存多个classpath路径</span><br>    ucp = <span class="hljs-keyword">new</span> URLClassPath(urls, factory, acc);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>经过上面的源码学习，我们已经非常清楚这三类加载器如何实现<strong>双亲</strong>的逻辑，并且还顺便搞懂了classpath的初始化过程。那么委派是什么呢？下面的加载流程很好地解释了什么是委派：</p><ol><li><p>在传统情况下，一个类的加载会由默认的类加载器加载，而一般情况下<code>Application ClassLoader</code>会作为默认的类加载器。类加载器首先会将请求委派给父类，而不是由自己来加载。</p></li><li><p><code>Application ClassLoader</code>会将加载请求委派给父类<code>Extension ClassLoader</code>,而<code>Extension ClassLoader</code>又会将请求委派给父类<code>BootStrap ClassLoader</code>。</p></li><li><p>如果<code>BootStrap ClassLoader</code>加载失败，那么具体的加载会由<code>Extension ClassLoader</code>完成。如果<code>Extension ClassLoader</code>加载失败，具体的加载会由<code>Extension ClassLoader</code>完成。如果再次不能完成，那么就会抛出异常。</p></li></ol><p>可以看到，加载请求会一级一级向上传递，直到传到根加载器。然后如果不能完成，请求又会一级一级从上到下传递到底部加载器。<strong>那么为什么要这么做呢？</strong></p><p>答案来自《深入理解java虚拟机》：</p><blockquote><p>这样做的一个显而易见的好处是，被加载的类随着它的加载器一起具备了一种优先级的层次关系。</p></blockquote><p>试想加载类<code>Object</code>,这个类肯定最终由<code>bootstrap ClassLoader</code>来加载。如果没有这种委派关系，我们随便写一个同名的类<code>Object</code>,虚拟机无法保证使用加载正确的<code>Object</code>类。那么最基础的核心类都无法保证正确加载，那就出大问题了。</p><p><strong>双亲委派模型的代码实现</strong></p><p>双亲委派的原理简单，代码实现也非常简单，下面的短短几十行代码就完成了操作：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>        <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// First, check if the class has already been loaded</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">long</span> t0 = System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//如果父类不为空，那么就使用父类的加载方法</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//否则使用根加载器加载</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                <span class="hljs-comment">// to find the class.</span><br>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br>                c = findClass(name);<br>                ...<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>系统类加载器的设置</strong></p><p>update：2021-01-18 00:31:03</p><p>复习到这时，我提出了一个问题：系统类加载器的设置和三类加载器之间的关系是怎么样的？是谁调用谁的？</p><p>目前我只能回答这个问题的一半：某个函数会首先调用<code>getSystemClassLoader()</code>，然后调用链如下：<code>getSystemClassLoader()</code>—&gt;<code>initSystemClassLoader</code>—&gt;<code>sun.misc.Launcher.getLauncher()</code></p><hr><p>我曾在上面提到，如果没有意外发生，那么在jvm中，<code>AppClassLoader</code>会被设置为默认的系统类加载器，这也是为什么会在某些场合称其为“系统类加载器”。那么这一设置是什么时候完成的呢？这一切都起源于<code>ClassLoader</code>中的方法<code>getSystemClassLoader</code>。其注释写道：</p><blockquote><p>If the system property “java.system.class.loader” is defined<br>when this method is first invoked then the value of that property is<br>taken to be the name of a class that will be returned as the system<br>class loader.  The class is loaded using the default system class loader<br>and must define a public constructor that takes a single parameter of<br>type ClassLoader which is used as the delegation parent.  An<br>instance is then created using this constructor with the default system<br>class loader as the parameter.  The resulting class loader is defined<br>to be the system class loader.</p></blockquote><p>如果设置为系统属性<code>java.system.class.loader</code>，那么在第一次调用<code>getSystemClassLoader</code>时，会将该系统属性指向的类设置为系统类加载器。值得注意的是，自定义的系统类加载器必须声明一个带有一个参数的公共构造方法，并且唯一参数用来当作委派父类。下面我们来看看这一方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClassLoader <span class="hljs-title">getSystemClassLoader</span><span class="hljs-params">()</span> </span>&#123;<br>    initSystemClassLoader();<br>    <span class="hljs-keyword">if</span> (scl == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    SecurityManager sm = System.getSecurityManager();<br>    <span class="hljs-keyword">if</span> (sm != <span class="hljs-keyword">null</span>) &#123;<br>        checkClassLoaderPermission(scl, Reflection.getCallerClass());<br>    &#125;<br>    <span class="hljs-keyword">return</span> scl;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们看到，该方法内部会调用<code>initSystemClassLoader()</code>，那么这个方法又做了什么事情呢？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initSystemClassLoader</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!sclSet) &#123;<span class="hljs-comment">//如果系统类加载器还没有被设置</span><br>        <span class="hljs-keyword">if</span> (scl != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;recursive invocation&quot;</span>);<br>        sun.misc.Launcher l = sun.misc.Launcher.getLauncher();<br>        <span class="hljs-keyword">if</span> (l != <span class="hljs-keyword">null</span>) &#123;<br>            Throwable oops = <span class="hljs-keyword">null</span>;<br>            scl = l.getClassLoader();<span class="hljs-comment">//获得ApplicationClassLoader</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                scl = AccessController.doPrivileged(<br>                    <span class="hljs-keyword">new</span> SystemClassLoaderAction(scl));<span class="hljs-comment">//设置系统类加载器</span><br>            &#125; <span class="hljs-keyword">catch</span> (PrivilegedActionException pae) &#123;<br>                oops = pae.getCause();<br>                <span class="hljs-keyword">if</span> (oops <span class="hljs-keyword">instanceof</span> InvocationTargetException) &#123;<br>                    oops = oops.getCause();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (oops != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (oops <span class="hljs-keyword">instanceof</span> Error) &#123;<br>                    <span class="hljs-keyword">throw</span> (Error) oops;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// wrap the exception</span><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(oops);<br>                &#125;<br>            &#125;<br>        &#125;<br>        sclSet = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中<code>sclSet</code>是<code>ClassLoader</code>的属性，如果是第一次调用，那么会通过<code>Launcher</code>调用<code>getSystemLoader</code>获取<code>Launcher</code>内部字段<code>loader</code>的值。不知道大家还记不记得，<code>loader</code>字段会被设置为<code>AppClassLoader</code>。此后<code>scl</code>会被设置为<code>AppCLassLoader</code>。</p><p>然后会使用<code>SystemClassLoaderAction</code>读取系统属性<code>java.system.class.loader</code>,完成系统类加载器的设置，我们来看看其源码。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemClassLoaderAction</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">PrivilegedExceptionAction</span>&lt;<span class="hljs-title">ClassLoader</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> ClassLoader parent;<br><br>    SystemClassLoaderAction(ClassLoader parent) &#123;<br>        <span class="hljs-keyword">this</span>.parent = parent;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ClassLoader <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String cls = System.getProperty(<span class="hljs-string">&quot;java.system.class.loader&quot;</span>);<br>        <span class="hljs-keyword">if</span> (cls == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> parent;<br>        &#125;<br>        Constructor&lt;?&gt; ctor = Class.forName(cls, <span class="hljs-keyword">true</span>, parent)<br>            .getDeclaredConstructor(<span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123; ClassLoader.class &#125;);<br>        ClassLoader sys = (ClassLoader) ctor.newInstance(<br>            <span class="hljs-keyword">new</span> Object[] &#123; parent &#125;);<br>        Thread.currentThread().setContextClassLoader(sys);<br>        <span class="hljs-keyword">return</span> sys;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们可以很清楚的看到，如果系统属性<code>java.system.class.loader</code>为空，那么就会返回<code>parent</code>。此前<code>parent</code>已通过构造函数被设置为<code>AppClassLoader</code>。</p><p>否则，加载系统属性指向的类并获取带有一个参数的构造方法。随后创建自定义类加载器的实例<code>sys</code>并返回。</p><p>至此，已经完成了系统类加载器的设置。所以说，默认情况下，所有的类都会使用<code>AppClassLoader</code>来加载。</p><h2 id="3-破坏双亲委派模型"><a href="#3-破坏双亲委派模型" class="headerlink" title="3. 破坏双亲委派模型"></a>3. 破坏双亲委派模型</h2><p>虽然双亲委派模型好，但它也不是万能的。到目前为止，已经出现了三次破坏行为。下面来品一哈。</p><h3 id="3-1-第一次破坏"><a href="#3-1-第一次破坏" class="headerlink" title="3.1 第一次破坏"></a>3.1 第一次破坏</h3><p>第一次破坏是由于JDK1.2之前还没有出现双亲委派模型，但是此时已经有了类加载器的概念。那么此时已经有了许多用户自定义的类加载器。那么为了兼容以前的代码，无法再以技术手段避免<code>loadClass()</code>被子类覆盖的可能性。这里所谓的无法避免是什么呢？我们再次来看看双亲委派的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>        <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// First, check if the class has already been loaded</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">long</span> t0 = System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//如果父类不为空，那么就使用父类的加载方法</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//否则使用根加载器加载</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                <span class="hljs-comment">// to find the class.</span><br>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br>                c = findClass(name);<br>                ...<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果此时用户代码还在覆盖<code>loadClass</code>,但是编写出的代码并没有采用双亲委派，那么就会使双亲委派失效。因为双亲委派就是靠<code>loadClass</code>来实现的。所以尽管不能避免之前的状态，但是以后要尽量避免让用户覆盖<code>loadClass</code>。</p><p>所以在JDK1.2之后，在<code>ClassLoader</code>中引入了一个<code>protected</code>方法<code>findClass()</code>。希望引导用户能够覆盖<code>findClass()</code>编写自定义类加载器。这样既不影响双亲委派，又可以按照用户自己的意愿加载类，就像上面源码中的那样，当父类加载失败，那么就会调用<code>findClass()</code>加载。</p><p>所以重写<code>loadClass</code>会破坏双亲模型，而重写<code>findClass</code>则不会，如果需要在多个类加载器中加载同一个<code>Class</code>，则需要使用前者。</p><h3 id="3-2-第二次破坏"><a href="#3-2-第二次破坏" class="headerlink" title="3.2 第二次破坏"></a>3.2 第二次破坏</h3><p>第二次破坏是因为双亲委派这个机制存在缺陷。首先我们需要明白下面这种机制：</p><blockquote><p>假设我们当前代码所处的类为D，如果此时要把一个从未解析的符号解析成类或接口C。如果C不是数组类型，那么<strong>jvm会使用加载D的类加载器来加载C</strong>。</p></blockquote><p>但是在双亲委派模型中，上层的类加载器是无法指派下层的类加载器来完成加载动作的。一个典型的例子就是JNDI(The Java Naming and Directory Interface)服务。简而言之，JDNI就是java规定一组服务的接口，但是具体的实现由第三方提供，例如数据库的驱动。</p><p>那么这个<strong>破坏</strong>在哪里呢？首先JDNI肯定是由启动类加载器加载至JVM。那么调用具体的实现类时，启动类加载器是不可能将实现类加载进来的，因为这不符合启动类加载器的规定。那么怎么办呢？</p><p>开发人员又设计了一种叫进程上下文类加载器(Thread Context ClassLoader)的东西来完成这个任务。启动类加载器会调用进程上下文类加载器来加载接口的实现类。</p><p>线程上下文类加载器在(默认情况下)由<code>Bootstrap classLoader</code>第一次加载<code>Launcher</code>类时就会被设置为<code>App ClassLoader</code>。当然，我们可以通过<code>setContextClassLoader(ClassLoader cl)</code>和<code>getContextClassLoader()</code>来设置和使用我们自定义的线程上下文类加载器。<strong>在多线程的情况下</strong>，子线程会继承父线程的线程上下文类加载器。</p><h3 id="3-3-第三次破坏"><a href="#3-3-第三次破坏" class="headerlink" title="3.3 第三次破坏"></a>3.3 第三次破坏</h3><p>这次破坏是为了实现java应用的热部署。简单来说就是OSGi机制破坏了双亲委派模型。以下引自《深入理解java虚拟机》：</p><blockquote><p>OSGi实现模块热部署的关键是它自定义的类加载机制的实现，每一个程序模块（OSGi称其为bundle）都有属于自己的类加载器。当需要替换Bundle时，就把Bundle连同类加载器一起替换以实现代码的热替换。</p><p>在OSGi环境下，类加载机制不再是委派双亲的树模型，而是一个<strong>网状</strong>结构。OSGi的类加载顺序中，只有前两个步骤符合双亲委派的原则，即：</p><ol><li>将以java.*开头的类，委派给父类加载器加载</li><li>否则,将委派列表名单内的类，委派给父类加载器加载</li></ol></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文详细介绍了双亲委派模型的类加载机制，解释了什么是“双亲”、什么是“委派”，三个系统自带的类加载器的初始化过程（仅限于JDK1.2-1.8）。以及历史上三次破坏双亲委派模型的事件，引出了SPI。后面我会以数据库加载驱动的案例讲解SPI到底是如何工作的。</p><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>我们在上面的源码中会经常看到<code> AccessController.doPrivileged()</code>这个方法，这又跟java的安全模型相关，谈起来不简单，后面我会专门开一篇来讲解它。</p><p><strong>参考文献</strong></p><p><a href="https://greenhathg.github.io/2019/06/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-Launcher%E7%B1%BB/">https://greenhathg.github.io/2019/06/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-Launcher%E7%B1%BB/</a></p><p><a href="https://juejin.im/post/6844903837472423944">https://juejin.im/post/6844903837472423944</a></p><p><a href="https://segmentfault.com/a/1190000021869536">https://segmentfault.com/a/1190000021869536</a></p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/jvm/">jvm</category>
      
      
      <category domain="https://eripe.me/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/">类加载</category>
      
      
      <comments>https://eripe.me/articles/parents-delegation-model.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>关于泛型的常见问题</title>
      <link>https://eripe.me/articles/Frequently-asked-questions-about-generics.html</link>
      <guid>https://eripe.me/articles/Frequently-asked-questions-about-generics.html</guid>
      <pubDate>Mon, 30 Aug 2021 16:38:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里罗列一些关于泛型的常见问题,并给出解答。其中本篇大多数问题来自<a href="http://www.angelikalanger.com/GenericsFAQ/FAQSections/ParameterizedTypes.html">Java Generics FAQs - Generic And Parameterized Types</a>,我这里仅翻译一些我认为比较容易糊涂的问题。</p><p>当然,在解答这些问题时,我们需要牢记一个概念,通配符<code>?</code>表示的是不知道是什么类型,而不是任意类型。</p><ul><li>泛型类型:<code>class test&lt;T&gt;&#123;&#125;</code></li><li>具体参数类型:<code>class test&lt;String&gt; t1=null;</code></li><li>泛型参数类型:<code>test&lt;?&gt; t2=null;</code></li></ul><h2 id="1-使用通配符时经常出现的capture-XXX-of-到底什么意思"><a href="#1-使用通配符时经常出现的capture-XXX-of-到底什么意思" class="headerlink" title="1. 使用通配符时经常出现的capture#XXX of ? 到底什么意思?"></a>1. 使用通配符时经常出现的capture#XXX of ? 到底什么意思?</h2><p>在使用通配符时,我们很有可能会遇到类似<code>capture#337 of ?</code>这样莫名奇妙的错误。其中<code>capture</code>是捕获的意思,捕获的是通配符<code>?</code>,那么<code>#337</code>又代表着什么?这一切都要从捕获转化(Capture Conversion)开始说起。</p><p>让我们思考一个问题,如果我们定义定义一个泛型类C如下(类似于List容器)如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> &lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span>&gt;</span>&#123;<br>    ...<br>    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T)</span></span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">C&lt;?&gt; c</span>=<span class="hljs-keyword">new</span> C&lt;Integer&gt;()<br></code></pre></div></td></tr></table></figure><p>那么通过<code>c</code>调用对象方法时,方法的签名是什么样的?像下面这样?(编译时期泛型还是存在的)</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> &lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span>&gt;</span>&#123;<br>    ...<br>    ? get();<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(?)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这显然是毫无意义的,但是我们知道实例化类时一定会使用一个具体的类型X:&lt; Number( <strong>:&lt;</strong> 表示前者继承于后者),尽管我们不知道这个X到底是什么类型的。这并不重要。那么被具体类型X实例化的类C长下面这样:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&lt;<span class="hljs-title">X</span>&gt;</span>&#123;<span class="hljs-comment">//X:&lt;Number</span><br>    ...<br>    <span class="hljs-function">X <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(X)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用一个具有名字的类型比使用通配符<code>?</code>容易多了。所以编译器也是这么做的。只不过编译器并不会使用<code>X</code>,而是随机使用一个数字,例如<code>#337</code>表示上面这个通配符。所以才会有了这句<code>capture#337 of ?</code>。即编译将遇到这个统配符<code>?</code>分配了一个名字叫做<code>#337</code>。</p><p>当一个<code>value</code>的类型是通配符类型,编译器会使用类型变量替换这个<code>value</code>种存在的通配符<code>?</code>(类型变量中的数字按序增长),这种操作名为<code>capture conversion</code>,通过这个操作,编译器只需要处理带有具体类型的对象。</p><p>对于上面的例子,<code>get()</code>方法返回一个<code>X</code>类型的引用,其中<code>X:&lt;Number</code>,那么我们就可以执行下述操作:</p><blockquote><p>Number n= c.get();//c为类C的实例,get方法返回的是Number类型</p></blockquote><p>但是我们却不能向c中添加元素。</p><blockquote><p>c.add(number)//add方法接受的参数为类型为capture#1 of ?</p></blockquote><p>因为add方法接受的参数类型为x(编译器的名字可能为capture#1 of ?),而容器c中的引用至少都为Number类型,因为容器内的元素类型都有一个限制:<code>? extends Number</code>,所以编译器出于安全,将容器内的引用推断为<code>Number</code>类型肯定是不会错的。<br>那么一个存储<code>Number</code>类型的容器,能接受一个类型为<code>capture#1 of ?</code>的值吗?不知道,因为后者的类型编译器无法推断,所以为了保险起见,直接会产生编译错误。</p><p>只要有表达式产生了<code>wild type</code>的<strong>value</strong>(The compiler applies capture conversion on every expression that yields a value in wild type),<code>capture conversion</code>操作就存在。并且会为每个通配符<code>?</code>分配一个唯一ID。以下面代码为例:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;? extends Number&gt; foo(List&lt;? extends Number&gt; numberList)<br>&#123;<br>#<span class="hljs-number">1</span>  <span class="hljs-keyword">for</span>(Number number : numberList)<br>#<span class="hljs-number">2</span>      <span class="hljs-keyword">assert</span> numberList.contains(number);<br>#<span class="hljs-number">3</span>  numberList = numberList;<br>#<span class="hljs-number">4</span>  <span class="hljs-keyword">return</span> numberList;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面代码有四个地方都存在<code>wild type</code>的变量,我们一个一个来分析。</p><p>对于<code>#1</code>处的<code>numberList</code>,其类型为<code>List &lt;? extends Number&gt;</code>,那么会将这处的<code>numberList</code>转换为<code>List&lt;X1&gt;</code>类型,<code>List&lt;X1&gt;</code>是<code>Iterable&lt;X1&gt;</code>的子类,所以可以使用for循环遍历,number的类型是<code>X1</code>,又因为<code>X1:&lt;Number</code>,所以其可以向上转型为<code>Number</code></p><p>对于<code>#2</code>处的<code>numberList</code>,编译器会将其类型转换为<code>List&lt;X2&gt;</code>类型,其中的<code>contains</code>方法是<code>List&lt;X2&gt;</code>类型下的<code>contains</code>方法,所以该方法接受一个<code>X2</code>类型的参数</p><p>对于<code>#3</code>处的右<code>numberList</code>,编译器会将其类型转换为<code>List&lt;X3&gt;</code>,但是！！！对于左边的<code>numberList</code>,因为其是一个variable,而不是一个value,所以编译器不会对其类型进行转换,还是<code>List&lt;? extends Number&gt;</code>,将<code>List&lt;X3&gt;</code>类型赋值给<code>List&lt;? extends Number&gt;</code>类型是合法的,因为<code>X3:&lt;Number</code>。<br><strong>那么是否可以认为左侧的都是variable,而右侧的是value???</strong> 或者是否可以这样理解:右边的变量<code>numberList</code>把它的value赋值给了左侧的<code>numberList</code>,而这个value是<code>wild type</code>？或者说用的时候实际上使用的实际上是variable的value?</p><p>对于<code>#4</code>处的<code>numberList</code>,编译器同样会转换为<code>List&lt;X4&gt;</code>后返回。</p><p>上面的转换规则非常重要,我们再来看一个难一点的例子。现在有一个map,类型为<code>Map&lt;?,?&gt; map</code>,那么如果进行如下操作是合法的:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(Entry&lt;?,?&gt; entry : map.entrySet())<br></code></pre></div></td></tr></table></figure><p>因为<code>map</code>会被转型为<code>Map&lt;X1,X2&gt;</code>类型,那么返回的entrySet就是<code>Set&lt;Entry&lt;X1,X2&gt;&gt;</code>,因为<code>X1&lt;:?</code>,<code>X2&lt;:?</code>,所以将<code>Entry&lt;X1,X2&gt;</code>类型赋值给<code>Entry&lt;?,?&gt;</code>类型是合理的。但是下面的操作就非法了</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Set&lt;Entry&lt;?,?&gt;&gt; entrySet = map.entrySet(); <span class="hljs-comment">// compile error</span><br></code></pre></div></td></tr></table></figure><p>很简单,错误原因是因为泛型不是协变的,<code>Set&lt;Entry&lt;X1,X2&gt;&gt;</code>不是<code>Set&lt;Entry&lt;?,?&gt;&gt;</code>的子类。比较笨拙的办法是在定义一个<code>wild type</code>,如下所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Set&lt;? extends Entry&lt;?,?&gt;&gt; entrySet=map.entrySet();<br></code></pre></div></td></tr></table></figure><p>其实还有一个比较取巧的办法,通过名为<code>capture helper</code>的操作来解决这个问题。</p><h3 id="1-1-Capture-Helper"><a href="#1-1-Capture-Helper" class="headerlink" title="1.1 Capture Helper"></a>1.1 Capture Helper</h3><p>因为编译器对于<code>wild type</code>的取名都是任意的,并且对我们是不可见的,所以我们在源码中无法引用,以下面的代码为例:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(List&lt;? extends Number&gt; numberList)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// numberList.add( numberList.get(0) ); // compile error,因为左numberList接受的是X2类型,而又numberList接受的是X1类型</span><br><br>    <span class="hljs-comment">//假设下面的代码存在,我们将传进来的numberList转型为List&lt;X&gt;类型,那么该方法所有使用numberList的地方,其类型是List&lt;X&gt;</span><br>    <span class="hljs-comment">//而不是见一个numberList换一个类型</span><br>    List&lt;X&gt; list = numberList;  <span class="hljs-comment">// *imaginary* code</span><br><br>    X number = list.get(<span class="hljs-number">0</span>);     <span class="hljs-comment">// get() returns X</span><br>    list.add(number);           <span class="hljs-comment">// add() accepts X</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>既然人为定义<code>wild type</code>的类型,可行,那么我把类型<code>X</code>定义出来不久好了?如下面代码所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">&lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar2</span><span class="hljs-params">(List&lt;T&gt; list)</span></span><br><span class="hljs-function"></span>&#123;<br>    T number = list.get(<span class="hljs-number">0</span>);<br>    list.add(number);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后我们就可以调用<code>bar(numberList)</code>解决上面每个<code>numberList</code>类型不一样的问题。方法<code>bar2</code>就叫做<code>capture helper</code>。</p><p>那么<code>capture helper</code>的出现有什么意义呢?<br>答案是为了兼容老代码,因为1.5之前的代码没有泛型,如果使用泛型的代码想要接受没有泛型的容器,就得实现<code>capture helper</code>(当然不局限于容器,这里容器比较典型)</p><p><strong>参考文献:</strong></p><ol><li><p><a href="http://bayou.io/draft/Capturing_Wildcards.html#Capture_Everywhere">Capturing Wildcards</a></p></li><li><p><a href="http://bayou.io/draft/Wildcard_Case_Studies.html#Map&lt;?,?&gt;_Entry_Set">Wildcard Case Studies</a></p></li></ol><h2 id="2-lt-extends-E-gt-与-lt-T-extends-E-gt-有什么区别"><a href="#2-lt-extends-E-gt-与-lt-T-extends-E-gt-有什么区别" class="headerlink" title="2. &lt;? extends E&gt;与&lt;T extends E&gt;有什么区别?"></a>2. &lt;? extends E&gt;与&lt;T extends E&gt;有什么区别?</h2><p>这是容易搞混的一点,首先<code>T</code>叫做类型变量(type variable),<code>?</code>叫做通配符(wildcard)。</p><ol><li><p>类型变量不能使用<code>super</code>,即类型变量不能有上界,例如<code>T super E</code>,这样是非法的。至于为什么非法可以看下一个问题。但是通配符<code>?</code>却可以有上界或者下界。</p></li><li><p>类型变量可以有多个限制,例如<code>T extends A &amp; B</code>,但是通配符<strong>至多</strong>有一个界限。</p></li><li><p>通配符不能表示一个类型变量,所以通配符不能用来定义<code>generic type</code> ,类型变量可以用来定义<code>generic type</code></p></li></ol><p><strong>参考文献:</strong></p><ol><li><a href="https://stackoverflow.com/questions/18384897/what-is-difference-between-extends-object-and-e-extends-object">What is difference between &lt;? extends Object&gt; and <E extends Object>?</a></li></ol><h2 id="3-lt-T-super-E-gt-为什么是非法的"><a href="#3-lt-T-super-E-gt-为什么是非法的" class="headerlink" title="3. &lt;T super E&gt;为什么是非法的?"></a>3. &lt;T super E&gt;为什么是非法的?</h2><p>因为Object所有引用类型的父类。<T super E>并不会按照我们的想法工作。例如我们定义了一个容器<code>ArrayList&lt;Integer&gt; list</code>,思考下面的代码是否意义:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//add方法是list的对象方法</span><br><span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">super</span> Integer&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T)</span></span>&#123;<br>    list.add(T);<br>&#125;<br><br>ArrayList&lt;Integer&gt; list=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<span class="hljs-comment">//正常,没有任何问题</span><br>lsit.add(<span class="hljs-string">&quot;aaa&quot;</span>);<span class="hljs-comment">//我们的本意是这句不该通过编译,但是却通过了</span><br></code></pre></div></td></tr></table></figure><p><code>add</code>方法的本意是接受类型是<code>Integer</code>的参数,可以是<code>Object</code>、<code>Number</code>、<code>Integer</code>,不应该接受<code>String</code>类型。</p><p>但是<code>Object</code>也是<code>String</code>的父类。很有可能给<code>add</code>传入的参数静态类型是<code>Object</code>,动态类型是<code>String</code>。虽然放进去是没有问题,但是如果把这个<code>String</code>类型的元素取出来,会出现<code>castException</code>,因为<code>String</code>根本不可能转换为<code>Integer</code>。</p><p><strong>参考文献:</strong></p><ol><li><a href="https://stackoverflow.com/questions/2800369/bounding-generics-with-super-keyword">Bounding generics with ‘super’ keyword</a></li></ol><h2 id="4-为什么定义类型参数时不能使用通配符’-’"><a href="#4-为什么定义类型参数时不能使用通配符’-’" class="headerlink" title="4. 为什么定义类型参数时不能使用通配符’?’?"></a>4. 为什么定义类型参数时不能使用通配符’?’?</h2><p>因为通配符<code>?</code>只是用来定义<code>wild type</code>的一个语法成分,它没有任何语义,<strong>它不能表示任何类型</strong>。想象一下,如果下面的代码是合法的:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>&lt;?&gt;</span>&#123;<br>    ? get(<span class="hljs-keyword">int</span> index)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(? elem)</span></span>&#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在前面曾经说过,由于<code>capture conversion</code>的原因,编译器会把每一个类型是<code>wild type</code>的value中的通配符<code>?</code>赋一个名字,例如像下面这样:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">X1</span>&gt;</span>&#123;<br>    <span class="hljs-function">X2 <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> inedx)</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(X3 elem)</span></span>&#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么我们在实例化List的时候,像<code>List&lt;String&gt;</code>这样?那么<code>get</code>的返回值类型又是什么?这样就违背了我们使用<code>?</code>定义泛型类的初衷。我们的本意是<code>List</code>接受一个不知道是什么类型的类型参数(unkown type),并且想要<code>get</code>的返回值类型也是同一个<code>unknown type</code>。但是这很显然不可能。</p><p><strong>所以通配符<code>?</code>就不能用来定义一个类型变量(type variable),它只能用在类型声明的地方</strong>,例如声明方法的形参类型,声明一个变量。因为 <strong>?不是一个有效的变量名,不是一个有效的标识符</strong>:</p><blockquote><p>You can’t name a generic parameter as ?, because ? is not a valid identifier - a valid name of a variable.<br>You have to give a generic parameter a valid java name so you can refer to it in the implementation.</p></blockquote><p>下面是通配符常用的地方:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;?&gt; list;<span class="hljs-comment">//ok,声明变量类型</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(List&lt;? extends Number&gt; list)</span></span>;<span class="hljs-comment">//ok,声明参数类型</span><br></code></pre></div></td></tr></table></figure><p>那么所谓的定义一个泛型类型是什么?就像下面这样:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">    List MyList&lt;T&gt;&#123;<span class="hljs-comment">//定义了一个泛型类型MyList&lt;T&gt;,T是类型变量</span><br><br>    <span class="hljs-keyword">public</span> &lt;V&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(V num,T test)</span></span>&#123;&#125;<span class="hljs-comment">//定义了一个类型变量V</span><br>    <span class="hljs-keyword">public</span> &lt;?&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//compile error</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>并且统配符<code>?</code>只能用来填充类型变量。所谓的填充是什么意思,比如我们定义了一个方法接受<code>MyList&lt;T&gt;</code>泛型的方法,那么我们就可以用<code>?</code>填充这个T。那么填充在哪?</p><ul><li>声明方法的参数</li><li>声明变量</li></ul><p>如下所示:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//定义方法时声明参数,使用?填充T</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(MyList&lt;?&gt; myList)</span></span>&#123;&#125;<br><span class="hljs-comment">//或者加个界限</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(MyList&lt;? extends Number&gt; myList)</span></span>&#123;&#125;<br><span class="hljs-comment">//定义了一个MyList&lt;T&gt;的变量,使用?填充T</span><br>MyList&lt;?&gt; myList;<span class="hljs-comment">//</span><br></code></pre></div></td></tr></table></figure><p><strong>参考文献:</strong></p><ol><li><a href="https://stackoverflow.com/questions/24740590/java-generic-wildcard?rq=1">java Generic wildcard “?”</a></li><li><a href="https://blog.csdn.net/harvic880925/article/details/49883589">夯实JAVA基本之一——泛型详解(2)：高级进阶</a></li></ol><h2 id="5-有没有不能使用泛型的地方"><a href="#5-有没有不能使用泛型的地方" class="headerlink" title="5. 有没有不能使用泛型的地方?"></a>5. 有没有不能使用泛型的地方?</h2><p>几乎所有类型都可以拥有类型参数,但除了一下几种类型:</p><ul><li>枚举类型:因为枚举类型不能有类型参数,所以枚举类中的值都是静态类型的,但是又因为<strong>类型参数不能用于任何静态的上下文环境</strong>,所以在枚举类中使用泛型是没有任何意义的</li><li>匿名内部类:它可以继承一个参数化类型的类或者接口,但它本身不能是，因为<strong>匿名内部泛型类没有任何意义</strong>。因为匿名内部类没有名字,所以在声明时就没有地方提供类型参数</li><li>异常类:一个泛型类不能间接或者直接继承自<code>Throwable</code>接口,因为异常处理机制是一种运行时机制,但是在运行时泛型已经被擦出了。所以对于同一个泛型类型但是类型参数不同的两个参数化类型来说,虚拟机并不能区分它们,所以异常泛型类也是无意义的。</li></ul><h2 id="6-能不能强转成参数化类型"><a href="#6-能不能强转成参数化类型" class="headerlink" title="6.能不能强转成参数化类型?"></a>6.能不能强转成参数化类型?</h2><p>可以,但是这种操作是类型不安全的,且会产生”unchecked”的编译警告。</p><p>因为一个变量的类型分为静态类型与动态类型。一个类型转换操作也分为两个部分:</p><ul><li>编译时期的静态类型检查</li><li>运行十七的动态类型检查</li></ul><p>静态时期的类型检查去除了一些显而易见的错误,例如讲<code>String</code>转换成<code>Date</code>。而动态类型检查使用了动态类型进行检查。如果动态类型不是目标类型或者不是目标类型的子类(也就是所谓的向下转型),那么就会产生<code>ClassCastException</code>。</p><p>但是并不是所有类型转换都会动态类型检查。基本类型之间的转换仅会进行静态类型检查。并且向上转型也只会进行静态类型检查,向上转型不写也没关系,因为编译器会帮你做这件事。</p><p><strong>需要动态检查</strong>的类型转换潜在是类型不安全的,尤其是当目标类型为一个参数化类型。在运行时参数化类型的类型信息不在存在,虚拟机不能区分两个是同一个泛型,但是采用不同的类型参数实例化出的参数化类型,所以在这种情况下,本不该通过动态检查的类型转换却通过了,这不是我们希望看到的。例如下面的代码,将<code>Object</code>转换为<code>List&lt;String&gt;</code>,但是却没有抛出<code>ClassCastException</code>.</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br>  List&lt;Date&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Date&gt;();<br>  ...<br>  m2(list);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">(Object arg)</span> </span>&#123;<br>  ...<br>  List&lt;String&gt; list = (List&lt;String&gt;) arg;    <span class="hljs-comment">// unchecked warning</span><br>  ...<br>  m3(list);<br>  ...<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">(List&lt;String&gt; list)</span> </span>&#123;<br>  ...<br>  String s = list.get(<span class="hljs-number">0</span>);      <span class="hljs-comment">// ClassCastException</span><br>  ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意上面抛出异常的位置,不是在我们进行类型转换的位置,而是在我们提取元素的时候。这种没有在正确地方抛出的异常是我们非常不愿意看到的。所以为了引起我们对这种潜在的类型不安全的转换注意,编译器产生了”unchecked”警告在遇到可疑的转换时。</p><p>所以,<strong>编译器在每一处目标类型是参数化类型并且是向下转型的地方,都会产生一个unchecked警告</strong>。</p><h2 id="7-泛型中哪里会出现的”unchecked”警告"><a href="#7-泛型中哪里会出现的”unchecked”警告" class="headerlink" title="7.泛型中哪里会出现的”unchecked”警告?"></a>7.泛型中哪里会出现的”unchecked”警告?</h2><ol><li><p>首先就是上面一个问题所说的:向下转型为参数化类型的地方。</p></li><li><p>如果方法的参数类型没有因为类型擦除而改变,那么调用这个方法就是类型安全的</p></li><li><p>如果字段的类型因为类型擦除而改变,那么对该字段赋值就会产生”unchecked”,但是读取该字段的值却不会产生任何问题</p></li></ol><h2 id="8-unbound-wildcard-parameterized-type和raw-type有什么区别"><a href="#8-unbound-wildcard-parameterized-type和raw-type有什么区别" class="headerlink" title="8. unbound wildcard parameterized type和raw type有什么区别?"></a>8. unbound wildcard parameterized type和raw type有什么区别?</h2><p>其实这二者没有太大区别,二者都可以被视作是任何参数化类型的超级类,并且二者都是<code>reifiable types</code>。所以这两种类型可以作为数组的元素类型(注意是unbound wildcard而不是wildcard)。但是编译器对<code>unbound wildcard parameterized type</code>更严格。对于同样的操作,如果<code>raw type</code>产生了<code>unchecked</code>警告,那么<code>unbound wildcard parameterized type</code>则会产生编译错误。</p><h2 id="9-泛型真的不能使用instance-of吗"><a href="#9-泛型真的不能使用instance-of吗" class="headerlink" title="9. 泛型真的不能使用instance of吗?"></a>9. 泛型真的不能使用instance of吗?</h2><p>大部分都不行,只有无界通配符可以,因为只有<code>reifiable type</code>能够使用<code>instance of</code>,<code>reifiable types</code>包括且只包括:</p><ul><li><p>It refers to a non-generic class or interface type declaration.</p></li><li><p>It is a parameterized type in which all type arguments are <strong>unbounded</strong> wildcards (§4.5.1).</p></li><li><p>It is a raw type (§4.8).</p></li><li><p>It is a primitive type (§4.2).</p></li><li><p>It is an array type (§10.1) whose element type is reifiable.</p></li><li><p>It is a nested type where, for each type T separated by a “.”, T itself is reifiable.</p></li></ul><h2 id="10-能创建数组元素是具体参数化类型的数组吗"><a href="#10-能创建数组元素是具体参数化类型的数组吗" class="headerlink" title="10. 能创建数组元素是具体参数化类型的数组吗?"></a>10. 能创建数组元素是具体参数化类型的数组吗?</h2><p>所谓的具体参数化类型就是类型参数是一个具体的参数,例如<code>String</code>、<code>Integer</code>等等。对于这个问题的答案是不能,因为是类型不安全的。</p><p>因为插入操作会逃过数组的动态类型检查,见如下代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>  Pair&lt;Integer,Integer&gt;[] intPairArr = <span class="hljs-keyword">new</span> Pair&lt;Integer,Integer&gt;[<span class="hljs-number">10</span>] ; <span class="hljs-comment">// error</span><br>  addElements(intPairArr); <br>  Pair&lt;Integer,Integer&gt; pair = intPairArr[<span class="hljs-number">1</span>];<br>  Integer i = pair.getFirst();<br>  pair.setSecond(i);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addElements</span><span class="hljs-params">( Object[] objArr)</span> </span>&#123;<br>  objArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair&lt;Integer,Integer&gt;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>  objArr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Pair&lt;String,String&gt;(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);      <span class="hljs-comment">// should fail with ArrayStoreException,但是因为在运行时泛型已经不存在了</span><br>                                                  <span class="hljs-comment">//  逃过了数组插入时的类型动态检查</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="11-能创建数组元素类型是通配符参数化类型的数组吗"><a href="#11-能创建数组元素类型是通配符参数化类型的数组吗" class="headerlink" title="11. 能创建数组元素类型是通配符参数化类型的数组吗?"></a>11. 能创建数组元素类型是通配符参数化类型的数组吗?</h2><p>无界通配符可以,有界通配符不行。因为有界通配符的插入操作也可以逃过数组插入时的动态类型检查,而无界通配符不会。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//非法操作</span><br>Object[] numPairArr = <span class="hljs-keyword">new</span> Pair&lt;? extends Number,? extends Number&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">// illegal</span><br>numPairArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair&lt;Long,Long&gt;(<span class="hljs-number">0L</span>,<span class="hljs-number">0L</span>);     <span class="hljs-comment">// fine</span><br><span class="hljs-comment">//注意,下面这句逃过了数组的动态类型检查</span><br>numPairArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair&lt;String,String&gt;(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// should fail, but would succeed</span><br><br><span class="hljs-comment">//合法操作</span><br>Object[] pairArr = <span class="hljs-keyword">new</span> Pair&lt;?,?&gt;[<span class="hljs-number">10</span>] ;        <span class="hljs-comment">// fine</span><br>pairArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair &lt;Long,Long&gt;(<span class="hljs-number">0L</span>,<span class="hljs-number">0L</span>);     <span class="hljs-comment">// fine</span><br>pairArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair &lt;String,String&gt;(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// fine </span><br>pairArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> ArrayList &lt;String&gt;();        <span class="hljs-comment">// fails with ArrayStoreException</span><br></code></pre></div></td></tr></table></figure><h2 id="12-能创建数组元素是有界通配符参数化类型的数组引用吗"><a href="#12-能创建数组元素是有界通配符参数化类型的数组引用吗" class="headerlink" title="12. 能创建数组元素是有界通配符参数化类型的数组引用吗?"></a>12. 能创建数组元素是有界通配符参数化类型的数组引用吗?</h2><p>可以,但没必要。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//创建了数组元素类型是有界通配符类型的数组</span><br><br>Pair&lt;? extends Number,? extends Number&gt;[] arr = <span class="hljs-keyword">null</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">Double</span>,<span class="hljs-title">Double</span>&gt; </span>&#123; ... &#125;<br>Pair&lt;? extends Number,? extends Number&gt;[] arr = <span class="hljs-keyword">new</span> Point[<span class="hljs-number">2</span>];<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Point(-<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>);  <span class="hljs-comment">// fine</span><br><span class="hljs-comment">//虽然能通过静态类型检查,但是无法通过数组的动态类型检查</span><br>arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Pair&lt;Number,Number&gt;(-<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>); <span class="hljs-comment">// fine (causes ArrayStoreException)</span><br>arr[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Pair&lt;Integer,Integer&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// fine (causes ArrayStoreException)</span><br></code></pre></div></td></tr></table></figure><h2 id="13-通配符参数化类型不能干嘛"><a href="#13-通配符参数化类型不能干嘛" class="headerlink" title="13.通配符参数化类型不能干嘛?"></a>13.通配符参数化类型不能干嘛?</h2><p>不能做父类。见如下代码:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span> &lt;?&gt; </span>&#123; <span class="hljs-comment">// error</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">( ??? arg)</span> </span>&#123; ... &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>编译器无法知道<code>comapreTo</code>方法到底接受的是什么类型的参数,很奇怪。而且,如前面所说,因为有<code>capture conversion</code>操作,这样的定义是没有任何意义的。</p><h2 id="15-具体化参数类型不能做什么"><a href="#15-具体化参数类型不能做什么" class="headerlink" title="15. 具体化参数类型不能做什么?"></a>15. 具体化参数类型不能做什么?</h2><p>具体化参数类型(concrete parameterized type)就是使用具体类型实例化泛型类型的类型。那么它不能做:</p><ol><li>使用<code>instance of</code></li><li>不能创建数组</li><li>不能用于异常处理(泛型都不行)</li></ol><h2 id="14-泛型不能做什么"><a href="#14-泛型不能做什么" class="headerlink" title="14. 泛型不能做什么?"></a>14. 泛型不能做什么?</h2><ol><li>不能在静态字段中使用类型参数(type paramemter):<strong>因为type parameter不适用于静态上下文环境</strong>,所以泛型不能适用于静态泛型字段,例如<code>static T member</code>、<code>static List&lt;T&gt; list</code></li><li>不用如此使用：<code>obj instanceof T</code>，因为类型擦除的原因</li></ol><p><strong>参考文献:</strong></p><p>若非特殊标注,问题引自<a href="http://www.angelikalanger.com/GenericsFAQ/FAQSections/ParameterizedTypes.html#FAQ001">Java Generics FAQs - Generic And Parameterized Types</a></p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E5%9F%BA%E7%A1%80/">基础</category>
      
      
      <category domain="https://eripe.me/tags/%E6%B3%9B%E5%9E%8B/">泛型</category>
      
      
      <comments>https://eripe.me/articles/Frequently-asked-questions-about-generics.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>volatile关键字</title>
      <link>https://eripe.me/articles/volatile-keyword.html</link>
      <guid>https://eripe.me/articles/volatile-keyword.html</guid>
      <pubDate>Mon, 30 Aug 2021 16:38:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;1-volatile是什么&quot;&gt;&lt;a href=&quot;#1-volatile是什么&quot; class=&quot;headerlink&quot; title=&quot;1. volatile是什么&quot;&gt;&lt;/a&gt;1.</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1-volatile是什么"><a href="#1-volatile是什么" class="headerlink" title="1. volatile是什么"></a>1. volatile是什么</h2><p>volatile被称为轻量级的<code>synchronzied</code>，它保证了内存的可见性、指令的有序性。我们通过经典的懒汉单例模式看看这个关键字的作用。</p><figure class="highlight java"><figcaption><span>"线程不安全"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DraconianSingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DraconianSingleton instance;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  DraconianSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>            synchronzied(<span class="hljs-keyword">this</span>)&#123;<br>                <span class="hljs-keyword">if</span>(instance==<span class="hljs-keyword">null</span>)&#123;<br>                    instance = <span class="hljs-keyword">new</span> DraconianSingleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>虽然使用了双锁，但是上述代码仍然是线程不安全的，因为<code>new DraconianSingleton()</code>并不是原子操作。这句代码的正常操作是：</p><ol><li>分配内存空间</li><li>初始化对象</li><li>将对象地址赋给引用instance</li></ol><p>但是因为操作2和操作3之间没有数据依赖，编译器有理由将这两条指令进行重排。重拍后的操作为：</p><ol><li>分配内存空间</li><li>将对象地址赋给引用instance</li><li>初始化对象</li></ol><p>重排后的指令在单线程环境下执行是没有问题的。但是在多线程环境下，如果thread1获得锁并且在执行了第二步之后，<code>instance != null</code>,但是对象并没有完成初始化。此时如果thread1时间片到期，切换到thread2。thread2调用<code>getInstace()</code>后获得的是一个部分初始化的对象，此时thread2在使用这个对象时很可能会出现意外的错误。</p><p>但是使用<code>volatile</code>修饰<code>instance</code>后，就能够禁止上述的重排现象发生，从而变成线程安全。</p><figure class="highlight java"><figcaption><span>"线程安全"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DraconianSingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> DraconianSingleton instance;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  DraconianSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>            synchronzied(<span class="hljs-keyword">this</span>)&#123;<br>                <span class="hljs-keyword">if</span>(instance==<span class="hljs-keyword">null</span>)&#123;<br>                    instance = <span class="hljs-keyword">new</span> DraconianSingleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-volatile做了什么"><a href="#2-volatile做了什么" class="headerlink" title="2.volatile做了什么"></a>2.volatile做了什么</h2><p>volatile能够禁止上述指令重排的原因是因为它在volatile write操作之前插入了内存屏障，禁止volatile write操作之前任何的read/write操作重排序到volatile write之后。在执行<code>new DraconianSingleton()</code>时，构造函数(构造函数可以会执行写操作，例如写变量的初值)肯定会执行write操作，所以构造函数的write操作一定不会被重排序到volatile write操作之后，从而保证了只会在实例化对象完成后才会<code>instance</code>赋值。</p><p>网上许多文章都说volatile会执行上述的操作禁止指令重排，但是几乎没有人说它为什么这么做。我尝试使用如下代码解释一下我的理解：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">volatile</span> b;<br>write()&#123; <span class="hljs-comment">//thread 1</span><br>    a=<span class="hljs-number">1</span>; <span class="hljs-comment">//opreation 1</span><br>    <span class="hljs-comment">//StoreStore memory barrier</span><br>    b=<span class="hljs-number">2</span>; <span class="hljs-comment">//opreation 2</span><br>    <span class="hljs-comment">//StoreLoad memory barrier</span><br>&#125;<br><br>read()&#123; <span class="hljs-comment">//thread 2</span><br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">2</span>)&#123; <span class="hljs-comment">//opreation 3</span><br>        sout(a);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>根据happens before的程序次序原则，o1 hb o2，那么JMM保证o1的执行结果必须被o2看到。我们可以延伸一下，volatile write之前所有的动作结果都应该在volatile write执行时被看到。所以为了实现这个效果，JMM会在volatile write之前插入StoreStore、StoreLoad内存屏障（这是最笨、最稳妥的办法，具体实现时肯定会有相应的优化。<br>根据happens before的volatile变量规则，o2 hb o3，JMM保证o2（volatile写）的执行结果必须被o3（volatile读）看到。为了实现这个效果，需要借助StoreLoad内存屏障的力量。</p><p><strong>所以volatile做这些工作都是为了实现happens before relation</strong>。内存屏障只是volatile实现happens before的<strong>技术手段</strong>。并且volatile并不会刷新内存，那不是它的责任，刷新内存是内存屏障的作用。</p><hr><p><strong>对于volatile的一些小疑问：</strong></p><p><strong>Q1：对于volatile write(A) hb volatile read(B)，是不是只有A先比B发生，JMM才会使用内存屏障达到B一定能够看到A的效果（即实现 A hb B）。也就是说，如果A没有比B先发生，JMM就不会使用内存屏障实现A hb B了？</strong></p><p>很明显这个表述是有问题的，但是我一直不知道如何否定这个逻辑。经过几天的思考，我给出我的理解：<br>对于volatile write(A) hb volatile read(B)，JMM不管A与B谁先发生，它只管使用内存屏障达到：如果A发生，B就能看到结果的效果（换言之，JMM按照理想情况，A先发生B后发生的情形插入内存屏障）。这样就会有：</p><ul><li>如果A比B先发生，那么就能实现A hb B的效果</li><li>如果B比A先发生，那么虽然插入了内存屏障，但是也没有产生什么负面效果</li></ul><p><strong>Q2：volatile真的禁止重排序了吗？</strong></p><p>我认为volatile并没有这么做，volatile它只是借助内存屏障禁止volatile write之前的任何read/write重排序到volatile write之后，至于那些read/write操作到底如何重排序，volatile并不care</p><hr><h2 id="3-volatile如何使用"><a href="#3-volatile如何使用" class="headerlink" title="3. volatile如何使用"></a>3. volatile如何使用</h2><p>首先我们需要知道volatile只有read/write操作具有原子性，剩余的基于volatile的算数运算并没有原子性。例如：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clac</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>        <span class="hljs-keyword">new</span> Thread()&#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">1000</span>;j++)<br>                    j++;<br>            &#125;;<br>        &#125;.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述<code>j++</code>并不具有原子性。想象以下多线程的场景：</p><p><code>j</code>默认初始化为0。首先thread读取到<code>j=0</code>，然后进行<code>+1</code>操作，但是在将1赋给<code>j</code>之前，时间片用完，所以此时并没有volatile write操作。切换到thread2，thread2读取到的<code>j</code>仍然为0，并且完成了<code>+1</code>的动作。这样在thread2完成之后，其他所有的线程读取到的<code>j</code>肯定都为<code>1</code>。但是thread1此时不需要读取<code>j</code>了，它只会完成最后一步的volatile write动作。出现了线程安全问题。所以说volatile只有read/write操作具有原子性。</p><p>上面出现问题的原因是什么呢？</p><blockquote><p>多个线程都能够修改同一个volatile的值，并且目标修改值依赖volatile变量的前一个值</p></blockquote><p>所以为了避免上述缺陷，volatile的理想使用场景是：</p><ol><li><p>可以有多个线程修改volatile变量，但是修改后的值不应该依赖volatile变量之前的值</p></li><li><p>volatile变量不需要与其他变量构成约束条件（我理解的约束条件是导致控制流发生改变的条件）</p></li></ol><p>规则1很好理解，对于规则2的理解见如下代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//代码摘自：http://kael-aiur.com/java/java%E4%B8%ADvolatile%E5%85%B3%E9%94%AE%E5%AD%97.html</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberRange</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> lower, upper;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLower</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> lower; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getUpper</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> upper; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLower</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123; <br>        <span class="hljs-keyword">if</span> (value &gt; upper) <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(...);<br>        lower = value;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUpper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123; <br>        <span class="hljs-keyword">if</span> (value &lt; lower) <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(...);<br>        upper = value;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在上面的代码中，如果lower与upper初始化为(0,5)。两个线程分别调用<code>setLower</code>和<code>setUpper</code>，将（lower,upper）设置为（4，3），例如调用<code>setLower</code>通过if检查后，让出cpu，<code>setUpper</code>通过if检查后，继续执行，就能够成功将区间设置为（4，3）。这样的区间是没有意义的，之所以会出现这样的错误是因为约束条件为<code>value&gt;upper</code>，<code>volatile</code>与<code>value</code>共同参与了不变约束。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://stackoverflow.com/questions/11639746/what-is-the-point-of-making-the-singleton-instance-volatile-while-using-double-l/11640026#11640026">What is the point of making the singleton instance volatile while using double lock?</a></p></li><li><p><a href="https://stackoverflow.com/questions/51647337/java-volatile-reordering-prevention-scope">Java volatile reordering prevention scope</a></p></li><li><p><a href="https://blog.csdn.net/xdzhouxin/article/details/81236356">volatile为什么不能保证原子性</a></p></li><li><p><a href="https://developpaper.com/memory-barrier-and-its-application-in-jvm-2/">Memory barrier and its application in – JVM (2)</a></p></li><li><p><a href="https://stackoverflow.com/questions/45151763/analyzing-of-x86-output-generated-by-jit-in-the-context-of-volatile">Analyzing of x86 output generated by JIT in the context of volatile</a></p></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">多线程基础</category>
      
      
      <category domain="https://eripe.me/tags/volatile/">volatile</category>
      
      
      <comments>https://eripe.me/articles/volatile-keyword.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>多线程为什么会不安全</title>
      <link>https://eripe.me/articles/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%B8%8D%E5%AE%89%E5%85%A8.html</link>
      <guid>https://eripe.me/articles/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%B8%8D%E5%AE%89%E5%85%A8.html</guid>
      <pubDate>Mon, 30 Aug 2021 16:38:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;在聊多线程为什么不安全之前，需要说一哈学习多线程编程的路线。多线程说到底就是为了提高效率，而这个效率的提高是有安全风险的，这也是多线程为啥这么难的原因。而编写一个多线程的程序可以分为三个部分：分</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>在聊多线程为什么不安全之前，需要说一哈学习多线程编程的路线。多线程说到底就是为了提高效率，而这个效率的提高是有安全风险的，这也是多线程为啥这么难的原因。而编写一个多线程的程序可以分为三个部分：分工、同步、互斥。</p><p>分工更偏向于<strong>设计</strong>，这里是提高性能的关键。相当于项目经理分配任务。与现实世界非常相似, <strong>不过是一个线程执行完了一个任务，如何通知执行后续任务的线程开工而已。</strong> 这里多说一句，计算机里的这个模型那个模型我认为都是为了更好的模拟现实世界。</p><p>而同步是偏向于<strong>实现</strong>，同步就是为了线程之间的更好的有序协作，这与现实世界的分工合作并无不同。线程之间的协作问题都可以认为时：当某个线程不满足条件时，需要怎么样，满足条件了，又怎么样。<strong>在Java并发编程领域，解决协作问题的核心技术是管程</strong>。</p><p>而互斥则是为了<strong>安全</strong>。线程不安全是因为线程之间执行的顺序是不确定的，导致不确定的因素有三点：可见性问题、有序性问题和原子性问题。java引入了JMM(内存模型，一组规则)解决前两个问题，这还不够。还需要解决互斥问题，所谓的互斥就是指<strong>同一时刻，只能有一个线程访问共享变量</strong>。解决互斥的关键还是锁。</p><p>下面贴出一张大佬总结并发学习的思路：</p><p><img src="images/learn-route.png" alt="并发学习架构"></p><p>ok,我们开始进入正题：并发安全的三大问题是：可见性问题、原子性问题、有序性问题。在普通的计算机模型中，cpu通常采用三级缓存，之后才是内存，所以如果有多个核心，它们的一二级缓存是不共享的，但是它们对变量的操作都会在缓存里进行，显而易见，各个核心在自己缓存里的操作是隔离的，别人看不到的，这也就是所谓的可见性问题。</p><p>那么在java中，因为有JMM，堆是共享的，每个线程都有自己的逻辑工作内存，当然这个工作内存也是互不可见的。这就与上面的缓存问题是等价的。那么如果我们想在java中解决可见性，就需要对共享变量加上volatile关键字，注意，<strong>volatile只保证可见性与有序性，不保证原子性</strong>。volatile的工作原理时如果一个线程对共享变量做了改变，那么就会将改变强制刷新到堆中，同理如果有另外的线程想要操作共享变量，只能强制从堆中读取最新的数据。这里还有一点需要注意：<strong>JMM规定，线程的操作只能在自己的工作内存中完成</strong>。</p><p>原子性没啥好解释的。</p><p>有序性就是汇编指令的执行顺序不定，但是保证结果是一样的。</p><p>下面是一个存在线程安全的单例模式：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> Singleton instance;<br>  <span class="hljs-function"><span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)<br>          instance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>问题在于 <code>new Singlrton()</code>的指令重排问题。可能的步骤是先分配内存，然后设置地址引用，最后初始化。如果线程A在设置完地址引用后，时间到了，此时不会释放锁。如果线程B此时才进入第一个if判断，因为已经设置过引用了，会直接返回。此时的对象还未创建后，会出现非法引用的错误。</p><p>在评论区看到一个正确的解答：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySingleton</span> </span>&#123;<br><br>    <span class="hljs-comment">//内部类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySingletonHandler</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> MySingleton instance = <span class="hljs-keyword">new</span> MySingleton();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">MySingleton</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> MySingletonHandler.instance;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><a href="https://blog.csdn.net/mnb65482/article/details/80458571">静态内部类实现的单例模式为什么是线程安全的</a></p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</category>
      
      
      <category domain="https://eripe.me/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">基本概念</category>
      
      
      <comments>https://eripe.me/articles/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%B8%8D%E5%AE%89%E5%85%A8.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ThreadLocal源码解析</title>
      <link>https://eripe.me/articles/threadlocal-analysis.html</link>
      <guid>https://eripe.me/articles/threadlocal-analysis.html</guid>
      <pubDate>Mon, 30 Aug 2021 16:38:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;顾名思义，&lt;code&gt;ThreadLocal&lt;/code&gt;就是基于线程粒度的私有变量，跟我们以往认知中基于函数、类粒度的私有变量不同。而且&lt;code&gt;ThreadLocal&lt;/code&gt;的使用频</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>顾名思义，<code>ThreadLocal</code>就是基于线程粒度的私有变量，跟我们以往认知中基于函数、类粒度的私有变量不同。而且<code>ThreadLocal</code>的使用频率非常高，但是如若使用不当，则可能会发生内存泄漏，所以好好研究一下其实现原理是非常有必要的。内容分为三个部分：<code>ThreadLocalMap</code>是什么，<code>ThreadLocal</code>是如何插入变量的，<code>ThreadLocal</code>是如何删除变量的。</p><h2 id="ThreadLocalMap是什么"><a href="#ThreadLocalMap是什么" class="headerlink" title="ThreadLocalMap是什么"></a><code>ThreadLocalMap</code>是什么</h2><p>在<code>ThreadLocal</code>中，其自己实现了一个名为<code>ThreadLocalMap</code>的静态类，从名字就可以看出，其功能类似于map，用于维护形如&lt;key=<code>ThreadLocal</code>弱引用，value=’Corresponding value’&gt;的键值对，但是它没有用在<code>ThreadLocal</code>中，反而<code>Thread</code>类中维护了一个<code>ThreadLocalMap</code>对象，我认为这是理解<code>ThreadLocal</code>的关键。<code>ThreadLocal</code>中维护的<code>ThreadLocalMap</code>如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    ...<br>    <br>    <span class="hljs-comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="hljs-comment">     * by the ThreadLocal class. */</span><br>    <span class="hljs-comment">// 因为ThreadLocal和Thread处于同一个包，可以直接使用</span><br>    ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * InheritableThreadLocal values pertaining to this thread. This map is</span><br><span class="hljs-comment">     * maintained by the InheritableThreadLocal class.</span><br><span class="hljs-comment">     */</span><br>    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="hljs-keyword">null</span>;<br>    ...<br></code></pre></div></td></tr></table></figure><p><code>ThreadLocal</code>不像网上大部分文章说的，在<code>ThreadLocal</code>中维护了一个HashMap，key为ThreadID，value为对应值。而是通过<code>Thread</code>中的<code>ThreadLocalMap</code>维护多个<code>ThreadLocal</code>对象，每个<code>ThreadLocal</code>对象维护其自己对应的值。</p><p>如果有多个<code>ThreadLocal</code>对象作用于同一个线程A，那么这些<code>ThreadLocal</code>共享线程A的<code>ThreadLocalMap</code>，或者同一个<code>ThreadLocal</code>对象B同时作用于多个线程，例如线程C、D。那么在C、D的<code>ThreadLocalMap</code>会维护两组key相同但值不同的键值对，例如&lt;key=B.hashcode,value=C.value&gt;，&lt;key=B.hashcode,value=D.value&gt;，不会相互干扰。所以<code>ThreadLocalMap</code>才是<code>ThreadLocal</code>的关键，那么<code>ThreadLocalMap</code>到底是如何实现的？先来看看其部分实现源码：</p><figure class="highlight java"><figcaption><span>"ThreadLocalMap"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* ThreadLocalMap is a customized hash map suitable only for</span><br><span class="hljs-comment">* maintaining thread local values. No operations are exported</span><br><span class="hljs-comment">* outside of the ThreadLocal class. The class is package private to</span><br><span class="hljs-comment">* allow declaration of fields in class Thread.  To help deal with</span><br><span class="hljs-comment">* very large and long-lived usages, the hash table entries use</span><br><span class="hljs-comment">* WeakReferences for keys. However, since reference queues are not</span><br><span class="hljs-comment">* used, stale entries are guaranteed to be removed only when</span><br><span class="hljs-comment">* the table starts running out of space.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//静态内部类是可以实例化的哦</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalMap</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;<br>        <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>        Object value;<br><br>        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>            <span class="hljs-keyword">super</span>(k);<br>            value = v;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * TThreadLocalMap的初始容量，必须是2的指数倍</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INITIAL_CAPACITY = <span class="hljs-number">16</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 用于存放Entry的table，长度必须是2的指数倍</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> Entry[] table;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * table的初始大小</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 下一次扩容的阈值</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> threshold; <span class="hljs-comment">// Default to 0</span><br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>跟HashMap类似，ThreadLocalMap也是通过静态内部类<code>Entry</code>来维护键值对，其中key为<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>，value为具体的值。这里存在一个问题：为何使用要使用弱引用？用意何在？这个问题先留着，后续再讨论。从上面的代码我们可以看出，<code>ThreadLocalMap</code>通过数组<code>table</code>来维护插入的键值对，并且同样的，数组大小必须是2的次方，这里的理由与hashMap容量必须是2的整数幂一样。</p><h2 id="ThreadLocal的插入操作"><a href="#ThreadLocal的插入操作" class="headerlink" title="ThreadLocal的插入操作"></a>ThreadLocal的插入操作</h2><p>我们一般使用<code>ThreadLocal</code>的<code>set(T)</code>方法进行插入操作：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    Thread t = Thread.currentThread();<br>    <span class="hljs-comment">//首先获取当前线程内部的ThreadLocalMap</span><br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-comment">// 如果map为空，说明当前线程中的ThreadLocalMap还未创建</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)<br>        map.set(<span class="hljs-keyword">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;<br><br><span class="hljs-comment">//getMap的实现原理也非常简单，直接返回线程的内部变量</span><br><span class="hljs-function">ThreadLocalMap <span class="hljs-title">getMap</span><span class="hljs-params">(Thread t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从上面代码我们能够得知：往<code>ThreadLocal</code>中插入元素的第一步就是获取当前线程内部的<code>ThreadLocalMap</code>。如果map已经存在，则直接调用<code>set(ThreadLocal&lt;?&gt;, Object)</code>存储值。否则调用<code>createMap(Thread, Object)</code>创建map并存储。我们先来分析<code>createMap</code>:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>&#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>createMap</code>的逻辑很简单，就是调用<code>ThreadLocalMap</code>的构造函数生成对象后，赋值给当前线程的<code>threadLocals</code>变量。</p><figure class="highlight java"><figcaption><span>"constructor method"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br>ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>    table = <span class="hljs-keyword">new</span> Entry[INITIAL_CAPACITY];<br>    <span class="hljs-keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//我们先分析前两句，注释的部分先不看</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    table[i] = new Entry(firstKey, firstValue);</span><br><span class="hljs-comment">    size = 1;</span><br><span class="hljs-comment">    setThreshold(INITIAL_CAPACITY);</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这个构造函数，会首先初始化table，然后利用当前<code>Threadlocal</code>对象的hash值计算索引。首先这句代码就会产生两个问题：<code>ThreadLocal</code>对象的hash值是如何产生的？索引计算为何使用<code>&amp;</code>运算符？</p><h3 id="ThreadLocal的hash值计算原理"><a href="#ThreadLocal的hash值计算原理" class="headerlink" title="ThreadLocal的hash值计算原理"></a>ThreadLocal的hash值计算原理</h3><p>对于第一个问题，首先我们需要知道，<code>ThreadLocal</code>对象的hash值是在<code>new</code>的时候就构造好了。hash值构造方法如下所示：</p><figure class="highlight java"><figcaption><span>"ThreadLocal哈希码生成部分"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocal</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    ...<br>    <br>    <span class="hljs-comment">//每次生成ThreadLocal对象时会自动调用nextHashCode</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threadLocalHashCode = nextHashCode();<br><br>    <span class="hljs-comment">//静态变量，第一次加载该类时threadLocalHashCode会被初始化为0</span><br>    <span class="hljs-comment">//随后每生成一个ThreadLocal对象，nextHashCode的值都为上一个ThreadLocal对象的HashCode</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicInteger nextHashCode =<br>        <span class="hljs-keyword">new</span> AtomicInteger();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The difference between successively generated hash codes - turns</span><br><span class="hljs-comment">     * implicit sequential thread-local IDs into near-optimally spread</span><br><span class="hljs-comment">     * multiplicative hash values for power-of-two-sized tables.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HASH_INCREMENT = <span class="hljs-number">0x61c88647</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextHashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>    &#125;<br>    ...<br></code></pre></div></td></tr></table></figure><p><code>threadLocalHashCode</code>是通过<code>nextHashCode()</code>完成计算的，而在<code>nextHashCode()</code>中，它会将<code>nextHashCode</code>加上<code>HASH_INCREMENT</code>，并返回原始的<code>nextHashCode</code>。<code>nextHashCode</code>是一个静态变量，被所有<code>ThreadLocal</code>对象共享。所以每当有新的<code>ThreadLocal</code>对象生成时，就会使用上一个<code>ThreadLocal</code>改变的<code>nextHashCode</code>。至于为什么<code>nextHashCode</code>的增量<code>HASH_INCREMENT</code>是魔数<code>0x61c88647</code>，理由是计算出的hash值足够离散，能够均匀地分布在<code>table</code>数组中。</p><p>对于第二个问题：使用<code>&amp;</code>计算索引是因为如果n是2的整数次幂，那么则有<code>hash % n == (n-1)&amp; hash</code>，这样做是为了加速运算。</p><p>了解了如何计算<code>ThreadLocal</code>对象的hash值后，我们的视角回到<code>ThreadLocalMap</code>的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    table = new Entry[INITIAL_CAPACITY];</span><br><span class="hljs-comment">    int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="hljs-comment">    */</span><br>    table[i] = <span class="hljs-keyword">new</span> Entry(firstKey, firstValue);<br>    size = <span class="hljs-number">1</span>;<br>    setThreshold(INITIAL_CAPACITY);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在<code>table</code>中安置好新加入的entry后，则会调用<code>setThreshold</code>设置扩容阈值，阈值大小为<code>table</code>容量的<strong>2/3</strong>，而不是HashMap的3/4。</p><h3 id="set-方法原理"><a href="#set-方法原理" class="headerlink" title="set()方法原理"></a>set()方法原理</h3><p>那么如果线程的<code>ThreadLocalMap</code>已经构造好了，添加元素是怎么样一个过程呢？来看看私有的<code>set(ThreadLocal&lt;?&gt;, Object)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;<br>    <span class="hljs-comment">// 我们不像get()那样使用哈希值快速查找Entry</span><br>    <span class="hljs-comment">// 因为使用set()创建新条目和替换现有条目至少是一样普遍的</span><br>    <span class="hljs-comment">// 在这种情况下，使用哈希值失败的可能性通常会更高</span><br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    <span class="hljs-comment">// 计算ThreadLocal对象的索引</span><br>    <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 遍历table，这里一定会找到一个Entry==null的索引</span><br>    <span class="hljs-comment">// 因为有提前扩容机制，不可能把table填满</span><br>    <span class="hljs-keyword">for</span> (Entry e = tab[i];<br>            e != <span class="hljs-keyword">null</span>;<br>            e = tab[i = nextIndex(i, len)]) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//找到一个失效的Entry</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//stale是陈旧的意思</span><br>            replaceStaleEntry(key, value, i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    tab[i] = <span class="hljs-keyword">new</span> Entry(key, value);<br>    <span class="hljs-keyword">int</span> sz = ++size;<br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在<code>set(ThreadLocal&lt;?&gt;, Object)</code>中，首先会计算当前<code>ThreadLocal</code>对象的索引<code>i</code>，然后使用<code>for</code>循环从<code>i</code>之后遍历<code>table</code>数组，直到找到一个空的位置，for循环调用了<code>nextIndex(int,int)</code>进行变量自增，那么<code>nextIndex</code>做了什么？看看它的实现代码：</p><figure class="highlight java"><figcaption><span>"nextIndex"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ((i + <span class="hljs-number">1</span> &lt; len) ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>含义很简单，就是从索引<code>i</code>开始计算下一个位置，如果已经<code>i</code>已经到达尾部，那么循环到头部开始。所以可以把<code>ThreadLocalMap</code>中的<code>table</code>当作一个环形数组，如下图所示：</p><p><img src="images/circular-ThreadLocalMap.drawio.svg" alt="table"></p><p><code>set(ThreadLocal&lt;?&gt;, Object)</code>的for循环含义很简单：</p><ol><li>如果当前<code>ThreadLocal</code>对象已经在<code>table</code>中，那么就更新其对应的value</li><li>如果找到了一个无效Entry，那么就会从当前Entry开始，调用<code>replaceStaleEntry(ThreadLocal&lt;?&gt;,Object,int)</code></li><li>尝试在table中找到我们的目标Entry，并将目标Entry和无效Entry交换，然后进行一些清除无效Entry的操作。replaceStaleEntry的实现源码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* @param  key the key</span><br><span class="hljs-comment">* @param  value key对应的value</span><br><span class="hljs-comment">* @param  staleSlot 当前Entry的key==null的索引，表示这个Entry是需要被清除的</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">replaceStaleEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-keyword">int</span> staleSlot)</span> </span>&#123;<br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    Entry e;<br>    <br>    <span class="hljs-comment">// slotToExpunge表示的含义是从当前索引值开始清理无效Entry</span><br>    <span class="hljs-comment">// 做法是从staleSlot开始向前，也就histaleSlot的左边，找到最远离staleSlot的，Entry不为空的，但是Entry.weakReference==null的Entry索引</span><br>    <span class="hljs-comment">// 如果在遇到空Entry之前，还未找到失效的Entry，那么slotToExpunge将会等于staleSlot</span><br>    <span class="hljs-keyword">int</span> slotToExpunge = staleSlot;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = prevIndex(staleSlot, len);<br>            (e = tab[i]) != <span class="hljs-keyword">null</span>;<br>            i = prevIndex(i, len))<br>        <span class="hljs-keyword">if</span> (e.get() == <span class="hljs-keyword">null</span>)<br>            slotToExpunge = i;<br><br>    <span class="hljs-comment">//从staleSlot开始向后遍历，直到遇到空Entry为止</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nextIndex(staleSlot, len);<br>            (e = tab[i]) != <span class="hljs-keyword">null</span>;<br>            i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br><br>        <span class="hljs-comment">//如果找到了我们的目标Entry的索引i</span><br>        <span class="hljs-comment">//那么就将索引staleSlot和i表示的Entry相互相互</span><br>        <span class="hljs-comment">//交换之后，索引i表示的Entry就失效了</span><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-comment">//交换Entry</span><br>            tab[i] = tab[staleSlot];<br>            tab[staleSlot] = e;<br><br>            <span class="hljs-comment">//如果在第一个for循环中没有找到失效的Entry，那么下面的if条件就会成立</span><br>            <span class="hljs-comment">//因为i现在表示的失效Entry索引，所以就将slotToExpunge设为i</span><br>            <span class="hljs-keyword">if</span> (slotToExpunge == staleSlot)<br>                slotToExpunge = i;<br>            <span class="hljs-comment">//然后开始使用两种方法清理无效Entry</span><br>            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果还未找到目标Entry，所以尝试找到staleSlot右边最近的失效Entry</span><br>        <span class="hljs-comment">// 因为我们是从staleSlot开始向后遍历，还是有可能遇到Entry.weakReference==null的情况</span><br>        <span class="hljs-comment">// 这个if只可能执行一次，表示staleSlot左边最远没有失效的Entry，只找到了右边最近的失效Entry</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)<br>            slotToExpunge = i;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果在table根本就不存在key</span><br>    <span class="hljs-comment">// 那么直接在当前失效Entry的槽位上新建Entry</span><br>    <span class="hljs-comment">// 在新建之前，会将原来Entry的value设为null，这是为了防止内存泄漏</span><br>    tab[staleSlot].value = <span class="hljs-keyword">null</span>;<br>    tab[staleSlot] = <span class="hljs-keyword">new</span> Entry(key, value);<br><br>    <span class="hljs-comment">// 如果存在失效Entry但是索引不是staleSlot，那么就从slotToExpunge开始清除无效Entry</span><br>    <span class="hljs-keyword">if</span> (slotToExpunge != staleSlot)<br>        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>replaceStaleEntry</code>函数的主要思想就是：</p><ol><li>如果在<code>table</code>中找到了目标Entry的索引<code>i</code>，那么就将我们索引<code>staleSlot</code>和<code>i</code>对应的Entry交换</li><li>如果在<code>table</code>中没有找到目标Entry，那么就直接在索引<code>staleSlot</code>对应的槽位构建新的Entry</li><li>期望在当前<code>staleSlot</code>的最远左边或者最近右边找到一个失效Entry以便最大化清除失效Entry的效果，具体的清除原理我们放到<code>ThreadLocal</code>删除操作一节中讲解。</li></ol><p>现在我们的视角回到<code>set(ThreadLocal&lt;?&gt;, Object)</code>:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;<br>    <span class="hljs-comment">// 我们不像get()那样使用哈希值快速查找Entry</span><br>    <span class="hljs-comment">// 因为使用set()创建新条目和替换现有条目至少是一样普遍的</span><br>    <span class="hljs-comment">// 在这种情况下，使用哈希值失败的可能性通常会更高</span><br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    <span class="hljs-comment">// 计算ThreadLocal对象的索引</span><br>    <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 遍历table，这里一定会找到一个Entry==null的索引</span><br>    <span class="hljs-comment">// 因为有提前扩容机制，不可能把table填满</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    for (Entry e = tab[i];</span><br><span class="hljs-comment">            e != null;</span><br><span class="hljs-comment">            e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="hljs-comment">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        if (k == key) &#123;</span><br><span class="hljs-comment">            e.value = value;</span><br><span class="hljs-comment">            return;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        //找到一个失效的Entry</span><br><span class="hljs-comment">        if (k == null) &#123;</span><br><span class="hljs-comment">            replaceStaleEntry(key, value, i);</span><br><span class="hljs-comment">            return;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br><br>    tab[i] = <span class="hljs-keyword">new</span> Entry(key, value);<br>    <span class="hljs-keyword">int</span> sz = ++size;<br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果在set中在找到空槽位之前没有找到目标Entry或者失效Entry，那么就会直接在空槽位上构建Entry对象。新构建之后第一步需要考虑的就是扩容问题。这个问题由<code>rehash</code>来解决。当然扩容也是有条件的：需要在调用<code>cleanSomeSlots</code>进行一波清理操作后，<code>table</code>内的Entry个数仍然大于扩容阈值才会调用<code>rehash</code>。<code>rehash</code>的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rehash</span><span class="hljs-params">()</span> </span>&#123;<br>    expungeStaleEntries();<br><br>    <span class="hljs-comment">// Use lower threshold for doubling to avoid hysteresis</span><br>    <span class="hljs-keyword">if</span> (size &gt;= threshold - threshold / <span class="hljs-number">4</span>)<br>        resize();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">expungeStaleEntries</span><span class="hljs-params">()</span> </span>&#123;<br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>        Entry e = tab[j];<br>        <span class="hljs-comment">//找到每个失效Entry，并对每个失效Entry调用expungeStaleEntry实施清除操作</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span> &amp;&amp; e.get() == <span class="hljs-keyword">null</span>)<br>            expungeStaleEntry(j);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>rehash</code>内部又会调用<code>expungeStaleEntries()</code>进行一波清理操作，如果<code>table</code>内的<code>Entry</code>数量仍然大于等于<code>table</code>容量得1/2(计算公式：threshold*2/3*capacity*3/4)，才会真正调用调用<code>resize()</code>进行扩容。所以这里有一个小点我们容易忽略：<strong>并不是table中的Entry数量大于等于容量的2/3就会进行扩容，而是在进行两类清除操作之后，Entry数量仍然大于等于容量的1/2，才会进行扩容</strong>。具体扩容的原理就很简单，简单的扩容<strong>两倍</strong>并复制了Entry。</p><h2 id="ThreadLocal的删除操作"><a href="#ThreadLocal的删除操作" class="headerlink" title="ThreadLocal的删除操作"></a>ThreadLocal的删除操作</h2><p>在插入操作的<code>set(ThreadLocal&lt;?&gt;, Object)</code>函数中，我们不止一次提到了两种清除操作:<code>cleanSomeSlots(int,int)</code>和<code>expungeStaleEntry(j)</code>，那么这两种清除操作最大的区别就是前者为<strong>启发式</strong>清除操作，后者为<strong>线性</strong>清除操作，为何这么说？首先来看看<code>cleanSomeSlots(int,int)</code>的实现代码：</p><figure class="highlight java"><figcaption><span>"启发式清除操作"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//参数i表示当前Entry必有效的索引，所以清除要从下一个index开始</span><br><span class="hljs-comment">//参数n表示清除操作的执行次数</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">cleanSomeSlots</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> removed = <span class="hljs-keyword">false</span>;<br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    <span class="hljs-keyword">do</span> &#123;<br>        i = nextIndex(i, len);<br>        Entry e = tab[i];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span> &amp;&amp; e.get() == <span class="hljs-keyword">null</span>) &#123;<br>            n = len;<br>            removed = <span class="hljs-keyword">true</span>;<br>            i = expungeStaleEntry(i);<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> ( (n &gt;&gt;&gt;= <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> removed;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>根据代码<code>n&gt;&gt;&gt;=1</code>可知，<code>cleanSomeSlots</code>总共会执行log2(n)次操作，而每次操作时会尝试找到失效Entry，然后从失效Entry的索引开始，调用<code>expungeStaleEntry</code>进行线程清除操作，来看看其实现源码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 参数staleSlot表示失效Entry的索引</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> staleSlot)</span> </span>&#123;<br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br><br>    <span class="hljs-comment">// 将value置为空，避免内存泄漏</span><br>    tab[staleSlot].value = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 将失效Entry移出</span><br>    tab[staleSlot] = <span class="hljs-keyword">null</span>;<br>    size--;<br><br>    <span class="hljs-comment">// Rehash until we encounter null</span><br>    Entry e;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-comment">//从staleSlot开始遍历table，直到遇到空槽位</span><br>    <span class="hljs-comment">//所以是一个线程清除操作</span><br>    <span class="hljs-keyword">for</span> (i = nextIndex(staleSlot, len);<br>            (e = tab[i]) != <span class="hljs-keyword">null</span>;<br>            i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-comment">//遇到失效Entry，进行移出操作</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span>) &#123;<br>            e.value = <span class="hljs-keyword">null</span>;<br>            tab[i] = <span class="hljs-keyword">null</span>;<br>            size--;<br>        &#125;<br>        <span class="hljs-comment">//遇到正常的Entry，那么就尝试重新计算索引</span><br>        <span class="hljs-comment">//因为在此之前这个Entry是因为哈希冲突才来到当前位置的</span><br>        <span class="hljs-comment">// 这么做的目的是让Entry更接近它的理想位置h</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (h != i) &#123;<br>                tab[i] = <span class="hljs-keyword">null</span>;<br><br>                <br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                * 以下解析摘自参考文章[1]</span><br><span class="hljs-comment">                * 在原代码的这里有句注释值得一提，原注释如下：</span><br><span class="hljs-comment">                *</span><br><span class="hljs-comment">                * Unlike Knuth 6.4 Algorithm R, we must scan until</span><br><span class="hljs-comment">                * null because multiple entries could have been stale.</span><br><span class="hljs-comment">                *</span><br><span class="hljs-comment">                * 这段话提及了Knuth高德纳的著作TAOCP（《计算机程序设计艺术》）的6.4章节（散列）</span><br><span class="hljs-comment">                * 中的R算法。R算法描述了如何从使用线性探测的散列表中删除一个元素。</span><br><span class="hljs-comment">                * R算法维护了一个上次删除元素的index，当在非空连续段中扫到某个entry的哈希值取模后的索引</span><br><span class="hljs-comment">                * 还没有遍历到时，会将该entry挪到index那个位置，并更新当前位置为新的index，</span><br><span class="hljs-comment">                * 继续向后扫描直到遇到空的entry。</span><br><span class="hljs-comment">                *</span><br><span class="hljs-comment">                * ThreadLocalMap因为使用了弱引用，所以其实每个slot的状态有三种也即</span><br><span class="hljs-comment">                * 有效（value未回收），无效（value已回收），空（entry==null）。</span><br><span class="hljs-comment">                * 正是因为ThreadLocalMap的entry有三种状态，所以不能完全套高德纳原书的R算法。</span><br><span class="hljs-comment">                *</span><br><span class="hljs-comment">                * 因为expungeStaleEntry函数在扫描过程中还会对无效slot清理将之转为空slot，</span><br><span class="hljs-comment">                * 如果直接套用R算法，可能会出现具有相同哈希值的entry之间断开（中间有空entry）。</span><br><span class="hljs-comment">                */</span><br>                <span class="hljs-comment">//从h之后线性探测一个空槽位</span><br>                <span class="hljs-keyword">while</span> (tab[h] != <span class="hljs-keyword">null</span>)<br>                    h = nextIndex(h, len);<br>                tab[h] = e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>线性操作的原理比较简单：</p><ol><li>如果遇到了失效Entry，就将其移除</li><li>如果遇到了正常Entry，那么就对其进行冲哈希定位，目的是尽可能地将当前Entry放在它应该在的位置上</li><li>如果遇到了空槽位，那么就直接返回当前空槽位的索引</li></ol><p>在了解了两种清除操作之后，再去看<code>ThreadLocal</code>的移出操作就非常简单了，我们一般都会调用<code>remove</code>进行移出，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 即使没有在ThreadLocal中存入值，也可以调用remove方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>    ThreadLocalMap m = getMap(Thread.currentThread());<br>    <span class="hljs-keyword">if</span> (m != <span class="hljs-keyword">null</span>)<br>        m.remove(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 寻找目标Entry进行移出，并会顺带调用expungeStaleEntry进行线性清除</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;<br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (Entry e = tab[i];<br>            e != <span class="hljs-keyword">null</span>;<br>            e = tab[i = nextIndex(i, len)]) &#123;<br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;<br>            e.clear();<br>            expungeStaleEntry(i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>所以经过以上学习，我们可以总结出：</p><ol><li>启发式清除操作会在<code>set(ThreadLocal&lt;?&gt;, Object)</code>中的两个地方被调用：<ul><li>table中存在目标Entry，那么就从找到的失效Entry开始启发式清除</li><li>table中不存在目标Entry，那么就从新插入的Entry开始启发式清除</li></ul></li><li>线性清除操作出现的地方比较多：<ul><li>在启发式清除中会开始线性清除</li><li>在<code>replaceStaleEntry</code>中，会先进行线性清除，之后进行启发式清除</li></ul></li></ol><h3 id="ThreadLocal中的内存泄漏问题"><a href="#ThreadLocal中的内存泄漏问题" class="headerlink" title="ThreadLocal中的内存泄漏问题"></a>ThreadLocal中的内存泄漏问题</h3><p>在前面我们曾提出了一个问题，为什么要对<code>ThreadLocal</code>使用弱引用，首先我们需要直到什么是弱引用：</p><blockquote><p>使用WeakReference修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收</p></blockquote><p>也就是说，当一个对象只存在弱引用时，无论内存空间是否足够，都会将其回收。那么试想如下一个场景：</p><p>如果对于一个<code>ThreadLocal</code>对象引用<code>a=new ThreadLocal&lt;&gt;()</code>，当我们不再需要这个<code>ThreadLocal</code>对象时，那么就会将<code>a</code>设为null。但是曾经使用过该<code>ThreadLocal</code>对象的线程A内部的<code>ThreadLocalMap</code>仍然持有该<code>ThreadLocal</code>对象的引用，所以如果不使用虚引用，那么否则直到线程A死亡，该<code>ThreadLocal</code>对象都不会被回收。当线程A运行时间特别长时，可能由于<code>ThreadLocal</code>对象无法被回收的问题，可能内存空间会越来越小。</p><p>所以这种类型的内存泄漏已经被大牛们解决了。那么我们常说的ThreadLocal内存泄漏是什么呢？</p><p>不知大家是否还记得<code>Entry</code>的结构，其内部属性<code>value</code>仍然是一个强引用，就会出现key无效但是value有效的<code>Entry</code>对象，导致<code>Entry</code>对象仍然无法会回收。所以虽然在调用<code>set</code>方法时，大概率会将无效<code>Entry</code>对象清除，但这种清除并不是百分百生效的。所以当我们不在需要一个<code>ThreadLocal</code>对象时，最后手动调用<code>remove</code>方法清除无效Entry，防止内存泄漏。</p><h2 id="ThreadLocal的获取操作"><a href="#ThreadLocal的获取操作" class="headerlink" title="ThreadLocal的获取操作"></a>ThreadLocal的获取操作</h2><p>实现获取操作的<code>get()</code>方法很简单，如下所示：</p><figure class="highlight java"><figcaption><span>"get()实现源码"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    Thread t = Thread.currentThread();<br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;<br>        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            T result = (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果没有存入value，那么则会初始化默认value并返回</span><br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="InheritableThreadLocal原理"><a href="#InheritableThreadLocal原理" class="headerlink" title="InheritableThreadLocal原理"></a>InheritableThreadLocal原理</h2><p>除了<code>ThreadLocal</code>，还有一种用于实现父子线程数据共享的<code>ThreadLocal</code>:<code>InheritableThreadLocal</code>，它的具体实现是在Thread类中除了threadLocals外还有一个inheritableThreadLocals对象。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="hljs-comment">     * by the ThreadLocal class. */</span><br>    ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * InheritableThreadLocal values pertaining to this thread. This map is</span><br><span class="hljs-comment">     * maintained by the InheritableThreadLocal class.</span><br><span class="hljs-comment">     */</span><br>    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="hljs-keyword">null</span>;<br></code></pre></div></td></tr></table></figure><p>在线程对象初始化的时候，会调用ThreadLocal的createInheritedMap从父线程的inheritableThreadLocals中把有效的entry都拷过来，做的事情就是以父线程的inheritableThreadLocalMap为数据源，过滤出有效的entry，初始化到自己的inheritableThreadLocalMap中。其中childValue可以被重写。需要注意的地方是InheritableThreadLocal只是在子线程创建的时候会去拷一份父线程的inheritableThreadLocals。如果父线程是在子线程创建后再set某个InheritableThreadLocal对象的值，对子线程是不可见的。</p><h2 id="ThreadLocal的基本使用"><a href="#ThreadLocal的基本使用" class="headerlink" title="ThreadLocal的基本使用"></a>ThreadLocal的基本使用</h2><p>下面是一个在线程中简单使用<code>ThreadLocal</code>的例子：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalExample1</span> </span>&#123;<br><br>    <span class="hljs-comment">// (1) 创建ThreadLocal变量</span><br>    <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; localVariable = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br><br>    <span class="hljs-comment">// (2)print函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str)</span></span>&#123;<br>        <span class="hljs-comment">// 打印当前线程本地内存中localVariable变量的值</span><br>        System.out.println(str + <span class="hljs-string">&quot;:&quot;</span> + localVariable.get());<br>        <span class="hljs-comment">// 2.1 清楚当前线程本地内存变量</span><br><span class="hljs-comment">//        localVariable.remove();</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">// (3) 创建线程one</span><br>        Thread threadOne = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">// 设置threadOne中的本地变量localVariable的值</span><br>                localVariable.set(<span class="hljs-string">&quot;threadOne local variable&quot;</span>);<br>                <span class="hljs-comment">// 调用打印函数</span><br>                print(<span class="hljs-string">&quot;threadOne&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;threadOne remove after&quot;</span> + localVariable.get());<br>            &#125;<br>        &#125;);<br><br><br>        <span class="hljs-comment">// 创建线程two</span><br>        Thread threadTwo = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">// 设置threadTwo线程中的本地线程变量</span><br>                localVariable.set(<span class="hljs-string">&quot;threadTwo local variable&quot;</span>);<br>                <span class="hljs-comment">// 调用打印函数</span><br>                print(<span class="hljs-string">&quot;threadTwo&quot;</span>);<br>                <span class="hljs-comment">// 打印本地线程变量</span><br>                System.out.println(<span class="hljs-string">&quot;threadTwo remove after&quot;</span> + <span class="hljs-string">&quot;:&quot;</span> + localVariable.get());<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// (5)启动线程</span><br>        threadOne.start();<br>        threadTwo.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以如果想要在每个线程都维护一个线程级的变量，那么只需要一个<code>ThreadLocal</code>对象即可，如果想要为一个线程维护多个线程级的私有变量，那么就需要多个<code>ThreadLocal</code>对象。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://www.cnblogs.com/micrari/p/6790229.html">ThreadLocal源码解读</a></li></ol><p>2.<a href="https://segmentfault.com/a/1190000022663697">面试官：小伙子，听说你看过ThreadLocal源码？</a></p><p>3.<a href="https://zhuanlan.zhihu.com/p/88133406">面试官连环炮轰炸的ThreadLocal 吃透源码的每一个细节和设计原理</a></p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">多线程基础</category>
      
      
      <category domain="https://eripe.me/tags/ThreadLocal/">ThreadLocal</category>
      
      
      <comments>https://eripe.me/articles/threadlocal-analysis.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>多线程基础</title>
      <link>https://eripe.me/articles/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.html</link>
      <guid>https://eripe.me/articles/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.html</guid>
      <pubDate>Mon, 30 Aug 2021 16:38:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;多进程是为了提高CPU效率，而多线程是为了提高程序使用率？我咋感觉不对啊，多线程通信方便，资源浪费小。并且多线程能不能提高效率得看是什么任务。&lt;/p&gt;
&lt;p&gt;总而言之：&lt;strong&gt;多进程为操</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>多进程是为了提高CPU效率，而多线程是为了提高程序使用率？我咋感觉不对啊，多线程通信方便，资源浪费小。并且多线程能不能提高效率得看是什么任务。</p><p>总而言之：<strong>多进程为操作系统提供了并发的可能，多进程为单个程序提供了并发的能力</strong>。</p><p>简而言之：多线程就是程序内部有多条执行路径，这句话至少我认为是没有错的。</p><p>并且并发是在某一时间段同时发生，<strong>并行</strong>是在某一<strong>时间点</strong>同时发生。不要记混了。所以记住java搞高并发就不会错了。</p><p>在java中，启动一个java程序，也就是启动一个JVM进程，然后进程会自动运行一个<strong>主线程</strong>来调用某个类的main方法。</p><blockquote><p>那么JVM的启动是单线程的还是多线程的？</p></blockquote><p>是多线程的，因为至少会启动一个gc线程和主线程。</p><h3 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h3><p>在java中，实现多线程的方法主要就分为三种，一种是继承Thread类，override它的run方法，第二种就是实现Runnable接口下的run方法。或者实现Callable<V>下的run方法。</p><h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><p>这是第一种实现多线程方式。</p><ol><li>首先我们需要自定义类并继承自Thread类</li><li>重写<code>run()</code>方法：因为<strong>不是类中的所有代码都需要被线程执行</strong>，所以为了区别哪些代码被线程执行，java提供了<code>run()</code>来包含那些需要被线程执行的代码。</li><li>创建对象</li><li>启动线程：如果直接使用<code>run()</code>启动线程，那么就相当直接调用线程，也就是只实现了单线程效果。</li></ol><blockquote><p>run()与start()有什么区别？</p></blockquote><p>run()仅仅是封装了需要执行的代码，直接调用就相当于调用普通方法。而<code>start()</code>是启动了线程，使线程处于就绪状态，然后再由JVM调用线程的<code>run()</code>方法。</p><blockquote><p>如何获取与设置线程的名称？</p></blockquote><p>很简单，调用线程的<code>getName()</code>与<code>setName()</code>即可。或者直接在构造线程对象时设置名称。</p><figure class="highlight java"><figcaption><span>"多线程入门栗子"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-comment">//super.run();</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;++i) &#123;<br>            System.out.println(getName()+<span class="hljs-string">&quot;:&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    MyThread my=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;tom&quot;</span>);<br>    my.start();<br>    MyThread my1=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;bob&quot;</span>);<br>    my1.start();<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>调用自己写的线程子类很容易获取名称。但是如何获取不是我们自定义的线程的名称呢？例如main线程？</p></blockquote><p>很简单，调用Thread类的静态方法：<code>public static Thread currentThread()</code>获得当前线程的引用。然后在调用该线程的<code>getName()</code>即可。在哪个线程里调<code>currentThread()</code>，就是获得了哪个线程的Thread对象引用。</p><h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><ol><li>自定义类实现Runnable接口，<code>Runnable</code>接口只有一个抽象方法<code>run</code>，无法取消</li><li>实现<code>run()</code>方法</li><li>创建MyRunnable对象</li><li>创建Thread对象并将第三步的对象作为参数传进去</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">500</span>;++i) &#123;<br>            System.out.println(Thread.currentThread().getName()+i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    MyRunnable my=<span class="hljs-keyword">new</span> MyRunnable();<br>    Thread t1=<span class="hljs-keyword">new</span> Thread(my,<span class="hljs-string">&quot;tom&quot;</span>);<br>    Thread t2=<span class="hljs-keyword">new</span> Thread(my,<span class="hljs-string">&quot;candy&quot;</span>);<br>    t1.start();<br>    t2.start();<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="实现callable接口"><a href="#实现callable接口" class="headerlink" title="实现callable接口"></a>实现callable接口</h4><p>这种实现多线程的方式必须配合线程池使用。这种方式与实现Runnable接口的区别就是这种方法可以返回一个值。由泛型指定类型。调用<code>submit()</code>后会返回一个Future，可以通过Future的<code>get()</code>方法获得返回值，但是该方法会阻塞当前线程，直到得到结果。下面是一个使用的栗子：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mycallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Mycallable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>        <span class="hljs-keyword">this</span>.num = num;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++) &#123;<br>            sum+=i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    ExecutorService pool=Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>    Future&lt;Integer&gt; f1=pool.submit(<span class="hljs-keyword">new</span> Mycallable(<span class="hljs-number">50</span>));<br>    Future&lt;Integer&gt; f2=pool.submit(<span class="hljs-keyword">new</span> Mycallable(<span class="hljs-number">100</span>));<br>    <span class="hljs-keyword">try</span> &#123;<br>        System.out.println(f1.get()+f2.get());<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-comment">// TODO Auto-generated catch block</span><br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>        <span class="hljs-comment">// TODO Auto-generated catch block</span><br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        pool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面提到了Future，这是个啥？其实它是一个接口，它只有五个非常简单的方法。</p><figure class="highlight java"><figcaption><span>"Future接口"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">cancel</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> mayInterruptIfRunning)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCancelled</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;<br><br>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>cancel()</code>表示<strong>试图</strong>取消当前线程的执行，但注意仅仅是试图，到底能不能取消还不知道，因为当前线程或许已经执行完了，或者已经取消了，或者一些其他不可控的因素。唯一的参数表示是否以中断的方式取消。</p><blockquote><p>所以有时候，为了让任务有能够取消的功能，就使用Callable来代替Runnable。如果为了可取消性而使用 Future但又不提供可用的结果，则可以声明 Future&lt;?&gt;形式类型、并返回 null作为底层任务的结果。<a href="http://concurrent.redspider.group/article/01/2.html">参考</a>。</p></blockquote><p>但是自定义Future接口中的<code>cancel</code>、<code>get</code>方法又非常困难，所以jdk为我们提供了一个Future的实现类<code>FutureTask</code>类。<code>FutureTask</code>实现了<code>RunnableFuture&lt;V&gt;</code>接口，而<code>RunnableFuture&lt;V&gt;</code>又继承了<code>Runnable</code>与<code>Future&lt;V&gt;</code>接口。</p><figure class="highlight java"><figcaption><span>"FutureTask简单使用"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService service= Executors.newCachedThreadPool();<br>        FutureTask&lt;Integer&gt; futureTask=<span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> CreateThread3());<br>        service.submit(futureTask);<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(futureTask.get());<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面使用线程池<code>submit()</code>提交一个FutureTask实例后，并不像提交Callable的实例后，有一个返回值。并且获取返回值的时候是直接通过FutureTask的实例获取。这里的submit原型为<code>submit(Runnable task)</code>，因为FutureTask就是Runnable接口的实现类。提交Callable的函数原型为<code>submit(Callable&lt;V&gt; task)</code>。</p><h4 id="java中实现线程的方式到底有几个？"><a href="#java中实现线程的方式到底有几个？" class="headerlink" title="java中实现线程的方式到底有几个？"></a>java中实现线程的方式到底有几个？</h4><p>这是一个值得思考的问题。上面我们看到定义一个线程的方法主要有三种。</p><p>第一种就是实现<code>Runnable</code>run方法。这种方式是怎么执行我们定义的线程代码的？源码给出了答案：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span>) &#123;<br>            target.run();<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>虚拟机会调用Thread实例的run方法执行线程代码，而在run方法中，又会调用target的<code>run()</code>方法，这个target就是我们传进去的RUnnable实例。</p><p>第二种就是继承Thread类，重写Thread的类的run方法。那么运行时会调用该实例重写的<code>run</code>方法。</p><p>第三种就是实现Callable接口的run方法，然后提交到线程池中。注意线程池中的线程是怎么来的？还是通过new一个Thread来实现的。</p><blockquote><p>无论是 Callable 还是 FutureTask，它们首先和 Runnable 一样，都是一个任务，是需要被执行的，而不是说它们本身就是线程。它们可以放到线程池中执行，如代码所示， submit() 方法把任务放到线程池中，并由线程池创建线程，不管用什么方法，最终都是靠线程来执行的。线程池里的线程还是new Thread创建出来的。</p></blockquote><p>所以说创建线程的方式就一种：<strong>创建一个Thread实例</strong>，而定义线程执行的内容有两种，实现Runnable、Callable等的run方法，或者重写Thread类的run方法。</p><p>那么我们应该选取哪种方式实现线程执行内容?</p><p>实现Runnable比继承Thread更好，理由如下：</p><ol><li>实现Runnable接口可以解决单继承的局限性</li><li>把线程和程序代码更好的分离。也就是如果使用继承Thread的方式实现，如果自定义类中有成员数据，就得创建多个MyThread对象才能实现多线程，数据成员也会出现多次。<br>而采用接口实现，只创建一个MyRunnabe对象就可实现多线程。数据成员只会出现一次。实现了Runnable与Thread类的解耦，Thread类只负责设置一些线程的参数。</li><li>在某些情况下Runnable的效率更好，比如我们需要重复执行一些小而短的程序，不停的创建Thread实例代价太高了，实现一个Runnable丢给线程池执行就好。</li></ol><h3 id="线程组的基本知识"><a href="#线程组的基本知识" class="headerlink" title="线程组的基本知识"></a>线程组的基本知识</h3><p>在java中，运行的线程必然属于某一个线程组，如果没有设置，默认线程组是当前启动新线程的线程所在的线程组，就是线程A启动了线程B，默认B的线程组为A所在的线程组。线程组的属性非常多，比如其他的线程组，当前组里的线程等等。</p><blockquote><p>ThreadGroup管理着它下面的Thread，ThreadGroup是一个标准的向下引用的树状结构，这样设计的原因是防止”上级”线程被”下级”线程引用而无法有效地被GC回收。</p></blockquote><h3 id="线程不安全的经典案例"><a href="#线程不安全的经典案例" class="headerlink" title="线程不安全的经典案例"></a>线程不安全的经典案例</h3><p>下面以电影院买票为例阐述多线程编程时的经典问题：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTickets</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tickets=<span class="hljs-number">10</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-keyword">while</span>(tickets&gt;<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-comment">// TODO Auto-generated catch block</span><br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;正在卖出第： &quot;</span>+(tickets--)+<span class="hljs-string">&quot;张票&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>买票时会出现售出同票或者售出负数票，这是为什么？</p><ol><li><p>首先解释同票的问题：因为<code>--</code>不是一个原子操作，所以有可能窗口1读到的tickets为100，此时时间片结束，窗口2读到的也为100，窗口3同理。由于不是原子性操作，所以可能会出现同票问题。</p></li><li><p>售出负数票是因为线程调度是随意的，没有顺序的。有可能tickets为1，t1、t2、t3三个线程都进入了循环，然后分别依次执行，就会出现负数票问题。</p></li></ol><p>综上，由于不是原子性操作和线程调度随意性。</p><h3 id="解决线程安全"><a href="#解决线程安全" class="headerlink" title="解决线程安全"></a>解决线程安全</h3><p>首先我们需要判断是否会出现线程不安全的问题。有以下几个标准：</p><ol><li>是否为多线程环境</li><li>是否线程间<strong>共享</strong>了数据</li><li>处理共享数据的操作是否为<strong>原子</strong>操作</li></ol><p>综上所述，只要将线程同步了，就可以解决线程安全的问题。那么同步有什么特征吗?</p><ol><li>必须是多线程环境</li><li>多个线程必须使用的同一把锁</li><li>当线程过多时，由于需要判断锁的情况，效率地下</li></ol><p>那么如何实现同步？使用<code>synchronized</code>关键字的方法有三种：</p><ol><li><p>使用同步代码块，并且同步代码块能够解决线程安全的关键在于对象，这个对象就相当于一把锁。锁对象可以是<strong>任意对象</strong>。必须共享同一个对象。</p></li><li><p>使用对象同步方法：锁对象就是<strong>该实例对象</strong>本身，将这个对象都锁住了。</p></li><li><p>使用静态同步方法：锁就是<strong>class对象</strong>本身</p></li></ol><p>显而易见，锁的范围越小越好，所以同步代码块的代价是最低的。</p><p>如果采用实例同步方法：同时有两个不相关的实例同步方法。当某个线程在调用其中一个同步实例方法的时候，其他的线程就无法继续调用另外的一个实例同步方法。因为锁只有一个，就是这个实例本身，导致没有关系的两个方法却不能同时进行。<a href=http://www.tianshouzhi.com/api/tutorials/mutithread/284>哪种同步方法好解析</a>。</p><figure class="highlight java"><figcaption><span>"同步代码块实例"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTickets</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tickets = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">private</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-keyword">synchronized</span> (obj) &#123;<span class="hljs-comment">//同步代码块的对象必须是同一对象</span><br>        <span class="hljs-keyword">while</span> (tickets &gt; <span class="hljs-number">0</span>) &#123;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-comment">// TODO Auto-generated catch block</span><br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在卖出第： &quot;</span> + (tickets--) + <span class="hljs-string">&quot;张票&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><figure class="highlight java"><figcaption><span>"实例同步方法"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTickets</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tickets = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (tickets &gt; <span class="hljs-number">0</span>) &#123;<br>        sell();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tickets &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在卖出第： &quot;</span> + (tickets--) + <span class="hljs-string">&quot;张票&quot;</span>);<br>    &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="解决死锁问题"><a href="#解决死锁问题" class="headerlink" title="解决死锁问题"></a>解决死锁问题</h3><p>死锁问题归根到底就是锁的嵌套问题。下面是一个死锁的栗子：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//公共锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLock</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj1=<span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj2=<span class="hljs-keyword">new</span> Object();<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> flag;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MultiThread</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> flag)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>();<br>    <span class="hljs-keyword">this</span>.flag = flag;<br>&#125;;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-comment">// super.run();</span><br>        <span class="hljs-keyword">if</span>(flag) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-comment">// TODO Auto-generated catch block</span><br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (MyLock.obj1) &#123;<br>                System.out.println(Thread.currentThread().getName()+<br>                        <span class="hljs-string">&quot;get lock obj1&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (MyLock.obj2) &#123;<br>                    System.out.println(Thread.currentThread().getName()+<br>                            <span class="hljs-string">&quot;get lock obj2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (MyLock.obj2) &#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;get lock obj2&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (MyLock.obj1) &#123;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;get lock obj1&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面的代码由于锁的相互嵌套，造成了死锁问题。这是由线程间通信方式不当而造成的。</p><blockquote><p>什么是线程间的通信问题？</p></blockquote><p>就是不同<strong>种类</strong>的线程针对同一资源的操作。</p><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p>场景：</p><ol><li>共同资源：学生对象</li><li>设置学生数据：setThread(生产者)</li><li>获得学生数据： getThread(消费者)</li><li>测试demo</li></ol><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>线程调度有两种模型，分别为：</p><ul><li>分时调度模型：所有线程轮流使用CPU，并且分配的时间片都相同</li><li>抢占式调度模型：优先级高的线程优先获得CPU使用权，并且时间片也会比低级线程的多一些。如果线程优先级相同，则随机选一个。</li></ul><p><strong>java使用抢占式调度模式。</strong></p><p>那么如何设置优先级呢？没有设置优先级之前，在java中所有线程的优先级都为5。线程优先级范围为1-10。注意：</p><blockquote><p>线程优先级高仅仅代表线程获取时间片的几率较高，而不是这个线程最先执行完毕。并且要多次执行才能看出效果。</p></blockquote><p>而且这里设置的优先级也仅仅是建议，到底优不优先还得看操作系统。并且线程一定属于线程组，那么如果线程的优先级高于所在线程组的优先级，会怎么样呢？</p><figure class="highlight java"><figcaption><span>"线程组优先级"</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ThreadGroup t=<span class="hljs-keyword">new</span> ThreadGroup(<span class="hljs-string">&quot;t&quot;</span>);<br>    Thread t1= <span class="hljs-keyword">new</span> Thread(t,<span class="hljs-keyword">new</span> CreateThread2(<span class="hljs-string">&quot;tom&quot;</span>));<br>    Thread t2=<span class="hljs-keyword">new</span> Thread(t,<span class="hljs-keyword">new</span> CreateThread2(<span class="hljs-string">&quot;bob&quot;</span>));<br>    t.setMaxPriority(<span class="hljs-number">6</span>);<br>    t1.setPriority(<span class="hljs-number">9</span>);<br>    t2.setPriority(<span class="hljs-number">2</span>);<br>    t1.start();<br>    t2.start();<br>    System.out.println(<span class="hljs-string">&quot;线程组优先级:&quot;</span>+t.getMaxPriority());<br>    System.out.println(<span class="hljs-string">&quot;t1优先级:&quot;</span>+t1.getPriority());<br>    System.out.println(<span class="hljs-string">&quot;t2优先级:&quot;</span>+t2.getPriority());<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>结果如下：</p><blockquote><p>线程组优先级:6<br>t1优先级:6<br>t2优先级:2</p></blockquote><ul><li>设置优先级：<ul><li>setPriority()</li></ul></li><li>获取优先级：<ul><li>getPriority()</li></ul></li></ul><h3 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h3><ul><li><p>线程休眠：<code>public static void sleep(long time)</code>，time表示休眠的毫秒值</p></li><li><p>线程加入：<code>public final void join()</code>,这个方法的作用就是调用该方法的线程先执行完了，其他的线程才能加进来，进入就绪状态。这个join方法有点意思，后序会更新。现在先列一些参考：<a href="https://blog.csdn.net/u013425438/article/details/80205693">参考1</a>,<a href="https://blog.csdn.net/qq_20919883/article/details/100695018">参考2</a><a href="https://www.cnblogs.com/techyc/p/3286678.html">参考3</a></p></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    MyThread my=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;tom&quot;</span>);<br><br>    MyThread my1=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;bob&quot;</span>);<br><br>    MyThread my2=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;candy&quot;</span>);<br>    my.start();<br>    my.join();<br>    my1.start();<br>    my2.start();<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p><del>注意：调用join的位置很重要，必须放在其他线程对象调用<code>start()</code>之前才起作用。</del> 前面这句话完全是在扯淡。在使用join方法，我们需要考虑一个更高的维度，就是当前代码的执行环境。我们可以看到<code>my.join()</code>是在主线程里被调的，虽然调的是<code>MyThread</code>的join方法，但是执行的线程环境是在执行这句代码的线程中。所以这就解释了为什么是<code>my</code>在调用，而阻塞的是<code>main</code>线程，之所以与位置有关，是为主线程被阻塞了，<code>my1.start()</code>、<code>my2.start()</code>还没执行呢，线程当然不会启动。</p><p>这里多说一句，<code>join()</code>方法底层调用的还是<code>wait(0)</code>。</p><ul><li>线程礼让：<code>public static void yield()</code>:暂停当前执行的线程对象，并之情其他线程，让多个线程执行更和谐，但不能保证一人一次。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-comment">//super.run();</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;++i) &#123;<br>            System.out.println(getName()+<span class="hljs-string">&quot;:&quot;</span>+i);<br>            Thread.yield();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>守护线程：简而言之就是守护线程是与其守护的线程的同生死的。被守护的线程死了，守护线程必须得死，但不是立即死。反之则不一定。被守护的线程没死，守护线程可以死。</li></ul><p>那么守护线程到底守护的是谁？是所有的非守护线程，只要还有非守护线程，那么守护线程就会一直工作。</p><p>通过使用成员方法<code>public final void setDaemon()</code>。并且一定要在线程启动前调用。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    MyThread my=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;tom&quot;</span>);<br><br>    MyThread my1=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;bob&quot;</span>);<br><br>    MyThread my2=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;candy&quot;</span>);<br>    my.setDaemon(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//必须在就绪前设为守护线程</span><br>    my1.setDaemon(<span class="hljs-keyword">true</span>);<br>    my2.setDaemon(<span class="hljs-keyword">true</span>);<br>    my.start();<br>    my1.start();<br>    my2.start();<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++) &#123;<br>        System.out.println(Thread.currentThread().getName()+i);<br>    &#125;<br>    <span class="hljs-comment">//System.out.println(my.getPriority());</span><br>    <span class="hljs-comment">//Thread curThread=Thread.currentThread();</span><br>    <span class="hljs-comment">//System.out.println(curThread.getName());</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><ul><li>线程终止：有两种方法，<code>stop()</code>,<code>public void interrupt()</code>。前者已经过时。主要使用后者。后者中断的原理时抛出<code>InterruptedException</code>异常，使用<code>try-catch</code>捕捉后，后续代码仍可执行。</li></ul>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="https://eripe.me/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</category>
      
      
      <comments>https://eripe.me/articles/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>五种IO模型</title>
      <link>https://eripe.me/articles/five-IO-model.html</link>
      <guid>https://eripe.me/articles/five-IO-model.html</guid>
      <pubDate>Mon, 30 Aug 2021 16:38:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信对于很多新人来说，同步、异步、阻塞、与非阻塞这四个概念非常容易混淆。那是因为我们没有搞清楚我们看待问题的视角。对于这四个概念，站在不同的角度，如何区别是不同的。我在此将所有的资料汇总，总结，并提出我自己的见解。</p><p>我将分两种维度讨论这四种概念，分别是广义上的同步与阻塞，以及狭义上的同步与阻塞。</p><h2 id="1-广义维度下的区分"><a href="#1-广义维度下的区分" class="headerlink" title="1. 广义维度下的区分"></a>1. 广义维度下的区分</h2><p>相信很多人在编写多线程程序最大的难度就是让各个线程之间同步合作。那么根据&lt;&lt;操作系统概念&gt;&gt;(第九版)一书中关于进程之间通信部分小节的同步异步概念:(<a href="https://www.zhihu.com/question/19732473">怎样理解阻塞非阻塞与同步异步的区别?</a>)<br><img src="images/os.jpg" alt="os"></p><p>其中说到进程之间的消息传递可以分为阻塞或者非阻塞的，也即是同步或者异步的。发送和接受动作分别可以细分为两种情况：</p><ul><li>阻塞发送：发送进程会被阻塞直到消息被接受</li><li>非阻塞发送：发送进程发送完毕后可以进行其他操作</li><li>阻塞接受：接收进程会被阻塞直到消息可用</li><li>非阻塞接受：接收进程收到消息或返回空</li></ul><p>那么站在我们多线程程序的角度，我们可以认为同步即阻塞，异步即非阻塞。无论底层是如何实现的。</p><h2 id="2-狭义维度下的区分"><a href="#2-狭义维度下的区分" class="headerlink" title="2. 狭义维度下的区分"></a>2. 狭义维度下的区分</h2><p>所谓的狭义维度即我们进行IO操作的角度。因为IO操作的特殊性，阻塞是可能发生的。那么下面我将通过介绍五种linux平台的IO模型来区分这四种概念：</p><ul><li>阻塞IO模型</li><li>非阻塞IO模型</li><li>IO多路复用模型</li><li>信号通知模型</li><li>异步IO模型</li></ul><p>首先我们肯定是要通过内核与外部设备进行IO交互，那么一次IO操作基本上可以分为三个步骤：</p><ol><li>用户进程等待IO设备的数据</li><li>通知用户进程所需数据已经准备好</li><li>用户进程把IO数据从内核空间拷贝至用户空间</li></ol><p>了解这三个步骤后，很自然地会想到第一部分的等待是如何等待，是占用CPU空等还是进行睡眠操作？第二部分的通知什么时候通知？（我们上面的IO操作基于单线程网络IO）下面的四种模型很好地回答了上述这两个问题。</p><h3 id="2-1-阻塞IO模型"><a href="#2-1-阻塞IO模型" class="headerlink" title="2.1 阻塞IO模型"></a>2.1 阻塞IO模型</h3><p>首先阻塞IO模型最符合我们的惯性思维，模型如下图所示(图片应该来自unix网络编程一书，未经本人考证):</p><p><img src="images/blocking-IO.jpg" alt="blocking-IO"></p><p>在linux的世界里，一切皆文件。那么我们也可以将socket当作一种特殊的文件来进行独写。在默认情况下socket为<strong>阻塞</strong>模式，那么当用户进程调用<code>recvfrom</code>后，由于此时IO数据尚未准备完成，用户进程会被阻塞(处于等待阶段)，直到数据准备完成。此时用户进程还是会被阻塞至数据拷贝至用户空间（处于拷贝阶段）。</p><p>可以看到，在一次IO操作中用户线程是全程被阻塞的，所以这是最基本的阻塞IO模型。</p><h3 id="2-2-非阻塞IO模型"><a href="#2-2-非阻塞IO模型" class="headerlink" title="2.2 非阻塞IO模型"></a>2.2 非阻塞IO模型</h3><p><img src="images/non-blocking-IO.jpg" alt="non-blocking-IO"></p><p>上图为非阻塞IO模型的基本示意图。</p><p>在进行网络IO时，我们可以将socket设置为<strong>非阻塞</strong>模式。这个设置就是告诉内核对于这个socket，调用<code>recvfrom</code>读取该socket时，如果数据尚未准备完成，那么直接返回，不必等待至数据准备好。所以在第一阶段我们不必等待。</p><p>那么什么时候用户进程会得知内核完成数据准备呢(即第二阶段)?在这个模型中，用户进程会不断进行轮循操作，即不断调用<code>recvfrom</code>来得知数据是否准备完毕，从而完成第二个阶段。</p><p>第三个阶段与阻塞IO模型类型，都是从内核空间将数据拷贝出来。可以看到第二阶段的轮循操作是非常浪费资源的，因为大多时候我们在做无用功。从而产生了IO多路复用模型。</p><h3 id="2-3-IO多路复用模型"><a href="#2-3-IO多路复用模型" class="headerlink" title="2.3 IO多路复用模型"></a>2.3 IO多路复用模型</h3><p>所谓的<strong>多路</strong>是指多个socket的读写，<strong>复用</strong>是指所有的IO都可以通过复用一个或几个线程来完成。基本模型如下图所示：</p><p><img src="images/multiplexing-IO.jpg" alt="IO-multixing"></p><p>IO多路复用模型的工作场景如下：</p><p>假设我们现在有socket A、B需要进行IO操作，有三种方案：</p><ol><li>单线程，采用阻塞IO模型：这就是将所有的IO操作串行，当两个socket流量都非常低且不活跃时，效率非常低，有可能排在后面的socket已经准备好了，但是当前处理线程仍然在等待第一个socket的数据</li><li>单线程，采用非阻塞IO模型，不断对A、B进行轮循操作，当然仍然会浪费大量的时间，并且不断使用<strong>多次使用系统调用</strong>查看一个socket，代价也比较高昂</li><li>采用多线程，阻塞IO模型，将A、B的IO轮循任务分配两个子线程。虽然这样效率比前面两种方案都高，但是线程是非常宝贵的资源，<strong>不停的切换线程</strong>、创建与销毁线程的代价都昂贵。</li></ol><p>难道我们就不能通过一次系统调用查看多个socket，让socket完成数据准备后自己通知用户线程吗？当然这是可行的，就是使用linux平台的select、poll、epoll等系统调用。对应于java中的NIO。<strong>一次系统调用监控多个socket</strong>就是多路IO复用模型出现的原因。</p><p>这里我首先以<code>select</code>作为例子。基本的流程如下：</p><ol><li>我们将需要操作的socket注册到<code>select</code>函数中，并绑定我们感兴趣的操作，例如是读还是写。然后调用<code>select</code>。<strong>注意：在没有socket准备好时，<code>select</code>仍然会阻塞用户进程</strong>。</li><li><code>select</code>会不断的对注册的socket进行轮循操作，直至有可用的socket出现，此时该函数会返回，但剩余未准备好的socket仍然可以继续准备。</li><li>对可用的socket进行感兴趣的操作。然后继续调用<code>select</code></li></ol><p>那么我们节省的时间在哪里？很简单，就是在当我们select出一些socket后进行数据处理操作时，剩余的socket仍然可以继续准备。可能当我们下一次调用<code>select</code>时又有新的socket已经准备好了。这样就避免对多个socket进行轮循时，已经准备好的socket后轮循，没准备好的先轮循，浪费了不必要的时间。</p><p>当然对于<code>select</code>,还有更多的细节需要注意。这里只需要记住，对于第一个等待数据的阶段同样会<strong>产生阻塞</strong>，第三阶段拷贝数据时也会<strong>产生阻塞</strong>。</p><h3 id="2-4-信号通知模型"><a href="#2-4-信号通知模型" class="headerlink" title="2.4 信号通知模型"></a>2.4 信号通知模型</h3><p>信号模型如下图所示：</p><p><img src="images/signal-IO.png" alt="signal-IO"></p><p>信号IO模型似乎用的不是很多，所以对于其的介绍我引用自<a href="https://segmentfault.com/a/1190000007355931">Unix 网络 IO 模型: 同步异步, 傻傻分不清楚?</a>：</p><blockquote><p>当文件描述符就绪时, 我们可以让内核以信号的方式通知我们.<br>我们首先需要开启套接字的信号驱动式 IO 功能, 并通过 sigaction 系统调用安装一个信号处理函数. sigaction 系统调用是异步的, 它会立即返回. 当有数据时, 内核会给此进程发送一个 SIGIO 信号, 进而我们的信号处理函数就会被执行, 我们就可以在这个函数中调用 recvfrom 读取数据</p></blockquote><h3 id="2-5-异步IO模型"><a href="#2-5-异步IO模型" class="headerlink" title="2.5 异步IO模型"></a>2.5 异步IO模型</h3><p>所谓的异步IO模型，是在我们进行系统调用后直接返回，但并不像阻塞IO模型返回<code>EWOULDBLOCK</code>，具体返回什么有待学习。然后当数据准备完毕并拷贝至用户空间时，内核会发送信号通知用户进程处理数据。模型如下所示：<br><img src="images/asynchronus-IO.jpg" alt="asyn-IO"></p><p>可以看到，异步IO模型甚至不需要我们拷贝数据，当然异步IO在网络编程中很少用到，可能会用在文件IO中。</p><h3 id="2-6-IO维度下的同步与异步"><a href="#2-6-IO维度下的同步与异步" class="headerlink" title="2.6 IO维度下的同步与异步"></a>2.6 IO维度下的同步与异步</h3><p>根据IEEE针对<a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html">POSIX相关规定</a>中的第3.30条异步I/O操作定义：</p><blockquote><p>3.30条：Asynchronous I/O Operation<br>An I/O operation that does not of itself cause the thread requesting the I/O to be blocked from further use of the processor.<br>This implies that the process and the I/O operation may be running concurrently.</p></blockquote><p>与第3.387条同步I/O操作的定义:</p><blockquote><p>3.387 Synchronous I/O Operation<br>An I/O operation that causes the thread requesting the I/O to be blocked from further use of the processor until that I/O operation completes.<br>Note:<br>A synchronous I/O operation does not imply synchronized I/O data integrity completion or synchronized I/O file integrity completion.</p></blockquote><p>我们可以得知在I/O视角下：</p><ul><li>同步IO：由于请求IO而导致当前进程丧失处理器使用权直至操作结束</li><li>异步IO：请求IO并不会导致当前进程对处理器的使用权</li></ul><p>那么我们就可以对上述五种IO模型进程同步与异步的划分了。</p><ul><li>阻塞IO模型：在第一阶段和第三阶段都会由于系统调用而当值当前线程被阻塞</li><li>非阻塞IO模型：在第三阶段拷贝数据时会导致当前线程被阻塞</li><li>IO多路复用模型：在第一阶段和第三阶段线程都会被阻塞</li><li>信号通知模型：在第三阶段拷贝数据时当前线程会被阻塞</li><li>异步模型：三个阶段线程都不会被阻塞</li></ul><p>那么我就可以得知，阻塞IO模型、非阻塞IO模型、多路复用IO模型、信号通知模型都是同步I/O操作。下图很好地进行了总结：</p><p><img src="images/IO-model-summary.jpg" alt="IO-model-summary"></p><h3 id="2-7-小节"><a href="#2-7-小节" class="headerlink" title="2.7 小节"></a>2.7 小节</h3><p>在网络I/O视角下，是否同步与是否采用阻塞模型无关。那么当我们将视角提高至线程之间通信时，此时的同步基本上可以与阻塞划等号。比如我们当前调用了一个异步API，与这个API底层怎么实现的无关。</p><p>所以说，要想分清同步异步与阻塞非阻塞这四个概念，不在一定的维度讨论是没有办法分清楚的。</p><h2 id="3-详解多路复用IO模型"><a href="#3-详解多路复用IO模型" class="headerlink" title="3. 详解多路复用IO模型"></a>3. 详解多路复用IO模型</h2><p>上面简要描述了linux平台下的五种I/O模型，其中多路复用模型其实才是我们最有可能采用的。在linux下，有三个API可以帮助我们实现这个模型，分别是：<code>select</code>、<code>poll</code>、<code>epoll</code>。这三个API的效率基本上按照从左到右由低到高。</p><p>在详细介绍这三种方法前，我们需要了解一个阻塞的socket和一个非阻塞的socket有什么区别：</p><ul><li>阻塞的socket：读取时如果数据尚未准备好，那么当前线程会一直被阻塞直至数据准备完成</li><li>未阻塞的socket：读取时如果数据尚未准备好，那么当前线程并不会被阻塞，会执行后续的操作</li></ul><p><strong>并且我们可以将socket当作文件处理，使用文件描述符fd指代向应socket。</strong></p><h3 id="3-1-select方法"><a href="#3-1-select方法" class="headerlink" title="3.1 select方法"></a>3.1 select方法</h3><p>函数签名如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nfds, fd_set *rdfds, fd_set *wtfds, fd_set *exfds, struct timeval *timeout)</span></span><br></code></pre></div></td></tr></table></figure><ul><li>ndfs：监听的fd(file descriptor)总数</li><li>rdfds：需要监听可读事件的socket集合</li><li>wtfds：需要监听可写事件的socket集合</li><li>exfds：需要监听异常事件的socket集合</li></ul><p>那么<code>select</code>的工作原理很简单，我们将需要监听的socket集合传入该函数后：</p><ol><li><code>select</code>会将相应的socket集合<strong>拷贝至内核空间</strong>(注意每次调用都会拷贝)</li><li><code>select</code>轮循探测监听的socket，如果有对应的socket完成事件，那么<code>select</code>就会返回，否则会保持阻塞状态</li><li>那么在函数返回后，我们并不知道是哪个socket的什么事件准备好了，所以我们需要<strong>遍历我们的socket</strong>，依次探测所有类型的事件是否完成，不管这个socket到底对当前探测的事件是否感兴趣，并且又会把相应的socket拷贝至用户空间</li><li>在进行新一轮的<code>select</code>调用时,又得重新设置socket集合，因为上一轮已经改变了集合</li></ol><p>当然<code>select</code>存在很多缺点：</p><ol><li>在<strong>每次</strong>调用<code>select</code>时都会将目标socket集合<code>fd_set</code>从用户空间拷贝至内核空间，所以当socket集合很大时，每次拷贝的效率会非常低</li><li><code>select</code>内部每次使用<strong>轮询操作</strong>探查是否有socket的对应事件准备完毕，因为其使用的<code>fd_set</code>由数组组成，大小一般限制为1024(因为操作系统对每个进程可用的最大描述符数限制了上限，可在编译时重新设置)，所以每次轮询都需要完整遍历，这又会使<code>select</code>效率变低</li><li>在找到准备好的socket集合后，<code>select</code>又会将所有的<code>fd_set</code>再从内核拷贝至用户空间，再次将<code>select</code>效率变低</li><li> 在每次调用<code>select</code>时，之前设置的<code>fd_set</code>都会失效，所以每次循环前都需要重新设置<code>fd_set</code>.</li></ol><h3 id="3-2-poll方法"><a href="#3-2-poll方法" class="headerlink" title="3.2 poll方法"></a>3.2 poll方法</h3><p><code>poll</code>与<code>select</code>并无大的差别，只不过<code>poll</code>使用的socket集合<code>pollfd</code>没有大小的限制，因为底层是采用链表实现的，所以<code>select</code>有的缺点<code>poll</code>都会存在</p><h3 id="3-3-epoll机制"><a href="#3-3-epoll机制" class="headerlink" title="3.3 epoll机制"></a>3.3 epoll机制</h3><p><strong>epoll的基本玩法</strong></p><p><code>epoll</code>是<code>poll</code>的升级版，<code>epoll</code>的API分为三个部分：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epfd, <span class="hljs-keyword">int</span> op, <span class="hljs-keyword">int</span> fd, struct epoll_event *event)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epfd, struct epoll_event * events, <span class="hljs-keyword">int</span> maxevents, <span class="hljs-keyword">int</span> timeout)</span></span>;<br></code></pre></div></td></tr></table></figure><ol><li>epoll_create：首先调用<code>epoll_create</code>创建<code>poll</code>对象。并且会开辟一个红黑树与就绪队列。红黑树用来保存我们需要监听的socket结合，就绪队列用来保存已经准备就绪的socket集合</li><li>epoll_ctl：注册要监听的事件类型。在每次注册新的事件到epoll句柄中时，会把对应的socket复制到内核中，注意对于一个socket，在<code>epoll</code>中<strong>只会被复制一次</strong>，不像<code>select</code><strong>每次调用</strong>时都会复制。并且同时会向内核注册回调函数，大致功能是当该socket关注的事件完成时将其加入就绪队列。</li><li>epoll_wait：等待事件的就绪，其只用遍历就绪队列，所以<code>epoll</code>的复杂度只与活跃的连接数有关。<del>并且返回就绪socket集合<strong>采用了内存映射</strong>，进一步减少了拷贝fds的操作</del>，好吧，这句话是错的，并没有内存映射，<a href="https://www.zhihu.com/question/39792257">参考</a>。但是同时<code>epoll_wait</code>返回后，会将就绪socket对应事件清空，如果后续仍想关注当前处理的socket，那么就需要用epoll_ctl(epfd,EPOLL_CTL_MOD,listenfd,&amp;ev)来重新设置socket fd的关注事件类型，<strong>而不需要重新注册fd</strong></li></ol><p><strong>epoll解决了什么问题：</strong></p><p>1. epoll通过回调机制实现了知道哪个socket的哪些事件准备完成，这在<code>select</code>中需要通过轮询完成(这里并不是指在<code>epoll_wait</code>返回后不需要遍历小于返回值的fd，仍然需要循环遍历socket进行处理)<br>2. epoll只会在fd初次注册使用<code>epoll_ctl</code>时拷贝至内核,而<code>select</code>每次都需要完整的拷贝所有fd，并且每次都需要重新设置描述符结合，因为每次<code>select</code>返回后都会修改描述符集合</p><p><strong>epoll的LT与ET模式：</strong></p><p>epoll有EPOLLLT和EPOLLET两种触发模式。它们主要的区别有两点：</p><ol><li>LT模式下，只要有socket活跃，那么就会向用户进程发送信号，通知进程对数据进行操作。而ET模式只会在socket无法存放数据时才会通知进程对数据进程操作，例如读时没有内存存储数据</li><li>LT模式下，如果一个socket的数据未使用完毕，那么下一轮通知中还会包含未处理完毕的socket，ET模式下，一个socket的数据未使用完毕，那么epoll会认为当前socket的状态未发生改变，下轮通知时不会包含当前socket</li></ol><p>那么LT模式的缺点是很明显的，因为有可能会有大量的我们并不关心的socket对我们发送通知，所以我们一般都会采用ET模式。</p><p>但是ET模式下，如果一个socket的数据不能一次处理完毕，该socket就会被认为状态未发生改变。所以我们一般会采用循环处理socket的所有数据。这又产生了新的问题。如果该socket被设置阻塞模式，在循环进行最后一次读取时，读取到的数据必然为空，当前线程会被阻塞，直到该socket收到数据。<br>那么LT模式如果有阻塞socket的数据一次不能处理完呢？解决方法就是我们就不需要使用循环读取所有数据，只需调用一次，因为LT模式下该socket还会出现在就绪队列中。</p><p>所以我们一般<strong>建议</strong>在使用ET模式将socket设置为<strong>非阻塞模式</strong>。但是这并不说明ET模式下不能将socket设置为阻塞模式。如果socket的数据一次能够读取完毕，那么也不会阻塞当前线程。所以我们说建议，因为ET模式的阻塞socket可能会产生预想不到的问题。<strong>同时也说明是否阻塞socket并不影响多路复用IO模型的使用。</strong></p><h3 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h3><p>其实我们可以发现多路复用IO模型其实就是在完成两件事：</p><ul><li>维护需要监听的fd集合</li><li>等待目标事件的完成</li></ul><p><code>select</code>就是把这两件事放在一起做，每次调用时都要重新注册需要监听的集合，并且每次都会进行阻塞操作。</p><p>而<code>epoll</code>就将维护操作放在了第二步，只需第一次注册，然后使用<code>wait</code>函数完成阻塞的操作。</p><p>那么<code>epoll</code>比<code>select</code>快是理由的：</p><ol><li>因为在大部分情况下我们需要监听的fd集合是固定的，<code>epoll</code>不会进行重复注册</li><li>在每次设置fd的目标事件时，因为<code>epoll</code>内部采用的红黑树保存需要监听的fd集合，查找对应的<code>socket</code>都是<code>o(lgn)</code>的复杂度。而<code>select</code>需要设置所有的带监听的fd集合。</li></ol><p><strong>那么在任何时候都应该优选选择<code>epoll</code>吗？</strong></p><p>答案当然是否定的。如果当前服务器的连接数较少并且都很活跃，<code>epoll</code>不一定会优于<code>select</code>，因为<code>epoll</code>注册回调函数等操作都需要代价。</p><h2 id="4-java世界中的多路复用模型"><a href="#4-java世界中的多路复用模型" class="headerlink" title="4. java世界中的多路复用模型"></a>4. java世界中的多路复用模型</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://cllc.fun/2019/03/07/synchronous-asynchronous-io/">同步I/O(阻塞I/O，非阻塞I/O)，异步I/O</a></p></li><li><p><a href="https://medium.com/@liakh.aliaksandr/java-sockets-i-o-blocking-non-blocking-and-asynchronous-fb7f066e4ede">Java sockets I/O: blocking, non-blocking and asynchronous</a></p></li><li><p><a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html">POSIX的一些相关定义</a></p></li><li><p><a href="https://www.zhihu.com/question/19732473">怎样理解阻塞非阻塞与同步异步的区别？</a></p></li><li><p><a href="https://imageslr.github.io/2020/02/27/select-poll-epoll.html">I/O 多路复用，select / poll / epoll 详解</a></p></li><li><p><a href="https://www.cnblogs.com/skyfsm/p/7079458.html">Linux编程之select</a></p></li><li><p><a href="https://www.cnblogs.com/upnote/p/12017212.html">关于非阻塞I/O、多路复用、epoll的杂谈</a></p></li><li><p><a href="https://www.cnblogs.com/aspirant/p/9166944.html">select、poll、epoll之间的区别(搜狗面试)</a></p></li><li><p><a href="https://blog.csdn.net/daaikuaichuan/article/details/83862311">poll原理详解及epoll反应堆模型</a></p></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/IO/">IO</category>
      
      
      <category domain="https://eripe.me/tags/IO%E6%A8%A1%E5%9E%8B/">IO模型</category>
      
      
      <comments>https://eripe.me/articles/five-IO-model.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>synchronized关键字</title>
      <link>https://eripe.me/articles/synchronized-keyword.html</link>
      <guid>https://eripe.me/articles/synchronized-keyword.html</guid>
      <pubDate>Mon, 30 Aug 2021 16:38:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>Java提供的同步机制有许多，<code>synchronized</code>是其中最经常使用、最万能的机制之一。<br>为了学习<code>synchronized</code>的实现原理，进而了解到<code>monior object</code>模式。在java中<code>synchronized</code>辅助实现了该模式。</p><h1 id="1-monitor机制的起源与定义"><a href="#1-monitor机制的起源与定义" class="headerlink" title="1. monitor机制的起源与定义"></a>1. monitor机制的起源与定义</h1><p>在早期，编写并发程序时使用的同步原语是信号量semaphore与互斥量mutex。程序员需要手动操作信号量的数值与线程的唤醒与挂起，想想这也是一个十分麻烦的工作。所以提出了更高层次的同步机制<code>monitor</code>封装了信号量的操作。但是值得注意的是<code>monitor</code>并未在操作系统层面实现，而是在软件层次完成了这一机制。</p><p>下面描述了<code>monitor</code>机制之所以会出现的一个应用场景（摘自<a href="https://developer.ibm.com/zh/articles/j-lo-synchronized/">探索Java同步机制</a>）：</p><blockquote><p>我们在开发并发的应用时，经常需要设计这样的对象，该对象的方法会在多线程的环境下被调用，而这些方法的执行都会改变该对象本身的状态。为了防止竞争条件 (race condition，等同于死锁) 的出现，对于这类对象的设计，需要考虑解决以下问题：<br>1.在任一时间内，只有唯一的公共的成员方法，被唯一的线程所执行。<br>2.对于<strong>对象的调用者</strong>来说，如果总是需要在调用方法之前进行拿锁，而在调用方法之后进行放锁，这将会使并发应用编程变得更加困难。合理的设计是，该对象本身确保任何针对它的方法请求的会同步并且透明的进行，而<strong>不需要调用者的介入</strong>。<br>3.如果一个对象的方法执行过程中，由于某些条件不能满足而阻塞，应该允许其它的客户端线程的方法调用可以访问该对象。</p></blockquote><p>我们使用 Monitor Object 设计模式来解决这类问题：<strong>将被客户线程并发访问的对象定义为一个 monitor 对象</strong>。客户线程仅仅通过 monitor 对象的同步方法才能使用 monitor 对象定义的服务。为了防止陷入死锁，在任一时刻只能有一个同步方法被执行。每一个monitor对象包含一个 monitor锁，被同步方法用于串行访问对象的行为和状态。此外，同步方法可以根据一个或多个与monitor对象相关的monitor conditions 来决定在何种情况下挂起或恢复他们的执行。</p><p>根据上述定义，monitor object模式分为四个组成部分：</p><ul><li><strong>监视者对象 (Monitor Object):</strong> 负责定义公共的接口方法，这些公共的接口方法会在多线程的环境下被调用执行。</li><li><strong>同步方法：</strong> 这些方法是<strong>监视者对象</strong>所定义。为了防止死锁，无论是否同时有多个线程并发调用同步方法，还是监视者对象含有多个同步方法，在任一时间内只有监视者对象的一个同步方法能够被执行（所谓的同步方法也就是我们经常说的临界区）</li><li><strong>监视锁 (Monitor Lock):</strong> 每一个监视者对象都会拥有一把监视锁。</li><li><strong>监视条件 (Monitor Condition):</strong> 同步方法使用监视锁和监视条件来决定方法是否需要阻塞或重新执行。这里的监视条件可以来自程序本身也可来自monitor object内部。</li></ul><p>这四个部分完成了两个动作：</p><ol><li>线程互斥的进入同步方法</li><li>完成线程的一些调度动作，例如线程的挂起与唤醒</li></ol><h1 id="2-Java中的monitor-object模式"><a href="#2-Java中的monitor-object模式" class="headerlink" title="2. Java中的monitor object模式"></a>2. Java中的monitor object模式</h1><p>按照定义，Java下基于<code>synchronized</code>的<code>monitor object</code>模式也应该由四个部分组成,包括监视者对象、监视锁、监视条件、同步方法（临界区）。那么首先来看看我们一般使用<code>synchronized</code>来实现同步的代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">demo</span></span>&#123;<br>    Object lock=<span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(lock)&#123;<br>            ...<br>        &#125;<br>        ...<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在我看到的大部分资料中，都认为上述代码中的<code>lock</code>对象是监视者对象，监视条件上面没有展示出来，<code>synchronized</code>后跟的代码块就是同步方法。但是这个同步方法并不是在<code>lock</code>所在的类<code>Object</code>中定义的啊，这如何解释？</p><blockquote><p>我的理解是这里的“定义”并不是诸如在类<code>A</code>中定义一个方法<code>test</code>之类的定义，而是规定了某些代码作为同步方法，例如规定字母<code>A</code>代表学校，字母<code>B</code>代表公司之类的将两个事物联系到一起的定义，就像在上面代码中规定了<code>&#123;&#125;</code>中的代码作为<code>lock</code>的同步方法</p></blockquote><p>那么监视锁呢？上面完全没有锁的痕迹。原因是基于<code>monitor object</code>模式的<code>synchronized</code>，监视锁是由监视对象自带的，也被称为<code>intrinsic lock</code>。这个锁在java中是由<code>objectmonitor</code>实现的。</p><p>那么监视者对象、监视锁和线程这三者如何产生联系的呢？这就跟Java中对象的内存布局有关了。在jvm中，任何一个对象都会持有一个对象头用来存储一些对象的信息,下图中是一个对象的内存布局，由对象头、对象数据和填充数据组成。</p><p><img src="images/object_header.png" alt="object memory layout"></p><p>其中对象头由<code>markword</code>和<code>klass pointer</code>组成，如果当前对象是数组，那么在<code>klass pointer</code>后面还会追加数组的长度。</p><p><code>klass point</code>指针指向它的类元数据，用于判断当前对象属于哪个类(Points to another object (a metaobject) which describes the layout and behavior of the original object.)，<code>markword</code>在32位和64位的机器上略有不同，32bit长的<code>markword</code>布局如下所示（图片出自<a href="https://deecyn.com/java-synchronized-and-lock.html">Synchronized与锁</a>）：</p><p><img src="images/32-MarkWord.png" alt="32-markword"></p><p>因为空间有限，所以这32bit是复用的，在不同状态下存储的信息是不同的。对于Java1.6之前的<code>synchronized</code>对应于图中的重量级锁状态（其他三种锁状态在Java1.6后出现），该状态下<code>markword</code>存储了指向了重量级锁的指针，这个重量级锁就是<code>monitor object</code>模式中的监视锁。这个重量级锁是在JVM中通过<code>ObjectMonitor</code>类实现的，<strong>而该类本质上又是基于系统的mutex创建的</strong>。其部分代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectMonitor</span> </span>&#123;<br>...<br>  <span class="hljs-comment">//省略一些代码</span><br>  <span class="hljs-function">bool      <span class="hljs-title">try_enter</span> <span class="hljs-params">(TRAPS)</span> </span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span>      <span class="hljs-title">enter</span><span class="hljs-params">(TRAPS)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span>      <span class="hljs-title">exit</span><span class="hljs-params">(bool not_suspended, TRAPS)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span>      <span class="hljs-title">wait</span><span class="hljs-params">(jlong millis, bool interruptable, TRAPS)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span>      <span class="hljs-title">notify</span><span class="hljs-params">(TRAPS)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span>      <span class="hljs-title">notifyAll</span><span class="hljs-params">(TRAPS)</span></span>;<br>  ...<br><br>  <span class="hljs-comment">// WARNING: this must be the very first word of ObjectMonitor</span><br>  <span class="hljs-comment">// This means this class can&#x27;t use any virtual member functions.</span><br><br>  <span class="hljs-keyword">volatile</span> markOop   _header;       <span class="hljs-comment">// displaced object header word - mark</span><br>  <span class="hljs-keyword">void</span>*     <span class="hljs-keyword">volatile</span> _object;       <span class="hljs-comment">// backward object pointer - strong root</span><br><br>  <span class="hljs-comment">// All the following fields must be machine word aligned</span><br>  <span class="hljs-comment">// The VM assumes write ordering wrt these fields, which can be</span><br>  <span class="hljs-comment">// read from other threads.</span><br><br> <span class="hljs-keyword">protected</span>:                         <span class="hljs-comment">// protected for jvmtiRawMonitor</span><br>  <span class="hljs-keyword">void</span> *  <span class="hljs-keyword">volatile</span> _owner;          <span class="hljs-comment">// pointer to owning thread OR BasicLock</span><br>...<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">int</span> OwnerIsThread ;               <span class="hljs-comment">// _owner is (Thread *) vs SP/BasicLock</span><br>...<br> <span class="hljs-keyword">protected</span>:<br>  ObjectWaiter * <span class="hljs-keyword">volatile</span> _EntryList ;     <span class="hljs-comment">// Threads blocked on entry or reentry.</span><br><br> <span class="hljs-keyword">protected</span>:<br>  ObjectWaiter * <span class="hljs-keyword">volatile</span> _WaitSet; <span class="hljs-comment">// LL of threads wait()ing on the monitor</span><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> _WaitSetLock;        <span class="hljs-comment">// protects Wait Queue - simple spinlock</span><br>  <span class="hljs-comment">//省略一些代码</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中：</p><ul><li><code>_header</code>存储了指向属于<code>monitor object</code>的<code>object header</code>的指针，也就是指向对象头的指针</li><li><code>_object</code>存储了指向<code>monitor object</code>的指针</li><li><code>_owner</code>存储了指向获得监视锁的线程</li><li><code>_EntryList</code>存储了访问同一临界区但是被阻塞的线程集合</li><li><code>_WaitList</code>存储了调用<code>wait()</code>方法主动释放锁的线程集合</li></ul><p>并且<code>ObjectMonitor</code>实现了<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>等方法。</p><p>那么监视对象、监视锁、线程的关系是：监视对象内存存储了监视锁，而监视锁中又存储了获得当前锁的线程。并且由于每个对象都会有对象头，而对象头中自带监视锁，所以Java中任何一个对象都可以用作监视对象，所以<code>wait()</code>、<code>notify()</code>等方法在顶级父类<code>Object</code>中实现。</p><h1 id="3-Java1-6后的synchronized"><a href="#3-Java1-6后的synchronized" class="headerlink" title="3. Java1.6后的synchronized"></a>3. Java1.6后的synchronized</h1><p>因为Java的线程模型采用的是1:1模型，一个Java线程映射到系统的一个线程，所以Java线程的切换、阻塞、唤醒都需要在内核模式中完成，频繁地切换用户模式与内核模式代价非常高（所以<code>synchronzied</code>被称为重锁）。那么如果同步区非常短，执行同步区的时间比切换内核模式的时间还短，程序的效率就比较低了。所以在Java1.6之后，<code>synchronzied</code>进行了大量优化。对于<code>synchronized</code>，不会再一开始就使用<code>objectMonitor</code>完成同步。而是根据线程对锁的竞争程度不断升级获取锁的难度。</p><p>升级后的<code>synchronized</code>分为四个阶段：无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁。这四个状态通过<code>markword</code>中的两位标记来区分，再次搬出32位下的<code>markword</code>结构图：</p><p><img src="images/32-MarkWord.png" alt="32-markword"></p><p>可以看到，偏向锁和无锁状态的锁标志位都是<code>01</code>，他们是通过1bit的标志位来区分。</p><p>同时JVM会使用<code>Lock Record</code>在线程中保存锁的一些信息，其组成如下所示：<br><img src="images/lock-record.png" alt="lock record"></p><p>其中：</p><ul><li><code>displaced hdr(displaced markword)</code>:一般用来保存<code>monitor object</code>对象头中的<code>markword</code>信息副本</li><li><code>owner</code>：指向<code>monitor object</code>的指针。</li></ul><p>在三种锁状态中，都会使用<code>Lock Record</code>。但是在偏向锁状态中并不会使用<code>Lock Record</code>的<code>displaced markword</code>。</p><h2 id="3-1-偏向锁"><a href="#3-1-偏向锁" class="headerlink" title="3.1 偏向锁"></a>3.1 偏向锁</h2><p>偏向锁，将锁的归属权偏向给第一个获得该锁的线程。说人话，就是如果有一个线程threadA第一次成功获得了偏向锁lock，那么lock默认认为以后能够成功获得锁的线程都会是线程A。</p><blockquote><p>注意：“偏向第一个获得该锁的线程”并不是指在偏向锁的生命周期内只会有一个线程获得锁。<br>比如在最开始，threadA获得了偏向锁lock，此时lock偏向threadA。使用完毕后，threadB请求lock。虽然lock发现此时请求的线程不是threadA，但是由于此时没有发生竞争，所以lock重新设置其偏向的线程为threadB。<strong>而不是说从头到尾lock都只偏向threadA。</strong></p></blockquote><p> 偏向锁的使用场景是同步区只被同一个线程访问。那么在使用偏向锁时<del>只会在第一次申请时</del>，使用CAS将<code>markword</code>中的线程ID（默认为0，表示匿名偏向状态）替换为当前获得锁的线程ID（当然如果不停地出现新线程成功获取锁的情况，那么每次新线程都会使用CAS替换ThreadID。但是并不是简单的替换而已，JVM同时也会在当前线程的<code>Lock Record</code>列表中插入一个<code>Lock Record</code>结构。</p><h3 id="3-1-1-偏向锁的获取流程"><a href="#3-1-1-偏向锁的获取流程" class="headerlink" title="3.1.1 偏向锁的获取流程"></a>3.1.1 偏向锁的获取流程</h3><p>下图中是偏向锁的工作流程：</p><p><img src="images/biased-lock.jpg" alt="biased-lock"></p><p>偏向锁的<strong>开启</strong>需要锁对象头开启以及klass属性头开启才算，单方面无法进入重偏向。其中有几点需要注意，在一个线程每次成功获取偏向锁时，<strong>会在当前线程的<code>Lock Record</code>队列中插入一个<code>Lock Record(LR)</code></strong>,并且设置新插入LR中的owner指向当前监视器对象（monitor object），具体的实现代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//代码分析摘自：Synchronized 源码分析（http://itliusir.com/2019/11-Synchronized/）</span><br><span class="hljs-comment">//源码地址：http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1816</span><br><br>CASE(_monitorenter): &#123;<br>  oop lockee = STACK_OBJECT(-<span class="hljs-number">1</span>);<br>  CHECK_NULL(lockee);<br>  <span class="hljs-comment">// 寻找空闲的锁记录(Lock Record) 空间</span><br>  BasicObjectLock* limit = istate-&gt;monitor_base();<br>  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();<br>  BasicObjectLock* entry = NULL;<br>  <span class="hljs-keyword">while</span> (most_recent != limit ) &#123;<br>  <span class="hljs-keyword">if</span> (most_recent-&gt;obj() == NULL) entry = most_recent;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (most_recent-&gt;obj() == lockee) <span class="hljs-keyword">break</span>;<br>  most_recent++;<br>  &#125;<br>  <span class="hljs-comment">// 存在空闲的Lock Record</span><br>  <span class="hljs-keyword">if</span> (entry != NULL) &#123;<br>    <span class="hljs-comment">/***********************************/</span><br>    <span class="hljs-comment">// 设置Lock Record 的 obj指针(owner)指向锁对象(monitor object)</span><br>    <span class="hljs-comment">//无论是轻量锁还是偏向锁都会设置这个指针</span><br>    <span class="hljs-comment">//这句代码完成了线程每次获取锁时向LR集合中插入新LR的动作</span><br>    entry-&gt;set_obj(lockee);<br>    <span class="hljs-comment">/***********************************/</span><br><br>    <span class="hljs-keyword">int</span> success = <span class="hljs-keyword">false</span>;<br>    uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;<br>    markOop mark = lockee-&gt;mark();<br>    intptr_t hash = (intptr_t) markOopDesc::no_hash;<br><br>    <span class="hljs-comment">/*****************************************************/</span><br>    <span class="hljs-comment">// 如果锁对象的对象头标志是偏向模式,即判断锁标志为101</span><br><br>    <span class="hljs-keyword">if</span> (mark-&gt;has_bias_pattern()) &#123;<br>      uintptr_t thread_ident;<br>      uintptr_t anticipated_bias_locking_value;<br>      thread_ident = (uintptr_t)istate-&gt;thread();<br>      <span class="hljs-comment">// 通过或运算计算anticipated_bias_locking_value</span><br>      anticipated_bias_locking_value =<br>      <span class="hljs-comment">// 将线程id与prototype_header(epoch、分代年龄、偏向模式、锁标志)部分相或</span><br>      (((uintptr_t)lockee-&gt;klass()-&gt;prototype_header() | thread_ident) <br>      <span class="hljs-comment">// 与锁对象的markword异或，相等为0</span><br>          ^ (uintptr_t)mark) <br>      <span class="hljs-comment">// 将上面结果中的分代年龄忽略掉</span><br>      &amp;~((uintptr_t) markOopDesc::age_mask_in_place);<br>      <span class="hljs-comment">// ① 为0代表偏向线程是当前线程 且 对象头的epoch与class的epoch相等，什么也不做</span><br>      <span class="hljs-keyword">if</span>  (anticipated_bias_locking_value == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (PrintBiasedLockingStatistics) &#123;<br>          (* BiasedLocking::biased_lock_entry_count_addr())++;<br>        &#125;<br>        success = <span class="hljs-keyword">true</span>;<br>      &#125;<br>      <span class="hljs-comment">// ② 代表class的prototype_header或对象的mark word中偏向模式是关闭的</span><br>      <span class="hljs-comment">//又因为能走到这已经通过了mark-&gt;has_bias_pattern()判断</span><br>      <span class="hljs-comment">//即对象的mark word中偏向模式是开启的，那也就是说class的prototype_header不是偏向模式。</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// try revoke bias</span><br>        markOop header = lockee-&gt;klass()-&gt;prototype_header();<br>        <span class="hljs-keyword">if</span> (hash != markOopDesc::no_hash) &#123;<br>            header = header-&gt;copy_set_hash(hash);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), mark) == mark) &#123;<br>          <span class="hljs-keyword">if</span> (PrintBiasedLockingStatistics)<br>            (*BiasedLocking::revoked_lock_entry_count_addr())++;<br>        &#125;<br>      &#125;<br><br>        <span class="hljs-comment">/*****************************************************/</span><br>        <span class="hljs-comment">// ③ 锁对象头的 epoch 与 class 的 epoch 不相等，尝试重偏向</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((anticipated_bias_locking_value &amp; epoch_mask_in_place) !=<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// try rebias</span><br>        markOop new_header = (markOop) ( (intptr_t) lockee-&gt;klass()-&gt;prototype_header() | thread_ident);<br>        <span class="hljs-keyword">if</span> (hash != markOopDesc::no_hash) &#123;<br>          new_header = new_header-&gt;copy_set_hash(hash);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Atomic::cmpxchg_ptr((<span class="hljs-keyword">void</span>*)new_header, lockee-&gt;mark_addr(), mark) == mark) &#123;<br>          <span class="hljs-keyword">if</span> (PrintBiasedLockingStatistics)<br>          (* BiasedLocking::rebiased_lock_entry_count_addr())++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 有竞争重偏向失败，调用 monitorenter 锁升级</span><br>          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);<br>        &#125;<br>        success = <span class="hljs-keyword">true</span>;<br>  <br><br>      <span class="hljs-comment">/*****************************************************/</span><br>      <span class="hljs-comment">// ④ 未偏向任何线程或者偏向的不是当前线程，尝试重新偏向</span><br>      <span class="hljs-keyword">else</span> &#123;<br>        markOop header = (markOop) ((uintptr_t) mark &amp; ((uintptr_t)markOopDesc::biased_lock_mask_in_place |<br>                                                        (uintptr_t)markOopDesc::age_mask_in_place |<br>                                                        epoch_mask_in_place));<br>        <span class="hljs-keyword">if</span> (hash != markOopDesc::no_hash) &#123;<br>            header = header-&gt;copy_set_hash(hash);<br>        &#125;<br>        markOop new_header = (markOop) ((uintptr_t) header | thread_ident);<br>        <span class="hljs-comment">// debugging hint</span><br>        DEBUG_ONLY(entry-&gt;lock()-&gt;set_displaced_header((markOop) (uintptr_t) <span class="hljs-number">0xdeaddead</span>);)<br>        <span class="hljs-comment">// CAS 尝试修改</span><br>        <span class="hljs-keyword">if</span> (Atomic::cmpxchg_ptr((<span class="hljs-keyword">void</span>*)new_header, lockee-&gt;mark_addr(), header) == header) &#123;<br>            <span class="hljs-keyword">if</span> (PrintBiasedLockingStatistics)<br>            (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;<br>        &#125;<br>        <span class="hljs-comment">// 有竞争偏向失败，调用 monitorenter 锁升级</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);<br>        &#125;<br>        success = <span class="hljs-keyword">true</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*****************************************************/</span><br>    <span class="hljs-comment">//能走到这说明当前没有开启偏向模式，而不可能出现偏向的不是当前线程的情况</span><br>    <span class="hljs-comment">//那么就走轻量锁的逻辑</span><br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>      <span class="hljs-comment">// 轻量级锁逻辑 start</span><br>      <span class="hljs-comment">// 构造无锁状态 Mark Word 的 copy(Displaced Mark Word)</span><br><br>      <span class="hljs-comment">/**************************************************/</span><br>      <span class="hljs-comment">//如果是第一次获取轻量锁，那么mark()-&gt;set_unlocked()</span><br>      <span class="hljs-comment">//lockee中的markword期望值最后两位必是01（无锁或偏向锁），所以一定会CAS成功</span><br>      markOop displaced = lockee-&gt;mark()-&gt;set_unlocked();<br>      <span class="hljs-comment">/*************************************************/</span><br>      <br>      <span class="hljs-comment">// 将锁记录空间(Lock Record)指向Displaced Mark Word</span><br>      entry-&gt;lock()-&gt;set_displaced_header(displaced);<br>      <span class="hljs-comment">//如果指定了-XX:+UseHeavyMonitors，则call_vm=true，代表禁用偏向锁和轻量级锁</span><br>      bool call_vm = UseHeavyMonitors;<br>      <span class="hljs-keyword">if</span> (call_vm || Atomic::cmpxchg_ptr(entry, lockee-&gt;mark_addr(), displaced) != displaced) &#123;<br>        <span class="hljs-comment">// 判断是不是锁重入，是的话把Displaced Mark Word设置为null来表示重入</span><br>        <span class="hljs-comment">// 置null的原因是因为要记录重入次数，但是mark word大小有限，所以每次重入都在栈帧中新增一个Displaced Mark Word为null的记录</span><br>        <span class="hljs-keyword">if</span> (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced-&gt;clear_lock_bits())) &#123;<br>          entry-&gt;lock()-&gt;set_displaced_header(NULL);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 若禁用则锁升级</span><br>          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);<br>        &#125;<br>      &#125;<br>    &#125;<br>    UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br>  &#125; <br>  <span class="hljs-keyword">else</span> &#123;<br>    istate-&gt;set_msg(more_monitors);<br>    UPDATE_PC_AND_RETURN(<span class="hljs-number">0</span>); <span class="hljs-comment">// Re-execute</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>对偏向锁的获取流程总结如下：</strong></p><ol><li><p>如果当前线程有空闲的LockRecord（LR），那么设置当前使用的LR的<code>owner</code>指针指向当前<code>monitor object</code>（也就相当于添加了一个新的LR到当前线程中）</p></li><li><p>检查monitor object是否处于可偏向状态（在开启偏向锁后，markword中的锁标志默认为可偏向状态，如果存储的线程ID为0，则称其为匿名可偏向状态）</p></li><li><p>如果处于可偏向状态，检查偏向锁偏向的线程是否为当前线程，如果是，那么则执行（6），否则执行（4）</p></li><li><p>如果偏向模式被关闭，那么执行（8）</p></li><li><p>对偏向锁设置重偏向，如果成功，那么则执行（7），否则产生竞争，执行（8）</p></li><li><p>对偏向锁第一次设置偏向线程，如果成功，那么则执行（7），否则产生竞争，执行（8）</p></li><li><p>执行临界区代码</p></li><li><p>进行一系列判断，决定是否能够保留偏向锁，或者升级为轻量级锁</p></li></ol><h3 id="3-1-2-偏向锁的撤销流程"><a href="#3-1-2-偏向锁的撤销流程" class="headerlink" title="3.1.2 偏向锁的撤销流程"></a>3.1.2 偏向锁的撤销流程</h3><p>对于偏向锁获取流程中第（8）步的判断，其执行的检查十分复杂，调用链如下：</p><p>InterpreterRuntime::monitorenter –&gt; ObjectSynchronizer::fast_enter –&gt; BiasedLocking::revoke_and_rebias –&gt; (safepoint调用)BiasedLocking::revoke_bias</p><p>我们着重分析<code>revoke_and_rebias</code>与<code>revoke_bias</code></p><p><code>revoke_bias</code>的部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//源码链接:http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/runtime/biasedLocking.cpp#l146</span><br><span class="hljs-keyword">static</span> BiasedLocking::<span class="hljs-function">Condition <span class="hljs-title">revoke_bias</span><span class="hljs-params">(oop obj, bool allow_rebias, bool is_bulk, JavaThread* requesting_thread)</span> </span>&#123;<br>  markOop mark = obj-&gt;mark();<br>  <span class="hljs-comment">// 如果对象不是偏向锁，直接返回 NOT_BIASED</span><br>  <span class="hljs-keyword">if</span> (!mark-&gt;has_bias_pattern()) &#123;<br>    ...<br>    <span class="hljs-keyword">return</span> BiasedLocking::NOT_BIASED;<br>  &#125;<br><br>  uint age = mark-&gt;age();<br>  <span class="hljs-comment">// 构建两个 mark word，一个是匿名偏向模式（101），一个是无锁模式（001）</span><br>  markOop   biased_prototype = markOopDesc::biased_locking_prototype()-&gt;set_age(age);<br>  markOop unbiased_prototype = markOopDesc::prototype()-&gt;set_age(age);<br><br>  ...<br><br>  JavaThread* biased_thread = mark-&gt;biased_locker();<br>  <span class="hljs-keyword">if</span> (biased_thread == NULL) &#123;<br>     <span class="hljs-comment">// 匿名偏向。当调用锁对象原始的 hashcode() 方法会走到这个逻辑</span><br>     <span class="hljs-comment">// 如果不允许重偏向，则将对象的 mark word 设置为无锁模式</span><br>    <span class="hljs-keyword">if</span> (!allow_rebias) &#123;<br>      obj-&gt;set_mark(unbiased_prototype);<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">return</span> BiasedLocking::BIAS_REVOKED;<br>  &#125;<br><br>  <span class="hljs-comment">// 判断偏向线程是否还存活</span><br>  bool thread_is_alive = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-comment">// 如果当前线程就是偏向线程 </span><br>  <span class="hljs-keyword">if</span> (requesting_thread == biased_thread) &#123;<br>    thread_is_alive = <span class="hljs-keyword">true</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-comment">// 遍历当前 jvm 的所有线程，如果能找到，则说明偏向的线程还存活</span><br>    <span class="hljs-keyword">for</span> (JavaThread* cur_thread = Threads::first(); cur_thread != NULL; cur_thread = cur_thread-&gt;next()) &#123;<br>      <span class="hljs-keyword">if</span> (cur_thread == biased_thread) &#123;<br>        thread_is_alive = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 如果偏向的线程已经不存活了</span><br>  <span class="hljs-keyword">if</span> (!thread_is_alive) &#123;<br>    <span class="hljs-comment">// 如果允许重偏向，则将对象 mark word 设置为匿名偏向状态，否则设置为无锁状态</span><br>    <span class="hljs-keyword">if</span> (allow_rebias) &#123;<br>      obj-&gt;set_mark(biased_prototype);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      obj-&gt;set_mark(unbiased_prototype);<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">return</span> BiasedLocking::BIAS_REVOKED;<br>  &#125;<br><br>  <span class="hljs-comment">// 线程还存活则遍历线程栈中所有的 lock record</span><br>  GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(biased_thread);<br>  BasicLock* highest_lock = NULL;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cached_monitor_info-&gt;length(); i++) &#123;<br>    MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);<br>    <span class="hljs-comment">// 如果能找到对应的 lock record，说明偏向所有者正在持有锁</span><br>    <span class="hljs-keyword">if</span> (mon_info-&gt;owner() == obj) &#123;<br>      ...<br>      <span class="hljs-comment">// 升级为轻量级锁，修改栈中所有关联该锁的 lock record</span><br>      <span class="hljs-comment">// 先处理所有锁重入的情况，轻量级锁的 displaced mark word 为 NULL，表示锁重入</span><br>      markOop mark = markOopDesc::encode((BasicLock*) NULL);<br>      highest_lock = mon_info-&gt;lock();<br>      highest_lock-&gt;set_displaced_header(mark);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      ...<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (highest_lock != NULL) &#123; <br>    <span class="hljs-comment">// highest_lock 如果非空，则它是最早关联该锁的 lock record</span><br>    <span class="hljs-comment">// 这个 lock record 是线程彻底退出该锁的最后一个 lock record</span><br>  <br>    <span class="hljs-comment">//关闭偏向模式，这样后面的线程再次抢锁时直接走轻量锁流程</span><br>    highest_lock-&gt;set_displaced_header(unbiased_prototype);<br>    <span class="hljs-comment">//设置锁对象的markword指向displaced header</span><br>    obj-&gt;release_set_mark(markOopDesc::encode(highest_lock));<br>    ...<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 走到这里说明偏向所有者没有正在持有锁</span><br>    ...<br>    <span class="hljs-keyword">if</span> (allow_rebias) &#123;<br>       <span class="hljs-comment">// 设置为匿名偏向状态</span><br>      obj-&gt;set_mark(biased_prototype);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 将 mark word 设置为无锁状态</span><br>      obj-&gt;set_mark(unbiased_prototype);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> BiasedLocking::BIAS_REVOKED;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述代码中只有一点需要注意：在判断线程是否处于同步状态时，遍历的<code>Lock Record</code>正是线程在获取锁时添加到线程中的只有<code>owner</code>指针的<code>Lock Record</code>。</p><ol><li><p>所以当偏向锁产生锁的竞争时，JVM会首先JVM中所有存活的线程中是否存在偏向锁偏向的线程。如果存在，执行（2），否则执行（4）</p></li><li><p>判断偏向锁偏向的线程当前是否处于同步区，这通过遍历目标线程的<code>Lock Record</code>集合实现（为什么能这么做呢？这跟偏向锁的释放有关，见后文）。如果处于同步区，则执行（3），否则执行（4）</p></li><li><p>将最先关联到线程的<code>Lock Record</code>结构中的<code>Displace markword</code>设置为无锁模式，然后将monitor object对象头的markdown设置为指向<code>Displace markword</code>的指针（处于safepoint，所有线程终止）。至此，完成轻量锁的升级。注意，此时轻量锁的归属权仍然属于原来获得偏向锁的线程</p></li><li><p>如果开启可重偏向，那么则将monitor object对象的markword设置为匿名偏向模式，否则执行（5）</p></li><li><p>将将monitor object对象头的markword设置为无锁模式</p></li></ol><h3 id="3-1-3-偏向锁的释放流程"><a href="#3-1-3-偏向锁的释放流程" class="headerlink" title="3.1.3 偏向锁的释放流程"></a>3.1.3 偏向锁的释放流程</h3><p>偏向锁的释放流程比较简单，只是简单地把添加到线程<code>LockRecord</code>列表中的<code>Lock Record</code>删除，当然这里仅是逻辑删除，将<code>Lock Record</code>的owner指针设为null即可。实现源码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//代码来自：http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1923</span><br>CASE(_monitorexit): &#123;<br>  oop lockee = STACK_OBJECT(-<span class="hljs-number">1</span>);<br>  CHECK_NULL(lockee);<br>  <span class="hljs-comment">// derefing&#x27;s lockee ought to provoke implicit null check</span><br>  <span class="hljs-comment">// find our monitor slot</span><br>  BasicObjectLock* limit = istate-&gt;monitor_base();<br>  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();<br>  <span class="hljs-comment">// 从低往高遍历栈的Lock Record</span><br>  <span class="hljs-keyword">while</span> (most_recent != limit ) &#123;<br>    <span class="hljs-comment">// 如果Lock Record关联的是该锁对象</span><br>    <span class="hljs-keyword">if</span> ((most_recent)-&gt;obj() == lockee) &#123;<br>      BasicLock* lock = most_recent-&gt;lock();<br>      markOop header = lock-&gt;displaced_header();<br>      <span class="hljs-comment">// 释放Lock Record</span><br>      most_recent-&gt;set_obj(NULL);<br>      <span class="hljs-comment">// 如果是偏向模式，仅仅释放Lock Record就好了。否则要走轻量级锁or重量级锁的释放流程</span><br>      <span class="hljs-keyword">if</span> (!lockee-&gt;mark()-&gt;has_bias_pattern()) &#123;<br>        bool call_vm = UseHeavyMonitors;<br>        <span class="hljs-comment">// header!=NULL说明不是重入，则需要将Displaced Mark Word CAS到对象头的Mark Word</span><br>        <span class="hljs-keyword">if</span> (header != NULL || call_vm) &#123;<br>          <span class="hljs-keyword">if</span> (call_vm || Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), lock) != lock) &#123;<br>            <span class="hljs-comment">// CAS失败或者是重量级锁则会走到这里，先将obj还原，然后调用monitorexit方法</span><br>            most_recent-&gt;set_obj(lockee);<br>            CALL_VM(InterpreterRuntime::monitorexit(THREAD, most_recent), handle_exception);<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">//执行下一条命令</span><br>      UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//处理下一条Lock Record</span><br>    most_recent++;<br>  &#125;<br>  <span class="hljs-comment">// Need to throw illegal monitor state exception</span><br>  CALL_VM(InterpreterRuntime::throw_illegal_monitor_state_exception(THREAD), handle_exception);<br>  ShouldNotReachHere();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于偏向锁，代码从低往高的遍历<code>Lock Record</code>，因为加进去的时候就是按照从高往低加入的。它将当前遍历的<code>Lock Record</code>中的owner指针都置为null，表示当前线程释放了偏向锁。这也就是为什么在偏向锁撤销的过程中，通过查看线程中的<code>Lock Record</code>的owner指针是否指向monitor object就能判断当前持有偏向锁的线程是否处于同步区。因为如果不处于同步区，线程肯定会释放将owner置为null偏向锁。</p><h3 id="3-1-4-批量重偏向与撤销"><a href="#3-1-4-批量重偏向与撤销" class="headerlink" title="3.1.4 批量重偏向与撤销"></a>3.1.4 批量重偏向与撤销</h3><p>批量重偏向是指对于大量来自同一个类的锁对象，如果频繁的对这个类的锁对象进行重偏向操作（<strong>在偏向锁模式下抢锁失败才会对重偏向次数计数</strong>），撤销偏向锁的代价也是不能被忽略的。所以如果对一个类的偏向锁撤销次数达到二十次。那么后续使用这种锁的线程都会直接重偏向到目标线程，略去了恢复到匿名偏向状态的过程，这叫<strong>批量重偏向</strong>。</p><p>如果在批量重偏向的基础上，还在对这个这个类的锁对象进行重偏向或者升级锁的操作，重偏向达到40次（20+20）。那么以后这个类生成的锁对象就再也不会有作为偏向锁的机会，直接关闭偏向选项（这叫<strong>批量撤销</strong>，后续新生成的锁对象再不也能作为偏向锁），也就是说批量重偏向只有一次机会。但是如果总的重偏向次数在20次到40次之间，那么经过一段时间，该类的重偏向计数会归为0。之后重复上述的操作。</p><p>那么上述两个操作是如何实现的呢？其实它们是基于Class对象和锁对象头中<code>markword</code>字段中的<code>epoch</code>属性。</p><p>批量重偏向操作开启后，对类C的epcho值加1，以后这个类新生成的对象的mark字段里就是这个epoch值了，同时还要对当前已经获得偏向锁的对象的epoch值加1(通过遍历所有线程中的<code>Lock Record</code>字段中的<code>displace markword</code>并+1)。那么以后有线程再竞争类C的锁对象时，如果有锁对象.epoch!=Class.epoch。说明该锁对象的epoch字段没有更改，也就是说在对epoch+1时，该锁对象没有被使用。竞争这种锁时直接使用CAS替换threadID进行重偏向，，不走撤销这一步。</p><blockquote><p>所以我个人认为，批量重偏向只适用于那些没有被统一修改epoch字段的锁对象</p></blockquote><p>具体的函数调用链为：InterpreterRuntime::monitorenter –&gt; ObjectSynchronizer::fast_enter –&gt; BiasedLocking::revoke_and_rebias –&gt;update_heuristics。下面代码片段是对批量偏向和批量撤销前的阈值判断。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> HeuristicsResult <span class="hljs-title">update_heuristics</span><span class="hljs-params">(oop o, bool allow_rebias)</span> </span>&#123;<br>  markOop mark = o-&gt;mark();<br>  <span class="hljs-comment">// 如果不是偏向模式直接返回</span><br>  <span class="hljs-keyword">if</span> (!mark-&gt;has_bias_pattern()) &#123;<br>    <span class="hljs-keyword">return</span> HR_NOT_BIASED;<br>  &#125;<br> <br>  <span class="hljs-comment">// 获取锁对象的类元数据</span><br>  Klass* k = o-&gt;klass();<br>  <span class="hljs-comment">// 当前时间</span><br>  jlong cur_time = os::javaTimeMillis();<br>  <span class="hljs-comment">// 该类上一次批量重偏向的时间</span><br>  jlong last_bulk_revocation_time = k-&gt;last_biased_lock_bulk_revocation_time();<br>  <span class="hljs-comment">// 该类单个偏向撤销的计数</span><br>  <span class="hljs-keyword">int</span> revocation_count = k-&gt;biased_lock_revocation_count();<br><br>  <span class="hljs-comment">// 按默认参数来说：</span><br>  <span class="hljs-comment">// 如果撤销计数大于等于 20，且小于 40，</span><br>  <span class="hljs-comment">// 且距上次批量撤销的时间大于等于 25 秒，就会重置计数。</span><br>  <span class="hljs-keyword">if</span> ((revocation_count &gt;= BiasedLockingBulkRebiasThreshold) &amp;&amp;<br>      (revocation_count &lt;  BiasedLockingBulkRevokeThreshold) &amp;&amp;<br>      (last_bulk_revocation_time != <span class="hljs-number">0</span>) &amp;&amp;<br>      (cur_time - last_bulk_revocation_time &gt;= BiasedLockingDecayTime)) &#123;<br>    <span class="hljs-comment">// This is the first revocation we&#x27;ve seen in a while of an</span><br>    <span class="hljs-comment">// object of this type since the last time we performed a bulk</span><br>    <span class="hljs-comment">// rebiasing operation. The application is allocating objects in</span><br>    <span class="hljs-comment">// bulk which are biased toward a thread and then handing them</span><br>    <span class="hljs-comment">// off to another thread. We can cope with this allocation</span><br>    <span class="hljs-comment">// pattern via the bulk rebiasing mechanism so we reset the</span><br>    <span class="hljs-comment">// klass&#x27;s revocation count rather than allow it to increase</span><br>    <span class="hljs-comment">// monotonically. If we see the need to perform another bulk</span><br>    <span class="hljs-comment">// rebias operation later, we will, and if subsequently we see</span><br>    <span class="hljs-comment">// many more revocation operations in a short period of time we</span><br>    <span class="hljs-comment">// will completely disable biasing for this type.</span><br>    k-&gt;set_biased_lock_revocation_count(<span class="hljs-number">0</span>);<br>    revocation_count = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (revocation_count &lt;= BiasedLockingBulkRevokeThreshold) &#123;<br>    <span class="hljs-comment">// 自增计数</span><br>    revocation_count = k-&gt;atomic_incr_biased_lock_revocation_count();<br>  &#125;<br>  <span class="hljs-comment">// 此时，如果达到批量撤销阈值，则进行批量撤销。</span><br>  <span class="hljs-keyword">if</span> (revocation_count == BiasedLockingBulkRevokeThreshold) &#123;<br>    <span class="hljs-keyword">return</span> HR_BULK_REVOKE;<br>  &#125;<br>  <span class="hljs-comment">// 此时，如果达到批量重偏向阈值，则进行批量重偏向。</span><br>  <span class="hljs-keyword">if</span> (revocation_count == BiasedLockingBulkRebiasThreshold) &#123;<br>    <span class="hljs-keyword">return</span> HR_BULK_REBIAS;<br>  &#125;<br>  <span class="hljs-comment">// 否则，仅进行单个对象的撤销偏向</span><br>  <span class="hljs-keyword">return</span> HR_SINGLE_REVOKE;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="3-2-轻量锁"><a href="#3-2-轻量锁" class="headerlink" title="3.2 轻量锁"></a>3.2 轻量锁</h2><p>轻量锁是代价比偏向锁稍高的轻量级的锁。那么轻量锁和偏向锁的区别在哪呢？我认为有以下两点：</p><ol><li><p>偏向锁只需要在第一次请求锁使用CAS设置ThreadID，而轻量锁需要在每次请求锁时都使用CAS修改markword</p></li><li><p>偏向锁只适用于一个线程进入临界区，轻量锁适用于多个线程交替地进入临界区（交替是指不会发生争夺锁的冲突）</p></li></ol><h3 id="3-2-1-轻量锁的申请流程"><a href="#3-2-1-轻量锁的申请流程" class="headerlink" title="3.2.1 轻量锁的申请流程"></a>3.2.1 轻量锁的申请流程</h3><p>轻量锁的获取流程比较简单，假设现在有线程A，监视锁lock。</p><p>JVM会在线程A的<code>Lock Record</code>列表中添加一个<code>Lock Record</code>结构。并将其<code>displaced hdr</code>设置为<code>markword</code>无锁状态时的内容。同时JVM会将lock对象的<code>markword</code>修改为指向刚添加的<code>Lock Record</code>的指针。</p><p><strong>并且并且并且，lock的<code>markword</code>最后两位为<code>00</code>，表示轻量锁状态。</strong> 结构如下所示：</p><p><img src="images/light-lock.png" alt="light-lock"></p><p>在具体的JVM中，轻量锁的来源有两处：</p><ol><li>通过偏向锁升级而来</li><li>关闭偏向模式</li></ol><p>这二者的实现方式和偏向锁的获取都在同一个源文件中：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//代码分析摘自：Synchronized 源码分析（http://itliusir.com/2019/11-Synchronized/）</span><br><span class="hljs-comment">//源码地址：http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/interpreter/bytecodeInterpreter.cpp#l1816</span><br><br>CASE(_monitorenter): &#123;<br>  oop lockee = STACK_OBJECT(-<span class="hljs-number">1</span>);<br>  CHECK_NULL(lockee);<br>  <span class="hljs-comment">// 寻找空闲的锁记录(Lock Record) 空间</span><br>  BasicObjectLock* limit = istate-&gt;monitor_base();<br>  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();<br>  BasicObjectLock* entry = NULL;<br>  <span class="hljs-keyword">while</span> (most_recent != limit ) &#123;<br>    <span class="hljs-keyword">if</span> (most_recent-&gt;obj() == NULL) entry = most_recent;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (most_recent-&gt;obj() == lockee) <span class="hljs-keyword">break</span>;<br>    most_recent++;<br>  &#125;<br>  <span class="hljs-comment">// 存在空闲的Lock Record</span><br>  <span class="hljs-keyword">if</span> (entry != NULL) &#123;<br>    <span class="hljs-comment">/***********************************/</span><br>    <span class="hljs-comment">// 设置Lock Record 的 obj指针(owner)指向锁对象(monitor object)</span><br>    <span class="hljs-comment">//这句代码完成了线程每次获取锁时向LR集合中插入新LR的动作</span><br>    entry-&gt;set_obj(lockee);<br>    <span class="hljs-comment">/***********************************/</span><br><br>    <span class="hljs-keyword">int</span> success = <span class="hljs-keyword">false</span>;<br>    uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;<br>    markOop mark = lockee-&gt;mark();<br>    intptr_t hash = (intptr_t) markOopDesc::no_hash;<br><br>    <span class="hljs-comment">/*****************************************************/</span><br>    <span class="hljs-comment">// 如果锁对象的对象头标志是偏向模式(1 01)</span><br>    <span class="hljs-keyword">if</span> (mark-&gt;has_bias_pattern()) &#123;<br>      uintptr_t thread_ident;<br>      uintptr_t anticipated_bias_locking_value;<br>      thread_ident = (uintptr_t)istate-&gt;thread();<br>      <span class="hljs-comment">// 通过位运算计算anticipated_bias_locking_value</span><br>      anticipated_bias_locking_value =<br>        <span class="hljs-comment">// 将线程id与prototype_header(epoch、分代年龄、偏向模式、锁标志)部分相或</span><br>        (((uintptr_t)lockee-&gt;klass()-&gt;prototype_header() | thread_ident) <br>        <span class="hljs-comment">// 与锁对象的markword异或，相等为0</span><br>         ^ (uintptr_t)mark) <br>        <span class="hljs-comment">// 将上面结果中的分代年龄忽略掉</span><br>        &amp;~((uintptr_t) markOopDesc::age_mask_in_place);<br>        <span class="hljs-comment">// ① 为0代表偏向线程是当前线程 且 对象头的epoch与class的epoch相等，什么也不做</span><br>        ...<br>      <span class="hljs-comment">// ② 偏向模式关闭，则尝试撤销(0 01)</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// try revoke bias</span><br>        markOop header = lockee-&gt;klass()-&gt;prototype_header();<br>        <span class="hljs-keyword">if</span> (hash != markOopDesc::no_hash) &#123;<br>          header = header-&gt;copy_set_hash(hash);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), mark) == mark) &#123;<br>          <span class="hljs-keyword">if</span> (PrintBiasedLockingStatistics)<br>            (*BiasedLocking::revoked_lock_entry_count_addr())++;<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-comment">/*****************************************************/</span><br>      <span class="hljs-comment">// ③ 锁对象头的 epoch 与 class 的 epoch 不相等，尝试重偏向</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((anticipated_bias_locking_value &amp; epoch_mask_in_place) !=<span class="hljs-number">0</span>) &#123;<br>        ...<br>        <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 有竞争重偏向失败，调用 monitorenter 锁升级</span><br>          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);<br>        &#125;<br>        success = <span class="hljs-keyword">true</span>;<br>      &#125;<br><br>      <span class="hljs-comment">/*****************************************************/</span><br>      <span class="hljs-comment">// ④ 未偏向任何线程，尝试偏向</span><br>      <span class="hljs-keyword">else</span> &#123;<br>        markOop header = (markOop) ((uintptr_t) mark &amp; ((uintptr_t)markOopDesc::biased_lock_mask_in_place |<br>                                                        (uintptr_t)markOopDesc::age_mask_in_place |<br>                                                        epoch_mask_in_place));<br>        ...<br>        <span class="hljs-comment">// 有竞争偏向失败，调用 monitorenter 锁升级</span><br>        <span class="hljs-keyword">else</span> &#123;<br>          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);<br>        &#125;<br>        success = <span class="hljs-keyword">true</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*****************************************************/</span><br>    <span class="hljs-comment">// 走到这里说明没有开启偏向锁等原因</span><br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>      <span class="hljs-comment">// 轻量级锁逻辑 start</span><br>      <span class="hljs-comment">// 构造无锁状态 Mark Word 的 copy(Displaced Mark Word)</span><br>      <span class="hljs-comment">// 注意displaced markword是无锁状态!无锁状态!无锁状态！</span><br>      markOop displaced = lockee-&gt;mark()-&gt;set_unlocked();<br>      <span class="hljs-comment">// 将锁记录空间(Lock Record)的Displaced Mark Word设为无锁状态markword</span><br>      entry-&gt;lock()-&gt;set_displaced_header(displaced);<br>      <span class="hljs-comment">// 是否禁用偏向锁和轻量级锁</span><br>      bool call_vm = UseHeavyMonitors;<br>      <span class="hljs-comment">// exchange ,addr,compare</span><br>      <span class="hljs-comment">//return compare value</span><br>      <span class="hljs-keyword">if</span> (call_vm || Atomic::cmpxchg_ptr(entry, lockee-&gt;mark_addr(), displaced) != displaced) &#123;<br>        <span class="hljs-comment">// 判断是不是锁重入，是的话把Displaced Mark Word设置为null来表示重入</span><br>        <span class="hljs-comment">// 置null的原因是因为要记录重入次数，但是mark word大小有限，所以每次重入都在栈帧中新增一个Displaced Mark Word为null的记录</span><br>        <span class="hljs-keyword">if</span> (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced-&gt;clear_lock_bits())) &#123;<br>          entry-&gt;lock()-&gt;set_displaced_header(NULL);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 若禁用则锁升级</span><br>          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);<br>        &#125;<br>      &#125;<br>    &#125;<br>    UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    istate-&gt;set_msg(more_monitors);<br>    UPDATE_PC_AND_RETURN(<span class="hljs-number">0</span>); <span class="hljs-comment">// Re-execute</span><br>  &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>通过上面的源码我们能够知道：</p><p>如果没有开启偏向模式，JVM会初次构造轻量级锁，也就是执行<code>if (!success)&#123;...&#125;</code>后的内容第一次申请轻量锁，如果此时的请求是重入，那么则会在当前线程的<code>Lock Record</code>列表中插入一个新的<code>Lock Record</code>，其中<code>displaced hdr</code>指向null，这么做的原因是因为要记录重入次数。如果此时还发生锁竞争，那么则会调用<code>CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception)</code>升级成重量锁。</p><p>如果偏向锁偏向失败，会调用<code>CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception)</code>决定要不要升级成轻量锁。这部分的代码在偏向锁的撤销中都有提及过。</p><hr><p><strong>存在的问题：</strong></p><p><strong>Q1：在代码中，到底在什么时候将lock对象的<code>markword</code>最后两位设置为<code>00</code>？</strong></p><p>我阅读了很久的源码，都没有发现设置的地方，网上有人说是通过<a href="https://github.com/farmerjohngit/myblog/issues/14">字节填充对齐来解决的</a>。然而我不是很懂。</p><p>也就是说：执行<code>Atomic::cmpxchg_ptr(entry, lockee-&gt;mark_addr(), displaced)</code>时，entry是一个四字节的指针，由于对齐操作，entry的第31~32bit一定为<code>00</code>，如果CAS成功，那么锁对象头的<code>markword</code>就指向了栈中的<code>Lock Record</code>。</p><p><strong>Q2：在轻量锁状态时，CAS算法如何保证锁互斥的获取？</strong></p><p>首先，我们看看核心代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//code1</span><br>markOop displaced = lockee-&gt;mark()-&gt;set_unlocked();<br><span class="hljs-comment">//</span><br>entry-&gt;lock()-&gt;set_displaced_header(displaced);<br><span class="hljs-comment">// 是否禁用偏向锁和轻量级锁</span><br>bool call_vm = UseHeavyMonitors;<br><span class="hljs-comment">//code2</span><br><span class="hljs-keyword">if</span> (call_vm || Atomic::cmpxchg_ptr(entry, lockee-&gt;mark_addr(), displaced) != displaced) &#123;...&#125;<br></code></pre></div></td></tr></table></figure><p>CAS算法需要预期的值和目标修改值。预期值就是上述代码中的<code>displaced</code>。而这个<code>displaced</code>是如何构造出来的呢？见如下代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> </span>&#123; <br>    locked_value             = <span class="hljs-number">0</span>,<br>    unlocked_value           = <span class="hljs-number">1</span>,<br>    monitor_value            = <span class="hljs-number">2</span>,<br>    marked_value             = <span class="hljs-number">3</span>,<br>    biased_lock_pattern      = <span class="hljs-number">5</span><br>&#125;;<br><span class="hljs-function">markOop <span class="hljs-title">set_unlocked</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> markOop(value() | unlocked_value);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>lock</code>就是当前的锁对象，调用<code>set_unlocked()</code>后，会将当前对象头的<code>markword</code>(上述代码中的<code>value()</code>)与<code>unlocked_value</code>进行<strong>或</strong>操作。这样就能构造出一个无锁状态的<code>markword</code>（也就是最后两位为<code>01</code>）。所以CAS算法的旧预期值displaced<strong>肯定</strong>是一个无锁状态的<code>markword</code>，这跟锁对象的锁状态没有关系。</p><p>假设现在有threadA，<strong>第一次</strong>请求轻量锁时，锁对象头的<code>markword</code>第31~32位一定是<code>01</code>（因为如果走到这个CAS，锁对象头的markword一定是无锁状态）。<code>lockee-&gt;mark()</code>(CAS的真实值)与<code>displaced</code>(CAS的预期值)1~30位bit一定是相同的，因为<code>displaced</code>只改变了<code>lockee-&gt;mark()</code>的第32位bit。所以CAS算法的预期值和实际值符合，threadA成功获取锁。</p><p>在threadA执行同步区的过程中，如果有threadB请求轻量锁，因为<code>lockee-&gt;mark()</code>最后两位一定为<code>00</code>(详情见Q1)，但是我们构建的预期值<code>displaced</code>最后两位一定为<code>01</code>。所以CAS算法调用失败，保证了轻量锁的互斥获取。</p><hr><h3 id="3-2-2-轻量锁的释放流程"><a href="#3-2-2-轻量锁的释放流程" class="headerlink" title="3.2.2 轻量锁的释放流程"></a>3.2.2 轻量锁的释放流程</h3><p>轻量锁的释放只需要使用CAS算法将请求锁时，添加的<code>Lock Record</code>的<code>displaced markword</code>复制到锁对象头的<code>markword</code>即可，复制完成后，锁对象目前的状态是<code>001</code>，无锁状态。如果失败，则说明有锁竞争，会调用重锁的退出方法<code>monitorexit</code>。</p><p>轻量锁的释放代码和偏向锁的释放代码糅合在一起，详情见如下代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">CASE(_monitorexit): &#123;<br>  oop lockee = STACK_OBJECT(-<span class="hljs-number">1</span>);<br>  CHECK_NULL(lockee);<br>  <span class="hljs-comment">// derefing&#x27;s lockee ought to provoke implicit null check</span><br>  <span class="hljs-comment">// find our monitor slot</span><br>  BasicObjectLock* limit = istate-&gt;monitor_base();<br>  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();<br>  <span class="hljs-comment">// 从低往高遍历栈的Lock Record</span><br>  <span class="hljs-keyword">while</span> (most_recent != limit ) &#123;<br>    <span class="hljs-comment">// 如果Lock Record关联的是该锁对象</span><br>    <span class="hljs-keyword">if</span> ((most_recent)-&gt;obj() == lockee) &#123;<br>      BasicLock* lock = most_recent-&gt;lock();<br>      markOop header = lock-&gt;displaced_header();<br>      <span class="hljs-comment">// 释放Lock Record</span><br>      most_recent-&gt;set_obj(NULL);<br>      <span class="hljs-comment">// 如果是偏向模式，仅仅释放Lock Record就好了。否则要走轻量级锁or重量级锁的释放流程</span><br>      <span class="hljs-keyword">if</span> (!lockee-&gt;mark()-&gt;has_bias_pattern()) &#123;<br>        bool call_vm = UseHeavyMonitors;<br>        <span class="hljs-comment">// header!=NULL说明不是重入，则需要将Displaced Mark Word CAS到对象头的Mark Word</span><br>        <span class="hljs-keyword">if</span> (header != NULL || call_vm) &#123;<br>          <span class="hljs-keyword">if</span> (call_vm || Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), lock) != lock) &#123;<br>            <span class="hljs-comment">// CAS失败或者是重量级锁则会走到这里，先将obj还原，然后调用monitorexit方法</span><br>            most_recent-&gt;set_obj(lockee);<br>            CALL_VM(InterpreterRuntime::monitorexit(THREAD, most_recent), handle_exception);<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">//执行下一条命令</span><br>      UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//处理下一条Lock Record</span><br>    most_recent++;<br>  &#125;<br>  <span class="hljs-comment">// Need to throw illegal monitor state exception</span><br>  CALL_VM(InterpreterRuntime::throw_illegal_monitor_state_exception(THREAD), handle_exception);<br>  ShouldNotReachHere();<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-3-重量锁"><a href="#3-3-重量锁" class="headerlink" title="3.3 重量锁"></a>3.3 重量锁</h2><p>重量级锁就是使用<code>objectmonitor</code>（使用操作系统的mutex）完成同步的工具。</p><h3 id="3-3-1-重量锁的获取流程"><a href="#3-3-1-重量锁的获取流程" class="headerlink" title="3.3.1 重量锁的获取流程"></a>3.3.1 重量锁的获取流程</h3><p>获取重量锁的地方有两个：</p><ol><li>如果在<code>fast_enter</code>中偏向锁升级轻量级锁失败，那么会调用<code>slow_enter</code></li><li>在不开启偏向模式的情况下，直接调用<code>slow_enter</code>。在<code>slow_enter</code>中先尝试是否能够使用轻量级锁，如果失败，则直接调用<code>inflate</code>方法直接膨胀为重量级锁</li></ol><p>我们知道，重锁是需要一个<code>objectmonitor</code>维护互斥锁的。这个对象就是<code>inflate</code>中构建的。<code>inflate</code>主要流程如下：</p><ol><li>如果锁已经达到重量级状态，则直接返回</li><li>如果是轻量级锁状态，那么则需要膨胀，包括设置一些record</li><li>如果锁是膨胀中状态，那么则通过<strong>自旋</strong>操作完成忙等待</li><li>如果是无锁状态，那么则需要进行膨胀</li></ol><p>锁膨胀完成后，那么各个线程则尝试通过调用<code>enter</code>方法获取锁进入临界区，分析如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> ATTR ObjectMonitor::enter(TRAPS) &#123;<br>   <br>  Thread * <span class="hljs-keyword">const</span> Self = THREAD ;<br>  <span class="hljs-keyword">void</span> * cur ;<br>  <span class="hljs-comment">// owner为null代表无锁状态，如果能CAS设置成功，则当前线程直接获得锁</span><br>  cur = Atomic::cmpxchg_ptr (Self, &amp;_owner, NULL) ;<br>  <span class="hljs-keyword">if</span> (cur == NULL) &#123;<br>     ...<br>     <span class="hljs-keyword">return</span> ;<br>  &#125;<br>  <span class="hljs-comment">// 如果是重入的情况</span><br>  <span class="hljs-keyword">if</span> (cur == Self) &#123;<br>     <span class="hljs-comment">// TODO-<span class="hljs-doctag">FIXME:</span> check for integer overflow!  BUGID 6557169.</span><br>     _recursions ++ ;<br>     <span class="hljs-keyword">return</span> ;<br>  &#125;<br>  <span class="hljs-comment">// 当前线程是之前持有轻量级锁的线程。由轻量级锁膨胀且第一次调用enter方法，那cur是指向Lock Record的指针</span><br>  <span class="hljs-keyword">if</span> (Self-&gt;is_lock_owned ((address)cur)) &#123;<br>    <span class="hljs-keyword">assert</span> (_recursions == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;internal state error&quot;</span>);<br>    <span class="hljs-comment">// 重入计数重置为1</span><br>    _recursions = <span class="hljs-number">1</span> ;<br>    <span class="hljs-comment">// 设置owner字段为当前线程（之前owner是指向Lock Record的指针）</span><br>    _owner = Self ;<br>    OwnerIsThread = <span class="hljs-number">1</span> ;<br>    <span class="hljs-keyword">return</span> ;<br>  &#125;<br><br>  ...<br><br>  <span class="hljs-comment">// 在调用系统的同步操作之前，先尝试自旋获得锁</span><br>  <span class="hljs-keyword">if</span> (Knob_SpinEarly &amp;&amp; TrySpin (Self) &gt; <span class="hljs-number">0</span>) &#123;<br>     ...<br>     <span class="hljs-comment">//自旋的过程中获得了锁，则直接返回</span><br>     Self-&gt;_Stalled = <span class="hljs-number">0</span> ;<br>     <span class="hljs-keyword">return</span> ;<br>  &#125;<br><br>  ...<br><br>  &#123; <br>    ...<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      jt-&gt;set_suspend_equivalent();<br>      <span class="hljs-comment">// 在该方法中调用系统同步操作</span><br>      EnterI (THREAD) ;<br>      ...<br>    &#125;<br>    Self-&gt;set_current_pending_monitor(NULL);<br>    <br>  &#125;<br><br>  ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在<code>enter()</code>中，只能完成三种获取锁的动作，包括无锁状态获取锁（即锁没有被占有）、通过轻量级锁升级来获取锁、重入锁这三种情况。超出这三种情况，需要调用<code>enterI()</code>完成系统同步的操作。当然在调用系统同步操作之前，会尝试自旋获取锁。</p><p>在前面说过，监视锁<code>objectmonitor</code>维护了两个队列<code>_EntryList</code>、<code>_WaitList</code>用来保存被阻塞等待锁的线程和主动调用<code>wait()</code>等待锁的线程。其实在源码中， <code>objectmonitor</code> 还维护了一个队列<code>_cxq</code>,用来给<code>_EntryList</code>提供被阻塞的线程。这三者的关系如下图所示：</p><p><img src="images/synchronized.png" alt="syn"></p><p>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到cxq队列的队首，然后调用park函数挂起当前线程。在linux系统上，park函数底层调用的是gclib库的pthread_cond_wait。</p><p>当线程释放锁时，会从cxq或EntryList中挑选一个线程唤醒，被选中的线程叫做Heir presumptive即假定继承人（即图中的ready thread），假定继承人被唤醒后会尝试获得锁，但synchronized是非公平的，所以假定继承人不一定能获得锁（这也是它叫”假定”继承人的原因）。</p><p>如果线程获得锁后调用Object.wait方法，则会将线程加入到WaitSet中，当被Object#notify唤醒后，会将线程从WaitSet移动到cxq或EntryList中去。需要注意的是，<strong>当调用一个锁对象的wait或notify方法时，如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁。</strong> 源码分析如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> ATTR ObjectMonitor::EnterI (TRAPS) &#123;<br>    Thread * Self = THREAD ;<br>    ...<br>    <span class="hljs-comment">// 尝试获得锁</span><br>    <span class="hljs-keyword">if</span> (TryLock (Self) &gt; <span class="hljs-number">0</span>) &#123;<br>        ...<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    DeferredInitialize () ;<br> <br><span class="hljs-comment">// 自旋</span><br>    <span class="hljs-keyword">if</span> (TrySpin (Self) &gt; <span class="hljs-number">0</span>) &#123;<br>        ...<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <br>    ...<br><br>    <span class="hljs-comment">// 将线程封装成node节点中</span><br>    <span class="hljs-function">ObjectWaiter <span class="hljs-title">node</span><span class="hljs-params">(Self)</span> </span>;<br>    Self-&gt;_ParkEvent-&gt;reset() ;<br>    node._prev   = (ObjectWaiter *) <span class="hljs-number">0xBAD</span> ;<br>    node.TState  = ObjectWaiter::TS_CXQ ;<br><br>    <span class="hljs-comment">// 将node节点插入到_cxq队列的头部，cxq是一个单向链表</span><br>    ObjectWaiter * nxt ;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        node._next = nxt = _cxq ;<br>        <span class="hljs-keyword">if</span> (Atomic::cmpxchg_ptr (&amp;node, &amp;_cxq, nxt) == nxt) <span class="hljs-keyword">break</span> ;<br><br>        <span class="hljs-comment">// CAS失败的话 再尝试获得锁，这样可以降低插入到_cxq队列的频率</span><br>        <span class="hljs-keyword">if</span> (TryLock (Self) &gt; <span class="hljs-number">0</span>) &#123;<br>            ...<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// SyncFlags默认为0，如果没有其他等待的线程，则将_Responsible设置为自己</span><br>    <span class="hljs-keyword">if</span> ((SyncFlags &amp; <span class="hljs-number">16</span>) == <span class="hljs-number">0</span> &amp;&amp; nxt == NULL &amp;&amp; _EntryList == NULL) &#123;<br>        Atomic::cmpxchg_ptr (Self, &amp;_Responsible, NULL) ;<br>    &#125;<br><br><br>    TEVENT (Inflated enter - Contention) ;<br>    <span class="hljs-keyword">int</span> nWakeups = <span class="hljs-number">0</span> ;<br>    <span class="hljs-keyword">int</span> RecheckInterval = <span class="hljs-number">1</span> ;<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br><br>        <span class="hljs-keyword">if</span> (TryLock (Self) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span> ;<br>        <span class="hljs-keyword">assert</span> (_owner != Self, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br><br>        ...<br><br>        <span class="hljs-comment">// park self</span><br>        <span class="hljs-keyword">if</span> (_Responsible == Self || (SyncFlags &amp; <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-comment">// 当前线程是_Responsible时，调用的是带时间参数的park</span><br>            TEVENT (Inflated enter - park TIMED) ;<br>            Self-&gt;_ParkEvent-&gt;park ((jlong) RecheckInterval) ;<br>            <span class="hljs-comment">// Increase the RecheckInterval, but clamp the value.</span><br>            RecheckInterval *= <span class="hljs-number">8</span> ;<br>            <span class="hljs-keyword">if</span> (RecheckInterval &gt; <span class="hljs-number">1000</span>) RecheckInterval = <span class="hljs-number">1000</span> ;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//否则直接调用park挂起当前线程</span><br>            TEVENT (Inflated enter - park UNTIMED) ;<br>            Self-&gt;_ParkEvent-&gt;park() ;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (TryLock(Self) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span> ;<br><br>        ...<br>        <br>        <span class="hljs-keyword">if</span> ((Knob_SpinAfterFutile &amp; <span class="hljs-number">1</span>) &amp;&amp; TrySpin (Self) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span> ;<br><br>       ...<br>        <span class="hljs-comment">// 在释放锁时，_succ会被设置为EntryList或_cxq中的一个线程</span><br>        <span class="hljs-keyword">if</span> (_succ == Self) _succ = NULL ;<br><br>        <span class="hljs-comment">// Invariant: after clearing _succ a thread *must* retry _owner before parking.</span><br>        OrderAccess::fence() ;<br>    &#125;<br><br>   <span class="hljs-comment">// 走到这里说明已经获得锁了</span><br><br>    <span class="hljs-keyword">assert</span> (_owner == Self      , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>    <span class="hljs-keyword">assert</span> (object() != NULL    , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>  <br><span class="hljs-comment">// 将当前线程的node从cxq或EntryList中移除</span><br>    UnlinkAfterAcquire (Self, &amp;node) ;<br>    <span class="hljs-keyword">if</span> (_succ == Self) _succ = NULL ;<br><span class="hljs-keyword">if</span> (_Responsible == Self) &#123;<br>        _Responsible = NULL ;<br>        OrderAccess::fence();<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>主要步骤有3步：</p><ol><li>将当前线程插入到cxq队列的队首</li><li>然后park当前线程</li><li>当被唤醒后再尝试获得锁</li></ol><p>这里需要特别说明的是_Responsible和_succ两个字段的作用：</p><p>当竞争发生时，选取一个线程作为_Responsible，_Responsible线程调用的是有时间限制的park方法，其目的是防止出现搁浅现象。</p><p>_succ线程是在线程释放锁是被设置，其含义是Heir presumptive，也就是我们上面说的假定继承人。</p><h3 id="3-3-2-重量锁的释放流程"><a href="#3-3-2-重量锁的释放流程" class="headerlink" title="3.3.2 重量锁的释放流程"></a>3.3.2 重量锁的释放流程</h3><p>重量级锁释放的代码在ObjectMonitor::exit,在释放锁时，JVM需要提供下一个需要准备获取锁的线程（如果有线程需要的话），代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> ATTR ObjectMonitor::exit(bool not_suspended, TRAPS) &#123;<br>   Thread * Self = THREAD ;<br>   <span class="hljs-comment">// 如果_owner不是当前线程</span><br>   <span class="hljs-keyword">if</span> (THREAD != _owner) &#123;<br>     <span class="hljs-comment">// 当前线程是之前持有轻量级锁的线程。由轻量级锁膨胀后还没调用过enter方法，_owner会是指向Lock Record的指针。</span><br>     <span class="hljs-keyword">if</span> (THREAD-&gt;is_lock_owned((address) _owner)) &#123;<br>       <span class="hljs-keyword">assert</span> (_recursions == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>       _owner = THREAD ;<br>       _recursions = <span class="hljs-number">0</span> ;<br>       OwnerIsThread = <span class="hljs-number">1</span> ;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-comment">// 异常情况:当前不是持有锁的线程</span><br>       TEVENT (Exit - Throw IMSX) ;<br>       <span class="hljs-keyword">assert</span>(<span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;Non-balanced monitor enter/exit!&quot;</span>);<br>       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">false</span>) &#123;<br>          THROW(vmSymbols::java_lang_IllegalMonitorStateException());<br>       &#125;<br>       <span class="hljs-keyword">return</span>;<br>     &#125;<br>   &#125;<br>   <span class="hljs-comment">// 重入计数器还不为0，则计数器-1后返回</span><br>   <span class="hljs-keyword">if</span> (_recursions != <span class="hljs-number">0</span>) &#123;<br>     _recursions--;        <span class="hljs-comment">// this is simple recursive enter</span><br>     TEVENT (Inflated exit - recursive) ;<br>     <span class="hljs-keyword">return</span> ;<br>   &#125;<br><br>   <span class="hljs-comment">// _Responsible设置为null</span><br>   <span class="hljs-keyword">if</span> ((SyncFlags &amp; <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>) &#123;<br>      _Responsible = NULL ;<br>   &#125;<br><br>   ...<br><br>   <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-keyword">assert</span> (THREAD == _owner, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br><br>      <span class="hljs-comment">// Knob_ExitPolicy默认为0</span><br>      <span class="hljs-keyword">if</span> (Knob_ExitPolicy == <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-comment">// code 1：先释放锁，这时如果有其他线程进入同步块则能获得锁</span><br>         OrderAccess::release_store_ptr (&amp;_owner, NULL) ;   <span class="hljs-comment">// drop the lock</span><br>         OrderAccess::storeload() ;                         <span class="hljs-comment">// See if we need to wake a successor</span><br>         <span class="hljs-comment">// code 2：如果没有等待的线程或已经有假定继承人</span><br>         <span class="hljs-comment">//有假定继承人表示可能会选择假定继承人作为唤醒对象，以便争夺锁</span><br>         <span class="hljs-keyword">if</span> ((intptr_t(_EntryList)|intptr_t(_cxq)) == <span class="hljs-number">0</span> || _succ != NULL) &#123;<br>            TEVENT (Inflated exit - simple egress) ;<br>            <span class="hljs-keyword">return</span> ;<br>         &#125;<br>         TEVENT (Inflated exit - complex egress) ;<br><br>         <span class="hljs-comment">// code 3：要执行之后的操作需要重新获得锁，即设置_owner为当前线程</span><br>         <span class="hljs-keyword">if</span> (Atomic::cmpxchg_ptr (THREAD, &amp;_owner, NULL) != NULL) &#123;<br>            <span class="hljs-keyword">return</span> ;<br>         &#125;<br>         TEVENT (Exit - Reacquired) ;<br>      &#125; <br>      ...<br><br>      ObjectWaiter * w = NULL ;<br>      <span class="hljs-comment">// code 4：根据QMode的不同会有不同的唤醒策略，默认为0</span><br>      <span class="hljs-keyword">int</span> QMode = Knob_QMode ;<br>      <span class="hljs-keyword">if</span> (QMode == <span class="hljs-number">2</span> &amp;&amp; _cxq != NULL) &#123;<br>          <span class="hljs-comment">// QMode == 2 : cxq中的线程有更高优先级，直接唤醒cxq的队首线程</span><br>          w = _cxq ;<br>          <span class="hljs-keyword">assert</span> (w != NULL, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>          <span class="hljs-keyword">assert</span> (w-&gt;TState == ObjectWaiter::TS_CXQ, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>          ExitEpilog (Self, w) ;<br>          <span class="hljs-keyword">return</span> ;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (QMode == <span class="hljs-number">3</span> &amp;&amp; _cxq != NULL) &#123;<br>          <span class="hljs-comment">// 将cxq中的元素插入到EntryList的末尾</span><br>          w = _cxq ;<br>          <span class="hljs-keyword">for</span> (;;) &#123;<br>             <span class="hljs-keyword">assert</span> (w != NULL, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>             ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL, &amp;_cxq, w) ;<br>             <span class="hljs-keyword">if</span> (u == w) <span class="hljs-keyword">break</span> ;<br>             w = u ;<br>          &#125;<br>          <span class="hljs-keyword">assert</span> (w != NULL              , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br><br>          ObjectWaiter * q = NULL ;<br>          ObjectWaiter * p ;<br>          <span class="hljs-keyword">for</span> (p = w ; p != NULL ; p = p-&gt;_next) &#123;<br>              guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>              p-&gt;TState = ObjectWaiter::TS_ENTER ;<br>              p-&gt;_prev = q ;<br>              q = p ;<br>          &#125;<br><br>          <span class="hljs-comment">// Append the RATs to the EntryList</span><br>          <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> organize EntryList as a CDLL so we can locate the tail in constant-time.</span><br>          ObjectWaiter * Tail ;<br>          <span class="hljs-keyword">for</span> (Tail = _EntryList ; Tail != NULL &amp;&amp; Tail-&gt;_next != NULL ; Tail = Tail-&gt;_next) ;<br>          <span class="hljs-keyword">if</span> (Tail == NULL) &#123;<br>              _EntryList = w ;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              Tail-&gt;_next = w ;<br>              w-&gt;_prev = Tail ;<br>          &#125;<br><br>          <span class="hljs-comment">// Fall thru into code that tries to wake a successor from EntryList</span><br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (QMode == <span class="hljs-number">4</span> &amp;&amp; _cxq != NULL) &#123;<br>          <span class="hljs-comment">// 将cxq插入到EntryList的队首</span><br>          w = _cxq ;<br>          <span class="hljs-keyword">for</span> (;;) &#123;<br>             <span class="hljs-keyword">assert</span> (w != NULL, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>             ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL, &amp;_cxq, w) ;<br>             <span class="hljs-keyword">if</span> (u == w) <span class="hljs-keyword">break</span> ;<br>             w = u ;<br>          &#125;<br>          <span class="hljs-keyword">assert</span> (w != NULL              , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br><br>          ObjectWaiter * q = NULL ;<br>          ObjectWaiter * p ;<br>          <span class="hljs-keyword">for</span> (p = w ; p != NULL ; p = p-&gt;_next) &#123;<br>              guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>              p-&gt;TState = ObjectWaiter::TS_ENTER ;<br>              p-&gt;_prev = q ;<br>              q = p ;<br>          &#125;<br><br>          <span class="hljs-comment">// Prepend the RATs to the EntryList</span><br>          <span class="hljs-keyword">if</span> (_EntryList != NULL) &#123;<br>              q-&gt;_next = _EntryList ;<br>              _EntryList-&gt;_prev = q ;<br>          &#125;<br>          _EntryList = w ;<br><br>          <span class="hljs-comment">// Fall thru into code that tries to wake a successor from EntryList</span><br>      &#125;<br><br>      w = _EntryList  ;<br>      <span class="hljs-keyword">if</span> (w != NULL) &#123;<br>          <span class="hljs-comment">// 如果EntryList不为空，则直接唤醒EntryList的队首元素</span><br>          <span class="hljs-keyword">assert</span> (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>          ExitEpilog (Self, w) ;<br>          <span class="hljs-keyword">return</span> ;<br>      &#125;<br><br>      <span class="hljs-comment">// EntryList为null，则处理cxq中的元素</span><br>      w = _cxq ;<br>      <span class="hljs-keyword">if</span> (w == NULL) <span class="hljs-keyword">continue</span> ;<br><br>      <span class="hljs-comment">// 因为之后要将cxq的元素移动到EntryList，所以这里将cxq字段设置为null</span><br>      <span class="hljs-keyword">for</span> (;;) &#123;<br>          <span class="hljs-keyword">assert</span> (w != NULL, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>          ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL, &amp;_cxq, w) ;<br>          <span class="hljs-keyword">if</span> (u == w) <span class="hljs-keyword">break</span> ;<br>          w = u ;<br>      &#125;<br>      TEVENT (Inflated exit - drain cxq into EntryList) ;<br><br>      <span class="hljs-keyword">assert</span> (w != NULL              , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>      <span class="hljs-keyword">assert</span> (_EntryList  == NULL    , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br><br><br>      <span class="hljs-keyword">if</span> (QMode == <span class="hljs-number">1</span>) &#123;<br>         <span class="hljs-comment">// QMode == 1 : 将cxq中的元素转移到EntryList，并反转顺序</span><br>         ObjectWaiter * s = NULL ;<br>         ObjectWaiter * t = w ;<br>         ObjectWaiter * u = NULL ;<br>         <span class="hljs-keyword">while</span> (t != NULL) &#123;<br>             guarantee (t-&gt;TState == ObjectWaiter::TS_CXQ, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>             t-&gt;TState = ObjectWaiter::TS_ENTER ;<br>             u = t-&gt;_next ;<br>             t-&gt;_prev = u ;<br>             t-&gt;_next = s ;<br>             s = t;<br>             t = u ;<br>         &#125;<br>         _EntryList  = s ;<br>         <span class="hljs-keyword">assert</span> (s != NULL, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">// QMode == 0 or QMode == 2‘</span><br>         <span class="hljs-comment">// 将cxq中的元素转移到EntryList</span><br>         _EntryList = w ;<br>         ObjectWaiter * q = NULL ;<br>         ObjectWaiter * p ;<br>         <span class="hljs-keyword">for</span> (p = w ; p != NULL ; p = p-&gt;_next) &#123;<br>             guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>             p-&gt;TState = ObjectWaiter::TS_ENTER ;<br>             p-&gt;_prev = q ;<br>             q = p ;<br>         &#125;<br>      &#125;<br><br><br>      <span class="hljs-comment">// _succ不为null，说明已经有个继承人了，所以不需要当前线程去唤醒，减少上下文切换的比率</span><br>      <span class="hljs-keyword">if</span> (_succ != NULL) <span class="hljs-keyword">continue</span>;<br><br>      w = _EntryList  ;<br>      <span class="hljs-comment">// 唤醒EntryList第一个元素</span><br>      <span class="hljs-keyword">if</span> (w != NULL) &#123;<br>          guarantee (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>          ExitEpilog (Self, w) ;<br>          <span class="hljs-keyword">return</span> ;<br>      &#125;<br>   &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>代码中的<code>QMode</code>表示唤醒下一个线程的策略。</p><p>code 1 设置owner为null，即释放锁，这个时刻其他的线程能获取到锁。这里是一个非公平锁的优化；</p><p>code 2 如果当前没有等待的线程则直接返回就好了，因为不需要唤醒其他线程。或者如果说succ不为null，代表当前已经有个”醒着的”继承人线程，那当前线程不需要唤醒任何线程；</p><p>code 3 当前线程重新获得锁，因为之后要操作cxq和EntryList队列以及唤醒线程；</p><p>code 4根据QMode的不同，会执行不同的唤醒策略。</p><p>根据QMode的不同，有不同的处理方式：</p><p>QMode = 2且cxq非空：取cxq队列队首的ObjectWaiter对象，调用ExitEpilog方法，该方法会唤醒ObjectWaiter对象的线程（即cxq队列首元素），然后立即返回，后面的代码不会执行了；<br>QMode = 3且cxq非空：把cxq队列插入到EntryList的尾部；<br>QMode = 4且cxq非空：把cxq队列插入到EntryList的头部；<br>QMode = 0：暂时什么都不做，继续往下看；</p><p>只有QMode=2的时候会提前返回，等于0、3、4的时候都会继续往下执行：</p><ol><li>如果EntryList的首元素非空，就取出来调用ExitEpilog方法，该方法会唤醒ObjectWaiter对象的线程（EntryList首元素），然后立即返回；</li><li>如果EntryList的首元素为空，就将cxq的所有元素放入到EntryList中，然后再从EntryList中取出来队首元素执行ExitEpilog方法，然后立即返回；</li></ol><h1 id="4-synchronized锁的大体流程"><a href="#4-synchronized锁的大体流程" class="headerlink" title="4. synchronized锁的大体流程"></a>4. synchronized锁的大体流程</h1><p>偏向锁-&gt;轻量锁-&gt;重量锁三者转换的大体逻辑如下图：</p><p>图片来自<a href="https://blog.csdn.net/DBC_121/article/details/105453101">看完这篇恍然大悟，理解Java中的偏向锁，轻量级锁，重量级锁</a></p><p><img src="images/lock.png" alt="lock"></p><p>但是图片中存在错误：轻量级锁发生竞争时没有自旋操作，直接膨胀为重量级锁</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://segmentfault.com/a/1190000016417017">Java中的Monitor机制</a></p></li><li><p><a href="https://developer.ibm.com/zh/articles/j-lo-synchronized/">探索Java同步机制</a></p></li><li><p><a href="http://itliusir.com/2019/11-Synchronized/">Synchronized 源码分析</a></p></li><li><p><a href="https://juejin.cn/post/6844903726554038280">死磕Synchronized底层实现–偏向锁</a></p></li><li><p><a href="https://github.com/farmerjohngit/myblog/issues/14">死磕Synchronized底层实现–轻量级锁</a></p></li><li><p><a href="https://github.com/farmerjohngit/myblog/issues/15">死磕Synchronized底层实现–重量级锁</a></p></li><li><p><a href="https://blog.csdn.net/L__ear/article/details/106369509">源码解析-偏向锁撤销流程解读</a></p></li><li><p><a href="https://www.jianshu.com/p/fd780ef7a2e8">Lock Record–锁记录</a></p></li><li><p><a href="https://www.mdeditor.tw/pl/2Z1b">偏向锁到底是怎么回事啊啊啊啊</a></p></li><li><p><a href="https://blog.weghos.com/openjdk/OpenJDK/src/hotspot/">在线看JDK源码的网站</a></p></li><li><p><a href="https://blog.csdn.net/L__ear/article/details/106365869">源码解析-触发批量撤销或批量重偏向的条件</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/302874340">关于synchronized批量重偏向和批量撤销的一个小实验</a></p></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">多线程基础</category>
      
      
      <category domain="https://eripe.me/tags/synchronized/">synchronized</category>
      
      
      <comments>https://eripe.me/articles/synchronized-keyword.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>BlockingQueue接口分析</title>
      <link>https://eripe.me/articles/interface-BlockingQueue-analysis.html</link>
      <guid>https://eripe.me/articles/interface-BlockingQueue-analysis.html</guid>
      <pubDate>Mon, 30 Aug 2021 16:38:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;1-基本概念&quot;&gt;&lt;a href=&quot;#1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;1. 基本概念&quot;&gt;&lt;/a&gt;1.</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><p><code>BlockingQueue</code>接口，提供了一组集合，一般用在生产者消费者模式中。它能搞保证在多线程环境下：当队列为空时，消费者线程会等待直到队列不空；当队列满时，生产者会等待直到队列不满。该接口提供了四种存储与删除模式：</p><table><thead><tr><th>/</th><th>操作失败抛出异常</th><th>操作失败返回特殊值</th><th>操作失败阻塞线程</th><th>操作具有时间限制</th></tr></thead><tbody><tr><td>插入操作</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>删除操作</td><td>remove()</td><td>poll(e)</td><td>take(e)</td><td>poll(time,unit)</td></tr><tr><td>查询操作</td><td>element()</td><td>peek(e)</td><td>/</td><td>/</td></tr></tbody></table><p>并且<code>BlockingQueue</code>和<code>ConcurrentHashMap</code>一样不允许插入<code>null</code>，因为<code>null</code>代表着<code>poll()</code>方法失败。同时对于同一元素，<code>BlockingQueue</code>的插入操作happens before获取操作。</p><h2 id="2-体系架构"><a href="#2-体系架构" class="headerlink" title="2. 体系架构"></a>2. 体系架构</h2><p><code>BlockingQueue</code>接口继承自<code>utils</code>包下的<code>Queue</code>接口，如下所示：</p><p><img src="./images/BlockingQueue-arch.png" alt="BlockingQueue-arch"></p><p>可以看到，所以的阻塞队列都继承了<code>utils</code>包下的抽象实现类<code>AbstracQueue</code>（负责实现一些队列的核心方法）。阻塞队列的种类非常丰富，我将其按照功能划分为三类：</p><ol><li>普通的阻塞队列：所谓的普通阻塞队列，它们的区别只是底层使用的存储结构不同<ul><li><code>LinkedBlockingQueue</code>:底层存储结构为链表</li><li><code>ArrayBlockingQueue</code>：底层存储为循环数组</li><li><code>PriorityBlockingQueue</code>：具备阻塞功能的优先级队列</li><li><code>LinkedBlockingDeque</code>：底层存储结构为链表的双向阻塞队列</li></ul></li><li>转移队列：消费者线程和生产者线程一一匹配，如果还没有消费，那么会将生产者阻塞在队列中，直到有匹配的消费者将节点取出<ul><li><code>LinkedTransferQueue</code></li><li><code>SynchronousQueue</code></li></ul></li><li>延迟队列：队列中的节点只有经过一定延时才能取出、<ul><li><code>DelayQueue</code></li><li><code>DelayedWorkQueue</code></li></ul></li></ol><p>划分标准还有很多，可以按照有锁、无锁、队列有限无限来区分，这里我直接抄个别人的，<a href="https://segmentfault.com/a/1190000016460411">分类来源</a>：</p><p>|   队列特性   | 有界队列  |  似无界队列  |  无界队列  |  特殊队列  |<br>|  —-  | —-  | —-  | —-  | —-  | —-  |<br>| 有锁算法  | ArrayBlockingQueue（单锁） | LinkedBlockingQueue（双锁），LinkedBlockingDeque（双锁） | / | PriorityBlockingQueue（单锁），DelayQueue（单锁） |<br>| 无锁算法  | / | / | / | LinkedTransferQueue | SynchronousQueue |</p><p>其中所谓的无锁是指实现中没有显示的使用其他同步锁，只使用了CAS；而有锁则一般都是使用<code>ReentrantLock</code>。</p><h2 id="3-已声明的方法"><a href="#3-已声明的方法" class="headerlink" title="3. 已声明的方法"></a>3. 已声明的方法</h2><p><code>BlockingQueue</code>与普通队列接口<code>Queue</code>所声明的抽象方法大差不差，都规定了一些增删查改的操作，如下所示：</p><p><img src="./images/BlockingQueue-methods.png" alt="BlockingQueue-methods"></p><p>其中一个比较新奇的就是<code>drainTo()</code>方法，该方法的主要作用就是将阻塞队列中的节点转移到一个集合中，如果在转移的时候出现错误，那么节点有可能存在于<code>BlockingQueue</code>和<code>Collection</code>或者都不存在或者仅存在于一处。并且在转移的时候不支持对传入的<code>Collection</code>进行修改。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>BlockingQueue的典型使用场景就是生产者与消费者模式，它的实现种类繁杂，后续我将简要分析各种类型的代表队列，文章列表如下所示：</p><ol><li>普通阻塞队列：<a href="./LinkedBlockingQueue-analysis.md">LinkedBlockingQueue源码分析</a></li><li>转移队列：<ul><li><a href="./LinkedTransferQueue-analysis.md">LinkedTransferQueue源码分析</a></li><li><a href="./SynchronousQueue-analysis.md">SynchronousQueue源码分析</a></li></ul></li><li>延迟队列：<a href="./DelayQueue-analysis.md">DelayQueue源码分析</a></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="https://eripe.me/tags/concurrent-collections/">concurrent collections</category>
      
      
      <comments>https://eripe.me/articles/interface-BlockingQueue-analysis.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Exectuor框架解析</title>
      <link>https://eripe.me/articles/Executor-interface.html</link>
      <guid>https://eripe.me/articles/Executor-interface.html</guid>
      <pubDate>Mon, 30 Aug 2021 16:38:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;1-Executor接口&quot;&gt;&lt;a href=&quot;#1-Executor接口&quot; class=&quot;headerlink&quot; title=&quot;1. Executor接口&quot;&gt;&lt;/a&gt;1.</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1-Executor接口"><a href="#1-Executor接口" class="headerlink" title="1. Executor接口"></a>1. Executor接口</h2><p>在JUC包中，还提供了Executor框架用来实现线程池，我们经常使用的线程池都是从Executor派生而来。我们可以看看整个Executor框架的继承结构：</p><p><img src="images/executor-framework.png" alt="executor-framework"></p><p>那么在这个框架中，我们第一步应该需要了解它的核心接口<code>Executor</code>。这个接口的作用在它的注释中说的很清楚：</p><blockquote><p>An object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An Executor is normally used instead of explicitly creating threads. For example, rather than invoking new Thread(new(RunnableTask())).start() for each of a set of tasks</p></blockquote><p>这个接口的作用就是让用户专注于线程的任务，至于线程怎么调用的，如何运行的，用户并不需要关心。具体的实现类可以任意实现线程之间的协作。唯一的抽象方法就是<code>execute</code>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Executor</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Executes the given command at some time in the future.  The command</span><br><span class="hljs-comment">     * may execute in a new thread, in a pooled thread, or in the calling</span><br><span class="hljs-comment">     * thread, at the discretion of the &#123;<span class="hljs-doctag">@code</span> Executor&#125; implementation.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> command the runnable task</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException if this task cannot be</span><br><span class="hljs-comment">     * accepted for execution</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NullPointerException if command is null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-ExecutorService接口"><a href="#2-ExecutorService接口" class="headerlink" title="2. ExecutorService接口"></a>2. ExecutorService接口</h2><p>那么对于Executor的增强类接口<code>ExecutorService</code>呢？我们看看它的注释：</p><blockquote><p>An Executor that provides methods to manage termination and methods that can produce a Future for tracking progress of one or more asynchronous tasks.<br>An ExecutorService can be shut down, which will cause it to reject new tasks. Two different methods are provided for shutting down an ExecutorService. The shutdown method will allow previously submitted tasks to execute before terminating, while the shutdownNow method prevents waiting tasks from starting and attempts to stop currently executing tasks. Upon termination, an executor has no tasks actively executing, no tasks awaiting execution, and no new tasks can be submitted. An unused ExecutorService should be shut down to allow reclamation of its resources.</p></blockquote><p>上述大致就是ExecutorService作为一个Executor，它提供一些方法用来终止当前对象提供服务以及一些方法用于产生一个<strong>Future</strong>表示异步任务执行的结果。并且一个ExecutorService可以被关闭，但是这可能会导致新任务被迫终止。它提供了两类方法用来终止自身。</p><ul><li>第一类是<code>shutdown</code>方法，这类方法会将停止之前已经提交的任务执行完毕</li><li>第二类是<code>shutdownNow</code>方法，这类方法会将已经提交但未执行的任务直接终止，并且尝试对终止正在执行的任务。</li></ul><p>终止后ExecutorService不会存在还在执行的任务，并且也无法提交任务。当我们不再需要ExecutorService时，就应将其关闭，避免资源浪费。</p><p>对ExecutorService有了一个初步的认识后，我们看看它提供的一些核心方法：</p><p><img src="images/ExecutorService.png" alt="ExecutorService"></p><p>其实还有一点可以值得关注，就是上述提到的<code>Future</code>。这其实也是一个顶级接口，简而言之就是用来保存异步线程执行的结果。后续再详细分析。</p><h3 id="2-1-AbstractExecuteService"><a href="#2-1-AbstractExecuteService" class="headerlink" title="2.1 AbstractExecuteService"></a>2.1 AbstractExecuteService</h3><p>对于ExecutorService接口，JUC提供了一个抽象实现类<code>AbstractExecutorService</code>负责实现了一些异步执行任务核心方法的实现，包括<code>submit</code>、<code>invokeAll</code>、<code>invokeAny</code>这三类。并且提供了一个包装函数，能够将提交的任务（callable或者runnable）包装为一个<code>FutureTask</code>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">RunnableFuture&lt;T&gt; <span class="hljs-title">newTaskFor</span><span class="hljs-params">(Callable&lt;T&gt; callable)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FutureTask&lt;T&gt;(callable);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>所谓的<code>FutureTask</code>其实是<code>Future</code>接口的实现类，这个我们后续在分析<code>Future</code>体系的时候再详细介绍。其实我们应该重点关注提交函数<code>submit</code>到底是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>   <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>   RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-keyword">null</span>);<br>   execute(ftask);<br>   <span class="hljs-keyword">return</span> ftask;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从上面得知，<code>submit</code>函数的逻辑比较简单，就是将提交后的<code>Runnable</code>或者<code>callable</code>实现类包装成<code>FutureTask</code>后，还是会调用顶级接口的<code>execute</code>方法来执行一个具体的任务。这里还是无法得知线程到底是如何调度的。</p><h3 id="2-2-ScheduledExecutorService"><a href="#2-2-ScheduledExecutorService" class="headerlink" title="2.2 ScheduledExecutorService"></a>2.2 ScheduledExecutorService</h3><p><code>ScheduledExecutorService</code>接口的最用其实很简单，正如在它的注释中所写的，用来执行一些定时任务或者周期任务：</p><blockquote><p>An ExecutorService that can schedule commands to run after a given delay, or to execute periodically.<br>The schedule methods create tasks with various delays and return a task object that can be used to cancel or check execution. The scheduleAtFixedRate and scheduleWithFixedDelay methods create and execute tasks that run periodically until cancelled.</p></blockquote><p>那么该接口定义四个抽象方法用来提交定时或周期任务：</p><p><img src="images/ScheduleExecutorService.png" alt="ScheduleExecutorService"></p><p>提交任务后同样会返回一个<code>Future</code>接口的实现类<code>ScheduleFuture</code>，根据不同的任务安排，<code>ScheduleFuture</code>代表的含义不同，具体可以查看API文档。</p><h2 id="3-线程池ThreadPoolExecutor"><a href="#3-线程池ThreadPoolExecutor" class="headerlink" title="3. 线程池ThreadPoolExecutor"></a>3. 线程池ThreadPoolExecutor</h2><p><code>ThreadPoolExecutor</code>是一个具体线程池类，它通过继承<code>AbstractExecutorService</code>来实现接口<code>Executor</code>。该类实现了具体调度线程的方法负责完成提交的任务。并且通过一组参数实现了很强的扩展性，包括：</p><ol><li>核心线程数与最大线程数</li><li>预先启动核心线程</li><li>新线程的生产方式</li><li>线程存活时间</li><li>阻塞队列</li><li>任务的拒绝策略</li><li>hook方法（在任务执行前后添加代理方法）</li><li>线程池的终止策略</li></ol><h3 id="3-1-核心线程数"><a href="#3-1-核心线程数" class="headerlink" title="3.1 核心线程数"></a>3.1 核心线程数</h3><p>因为线程池中的线程数量会根据参数<code>corePoolSize</code>和<code>maximumPoolSize</code>的大小进行动态调整。当在方法<code>execute(Runnable)</code>中提交新任务时：</p><ol><li>如果正在运行的线程数量<strong>少于</strong><code>corePoolSize</code>线程时，<strong>即使其他工作线程处于空闲状态</strong>，也会创建一个新线程来处理请求</li><li>如果运行的线程数<strong>大于</strong><code>corePoolSize</code>但小于<code>maximumPoolSize</code>，则<strong>仅在队列已满时才创建新线程</strong>。</li></ol><p>通过将corePoolSize和maximumPoolSize设置为相同的值，可以创建固定大小的线程池。 通过将maximumPoolSize设置为一个本质上不受限制的值（例如Integer.MAX_VALUE），可以允许池容纳任意数量的并发任务。通常，核心和最大池大小仅在构造时设置，但也可以使用setCorePoolSize和setMaximumPoolSize动态更改。</p><h3 id="3-2-预先启动核心线程"><a href="#3-2-预先启动核心线程" class="headerlink" title="3.2 预先启动核心线程"></a>3.2 预先启动核心线程</h3><p>所谓的预先启动核心线程是指：在默认情况下，核心线程的生产条件是有新的任务提交。但是有可能我们在不提交任务的情况下也有启动核心线程的需求。例如假设我们提供的阻塞队列非空，那么在不调用<code>submit</code>提交新任务的前提下，需要手动启动核心线程来处理阻塞队列中的任务。</p><p>那么手动启动核心线程的操作可以通过<code>prestartCoreThread</code>或者<code>prestartAllCoreThreads</code><br>来完成。</p><h3 id="3-3-线程的生产模式"><a href="#3-3-线程的生产模式" class="headerlink" title="3.3 线程的生产模式"></a>3.3 线程的生产模式</h3><p>所谓的线程的生产模式，也就是当我们存活的线程不足以处理提交的任务，那么我们就需要生产新的线程来处理。那么在<code>ThreadPoolExecutor</code>中，维护了一个线程工厂<code>threadFactory</code>来生产线程。</p><p>在Java中，线程工厂有许多种，如下图所示：</p><p><img src="images/ThreadFactory.png" alt="ThreadFactory"></p><p>对于<code>ThreadPoolExecutor</code>来说，采用的是默认的线程工厂<code>DefaultThreadFactory</code>，该线程池创建的所有线程全部都属于同一ThreadGroup中，并且具有相同的NORM_PRIORITY优先级和非守护程序状态。</p><p>通过提供不同的ThreadFactory，可以更改线程的名称，线程组，优先级，守护程序状态等。如果ThreadFactory在通过从newThread返回null返回要求时未能创建线程，执行器将继续执行，但可能无法执行 执行任何任务。 线程应具有“ modifyThread” RuntimePermission。 如果线程池的工作线程或其他线程不具有此许可权，则服务可能会降级：配置更改可能不会及时生效，并且关闭池可能保持在可能终止但未完成的状态。</p><h3 id="3-2-线程的存活时间"><a href="#3-2-线程的存活时间" class="headerlink" title="3.2 线程的存活时间"></a>3.2 线程的存活时间</h3><p>一般来说，线程的存活时间一般用来限制非核心线程的数量。</p><p>如果池当前具有的核心线程数超过corePoolSize，则多余的线程如果在keepAliveTime的时长内都没有处理任务，那么多余的线程将会被关闭。 我们可以使用<code>setKeepAliveTime(long，TimeUnit)</code>方法动态更改此参数。 使用<code>Long.MAX_VALUE TimeUnit.NANOSECONDS</code>可以有使空闲线程永远不会在线程池关闭之前终止。</p><p>对于线程的存活时间，有一点需要我们注意：<strong>只要keepAliveTime值不为零，调用方法<code>allowCoreThreadTimeOut(boolean)</code>可用于将此超时策略应用于核心线程</strong></p><h3 id="3-3-阻塞队列"><a href="#3-3-阻塞队列" class="headerlink" title="3.3 阻塞队列"></a>3.3 阻塞队列</h3><p>阻塞队列主要用来存储多余的任务，它与线程池交互的逻辑如下：</p><ol><li>如果正在运行的线程数量少于<code>corePoolSize</code>，则Executor会添加新线程而不是将任务添加到阻塞队列</li><li>如果正在运行的线程数量不少于<code>corePoolSize</code>，则Executor会选择将新任务添加到阻塞队列而不是创建新线程</li><li>如果阻塞队列已满，那么Executor会选择创建一个新线程。如果总的线程数量大于<code>maximumPoolSize</code>，那么线程池会执行拒绝策略。</li></ol><p>对于阻塞队列如何排队的逻辑，可以细分为三种：</p><ol><li><p><strong>直接交付</strong>。对于工作队列，一个很好的默认选择是SynchronousQueue，它可以将任务移交给线程，而不必另外保留它们。在这里，如果没有立即可用的线程来运行任务，则尝试将其排队的尝试将失败，因此将构造一个新线程。在处理可能具有内部依赖项的请求集时，此策略避免了锁定。直接切换通常需要无限制的maximumPoolSizes以避免拒绝新提交的任务。反过来，当平均而言，命令继续以比其可处理的速度更快到达时，这可能会带来无限线程增长的可能性。</p></li><li><p><strong>无界队列</strong>。使用无界队列（例如，没有预定义容量的LinkedBlockingQueue）将在所有corePoolSize线程繁忙时使新任务在队列中等待。因此，将仅创建corePoolSize线程。 （因此，maximumPoolSize的值没有任何作用。）当每个任务完全独立于其他任务时，这可能是适当的，因此任务不会影响彼此的执行。例如，在网页服务器中。尽管这种排队方式对于消除短暂的请求突发很有用，但它承认当命令平均继续以比处理速度更快的速度到达时，无限制的工作队列增长是可能的。</p></li><li><p><strong>有界队列</strong>。与有限的maximumPoolSizes一起使用时，有界队列（例如ArrayBlockingQueue）有助于防止资源耗尽，但调优和控制起来会更加困难。队列大小和最大池大小可能会相互折衷：使用大队列和小容量线程池可以最大程度地减少CPU使用率，操作系统资源和上下文切换开销，但会导致人为地降低吞吐量。如果任务频繁阻塞（例如都是I/O操作），则系统在完成任务时因为阻塞会花费更多的时间。使用小队列大容量线程池，CPU频繁切换线程的开销也是不可忽略的，这同样会降低吞吐量。</p></li></ol><h3 id="3-4-拒绝任务的策略"><a href="#3-4-拒绝任务的策略" class="headerlink" title="3.4 拒绝任务的策略"></a>3.4 拒绝任务的策略</h3><p>线程池拒绝任务的时机有两种：</p><ol><li>当线程池关闭后，线程会拒绝执行提交的任务</li><li>当线程池的线程数量已经达到最大，并且阻塞队列也没有空间的时候，线程池会拒绝执行提交的任务。</li></ol><p>拒绝的操作由线程池中的<code>RejectedExecutionHandler</code>属性来完成。那么具体的拒绝逻辑又可以分为四种：</p><ol><li><strong>ThreadPoolExecutor.AbortPolicy</strong>：这是线程池的<strong>默认</strong>拒绝策略。该策略在拒绝时会抛出运行时异常RejectedExecutionException。</li><li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>：该策略就是在线程池<strong>未关闭时</strong>直接调用<code>Runnable</code>实现类的<code>run</code>执行任务。这提供了一种简单的反馈控制机制，该机制将减慢新任务的提交速度。</li><li><strong>ThreadPoolExecutor.DiscardPolicy</strong>：直接忽略当前提交的任务</li><li><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong>：如果线程池未关闭，则会抛弃阻塞队列头部的任务，然后重新尝试让线程池执行当前任务（该操作可能再次失败，导致重复执行此操作）。</li></ol><p>当然我们自己也可以实现自定义拒绝策略，不过需要注意，策略只能在阻塞队列容量一定的情况下才生效。</p><h3 id="3-5-可hook方法"><a href="#3-5-可hook方法" class="headerlink" title="3.5 可hook方法"></a>3.5 可hook方法</h3><p><code>ThreadPoolExecutor</code>内部提供了可以被override的<code>beforeExecute(Thread,Runnable)</code>和<code>afterExecute(Runnable,Throwable)</code>，这两个方法会在每个任务执行前后调用。这两个hook函数可以用来执行一些特殊操作。 例如，重新初始化ThreadLocals，收集统计信息或添加日志。 另外，一旦执行程序完全终止，可以终止方法终止以执行需要执行的任何特殊处理。</p><p>并且<code>ThreadPoolExecutor</code>也提供了可被override的<code>terminated()</code>方法。这个方法一般用来进行一些特殊操作（当然只能一次），当Executor被完全关闭的时候。<br>如果钩子或回调方法引发异常，内部工作线程可能进而失败并突然终止。</p><p><strong>当然如果这些hook函数内部抛出了异常，那么工作线程可能会出现不可预知的错误。</strong></p><p>Queue maintenance<br>Method getQueue() allows access to the work queue for purposes of monitoring and debugging. Use of this method for any other purpose is strongly discouraged. Two supplied methods, remove(Runnable) and purge are available to assist in storage reclamation when large numbers of queued tasks become cancelled.</p><h3 id="3-6-线程池的回收"><a href="#3-6-线程池的回收" class="headerlink" title="3.6 线程池的回收"></a>3.6 线程池的回收</h3><p>如果一个线程池没有被引用，并且池内<strong>没有存活线程</strong>的情况下，线程池会自动关闭。那么如何保证在不使用线程池的情况下，池内没有存活线程才是关键。那么这个问题有两种解决方法：</p><ol><li>不设置线程池的核心线程数量，那么对于临时申请的工作线程会自动关闭。</li><li>调用<code>allowCoreThreadTimeOut(boolean)</code>，允许核心线程存在过期机制</li></ol><h2 id="4-系统提供的线程池"><a href="#4-系统提供的线程池" class="headerlink" title="4. 系统提供的线程池"></a>4. 系统提供的线程池</h2><p>可以看到，前文提到线程池的参数是多样化的，那么为了适用于不同的生产环境，JUC提供了一个<code>Executor</code>工厂：<code>Exexutors</code>类，这个类通过预定义不同的参数生产一些适用于不同场景的线程池，包括：</p><ol><li><code>Executors.newCachedThreadPool</code>：无限制线程池，并且可以自动回收</li><li><code>Executors.newFixedThreadPool</code>：线程数量固定</li><li><code>Executors.newSingleThreadExecutor</code>：只有一个线程的线程池</li></ol><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>本篇简要叙述了JUC中的Executor框架，以及两个核心接口<code>Executor</code>、<code>ExecutorService</code>。并且简单介绍了线程池实现类<code>ThreadPoolExecutor</code>的一部分配置参数以及一些内置的线程池。后续我们就需要详细研究<code>ThreadPoolExecutor</code>到底是如何工作的。</p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="https://eripe.me/tags/Executor/">Executor</category>
      
      
      <comments>https://eripe.me/articles/Executor-interface.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ThreadPoolExecutor线程池解析</title>
      <link>https://eripe.me/articles/ThreadPoolExecutor.html</link>
      <guid>https://eripe.me/articles/ThreadPoolExecutor.html</guid>
      <pubDate>Mon, 30 Aug 2021 16:38:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;0-预备知识&quot;&gt;&lt;a href=&quot;#0-预备知识&quot; class=&quot;headerlink&quot; title=&quot;0. 预备知识&quot;&gt;&lt;/a&gt;0.</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="0-预备知识"><a href="#0-预备知识" class="headerlink" title="0. 预备知识"></a>0. 预备知识</h2><p>在了解<code>ThreadPoolExecutor</code>之前，我们首先需要了解一些基本概念，下图是<code>ThreadPoolExecutor</code>的部分核心字段。我先依次对其进行解释。</p><p><img src="images/ThreadPoolExecutor-fields.png" alt="ThreadPoolExecutor"></p><h3 id="0-1-线程池状态"><a href="#0-1-线程池状态" class="headerlink" title="#0.1 线程池状态"></a>#0.1 线程池状态</h3><p>JUC为线程池规定了5种状态，如下图所示：<br><img src="images/Executor-state.drawio.svg" alt="executor-state"></p><p>对于每种状态，含义如下：</p><ol><li>RUNNING: 线程池能够接受任务并处理阻塞队列中的任务</li><li>SHUTDOWN: 不再接受新的任务，但是会把阻塞队列中的任务全部执行完毕</li><li>STOP: 不再接受新的任务，不再处理阻塞队列中的任务，并且会中断正在执行的任务</li><li>TIDYING:  所有的任务都被终止，工作线程的数量为0，并且在转化为该状态时，线程池会执行<code>terminated()</code>方法</li><li>TERMINATED: <code>terminated()</code>方法执行完毕</li></ol><p>了解了线程池的五种状态后，那么它底层到底是如何实现的呢？其实也不复杂。<code>ThreadPoolExecutor</code>通过一个<code>AtomicInterger</code>维护了这五种状态。实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY   = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// runState is stored in the high-order bits</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING    = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br></code></pre></div></td></tr></table></figure><p>对于一个32为的<code>AtomicInteger</code>来说，它的信息分为两部分：</p><ul><li>第30~32位：线程池的状态</li><li>第1~29位，线程池中的线程数量</li></ul><p>从上面的定义中我们得知：<code>ctl</code>属性维护上述的两组信息，并且在初始化时会将线程数量设为0。获取状态时只需要通过<code>runStateOf(int)</code>方法获取<code>ctl</code>属性的高3位即可，对于线程数量的获取同理。</p><h3 id="0-2-线程池互斥锁"><a href="#0-2-线程池互斥锁" class="headerlink" title="#0.2 线程池互斥锁"></a>#0.2 线程池互斥锁</h3><p><code>ThreadPoolExecutor</code>内部维护了一个<code>ReentrantLock</code>用来实现对工作线程集合的互斥访问，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">new</span> ReentrantLock();<br></code></pre></div></td></tr></table></figure><p>因为在多线程环境，操作一个hashSet可能会出现线程不安全的问题。至于为什么不适用一个线程安全的set，是因为使用锁可以对<code>interruptIdleWorkers()</code>的操作进行序列化，从而避免了不必要的中断风暴，尤其是在关闭线程池期间。并且还能够简化一些数据的统计。</p><h3 id="0-3-线程包装类Worker"><a href="#0-3-线程包装类Worker" class="headerlink" title="#0.3 线程包装类Worker"></a>#0.3 线程包装类Worker</h3><p>在<code>ThreadPoolExecutors</code>中，定义了一个不可变对象<code>Worker</code>作为线程的wrapper，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span></span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * This class will never be serialized, but we provide a</span><br><span class="hljs-comment">    * serialVersionUID to suppress a javac warning.</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">6138294804551838833L</span>;<br><br>    <span class="hljs-comment">//具体执行任务的线程，为null表示出现错误</span><br>    <span class="hljs-keyword">final</span> Thread thread;<br>    <span class="hljs-comment">//worker执行的第一个任务，可能为null</span><br>    Runnable firstTask;<br><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> completedTasks;<br><br>    Worker(Runnable firstTask) &#123;<br>        <span class="hljs-comment">//防止在当前线程执行runWorker之前，就收到中断</span><br>        setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>        <span class="hljs-keyword">this</span>.firstTask = firstTask;<br>        <span class="hljs-keyword">this</span>.thread = getThreadFactory().newThread(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        runWorker(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Lock methods</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// The value 0 represents the unlocked state.</span><br>    <span class="hljs-comment">// The value 1 represents the locked state.</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>            setExclusiveOwnerThread(Thread.currentThread());<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br>        setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>        setState(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span>        </span>&#123; acquire(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span>  </span>&#123; <span class="hljs-keyword">return</span> tryAcquire(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span>      </span>&#123; release(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLocked</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> isHeldExclusively(); &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">interruptIfStarted</span><span class="hljs-params">()</span> </span>&#123;<br>        Thread t;<br>        <span class="hljs-keyword">if</span> (getState() &gt;= <span class="hljs-number">0</span> &amp;&amp; (t = thread) != <span class="hljs-keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.interrupt();<br>            &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>之所以要包装呢，是因为<code>Worker</code>可以比<code>Thread</code>提供更多的信息。例如当前<code>worker</code>累计执行了多少个任务。其实我们还可以注意到<code>Worker</code>继承了AQS。那么这里就会出现两个问题：</p><ol><li>为什么要继承AQS？一个<code>Worker</code>要锁干嘛？一个<code>Worker</code>不是自己负责一个任务吗？难道会有多个线程访问同一个<code>Worker</code>？</li><li>使用线程的锁不行吗？为什么要自己实现一个锁？</li></ol><p>那么对于第一个问题，其实这个问题在注释中已经说明了：</p><blockquote><p>Class Worker mainly <strong>maintains interrupt control state</strong> for threads running tasks, along with other minor bookkeeping. This class opportunistically extends AbstractQueuedSynchronizer to simplify acquiring and releasing a lock <strong>surrounding each task execution</strong>. This protects against interrupts that are intended to wake up a worker thread waiting for a task from instead interrupting a task being run. </p></blockquote><blockquote><p>We implement a simple <strong>non-reentrant mutual exclusion lock</strong> rather than use ReentrantLock because we do not want worker tasks to be able to reacquire the lock when they invoke pool control methods like setCorePoolSize. Additionally, to suppress interrupts until the thread actually starts running tasks, we initialize lock state to a negative value, and clear it upon start (in runWorker).</p></blockquote><p>大致意思是说：<br><code>Worker</code>类会管理线程在执行任务时的中断状态，以及一些其他的信息。<code>Worker</code>继承AQS是为了实现一个简单的不可重入的锁，用来在执行任务前上锁，在任务完毕后后释放锁。<strong>上锁的原因是因为如果有中断发生，那么只希望中断那些正在等待任务的<code>Worker</code>，而不是中断那些正在执行任务的<code>Worker</code>。</strong></p><p>自己实现一个简单的<strong>不可重入</strong>的锁是因为已有的锁都是可重入的，线程池需要一个不可重入锁的才能达到上面的目的。那么为什么不可重入的就能达到目的呢？考虑下面一个场景：假设主线程调用了<code>setCorePoolSize(int)</code>调整线程池的大小，那么<code>ThreadPoolExecutor</code>希望这个调整的动作不要影响那些正在执行任务的<code>Worker</code>，所以就通过能否获取<code>Worker</code>对应的锁来判断当前<code>Worker</code>是否处于空闲状态，那么这里的锁只能是独占锁。若是可重入锁，那么，无论是等待任务的，还是正在执行的，都会被中断。<code>setCorePoolSize(int)</code>如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//调用该函数需要中断那些空闲的线程</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCorePoolSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (workerCountOf(ctl.get()) &gt; corePoolSize)<br>        interruptIdleWorkers();<br>    ...<br>&#125;<br><br><span class="hljs-comment">//判断一个线程是否空闲就是看能否获取对应worker的不可重入独占锁</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> onlyOne)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (Worker w : workers) &#123;<br>            Thread t = w.thread;<br>            <span class="hljs-comment">//能够成功获取不可重入锁就表示当前Worker没有执行任务，自然可以执行中断</span><br>            <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    t.interrupt();<br>                &#125;<br>                ...<br>            &#125;<br>            ...<br>        &#125;<br>    &#125;<br>    ...<br></code></pre></div></td></tr></table></figure><h3 id="0-4-线程工厂-ThreadFactory"><a href="#0-4-线程工厂-ThreadFactory" class="headerlink" title="#0.4 线程工厂:ThreadFactory"></a>#0.4 线程工厂:ThreadFactory</h3><p>所谓的线程的工厂，JUC提供了一个线程工厂接口<code>ThreadFactory</code>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ThreadFactory</span> </span>&#123;<br>    <span class="hljs-function">Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>唯一需要重写的方法就是生产新线程的方法<code>newThread(Runnable)</code>。对<code>ThreadPoolExecutor</code>，它内部实现了两种工厂类：<code>DefaultThreadFactory</code>和<code>PrivilegedThreadFactory</code>。</p><p>区别就是前者生产的线程优先级默认为5，后者对于新生产的线程和调用线程工厂的线程具有相同优先级，并具有相同的线程上下文类加载器。下面只列出默认工厂的代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ThreadFactory</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicInteger poolNumber = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadGroup group;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger threadNumber = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String namePrefix;<br><br>    DefaultThreadFactory() &#123;<br>        SecurityManager s = System.getSecurityManager();<br>        group = (s != <span class="hljs-keyword">null</span>) ? s.getThreadGroup() :<br>                                Thread.currentThread().getThreadGroup();<br>        namePrefix = <span class="hljs-string">&quot;pool-&quot;</span> +<br>                        poolNumber.getAndIncrement() +<br>                        <span class="hljs-string">&quot;-thread-&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(group, r,<br>                                namePrefix + threadNumber.getAndIncrement(),<br>                                <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (t.isDaemon())<br>            t.setDaemon(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-comment">//设置新线程的默认优先级为5</span><br>        <span class="hljs-keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)<br>            t.setPriority(Thread.NORM_PRIORITY);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="0-5-拒绝策略-defaultHandler"><a href="#0-5-拒绝策略-defaultHandler" class="headerlink" title="#0.5 拒绝策略:defaultHandler"></a>#0.5 拒绝策略:defaultHandler</h3><p>对于拒绝策略，我在讲解<a href="executor-interface.md">Executor框架</a>时曾说过，自带的拒绝策略有四种，而<code>ThreadPoolExecutor</code>默认采用的是AbortPolicy，直接拒绝提交的任务，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbortPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(<span class="hljs-string">&quot;Task &quot;</span> + r.toString() +<br>                                                <span class="hljs-string">&quot; rejected from &quot;</span> +<br>                                                e.toString());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="0-6-阻塞队列-workQueue"><a href="#0-6-阻塞队列-workQueue" class="headerlink" title="#0.6 阻塞队列:workQueue"></a>#0.6 阻塞队列:workQueue</h3><h2 id="1-任务添加流程"><a href="#1-任务添加流程" class="headerlink" title="1. 任务添加流程"></a>1. 任务添加流程</h2><p>阅读过源码的同学都知道，<code>ThreadPoolExecutor</code>并没有重写<code>ExecutorService</code>的<code>submit(Runnable)</code>的方法。当我们调用<code>submit</code>时实际调用的是<code>AbstractExecutorService</code>重写的<code>submit</code>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-keyword">null</span>);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在<code>submit</code>中又会调用<code>ThreadPoolExecutor</code>重写的<code>execute(Runnable)</code>方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <br>    <span class="hljs-keyword">int</span> c = ctl.get();<br>    <span class="hljs-comment">//如果当前线程池的线程数量小于核心线程数</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-comment">//尝试设置线程的第一个任务，因为通过execute调用addWorker，那么一定是</span><br>        <span class="hljs-comment">//因为有新任务进来了</span><br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br>    <span class="hljs-comment">//走到这说明线程数已经不小于核心线程数了</span><br>    <br>    <span class="hljs-comment">//如果线程池处于running状态，但是无法向阻塞队列中添加任务</span><br>    <span class="hljs-comment">//那么尝试添加新的worker</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-keyword">int</span> recheck = ctl.get();<br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))<br>        reject(command);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>主要的流程分为三步：</p><ol><li>如果当前活跃的线程的数量小于核心线程数，那么就尝试调用<code>addWaiter(Runnable,boolean)</code>增加一个线程，如果成功直接返回，否则执行2</li><li>走到这里说明线程数至少不小于核心线程数，那么尝试向阻塞队列中添加任务，如果添加成功，我们仍然需要通过双重检查是否应该增加线程（因为有可能在上次检查之后，线程池中的线程全部死亡），如果线程全部死亡，那么则尝试添加一个Worker。</li><li>如果无法向阻塞队列中添加任务，说明阻塞队列已满，如果此时无法增加worker，那么则会根据拒绝策略拒绝当前任务</li></ol><p>添加<code>worker</code>的方法<code>addWaiter(Runnable,boolean)</code>如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">返回true表示成功添加了工作线程并启动</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">但是返回false的情况有很多，但是都会进行回滚操作：</span><br><span class="hljs-comment">1. 表示线程池已经stop或者即将关闭</span><br><span class="hljs-comment">2. 线程创建失败，要么是因为线程工厂返回null，或者在启动线程的时候内存溢出，</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//第一个参数表示当前worker是否有第一个任务</span><br><span class="hljs-comment">//第二个参数core表示当前线程数量的上限是选核心线程数还是最大线程数</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;<br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-comment">//获取线程池状态</span><br>        <span class="hljs-keyword">int</span> rs = runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-comment">//如果当前线程池已经shutdown及之后的状态</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            <span class="hljs-comment">//线程不是shutdown状态，表示已经进入stop或tidying</span><br>            <span class="hljs-comment">//线程池是shutdown状态，并且firstTask不为空，但是shutdown状态不再接受任务，所以返回false</span><br>            <span class="hljs-comment">//线程池是shutdown状态，并且firstTask为空，并且阻塞队列为空，没有任务要执行，自然返回false</span><br><br>            ! (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span> &amp;&amp; ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br>            <span class="hljs-comment">//如果线程池的线程数量已经超过了最大容量，返回false</span><br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                <span class="hljs-comment">//如果以核心线程数作界限，那么就看当前线程数是否超过了核心线程数</span><br>                <span class="hljs-comment">//只有在队列满之后core才会为false</span><br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">//线程数没超标，那么添加线程</span><br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            <span class="hljs-comment">//cas失败说明有多个线程在同时添加任务</span><br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-comment">//如果线程池的状态发生改变，那么retry</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;<br>    Worker w = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//生成一个Worker</span><br>        w = <span class="hljs-keyword">new</span> Worker(firstTask);<br>        <span class="hljs-keyword">final</span> Thread t = w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck while holding lock.</span><br>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                <span class="hljs-comment">// shut down before lock acquired.</span><br>                <span class="hljs-keyword">int</span> rs = runStateOf(ctl.get());<br>                <span class="hljs-comment">//检查线程池是否已经关闭</span><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;<br>                    <span class="hljs-comment">//判断线程工厂创建线程是否成功</span><br>                    <span class="hljs-keyword">if</span> (t.isAlive())<br>                        <span class="hljs-comment">//预先检查新worker的状态</span><br>                        <span class="hljs-comment">//如果在我们没有启动线程的情况，线程就alive肯定要抛出异常</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();<br>                    <span class="hljs-comment">//将新生成的worker添加到线程池中，其实就是一个HashSet</span><br>                    workers.add(w);<br>                    <span class="hljs-keyword">int</span> s = workers.size();<br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                <span class="hljs-comment">//启动线程</span><br>                t.start();<br>                workerStarted = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中逻辑还是比较清晰的，在生成线程后如果能成功启动，那么则返回true，否则会调用<code>addWorkerFailed</code>进行回滚操作。</p><p>值得注意的是在访问<code>worker</code>集合<code>workers</code>的时候，需要保证互斥访问。具体原理在预备知识中已经介绍过。</p><h2 id="2-线程工作流程"><a href="#2-线程工作流程" class="headerlink" title="2. 线程工作流程"></a>2. 线程工作流程</h2><p>在启动<code>worker</code>之后，最后在<code>worker</code>的<code>run()</code>方法中会调用<code>runWorker(Worker)</code>实现不断的从阻塞队列中获取任务，并调用任务的<code>run()</code>执行。</p><p>值得注意的是：在当前<code>worker</code>获取到新任务时，会使用自身的不可重入独占锁进行一个加锁操作，这个操作标志着当前<code>worker</code>已经开始执行具体的任务了，暂时屏蔽线程池发出的中断。</p><p><code>runWorker(Worker)</code>代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runWorker</span><span class="hljs-params">(Worker w)</span> </span>&#123;<br>    Thread wt = Thread.currentThread();<br>    Runnable task = w.firstTask;<br>    w.firstTask = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//需要首先解锁一次，因为一个worker最初始的状态为-1，这么做是为了防止</span><br>    <span class="hljs-comment">//worker在执行runWorker之前就收到了中断，例如在主函数关闭了线程池，</span><br>    w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>    <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//如果获取不到新的任务，那么就会退出循环</span><br>        <span class="hljs-comment">//getTask在线程池至少处于shutdown时，会返回null</span><br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = getTask()) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//使用worker的锁，表示当前worker已经获得新任务，暂时屏蔽中断</span><br>            w.lock();<br><br>            <span class="hljs-comment">//如果线程池进入stopping状态，那么必须保证当前worker被中断</span><br>            <span class="hljs-comment">//否则，必须保证当前worker不能被中断</span><br>            <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>            <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>            <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>            <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                    <span class="hljs-comment">//这里做的是二次检查，有可能用户突然调用了shutdownNow</span><br>                    (Thread.interrupted() &amp;&amp;<br>                    runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())<br>                wt.interrupt();<br>            <span class="hljs-keyword">try</span> &#123;<br>                beforeExecute(wt, task);<br>                Throwable thrown = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//执行任务自己的run方法</span><br>                    task.run();<br>                <span class="hljs-comment">//捕捉任务可能抛出的异常，然后从线程池抛出</span><br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(x);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    afterExecute(task, thrown);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-keyword">null</span>;<br>                w.completedTasks++;<br>                w.unlock();<br>            &#125;<br>        &#125;<br>        completedAbruptly = <span class="hljs-keyword">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//如果一个线程无法再获取新的任务，那么就会将当前线程销毁</span><br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-1-获取新任务的流程"><a href="#2-1-获取新任务的流程" class="headerlink" title="2.1 获取新任务的流程"></a>2.1 获取新任务的流程</h3><p>每当<code>worker</code>完成一个任务后，会尝试调用<code>getTask()</code>从我们提供的阻塞队列中获取新的任务。当阻塞队列为空时，该函数可以无限时等待或者有限等待，这需要根据是否允许核心线程过期来抉择。</p><p>如果该函数返回null就表示当前worker已经结束使命了，可以终结了。返回null的情况很多：</p><ol><li>线程池已经处于STOPING状态</li><li>线程池已经处于SHUTDOWN状态并且阻塞队列为空</li><li>线程数已经超过最大值</li><li>当前worker等待新任务的时间过长，也就是说等待的时长超过了一个核心线程的存活时长</li></ol><p>否则返回一个新的任务具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title">getTask</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> timedOut = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-keyword">int</span> rs = runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-comment">//如果线程已经至少处于SHUTDOWN状态并且empty为空，因为后续都不可能有新任务提交，那么直接返回null</span><br>        <span class="hljs-comment">//表示当前worker的工作可以结束了</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            <span class="hljs-comment">//将线程数减1</span><br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br><br>        <span class="hljs-comment">// Are workers subject to culling?</span><br>        <span class="hljs-keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;<br><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Runnable r = timed ?<br>                <span class="hljs-comment">//收到中断时take会抛出InterruptException</span><br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-2-worker退出流程"><a href="#2-2-worker退出流程" class="headerlink" title="2.2 worker退出流程"></a>2.2 worker退出流程</h3><p>从上面<code>runWorker(Worker)</code>的处理流程可以看到，当一个<code>Worker</code>无法获得新任务时，那么就会调用<code>processWorkerExit(Worker,boolean)</code>将当前<code>Worker</code>移出线程集合，并根据当前池内的线程数量来决定是否要添加新的<code>Worker</code>，实现逻辑如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-keyword">boolean</span> completedAbruptly)</span> </span>&#123;<br>    <span class="hljs-comment">//如果工作线程的结束是因为用户的代码产生了异常</span><br>    <span class="hljs-keyword">if</span> (completedAbruptly) <span class="hljs-comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span><br>        decrementWorkerCount();<br><br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    <span class="hljs-comment">//对线程集合进行互斥访问</span><br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        completedTaskCount += w.completedTasks;<br>        <span class="hljs-comment">//将当前线程移出工作队列</span><br>        workers.remove(w);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br><br>    <span class="hljs-comment">//尝试关闭线程池</span><br>    tryTerminate();<br><br>    <span class="hljs-keyword">int</span> c = ctl.get();<br>    <span class="hljs-comment">//如果当前线程池处于RUNNING/SHUTDOWN状态</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 那么这里可能会产生一个问题：如果处于SHUTDOWN状态，我们应该将所有的Worker移出集合</span><br><span class="hljs-comment">    * 但是SHUTDOWN是可以通过下面的if条件，那么最后又会执行addWorker()，又往集合中添加一个新的worker</span><br><span class="hljs-comment">    * 那岂不是集合内的worker永远都无法彻底移出？</span><br><span class="hljs-comment">    * 其实这种担心是多虑的，因为addWorker()会首先检查当前线程池的状态，如果为SHUTDOWN，直接返回false</span><br><span class="hljs-comment">    * 并不会构造新的worker</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;<br>        <span class="hljs-comment">//如果工作线程是正常地结束</span><br>        <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;<br>            <span class="hljs-keyword">int</span> min = allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;<br>            <span class="hljs-comment">//如果核心线程有失效时间限制并且阻塞队列不为空</span><br>            <span class="hljs-comment">//那么线程池中至少要保留一个线程</span><br>            <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.isEmpty())<br>                min = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// replacement not needed</span><br>        &#125;<br>        <span class="hljs-comment">//如果线程数量小于min，那么需要补上一个新的worker</span><br>        addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在将无法获得任务的线程移出集合后，会根据当前是否允许核心线程过期获得线程池的最低线程数量：</p><ol><li>如果当前线程数量仍然不小于最低限度，直接返回即可，不需要重新补充<code>Worker</code></li><li>如果当前线程数小于最低限度，那么需要最后调用<code>addWorker()</code>重新补充一个<code>Worker</code></li></ol><h2 id="3-线程池终止流程"><a href="#3-线程池终止流程" class="headerlink" title="3. 线程池终止流程"></a>3. 线程池终止流程</h2><p><strong>对于线程池来说，关闭线程池（shutdown）和终止线程池（terminate）完全是两码事</strong>。所谓的关闭，是指线程池不再接受新的任务，而终止则是线程池中的所有工作线程都已经正确地关闭。</p><h3 id="3-1-shutdown-的执行逻辑"><a href="#3-1-shutdown-的执行逻辑" class="headerlink" title="3.1 shutdown()的执行逻辑"></a>3.1 shutdown()的执行逻辑</h3><p><code>ThreadPoolExectuor</code>提供了两种方法<code>shutdown</code>和<code>shutdownNow</code>用来关闭线程池。对于前者，它会保证已经提交到阻塞队列的任务被执行，并不是等到任务都执行完毕才会关闭线程池。在关闭的流程中，一直有一个问题困扰着我：为什么要通过调用<code>interrupt()</code>抛出中断当作线程池关闭的信号？带着这个问题，我首先梳理了<code>shutdown()</code>的逻辑。首先我们来看看<code>shutdown()</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//检查是否有权限关闭线程池</span><br>        checkShutdownAccess();<br>        <span class="hljs-comment">//将当前线程池升级到SHUTDOWN状态</span><br>        advanceRunState(SHUTDOWN);<br>        <span class="hljs-comment">//中断空闲的线程</span><br>        interruptIdleWorkers();<br>        <span class="hljs-comment">//为周期任务线程池准备的hook函数</span><br>        onShutdown();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    <span class="hljs-comment">//尝试真正地终止线程</span><br>    tryTerminate();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从源码中我们得知：当调用<code>shutdown()</code>方法后，首先会将线程池状态转化到SHUTDOWN。然后中断空闲的线程。那么这里就有两个问题：</p><ol><li>为什么要中断空闲线程？</li><li>为什么关闭线程池需要通过中断这个操作？</li></ol><p>对于第一个问题，先说说我的理解：所谓的关闭关闭线程池就是将每个工作线程正确关闭，又因为<code>shutdown()</code>不影响正在执行任务的线程，所以就先关闭空闲的线程。那么我们来看看<code>interruptIdleWorkers()</code>到底是如何运作的：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> onlyOne)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//遍历工作线程集合，找出空闲的线程并抛出中断</span><br>        <span class="hljs-keyword">for</span> (Worker w : workers) &#123;<br>            Thread t = w.thread;<br>            <span class="hljs-comment">//如果线程没有被中断并且能够获取worker的独占锁</span><br>            <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    t.interrupt();<br>                &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    w.unlock();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (onlyOne)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在分析<code>Worker</code>的工作流程时，曾说到，当一个<code>worker</code>正在执行任务时，会使用自身的独占不可重入锁上锁。那么在查询空闲<code>worker</code>时就利用了这个特点：<code>w.tryLock()</code>成功就说当前<code>worker</code>没有上锁，那也就是没有执行任务，自然可以关闭了。</p><p>那么这里的关闭的操作实际上调用当前<code>worker</code>的<code>interrupt()</code>函数发出一个中断，why？我们思考如下一个场景：</p><p>首先我们中断的都是空闲线程，那么空闲线程都在干嘛？是不是都在等待获取新的任务？那么如何等待？也就是通过调用阻塞队列的<code>take()</code>方法（无限等待场景下），当我们发生一个中断时，<code>take()</code>方法会抛出一个<code>InterruptException</code>，会在<code>getTask()</code>方法中被捕获。</p><p>捕获之后，也就说明被中断的<code>worker</code>已经被唤醒了。那么会重新执行循环，在循环初始部分，会判断当前线程池的状态，如果为SHUTDOWN或者类似的，会返回null。返回null表示什么？表示当前<code>worker</code>可以结束使命了，那么会跳出<code>runWorker()</code>中的循环，执行<code>processWorkerExit(Worker,boolean)</code>。在<code>processWorkerExit(Worker,boolean)</code>中，又会调用<code>tryTerminate()</code>尝试终止线程池。该函数的任务就是当线程池数量为0，将线程池状态转化为TIDYING状态，并执行hook函数<code>terminated()</code>。最后转化为TERMINATED状态。</p><p>值得注意的是，<code>tryTerminate()</code>中会调用<code>interruptIdleWorkers(ONLY_ONE)</code>传播线程池准备终止的信息。那么怎么传播呢？我们观察上述<code>interruptIdleWorkers()</code>函数的源码，因为我们传入的参数为true，那么会随机中断一个空闲线程<code>worker</code>。而空闲线程在被移出线程集合后，又会调用<code>processWorkerExit(Worker,boolean)</code>。周而复始，最后所有的空闲工作线程都会收到中断。<code>tryTerminate()</code>逻辑如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//这个方法只能在可能需要终止线程池的时候调用，例如剔除无用worker或者在shutdown状态移出队列任务</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryTerminate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-comment">//如果线程池处于RUNNING状态</span><br>        <span class="hljs-comment">//如果线程池正在处于终止状态</span><br>        <span class="hljs-comment">//或者线程池处于SHUTDOWN并且阻塞队列不为空</span><br>        <span class="hljs-comment">//那么就不需要再终止了，终止一次就够了</span><br>        <span class="hljs-keyword">if</span> (isRunning(c) ||<br>            runStateAtLeast(c, TIDYING) ||<br>            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//走到这说明线程池没有任务需要执行了，处于需要终止的状态</span><br><br>        <span class="hljs-comment">//如果线程数量不为0，那么就尝试中断最多一个空闲线程，并传播这个中断状态</span><br>        <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Eligible to terminate</span><br>            interruptIdleWorkers(ONLY_ONE);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//如果池中的线程数量为0，那么尝试将线程池状态转化为TIDYING</span><br>        <span class="hljs-comment">//如果转化成功，则会执行hook函数terminated()，并把线程池状态转化为TERMINATED</span><br>        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    terminated();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));<br>                    <span class="hljs-comment">//唤醒在awaitTermination条件上等待的线程</span><br>                    termination.signalAll();<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>        <span class="hljs-comment">// else retry on failed CAS</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么这里又有一个问题了，上面中断的都是空闲工作线程，如果我们执行<code>shutdown()</code>时，没有空闲线程怎么办？正在执行任务的线程如何被回收？岂不是会在<code>runWorker()</code>中，因为调用<code>getTask()</code>一直被阻塞直到获取新的任务，但是又永远都不会有新任务？我想了很久，最后发现答案竟然在<code>getTask()</code>的源码中。当我们的工作线程执行完当前任务后，会再次调用<code>getTask()</code>，而<code>getTask()</code>在一开始就会判断当前线程池的状态，如果状态为SHUTDOWN并且阻塞队列为空，那么直接返回，不会被阻塞。从而最后也会执行<code>processWorkerExit(Worker,boolean)</code>，传播中断状态。</p><h3 id="3-2-shutdownNow的区别"><a href="#3-2-shutdownNow的区别" class="headerlink" title="3.2 shutdownNow的区别"></a>3.2 shutdownNow的区别</h3><p>对于<code>shutdownNow()</code>方法，跟<code>shutdown()</code>流程差不多。唯一不同的是：<code>shutdownNow()</code>不管<code>worker</code>有没有执行任务，只要<code>worker</code>执行过<code>runWorker(Worker)</code>函数，就发出一个中断请求。我们需要注意的是：中断请求对于空闲线程来说是一定有限的；对于正在执行任务的线程，这需要用户任务的配合，也就说用户任务能够处理中断才能结束未完成的任务。后续的流程就跟<code>shutdown()</code>几乎一样。调用<code>tryTerminate()</code>尝试终止线程池。<code>shutdownNow()</code>方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Attempts to stop all actively executing tasks, halts the</span><br><span class="hljs-comment">* processing of waiting tasks, and returns a list of the tasks</span><br><span class="hljs-comment">* that were awaiting execution. These tasks are drained (removed)</span><br><span class="hljs-comment">* from the task queue upon return from this method.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* &lt;p&gt;This method does not wait for actively executing tasks to</span><br><span class="hljs-comment">* terminate.  Use &#123;<span class="hljs-doctag">@link</span> #awaitTermination awaitTermination&#125; to</span><br><span class="hljs-comment">* do that.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* &lt;p&gt;There are no guarantees beyond best-effort attempts to stop</span><br><span class="hljs-comment">* processing actively executing tasks.  This implementation</span><br><span class="hljs-comment">* cancels tasks via &#123;<span class="hljs-doctag">@link</span> Thread#interrupt&#125;, so any task that</span><br><span class="hljs-comment">* fails to respond to interrupts may never terminate.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span> </span>&#123;<br>List&lt;Runnable&gt; tasks;<br><span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>mainLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    checkShutdownAccess();<br>    advanceRunState(STOP);<br>    interruptWorkers();<br>    tasks = drainQueue();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    mainLock.unlock();<br>&#125;<br>tryTerminate();<br><span class="hljs-keyword">return</span> tasks;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="4-内置线程池"><a href="#4-内置线程池" class="headerlink" title="4. 内置线程池"></a>4. 内置线程池</h2><p>JUC中提供了四种基于<code>ThreadPoolExecutor</code>的内置线程池：</p><ol><li><p><strong>newFixedThreadPool</strong>：核心线程数和最大线程数相等的线程，阻塞队列无限长度。也就是说线程池的线程数量固定</p></li><li><p><strong>newCachedThreadPool</strong>：核心线程数为0的线程池，并且阻塞队列不存储任务。也就是说该线程池只会使用非核心线程来处理任务，如果超过60秒等不到新的任务，那么则会回收当前线程</p></li><li><p><strong>newSingleThreadExecutor</strong>：线程池的线程数量为1，阻塞队列无限长度。也就是线程数量固定为1的线程池。该线程池能够保证任务串行地完成</p></li><li><p><strong>newScheduledThreadPool</strong>：核心线程数固定地的周期任务线程池</p></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><p><a href="https://segmentfault.com/a/1190000016586578">Java多线程进阶（三九）—— J.U.C之executors框架：executors框架概述</a></p></li><li><p><a href="https://javamana.com/2021/02/20210228205934972L.html">Java并发之ThreadPoolExecutor源码解析（三）</a></p></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="https://eripe.me/tags/Executor/">Executor</category>
      
      
      <comments>https://eripe.me/articles/ThreadPoolExecutor.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>中断机制</title>
      <link>https://eripe.me/articles/Interrupt-mechanism.html</link>
      <guid>https://eripe.me/articles/Interrupt-mechanism.html</guid>
      <pubDate>Mon, 30 Aug 2021 16:38:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;在多线程环境下，终止一个线程的任务最好的方法是通过中断。而Java的中断类似于通知协作机制，被中断的线程并不会立即停止自己的任务，而是仅仅收到了中断的通知，具体怎么处理收到的中断，这需要用户自己</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>在多线程环境下，终止一个线程的任务最好的方法是通过中断。而Java的中断类似于通知协作机制，被中断的线程并不会立即停止自己的任务，而是仅仅收到了中断的通知，具体怎么处理收到的中断，这需要用户自己定义。那么为什么说Java的中断类似于通知机制？我们首先需要了解中断到底做了什么。</p><h2 id="1-实施中断"><a href="#1-实施中断" class="headerlink" title="1. 实施中断"></a>1. 实施中断</h2><p>Java中的中断操作只需要调用目标线程的<code>interrupt()</code>方法即可完成。那么这个方法到底做了什么？我们来看看具体的实现源码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Interrupts this thread.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * &lt;p&gt; Unless the current thread is interrupting itself, which is</span><br><span class="hljs-comment">    * always permitted, the &#123;<span class="hljs-doctag">@link</span> #checkAccess() checkAccess&#125; method</span><br><span class="hljs-comment">    * of this thread is invoked, which may cause a &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment">    * SecurityException&#125; to be thrown.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * &lt;p&gt; If this thread is blocked in an invocation of the &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment">    * Object#wait() wait()&#125;, &#123;<span class="hljs-doctag">@link</span> Object#wait(long) wait(long)&#125;, or &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment">    * Object#wait(long, int) wait(long, int)&#125; methods of the &#123;<span class="hljs-doctag">@link</span> Object&#125;</span><br><span class="hljs-comment">    * class, or of the &#123;<span class="hljs-doctag">@link</span> #join()&#125;, &#123;<span class="hljs-doctag">@link</span> #join(long)&#125;, &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment">    * #join(long, int)&#125;, &#123;<span class="hljs-doctag">@link</span> #sleep(long)&#125;, or &#123;<span class="hljs-doctag">@link</span> #sleep(long, int)&#125;,</span><br><span class="hljs-comment">    * methods of this class, then its interrupt status will be cleared and it</span><br><span class="hljs-comment">    * will receive an &#123;<span class="hljs-doctag">@link</span> InterruptedException&#125;.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * &lt;p&gt; If this thread is blocked in an I/O operation upon an &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment">    * java.nio.channels.InterruptibleChannel InterruptibleChannel&#125;</span><br><span class="hljs-comment">    * then the channel will be closed, the thread&#x27;s interrupt</span><br><span class="hljs-comment">    * status will be set, and the thread will receive a &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment">    * java.nio.channels.ClosedByInterruptException&#125;.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * &lt;p&gt; If this thread is blocked in a &#123;<span class="hljs-doctag">@link</span> java.nio.channels.Selector&#125;</span><br><span class="hljs-comment">    * then the thread&#x27;s interrupt status will be set and it will return</span><br><span class="hljs-comment">    * immediately from the selection operation, possibly with a non-zero</span><br><span class="hljs-comment">    * value, just as if the selector&#x27;s &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment">    * java.nio.channels.Selector#wakeup wakeup&#125; method were invoked.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * &lt;p&gt; If none of the previous conditions hold then this thread&#x27;s interrupt</span><br><span class="hljs-comment">    * status will be set. &lt;/p&gt;</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span>  SecurityException</span><br><span class="hljs-comment">    *          if the current thread cannot modify this thread</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@revised</span> 6.0</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@spec</span> JSR-51</span><br><span class="hljs-comment">    */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interrupt</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != Thread.currentThread())<br>        checkAccess();<br><br>    <span class="hljs-keyword">synchronized</span> (blockerLock) &#123;<br>        Interruptible b = blocker;<br>        <span class="hljs-keyword">if</span> (b != <span class="hljs-keyword">null</span>) &#123;<br>            interrupt0();           <span class="hljs-comment">// Just to set the interrupt flag</span><br>            b.interrupt(<span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    interrupt0();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注释很长，我们分开慢慢细品。首先是第一段：</p><blockquote><p>Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.</p></blockquote><p>大意是说：任何一个线程都肯定能中断它自己，如果希望中断别的线程，那么需要通过<code>checkAccess()</code>方法检查权限，并且可能会抛出<code>SecurityException</code>异常。这很好理解。任何一个线程都可能接受到中断。</p><p>接着是第二段：</p><blockquote><p>If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.</p></blockquote><p>上面的注释中提到了两个新鲜玩意，<code>interrupt status</code>(中断状态)和<code>InterruptException</code>。中断状态就是实现中断通知机制的关键。当一个线程被中断后，它的中断标记可能会被改变。为什么说可能？<br>因为有些例外情况只会抛出中断异常而不是设置中断状态。而这些例外情况在第二段的注释已全部声明：如果中断目标是因为调用了以下的方法进入阻塞状态，那么目标线程的中断位会被<strong>清除</strong>，并且目标线程会收到<code>InterruptedException</code>异常：</p><ul><li><code>Object.wait()</code></li><li><code>Object.wait(long)</code></li><li><code>Object.wait(long,int)</code></li><li><code>Thread.join()</code></li><li><code>Thread.join(long)</code></li><li><code>Thread.join(long,int)</code></li><li><code>Thread.sleep(long)</code></li><li><code>Thread.sleep(long,int)</code></li></ul><p>接着是第三、四关于NIO的中断情况：</p><blockquote><p>If this thread is blocked in an I/O operation upon an InterruptibleChannel then the channel will be closed, the thread’s interrupt status will be set, and the thread will receive a java.nio.channels.ClosedByInterruptException.<br>If this thread is blocked in a java.nio.channels.Selector then the thread’s interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector’s wakeup method were invoked.</p></blockquote><p>如果中断目标是因为调用了<code>InterruotibleChannel()</code>而被阻塞，那么当收到中断时channel将被关闭，并且<strong>设置中断目标的中断状态</strong>，同时会收到<code>java.nio.channels.ClosedByInterruptException</code>。<br>或者中断目标是因为调用了<code>channels.Selector()</code>而被阻塞，那么当收到中断时该方法会立即返回，并且<strong>设置中断目标的中断状态</strong>。</p><p>接下来是最后一段：</p><blockquote><p>f none of the previous conditions hold then this thread’s interrupt status will be set.Interrupting a thread that is not alive need not have any effect.</p></blockquote><p>很简单，就是上面的情况除外，其他任何时候发生中断只会设置中断目标的中断标志。例如在运行时发起中断，目标线程只会设置中断标志。</p><h2 id="2-检测中断"><a href="#2-检测中断" class="headerlink" title="2. 检测中断"></a>2. 检测中断</h2><p>而检测中断的方法有两种：<code>interrupted</code>和<code>isInterrupted</code>。这两种方法都是检测当前当前线程的中断状态。唯一的区别就是：<code>interrupted</code>会清除调用线程的中断状态。也就是说如果连续调用两次该方法（在两次调用之间没有发生中断），中断标志一定是<code>false</code>。那么这两个方法一般用在哪里呢？这就跟中断发生的场景有关了，中断发生的情况一般只有两种：</p><ol><li>调用<code>wait</code>阻塞后，发生中断</li><li>线程运行时，发起中断</li></ol><p>对于第一种情况，因为会抛出中断异常，所以我们一般用以下模式检测中断：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// do some task</span><br>            <span class="hljs-comment">// blocked by calling wait/sleep/join</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;  <br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 这里使用break, 可以使我们在线程中断后退出死循环，从而终止线程。</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于第二种情况，因为只会设置中断标志，所以我们一般使用<code>interrupted</code>或者<code>isinterrupted</code>检测中断情况：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//isInterrupted() 用于终止一个正在运行的线程。</span><br>    <span class="hljs-keyword">while</span> (!isInterrupted()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//    do something</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;  <br>            <span class="hljs-comment">// 在这里不做任何处理，仅仅依靠isInterrupted检测异常</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>Java中的中断只是一种通知机制，并不会立即中断目标线程，被中断的线程如何响应中断完全是程序员自己的事。中断机制的核心内容就是中断标志<code>interrupted status</code>与中断异常<code>InterruptException</code>。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://segmentfault.com/a/1190000016083002">Thread类源码解读(3)——线程中断interrupt</a></p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">多线程基础</category>
      
      
      <category domain="https://eripe.me/tags/interrupt/">interrupt</category>
      
      
      <comments>https://eripe.me/articles/Interrupt-mechanism.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java内存模型</title>
      <link>https://eripe.me/articles/JMM.html</link>
      <guid>https://eripe.me/articles/JMM.html</guid>
      <pubDate>Mon, 30 Aug 2021 16:38:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;1-内存模型-memory-model&quot;&gt;&lt;a href=&quot;#1-内存模型-memory-model&quot; class=&quot;headerlink&quot; title=&quot;1.</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1-内存模型-memory-model"><a href="#1-内存模型-memory-model" class="headerlink" title="1. 内存模型(memory model)"></a>1. 内存模型(memory model)</h2><h3 id="1-1-内存模型是什么"><a href="#1-1-内存模型是什么" class="headerlink" title="1.1. 内存模型是什么"></a>1.1. 内存模型是什么</h3><p>在编译和运行程序时，编译器和CPU都会为了效率而力所能及地对程序进行优化，例如编译器和CPU的指令重排、CPU的流水线执行等操作。但是这种优化不是没有限制的，如果不能及时保证<strong>内存的可见性</strong>，程序就有可能出现错误,这里的可见性是指如果有一个线程A对某个内存地址addr进行了写操作，那么其他线程一定能够看到A对地址addr的操作。</p><p>所以内存模型就应运而生了，它能够保证优化后的程序的执行结果仍然与程序串行执行时一样。其实现原理是保证多线程之间的内存可见性，编译器和CPU需要在不违背内存模型的前提下，尽可能地达到优化的最大程度。这里所说的内存模型是一组规则，是抽象的，而不是像jvm的内存布局是具体存在的。</p><p>内存模型的实现基于内存屏障（memory barrier）。内存屏障分为四种类型：</p><ol><li>LoadLoad</li><li>LoadStore</li><li>StoreStore</li><li>StoreLoad</li></ol><p>在此我仅解释<code>LoadLoad</code>内存屏障的含义，剩余三条可类推：</p><figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm"><span class="hljs-keyword">load</span> <span class="hljs-keyword">x</span><span class="hljs-number">1</span><span class="hljs-comment">;</span><br>LoadLoad memory barrier<br><span class="hljs-keyword">load</span> <span class="hljs-keyword">x</span><span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>LoadLoad表示的内容时load x1的操作必须发生在load x2操作之前。</p><p>这四种类型的内存屏障并不是完全需要，这需要根据底层架构的内存模型来决定。内存模型大体可以分为两种：</p><ul><li>强内存模型：一个CPU核的写操作对剩余的CPU都可见</li><li>若内存模型：该模型需要使用上面提到的所有内存屏障来确保优化操作的正确性</li></ul><p>x86架构采用的就是强内存模型，所以在汇编中最多使用<code>StoreLoad</code>这一种屏障就足够了，其对应的具体汇编指令就是<code>lock</code>。</p><h2 id="2-JMM是什么"><a href="#2-JMM是什么" class="headerlink" title="2. JMM是什么"></a>2. JMM是什么</h2><p>因为每一个架构都有它自己的内存模型，这就可能带来Java程序的移植性问题。所以为了屏蔽底层架构的内存模型的差异性，Java开发团队为Java在多架构的背景下提出了跨平台的、具有移植性的内存模型，即Java memory model。它同样是靠指令中插入内存屏障（memory barrier）来实现的。我们先不谈JMM内存屏障的插入策略。我们思考一个问题，插入策略是如何制定的。</p><p>在JSR-133之后，JMM是一组基于<code>happens before</code>关系（后文简称hb）的规则。hb通过保证<strong>部分</strong>指令的有序性达到内存可见性，并且极大地简化了并发编程的难度。如果<code>操作A hb 操作B</code>，那么编译器、处理器以及内存系统必须保证操作A的结果对操作B可见。</p><h3 id="2-1-happens-before-relation"><a href="#2-1-happens-before-relation" class="headerlink" title="2.1 happens before relation"></a>2.1 happens before relation</h3><p>hb规则总计下面6条（简而言之就是read/write,lock/unlock,start/join threads）：</p><ul><li><p>程序次序规则(single thread rule) ：一个线程内，按照原始书写的<strong>没有被重排序</strong>的代码<strong>控制流</strong>顺序，编码在前面的<code>action</code>（包括内存读写、解锁、上锁等） 先行发生于编码在后面的<code>action</code>(<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.3">action的定义</a>)；<br><img src="images/thread-start-rule.png" alt="single thread rule"></p></li><li><p>锁定规则(monitor lock rule)：对于一个monitor lock的unLock操作 <code>happens before</code> 后面所有的对同一个monitor lock的lock操作；<br><img src="images/monitor-lock-rule.png" alt="monitor lock rule"></p></li><li><p>volatile变量规则(volatile variable rule)：对一个volatile变量的写操作<code>happens before</code>后面所有的对这个变量的读操作；<br><img src="images/volatile-variable-rule.png" alt="volatile-variable-rule"></p></li><li><p>线程启动规则（thread start rule）：Thread对象的start()方法<code>happens before</code>当前被启动线程的<code>run()</code>方法中的每个一个动作；<br><img src="images/thread-start-rule.png" alt="thread-start-rule"></p></li><li><p>线程终结规则（thread join rule）：假定线程A在执行的过程中，通过调用ThreadB.join()等待线程B终止，那么在join()返回后，线程B在run()完成的操作在线程A都可见<br><img src="images/thread-join-rule.png" alt="thread-join-rule"></p></li><li><p>传递规则(thread start rule)：如果操作A<code>happens before</code>操作B，而操作B又<code>happens before</code>操作C，则可以得出操作A<code>happens before</code>操作C；但是如果有 operation1(o1) &amp; operation2(o2) <code>happens before</code> operation3，并不能推导出 o1 <code>happens before</code> o2。所以o1和o2之间有没有重排序JMM并不关心</p></li></ul><p>通过上面六条规则，可以总结出四个方面的hb关系：</p><ol><li>初始化<ul><li>将字段初始化为默认值（例如将int初始化为0、boolean初始化为false）的操作 <code>happens before</code> 任何线程对同一字段地访问操作</li><li>对<code>static final</code>字段的写操作 <code>happens before</code> 任何线程对该字段的读操作</li><li>对<code>non-static final</code>字段的写操作 <code>happens before</code> 该线程后续通过引用访问当前对象同一字段的操作</li></ul></li><li>内存访问<ul><li>对一个monitor lock的unlock操作或者volatile写操作（volatile就相当于unlock操作，因为完成volatile写后，volatile读能够读到新值，就像unlock时，unlock之前的操作对lock操作来说都是可见的） <code>happens before</code> 任意线程对同一个monitor lock的lock操作或者对同一字段的volatile读</li><li>volatile读或者lock操作 <code>happens before</code> 当前线程后续对内存的所有操作</li></ul></li><li>原子操作<ul><li><code>java.utl.concurrent.atmoic.get()</code>方法的效果相当于volatile读，<code>xxxx.set()</code>方法的效果相当于volatile写</li><li><code>weakCompareAndSet</code> <code>happens before</code> 当前线程后续所有对原子字段的操作</li></ul></li><li>线程<ul><li><code>Thread.start()</code>方法之前的所有操作 <code>happens before</code> 新线程<code>run()</code>方法中的所有操作</li><li>任何写操作 <code>happens before</code> 当前线程的终止操作</li></ul></li></ol><p>上面的规则有点难以理解，但是我们要记住一句话：</p><blockquote><p><strong>规则 A hb B，仅表示JMM保证（通过内存屏障实现）A的操作结果能被B看到，并不保证操作A一定在操作B之前发生。</strong><br>那么在JMM保证的基础上，如果（注意是如果）A发生了，那么B一定能看到。我们需要做的就是保证这个“如果”在某些特定情况下变成“必须”。想想如果没有hb规则，那么即使A先于B发生，B也有可能看不到A的操作结果。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">int</span> a=<span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">int</span> b=<span class="hljs-number">2</span>;<br><br></code></pre></div></td></tr></table></figure><p>如果对指令进行重排序后的结果和遵守A hb B的执行是一样的（简而言之就是操作A和B不会发生访问冲突，没有共享内存），那么JVM并不会禁止这样的重排序。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/happens-before.html#:~:text=Happens%2Dbefore%20relationship%20is%20a,another%20action%20in%20different%20thread.&text=Happens%2Dbefore%20is%20not%20just,read%20and%20write%20to%20memory%20.">Java - Understanding Happens-before relationship</a></p></li><li><p><a href="http://gee.cs.oswego.edu/dl/cpj/JMMsynopsis.html">JMM Synopsis</a></p></li><li><p><a href="https://www.waitingforcode.com/java-memory-model/java-memory-model/read">Java memory model</a></p></li><li><p><a href="https://dzone.com/articles/multithreading-and-java-memory">Multithreading and the Java Memory Model</a></p></li></ol>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">多线程基础</category>
      
      
      <category domain="https://eripe.me/tags/JMM/">JMM</category>
      
      
      <comments>https://eripe.me/articles/JMM.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>线程的状态转换</title>
      <link>https://eripe.me/articles/Thread-state-transition.html</link>
      <guid>https://eripe.me/articles/Thread-state-transition.html</guid>
      <pubDate>Mon, 30 Aug 2021 16:38:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;因为线程是调度的基本单位，所以线程的状态转换与进程的状态转换是一致的。主要有五个状态：启动、就绪、执行、等待、销毁。这几个状态的转换图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>因为线程是调度的基本单位，所以线程的状态转换与进程的状态转换是一致的。主要有五个状态：启动、就绪、执行、等待、销毁。这几个状态的转换图如下所示：</p><p><img src="images/java-thread-state.drawio.svg" alt="线程状态转换图"></p><p>可以看到，等待状态只能转换为就绪，再等CPU调度。这是一般的线程状态转换图。</p><p>在java中，又多了几个状态。</p><h2 id="java中的线程状态"><a href="#java中的线程状态" class="headerlink" title="java中的线程状态"></a>java中的线程状态</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">State</span> </span>&#123;<br>    NEW,<br><br>    RUNNABLE,<br><br>    BLOCKED,<br><br>    WAITING,<br><br>    TIMED_WAITING,<br><br>    TERMINATED;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在java中，自定义的线程状态有6个。</p><ul><li><code>NEW</code>:表示线程还未启动</li><li><code>RUNNABLE</code>：就绪或者运行状态</li><li><code>BLOCKED</code>：等待锁</li><li><code>WAITINTG</code>：无限时等待</li><li><code>TIMED_WAITING</code>：有限时间等待</li><li><code>TERMINATED</code>：线程终止</li></ul><h3 id="BLOCKED状态"><a href="#BLOCKED状态" class="headerlink" title="BLOCKED状态"></a>BLOCKED状态</h3><p>进入BOCKED状态是因为需要请求锁资源，注意请求锁资源不影响线程本身的调度，但是如果一直不停的处于BLOCKED,会浪费资源，应当转为等待状态。</p><h3 id="WAITING状态"><a href="#WAITING状态" class="headerlink" title="WAITING状态"></a>WAITING状态</h3><p>进入WAITING状态的方法有三个：</p><ul><li>Object.wait()</li><li>Thread.join():该方法底层就是调用了wait，阻塞了当前线程</li><li>LockSupport.park()：这个方法我也是第一次见，具体含义为：除非获得调用许可，否则禁用当前线程进行线程调度</li></ul><p>进入WAITING状态就不参与CPU的线程调度了，直到系统对线程进行唤醒。那么从WAITING进入RUNNABLE有三个方法。</p><ul><li>Object.notify()</li><li>Object.notifyAll()</li><li>LockSupport.uppark(THread)</li></ul><h3 id="TIMED-WAITING状态"><a href="#TIMED-WAITING状态" class="headerlink" title="TIMED_WAITING状态"></a>TIMED_WAITING状态</h3><p>进入TIMED_WAITING的方法有四个：</p><ul><li><code>Object.wait(long times)</code>：加入参数后表示我这个线程最多等待times毫秒，时间一到，不管锁能不能用，我都会进入RUNNABLE状态参与进程调度。</li><li><code>Thread.join(long time)</code>: 这个方法同理，在底层会调用wait(time)。</li><li><code>Thread。sleep(long time)</code>:指定睡眠时常</li><li><code>LockSupport.parkNanos(long nanos)</code>： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；</li><li><code>LockSupport.parkUntil(long deadline)</code>：同上，也是禁止线程进行调度指定时间；</li></ul><blockquote><p>在调用上面这些方法前，我们不要想，我们是通过哪些对象来调用的方法，而是要思考在哪个线程中会执行调用方法的代码！这样才不容易搞混到底让谁wait，让谁runnable。</p></blockquote><h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>线程转换图如下(<a href="http://concurrent.redspider.group/article/01/4.html">图片来源</a>)：</p><p><img src="images/java-thread-state.png" alt="java线程状态转换图"></p><h4 id="BLOCKED与RUNNABLE的转换"><a href="#BLOCKED与RUNNABLE的转换" class="headerlink" title="BLOCKED与RUNNABLE的转换"></a>BLOCKED与RUNNABLE的转换</h4><p>在java中，就绪和运行都属于RUNNABLE，BLOCKED与RUNNABLE之间的转换是非常简单的，只要一个线程先得到锁，然后另一个线程就会不断尝试取获取锁，这个不断尝试的状态就是<code>BLOCKED</code>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Thread t1=<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;t1 is running&quot;</span>);<br>                lockMethod();<br><br>            &#125;<br>        &#125;);<br><br>        Thread t2=<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;t2 is running&quot;</span>);<br>                lockMethod();<br>            &#125;<br>        &#125;);<br>        t1.start();<br>        t2.start();<br><br>        System.out.println(<span class="hljs-string">&quot;t1 state: &quot;</span>+t1.getState());<br>        System.out.println(<span class="hljs-string">&quot;t2 state:&quot;</span>+ t2.getState());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockMethod</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;in lockMethod&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>上面的代码不一定会出现BLOCKED状态，因为从线程启动到线程执行还是要花点时间的，并且谁先得到锁还不一定，那么如果我们想让第二个线程出现BLOCKED状态怎么办？那么就需要第一个线程必得到锁。那么只需要让主线程睡一会，调用<code>sleep(time)</code>还是<code>wait(time)</code>都行。</p><h4 id="WAITING与RUNNABLE的转换"><a href="#WAITING与RUNNABLE的转换" class="headerlink" title="WAITING与RUNNABLE的转换"></a>WAITING与RUNNABLE的转换</h4><p>进入WAITING状态有三个方法，但是最常用的只用两个，就是<code>wait()</code>和<code>join()</code>方法，wait会释放锁，但是join不会。从WAITING转为RUNNABLE主要有<code>notify()</code>、<code>notifyAll()</code>，注意这个notify，它只是通知等待当前锁的线程，可以醒了，你们可以参与进程调度了，但是不会释放锁直到离开同步区。</p><p>而且如果有多个线程等待的是同一个锁，<code>notify()</code>只会唤醒一个等待锁的线程，至于唤醒的是谁，这就不知道了。同理<code>notifyAll()</code>唤醒所有等待锁的线程，谁抢得到锁，这个也不一定。</p><p>而<code>join()</code>方法其实在调用<code>join(0)</code>，不会释放当前锁，值到这个锁对象代表的线程terminated。因为调用的方式为<code>t1.join()</code>，t1即是Thread对象，也是个锁对象。</p><h4 id="TIMED-WAITING与RUNNABLE的转换"><a href="#TIMED-WAITING与RUNNABLE的转换" class="headerlink" title="TIMED_WAITING与RUNNABLE的转换"></a>TIMED_WAITING与RUNNABLE的转换</h4><p>进入TIMED_WAITING的方法常用的有三个:<code>join(time)``sleep(time)``wait(time)</code>。sleep不会释放锁，join应该会，这里不确定。wait一定会释放锁。</p><h4 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h4><p>进入TERMINATED的方法有三个：</p><ul><li>Thread.interrupt()：中断线程。这里的中断线程并不会立即停止线程，而是设置线程的中断状态为true（默认是flase）；</li><li>Thread.interrupted()：测试当前线程是否被中断。线程的中断状态受这个方法的影响，意思是调用一次使线程中断状态设置为true，连续调用两次会使得这个线程的中断状态重新转为false；</li><li>Thread.isInterrupted()：测试当前线程是否被中断。与上面方法不同的是调用这个方法并不会影响线程的中断状态。</li></ul><p>注意java里的中断也是一种建议，跟设置线程的优先级一样，被通知请求中断的线程到底断不断需要由被请求中断的线程自己决定。可以中断、也可以不中断。</p><p><strong>中断机制和设置优先级一样，完全是个建议!!!</strong></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://concurrent.redspider.group/article/01/4.html">RedSpider</a></p>]]></content:encoded>
      
      
      <category domain="https://eripe.me/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</category>
      
      
      <category domain="https://eripe.me/tags/%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/">状态转换</category>
      
      
      <comments>https://eripe.me/articles/Thread-state-transition.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
