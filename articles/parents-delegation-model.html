

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/panda.png">
  <link rel="icon" href="/img/panda.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#55967e">
  <meta name="description" content="欢迎乘坐八楼的二路公交车">
  <meta name="author" content="Rains.Lee">
  <meta name="keywords" content="Java">
  
  <title>双亲委派模型 - 一颗胡杨树</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"eripe.me","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":"UA-198559201-1","gtag":"G-19MVRDT9NM","tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"3MrDNVWQz1aBbREDmtPT7DuN-MdYXbMMI","app_key":"34YIO0Yk922Dzi79zUJidSkl","server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/rss2.xml" title="一颗胡杨树" type="application/rss+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Rains·Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/home.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="双亲委派模型">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-06-14 20:42" pubdate>
        2021年6月14日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      53
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">双亲委派模型</h1>
            
            <div class="markdown-body">
              <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先在了解双亲委派模型前，我们有必要了解它的英文名字：<code>parents delegation model</code>。其实在具体的模型中，并没有所谓的“双亲”，只有一个逻辑意义上的父类，详情见下文。</p>
<h2 id="1-类加载器"><a href="#1-类加载器" class="headerlink" title="1. 类加载器"></a>1. 类加载器</h2><p>在《深入理解java虚拟机》一书中写道：</p>
<blockquote>
<p>java团队有意将类加载阶段中的“通过一个类的全限定名来获取该类的二进制字节流”这个动作放到java虚拟机外部去实现<br>完成这个动作的代码就称为类加载器，以前不理解放到虚拟机外部是什么意思，现在我的理解是我们能够在编写程序时就能够编写目标类的加载过程，这也就是所谓的在虚拟机外部。这样如此，我们自定义的类加载器就能够处理我们自定义的字节码。</p>
</blockquote>
<p>值得一提的是：类加载器与类共同确定了该类在虚拟机中是否唯一。也就是说，在虚拟机要比较两个类是否相同，比较的前提是<strong>待比较的两个类是由同一个类加载器加载到虚拟机中的</strong>，才有比较的意义。</p>
<p>这里的比较包括：<code>instanceof</code>、Class对象的<code>equals()</code>、<code>isAssignableForm()</code>、<code>isInstance()</code>方法。</p>
<h2 id="2-双亲委派模型"><a href="#2-双亲委派模型" class="headerlink" title="2. 双亲委派模型"></a>2. 双亲委派模型</h2><p>在了解双亲委派模型前，我们需要知道，jvm中有三类自带的类加载器：</p>
<ul>
<li><code>bootstrap class loader</code>，启动类加载器</li>
<li><code>extension class loader</code>，扩展类加载器</li>
<li><code>Application class laoder</code>，应用程序类加载器</li>
</ul>
<p><strong>启动类加载器</strong><br>启动类加载器由cpp编写，在java代码中无法直接引用。该加载器负责加载java的核心库，包括<code>&lt;JAVA_HOME&gt;/lib/</code>下的库，例如rt.jar、tools.jar；或者由<code>-Xbootclasspath</code>指定的，并且存放在lib目录下的符合规则的库，这里的规则是库的名字由jvm指定，不符合名字要求的即使由参数指定，也不会被加载。</p>
<p>前面说到，该加载器由cpp编写时，所以在编写代码时如果我们需要使用到该加载器，我们可以用null指代启动类加载器，这一规则由java团队约定。</p>
<p><strong>扩展类加载器</strong><br>扩展类加载器由java编写，负责加载<code>&lt;JAVA_HOME&gt;/lib/ext/</code>目录下的库，或者由环境变量<code>java.extdirs</code>指定目录下的库。</p>
<p><strong>应用程序加载器</strong><br>应用程序类加载器通用由java编写，在代码中可以直接引用。该加载器是我们接触最多的加载器了，默认情况下，我们编写的class都由其加载至jvm中。它负责加载由<code>classpath</code>参数指定路径下的类库。</p>
<blockquote>
<p>应用程序类加载器由<code>sun.misc.Launcher$AppClassLoader</code>实现。并且应用程序类加载器是ClassLoader中的getSystemClassLoader()方法的返回值</p>
</blockquote>
<p>这三个加载器的关系如下所示：</p>
<p><img src="images/jvmclassloader.jpg" srcset="/img/loading.gif" lazyload alt="jvm class loader"></p>
<p>可以看到，<code>BootStrap ClassLoader</code>作为顶层的父类，<code>Extension ClassLoader</code>作为<code>BootStrap ClassLoader</code>的子类，而<code>Application ClassLoader</code>又作为<code>Extension ClassLoader</code>的子类。我们可以看到，这里并没有所谓的双亲，只有单亲，而这么翻译可能是因为第一个翻译的人看到的是parents吧。</p>
<blockquote>
<p>这里的父类与子类并不是传统意义上的使用extends保持的继承关系，而是通过内部包含来实现逻辑意义上的继承关系</p>
</blockquote>
<p><strong>三类加载器的初始化过程</strong></p>
<p>下图显示了<code>ExtClassLoader</code>、<code>AppClassLoader</code>、<code>ClassLoader</code>三者真正的继承关系。<br><img src="images/Inheritance.png" srcset="/img/loading.gif" lazyload alt="继承体系"></p>
<p><code>ExtClassLoader</code>和<code>AppClassLoader</code>处于平级的关系，那么如何实现所谓的双亲委派？这一切都要靠抽象类<code>ClassLoader</code>中的<code>parent</code>字段来实现，如下图所示：</p>
<p><img src="images/parents-field.png" srcset="/img/loading.gif" lazyload alt="parent字段"></p>
<p>每生成一个新的<code>ClassLoader</code>,都会用父类加载器去初始化它。那么这三个加载器是如何初始化的呢？这一切都起源于<code>Launcher</code>类。 <strong>该类由<code>Bootstrap ClassLoader</code>来加载。</strong> 我们来看看它的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Launcher</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Launcher launcher = <span class="hljs-keyword">new</span> Launcher();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String bootClassPath = System.getProperty(<span class="hljs-string">&quot;sun.boot.class.path&quot;</span>);<br>    <span class="hljs-keyword">private</span> ClassLoader loader;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Launcher <span class="hljs-title">getLauncher</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> launcher;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Launcher</span><span class="hljs-params">()</span> </span>&#123;<br>        Launcher.ExtClassLoader var1;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//初始化ExtClassLoader</span><br>            var1 = Launcher.ExtClassLoader.getExtClassLoader();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException var10) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(<span class="hljs-string">&quot;Could not create extension class loader&quot;</span>, var10);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//初始化loader字段，将其设置为AppClassLoader</span><br>            <span class="hljs-keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException var9) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(<span class="hljs-string">&quot;Could not create application class loader&quot;</span>, var9);<br>        &#125;<br>        <span class="hljs-comment">//设置线程上下文加载器，也就是AppClassLoader</span><br>        Thread.currentThread().setContextClassLoader(<span class="hljs-keyword">this</span>.loader);<br>        ...<br>    &#125;<br>    ...<br></code></pre></div></td></tr></table></figure>

<p>在<code>Bootstrap ClassLoader</code>把<code>Launcher</code>加载进虚拟机后，<code>Launcher</code>会初始化静态字段<code>Launcher</code>，然后会调用构造方法。在构造方法中，我们目前只需关注三个部分：</p>
<ol>
<li><p>使用<code>Launcher.ExtClassLoader.getExtClassLoader()</code>生成扩展类加载器<code>ExtClassLoader</code></p>
</li>
<li><p>使用<code>Launcher.AppClassLoader.getAppClassLoader(var1)</code>生成应用类加载器<code>App ClassLoader</code>,其中<code>var1</code>就是第一步生成的扩展类加载器，其用来初始化<code>parent</code>字段</p>
</li>
<li><p>使用<code>Thread.currentThread().setContextClassLoader(this.loader)</code>初始化线程上下文加载器，其中<code>loader</code>字段就是第二步生成的应用类加载器</p>
</li>
</ol>
<p>此外我们还需要关注以下<code>App ClassLoader</code>的生成方法，因为其与<code>classpath</code>的设置息息相关。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClassLoader <span class="hljs-title">getAppClassLoader</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ClassLoader var0)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//读取系统属性classpath</span><br>    <span class="hljs-comment">//这里读取的是一个整个字符串，因为在windows上由“;”将多个路径拼接成一个string</span><br>    <span class="hljs-comment">//linux平台使用“:”拼接多个路径组成一个string</span><br>    <span class="hljs-keyword">final</span> String var1 = System.getProperty(<span class="hljs-string">&quot;java.class.path&quot;</span>);<br>    <span class="hljs-comment">//将多个路径抽象为File</span><br>    <span class="hljs-keyword">final</span> File[] var2 = var1 == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> File[<span class="hljs-number">0</span>] : Launcher.getClassPath(var1);<br>    <span class="hljs-keyword">return</span> (ClassLoader)AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Launcher.AppClassLoader&gt;() &#123;<br>        <span class="hljs-keyword">public</span> Launcher.<span class="hljs-function">AppClassLoader <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">//将多个路径转化为URL数组</span><br>            URL[] var1x = var1 == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> URL[<span class="hljs-number">0</span>] : Launcher.pathToURLs(var2);<br>            <span class="hljs-comment">//使用URl路径和Ext ClassLoader生成新的AppClassLoader</span><br>            <span class="hljs-comment">//具体的初始化逻辑见下</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Launcher.AppClassLoader(var1x, var0);<br>        &#125;<br>    &#125;);<br>&#125;<br><br>AppClassLoader(URL[] var1, ClassLoader var2) &#123;<br>    <span class="hljs-comment">//调用父类URLClassLoader的构造函数保存多个classpath路径</span><br>    <span class="hljs-keyword">super</span>(var1, var2, Launcher.factory);<br>    <span class="hljs-keyword">this</span>.ucp.initLookupCache(<span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-comment">//父类URLClassLoader的构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">URLClassLoader</span><span class="hljs-params">(URL[] urls, ClassLoader parent,</span></span><br><span class="hljs-params"><span class="hljs-function">                        URLStreamHandlerFactory factory)</span> </span>&#123;<br>    <span class="hljs-comment">//初始化parent字段</span><br>    <span class="hljs-keyword">super</span>(parent);<br>    ...<br>    <span class="hljs-comment">//实际使用ucp字符保存多个classpath路径</span><br>    ucp = <span class="hljs-keyword">new</span> URLClassPath(urls, factory, acc);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>经过上面的源码学习，我们已经非常清楚这三类加载器如何实现<strong>双亲</strong>的逻辑，并且还顺便搞懂了classpath的初始化过程。那么委派是什么呢？下面的加载流程很好地解释了什么是委派：</p>
<ol>
<li><p>在传统情况下，一个类的加载会由默认的类加载器加载，而一般情况下<code>Application ClassLoader</code>会作为默认的类加载器。类加载器首先会将请求委派给父类，而不是由自己来加载。</p>
</li>
<li><p><code>Application ClassLoader</code>会将加载请求委派给父类<code>Extension ClassLoader</code>,而<code>Extension ClassLoader</code>又会将请求委派给父类<code>BootStrap ClassLoader</code>。</p>
</li>
<li><p>如果<code>BootStrap ClassLoader</code>加载失败，那么具体的加载会由<code>Extension ClassLoader</code>完成。如果<code>Extension ClassLoader</code>加载失败，具体的加载会由<code>Extension ClassLoader</code>完成。如果再次不能完成，那么就会抛出异常。</p>
</li>
</ol>
<p>可以看到，加载请求会一级一级向上传递，直到传到根加载器。然后如果不能完成，请求又会一级一级从上到下传递到底部加载器。<strong>那么为什么要这么做呢？</strong></p>
<p>答案来自《深入理解java虚拟机》：</p>
<blockquote>
<p>这样做的一个显而易见的好处是，被加载的类随着它的加载器一起具备了一种优先级的层次关系。</p>
</blockquote>
<p>试想加载类<code>Object</code>,这个类肯定最终由<code>bootstrap ClassLoader</code>来加载。如果没有这种委派关系，我们随便写一个同名的类<code>Object</code>,虚拟机无法保证使用加载正确的<code>Object</code>类。那么最基础的核心类都无法保证正确加载，那就出大问题了。</p>
<p><strong>双亲委派模型的代码实现</strong></p>
<p>双亲委派的原理简单，代码实现也非常简单，下面的短短几十行代码就完成了操作：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>        <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// First, check if the class has already been loaded</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">long</span> t0 = System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//如果父类不为空，那么就使用父类的加载方法</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//否则使用根加载器加载</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                <span class="hljs-comment">// to find the class.</span><br>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br>                c = findClass(name);<br>                ...<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>系统类加载器的设置</strong></p>
<p>update：2021-01-18 00:31:03</p>
<p>复习到这时，我提出了一个问题：系统类加载器的设置和三类加载器之间的关系是怎么样的？是谁调用谁的？</p>
<p>目前我只能回答这个问题的一半：某个函数会首先调用<code>getSystemClassLoader()</code>，然后调用链如下：<code>getSystemClassLoader()</code>—&gt;<code>initSystemClassLoader</code>—&gt;<code>sun.misc.Launcher.getLauncher()</code></p>
<hr>
<p>我曾在上面提到，如果没有意外发生，那么在jvm中，<code>AppClassLoader</code>会被设置为默认的系统类加载器，这也是为什么会在某些场合称其为“系统类加载器”。那么这一设置是什么时候完成的呢？这一切都起源于<code>ClassLoader</code>中的方法<code>getSystemClassLoader</code>。其注释写道：</p>
<blockquote>
<p>If the system property “java.system.class.loader” is defined<br>when this method is first invoked then the value of that property is<br>taken to be the name of a class that will be returned as the system<br>class loader.  The class is loaded using the default system class loader<br>and must define a public constructor that takes a single parameter of<br>type ClassLoader which is used as the delegation parent.  An<br>instance is then created using this constructor with the default system<br>class loader as the parameter.  The resulting class loader is defined<br>to be the system class loader.</p>
</blockquote>
<p>如果设置为系统属性<code>java.system.class.loader</code>，那么在第一次调用<code>getSystemClassLoader</code>时，会将该系统属性指向的类设置为系统类加载器。值得注意的是，自定义的系统类加载器必须声明一个带有一个参数的公共构造方法，并且唯一参数用来当作委派父类。下面我们来看看这一方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClassLoader <span class="hljs-title">getSystemClassLoader</span><span class="hljs-params">()</span> </span>&#123;<br>    initSystemClassLoader();<br>    <span class="hljs-keyword">if</span> (scl == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    SecurityManager sm = System.getSecurityManager();<br>    <span class="hljs-keyword">if</span> (sm != <span class="hljs-keyword">null</span>) &#123;<br>        checkClassLoaderPermission(scl, Reflection.getCallerClass());<br>    &#125;<br>    <span class="hljs-keyword">return</span> scl;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>我们看到，该方法内部会调用<code>initSystemClassLoader()</code>，那么这个方法又做了什么事情呢？</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initSystemClassLoader</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!sclSet) &#123;<span class="hljs-comment">//如果系统类加载器还没有被设置</span><br>        <span class="hljs-keyword">if</span> (scl != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;recursive invocation&quot;</span>);<br>        sun.misc.Launcher l = sun.misc.Launcher.getLauncher();<br>        <span class="hljs-keyword">if</span> (l != <span class="hljs-keyword">null</span>) &#123;<br>            Throwable oops = <span class="hljs-keyword">null</span>;<br>            scl = l.getClassLoader();<span class="hljs-comment">//获得ApplicationClassLoader</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                scl = AccessController.doPrivileged(<br>                    <span class="hljs-keyword">new</span> SystemClassLoaderAction(scl));<span class="hljs-comment">//设置系统类加载器</span><br>            &#125; <span class="hljs-keyword">catch</span> (PrivilegedActionException pae) &#123;<br>                oops = pae.getCause();<br>                <span class="hljs-keyword">if</span> (oops <span class="hljs-keyword">instanceof</span> InvocationTargetException) &#123;<br>                    oops = oops.getCause();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (oops != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (oops <span class="hljs-keyword">instanceof</span> Error) &#123;<br>                    <span class="hljs-keyword">throw</span> (Error) oops;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// wrap the exception</span><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(oops);<br>                &#125;<br>            &#125;<br>        &#125;<br>        sclSet = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>其中<code>sclSet</code>是<code>ClassLoader</code>的属性，如果是第一次调用，那么会通过<code>Launcher</code>调用<code>getSystemLoader</code>获取<code>Launcher</code>内部字段<code>loader</code>的值。不知道大家还记不记得，<code>loader</code>字段会被设置为<code>AppClassLoader</code>。此后<code>scl</code>会被设置为<code>AppCLassLoader</code>。</p>
<p>然后会使用<code>SystemClassLoaderAction</code>读取系统属性<code>java.system.class.loader</code>,完成系统类加载器的设置，我们来看看其源码。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemClassLoaderAction</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">PrivilegedExceptionAction</span>&lt;<span class="hljs-title">ClassLoader</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> ClassLoader parent;<br><br>    SystemClassLoaderAction(ClassLoader parent) &#123;<br>        <span class="hljs-keyword">this</span>.parent = parent;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ClassLoader <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String cls = System.getProperty(<span class="hljs-string">&quot;java.system.class.loader&quot;</span>);<br>        <span class="hljs-keyword">if</span> (cls == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> parent;<br>        &#125;<br>        Constructor&lt;?&gt; ctor = Class.forName(cls, <span class="hljs-keyword">true</span>, parent)<br>            .getDeclaredConstructor(<span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123; ClassLoader.class &#125;);<br>        ClassLoader sys = (ClassLoader) ctor.newInstance(<br>            <span class="hljs-keyword">new</span> Object[] &#123; parent &#125;);<br>        Thread.currentThread().setContextClassLoader(sys);<br>        <span class="hljs-keyword">return</span> sys;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>我们可以很清楚的看到，如果系统属性<code>java.system.class.loader</code>为空，那么就会返回<code>parent</code>。此前<code>parent</code>已通过构造函数被设置为<code>AppClassLoader</code>。</p>
<p>否则，加载系统属性指向的类并获取带有一个参数的构造方法。随后创建自定义类加载器的实例<code>sys</code>并返回。</p>
<p>至此，已经完成了系统类加载器的设置。所以说，默认情况下，所有的类都会使用<code>AppClassLoader</code>来加载。</p>
<h2 id="3-破坏双亲委派模型"><a href="#3-破坏双亲委派模型" class="headerlink" title="3. 破坏双亲委派模型"></a>3. 破坏双亲委派模型</h2><p>虽然双亲委派模型好，但它也不是万能的。到目前为止，已经出现了三次破坏行为。下面来品一哈。</p>
<h3 id="3-1-第一次破坏"><a href="#3-1-第一次破坏" class="headerlink" title="3.1 第一次破坏"></a>3.1 第一次破坏</h3><p>第一次破坏是由于JDK1.2之前还没有出现双亲委派模型，但是此时已经有了类加载器的概念。那么此时已经有了许多用户自定义的类加载器。那么为了兼容以前的代码，无法再以技术手段避免<code>loadClass()</code>被子类覆盖的可能性。这里所谓的无法避免是什么呢？我们再次来看看双亲委派的实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>        <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// First, check if the class has already been loaded</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">long</span> t0 = System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//如果父类不为空，那么就使用父类的加载方法</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//否则使用根加载器加载</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                <span class="hljs-comment">// to find the class.</span><br>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br>                c = findClass(name);<br>                ...<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>如果此时用户代码还在覆盖<code>loadClass</code>,但是编写出的代码并没有采用双亲委派，那么就会使双亲委派失效。因为双亲委派就是靠<code>loadClass</code>来实现的。所以尽管不能避免之前的状态，但是以后要尽量避免让用户覆盖<code>loadClass</code>。</p>
<p>所以在JDK1.2之后，在<code>ClassLoader</code>中引入了一个<code>protected</code>方法<code>findClass()</code>。希望引导用户能够覆盖<code>findClass()</code>编写自定义类加载器。这样既不影响双亲委派，又可以按照用户自己的意愿加载类，就像上面源码中的那样，当父类加载失败，那么就会调用<code>findClass()</code>加载。</p>
<p>所以重写<code>loadClass</code>会破坏双亲模型，而重写<code>findClass</code>则不会，如果需要在多个类加载器中加载同一个<code>Class</code>，则需要使用前者。</p>
<h3 id="3-2-第二次破坏"><a href="#3-2-第二次破坏" class="headerlink" title="3.2 第二次破坏"></a>3.2 第二次破坏</h3><p>第二次破坏是因为双亲委派这个机制存在缺陷。首先我们需要明白下面这种机制：</p>
<blockquote>
<p>假设我们当前代码所处的类为D，如果此时要把一个从未解析的符号解析成类或接口C。如果C不是数组类型，那么<strong>jvm会使用加载D的类加载器来加载C</strong>。</p>
</blockquote>
<p>但是在双亲委派模型中，上层的类加载器是无法指派下层的类加载器来完成加载动作的。一个典型的例子就是JNDI(The Java Naming and Directory Interface)服务。简而言之，JDNI就是java规定一组服务的接口，但是具体的实现由第三方提供，例如数据库的驱动。</p>
<p>那么这个<strong>破坏</strong>在哪里呢？首先JDNI肯定是由启动类加载器加载至JVM。那么调用具体的实现类时，启动类加载器是不可能将实现类加载进来的，因为这不符合启动类加载器的规定。那么怎么办呢？</p>
<p>开发人员又设计了一种叫进程上下文类加载器(Thread Context ClassLoader)的东西来完成这个任务。启动类加载器会调用进程上下文类加载器来加载接口的实现类。</p>
<p>线程上下文类加载器在(默认情况下)由<code>Bootstrap classLoader</code>第一次加载<code>Launcher</code>类时就会被设置为<code>App ClassLoader</code>。当然，我们可以通过<code>setContextClassLoader(ClassLoader cl)</code>和<code>getContextClassLoader()</code>来设置和使用我们自定义的线程上下文类加载器。<strong>在多线程的情况下</strong>，子线程会继承父线程的线程上下文类加载器。</p>
<h3 id="3-3-第三次破坏"><a href="#3-3-第三次破坏" class="headerlink" title="3.3 第三次破坏"></a>3.3 第三次破坏</h3><p>这次破坏是为了实现java应用的热部署。简单来说就是OSGi机制破坏了双亲委派模型。以下引自《深入理解java虚拟机》：</p>
<blockquote>
<p>OSGi实现模块热部署的关键是它自定义的类加载机制的实现，每一个程序模块（OSGi称其为bundle）都有属于自己的类加载器。当需要替换Bundle时，就把Bundle连同类加载器一起替换以实现代码的热替换。</p>
<p>在OSGi环境下，类加载机制不再是委派双亲的树模型，而是一个<strong>网状</strong>结构。OSGi的类加载顺序中，只有前两个步骤符合双亲委派的原则，即：</p>
<ol>
<li>将以java.*开头的类，委派给父类加载器加载</li>
<li>否则,将委派列表名单内的类，委派给父类加载器加载</li>
</ol>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文详细介绍了双亲委派模型的类加载机制，解释了什么是“双亲”、什么是“委派”，三个系统自带的类加载器的初始化过程（仅限于JDK1.2-1.8）。以及历史上三次破坏双亲委派模型的事件，引出了SPI。后面我会以数据库加载驱动的案例讲解SPI到底是如何工作的。</p>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>我们在上面的源码中会经常看到<code> AccessController.doPrivileged()</code>这个方法，这又跟java的安全模型相关，谈起来不简单，后面我会专门开一篇来讲解它。</p>
<p><strong>参考文献</strong></p>
<p><a target="_blank" rel="noopener" href="https://greenhathg.github.io/2019/06/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-Launcher%E7%B1%BB/">https://greenhathg.github.io/2019/06/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-Launcher%E7%B1%BB/</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903837472423944">https://juejin.im/post/6844903837472423944</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021869536">https://segmentfault.com/a/1190000021869536</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/jvm/">jvm</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/">类加载</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/articles/java-memory-layout.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">java的内存布局</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/articles/type-system-of-java.html">
                        <span class="hidden-mobile">java中的类型系统</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@waline/client@0.16.2/dist/Waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"https://blog-comment-blond.vercel.app","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":true,"avatarCDN":"","avatarForce":false,"requiredFields":[],"emojiCDN":null,"emojiMaps":null,"anonymous":null},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        new Waline(options);
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  

  <div>
    <span id="timeDate">载入天数...</span>
    <span id="times">载入时分秒...</span>
    <script>
    var now = new Date();
    function createtime(){
        var grt= new Date("06/03/2021 00:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24;
        dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
        hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){
            hnum = "0" + hnum;
        }
        minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes);
        if(String(mnum).length ==1 ){
                  mnum = "0" + mnum;
        }
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds);
        if(String(snum).length ==1 ){
                  snum = "0" + snum;
        }
        document.getElementById("timeDate").innerHTML = "🚀 for&nbsp"+dnum+"&nbspdays";  //此次自定义显示内容
        document.getElementById("times").innerHTML = hnum + "&nbsphr&nbsp" + mnum + "&nbspmin&nbsp" + snum + "&nbspsec";
    }  //此次自定义显示内容
    setInterval("createtime()",250);
    </script>
  </div>
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  
    <!-- Google Analytics -->
    <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'UA-198559201-1', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  
    <!-- Google gtag.js -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-19MVRDT9NM"></script>
    <script defer>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-19MVRDT9NM');
    </script>
  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
